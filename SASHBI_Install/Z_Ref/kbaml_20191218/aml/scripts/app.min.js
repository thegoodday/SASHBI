/**
 * Created by tomutd on 1/15/2015.
 */
(function() {
    'use strict';

    configDetails.$inject = ["$stateProvider"];
    angular.module('aml', [
        // angular and 3rd party dependencies
        'ngResource',
        'ngAnimate',
        'ngSanitize', // for sanitizing alert messages HTML
        'ngMessages', // displaying validation errors
        'ui.router',
        'ui.bootstrap',
        'ct.ui.router.extras',
        'kendo.directives',

        /*
         * Core cross-app functions.  Everybody has access to these.
         * We could place these under every feature area,
         * but this is easier to maintain.
         */
        'aml.core',

        /*
         * aml feature areas
         */
        'aml.customer',
        'aml.customer.details',
        'aml.cases',
        'aml.cases.details',
        'aml.reports',
        'aml.reports.details',
        'aml.efiles',
        'aml.efiles.details',
        'aml.admin',
        'aml.search',
        'aml.scenario',
        'aml.entities',
        'aml.riskAssessments',
        'cdd.reviews',
        'cdd.rule'
    ]).config(configDetails);

    // make $stateProvider available to onStateStart in app.config
    function configDetails($stateProvider) {
        angular.module('aml').$stateProvider = $stateProvider;
    }
})();

(function() {
    'use strict';

    angular
        .module('aml.admin', []);
})();
/**
 * @name aml.cases
 * @description cases module
 */
(function() {
    'use strict';

    angular
        .module('aml.cases', []);
})();
/**
 * @name cdd.rule
 * @description CDD Rule Administrator
 */
(function() {
    'use strict';

    angular
        .module('cdd.rule', []);
})();
(function() {
    'use strict';

    angular
        .module('aml.core', ['aml.core.logger', 'aml.core.exception', 'aml.core.links']);
})();
/**
 * @name aml.reviews
 * @description reviews module
 */
(function() {
    'use strict';

    angular
        .module('cdd.reviews', []);
})();
/**
 * @name aml.customer
 * @description customer module
 */
(function() {
    'use strict';

    angular
        .module('aml.entities', []);
})();
/**
 * @name aml.efiles
 * @description efiles module
 */
(function() {
    'use strict';

    angular
        .module('aml.efiles', []);
})();
/**
 * @name aml.reports
 * @description reports module
 */
(function() {
    'use strict';

    angular
        .module('aml.reports', []);
})();
(function() {
    'use strict';

    angular
        .module('aml.riskAssessments', []);
})();
/**
 * @name aml.customer
 * @description customer module
 */
(function() {
    'use strict';

    angular
        .module('aml.scenario', []);
})();
(function() {
    'use strict';

    angular.module('aml.search', []);
})();
/**
 * Created by sasrns on 8/19/2015.
 */
(function() {
    'use strict';

    configDetails.$inject = ["$stateProvider", "$urlRouterProvider"];
    angular
        .module('aml.cases.details', ['ngResource','ui.router']).config(configDetails);
    function configDetails($stateProvider, $urlRouterProvider) {

    }
})();

(function() {
    'use strict';

    angular.module('aml.core.exception', []);
})();

(function() {
    'use strict';

    angular.module('aml.core.links', []);
})();

(function() {
    'use strict';

    angular.module('aml.core.logger', []);
})();

/**
 * @name aml.customer
 * @description customer module
 */
(function() {
    'use strict';

    angular
        .module('aml.customer', []);
})();
/**
 * Created by sasrns on 8/19/2015.
 */
(function() {
    'use strict';

    configDetails.$inject = ["$stateProvider", "$urlRouterProvider"];
    angular
        .module('aml.efiles.details', ['ngResource','ui.router']).config(configDetails);
    function configDetails($stateProvider, $urlRouterProvider) {

    }
})();

/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';

    configDetails.$inject = ["$stateProvider", "$urlRouterProvider"];
    angular
        .module('aml.reports.details', ['ngResource', 'ui.router']).config(configDetails);
    function configDetails($stateProvider, $urlRouterProvider) {

    }

})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function() {
    'use strict';

    configDetails.$inject = ["$stateProvider", "$urlRouterProvider"];
    angular
        .module('aml.customer.details', ['ngResource','ui.router']).config(configDetails);
    function configDetails($stateProvider, $urlRouterProvider) {

    }
})();

(function () {
    'use strict';
    AlertController.$inject = ["resources", "$stateParams", "alertsService", "amlConstants", "usersService", "casesService", "entityListDataMessagingService", "entityService", "dataMessagingServiceFactory"];
    angular.module('aml.customer').controller('AlertController', AlertController);

    function AlertController(resources, $stateParams, alertsService, amlConstants, usersService, casesService, entityListDataMessagingService, entityService, dataMessagingServiceFactory) {
    	
//console.log("AlertController $stateParams : " + JSON.stringify($stateParams));

        var viewVm = this;
        viewVm.commentsOptions = {};
        viewVm.resources = resources;
        viewVm.alertId = $stateParams.alertid;
        
        viewVm.exttype = $stateParams.exttype;

        viewVm.displayTerrorFinancingScore = amlConstants.config.aml.terrorFinancing.display;
        viewVm.displayMLS = true;
        viewVm.entityId = {};
        viewVm.activateInProcess = false;
        
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        activate();

        viewVm.canActivate = function canActivate() {
//console.log("canActivate !!!");
            return viewVm.alert && !viewVm.activateInProcess &&
                ( (viewVm.alert.status === 'SUP' || viewVm.alert.status === 'SUE') && usersService.currentUserHasCapability(amlConstants.capabilities.activateSuppressedAlert) ||
                    viewVm.alert.status === 'CLS' && usersService.currentUserHasCapability(amlConstants.capabilities.activateClosedAlert));
        };

        viewVm.canRemoveAlertFromCase = function canRemoveAlertFromCase() {
//console.log("canRemoveAlertFromCase !!!");
            return viewVm.alert && !viewVm.activateInProcess &&
                (viewVm.alert.status === 'CLC' && usersService.currentUserHasCapability(amlConstants.capabilities.activateClosedByCaseAlert) &&
                    viewVm.case && amlConstants.config && amlConstants.config.caseStatusAllowAlertRemoval &&
                    amlConstants.config.caseStatusAllowAlertRemoval.indexOf('"'+viewVm.case.statusCode+'"')  !== -1
                );
        };

        viewVm.activateAlert = function activateAlert () {
//console.log("activateAlert !!!");
          viewVm.activateInProcess = true;
          alertsService.activateAlert(viewVm.alertId, viewVm.alert.status).then(
              function success(data) {
                //read updated alert to refresh the  UI status field
                activate();
                entityListDataMessagingService.refreshEntityAlertCount([viewVm.entityId]);
              },
              function error (data) {
                  //reload alert on error
                  activate();
              }
          );
        };

        viewVm.removeFromCase = function removeFromCase() {
//console.log("removeFromCase !!!");
            viewVm.activateInProcess = true;
            alertsService.removeFromCase(viewVm.alertId).then(
                function success(data) {
                    //read updated alert to refresh the  UI status field
                    activate();
                    entityListDataMessagingService.refreshEntityAlertCount([viewVm.entityId]);
                },
                function error (data) {
                    //reload alert on error
                    activate();
                }
            );
        };

        function activate() {
//console.log("activate !!!");
            if (amlConstants.config.aml && amlConstants.config.aml.MLS && angular.isDefined(amlConstants.config.aml.MLS.display)) {
                viewVm.displayMLS = amlConstants.config.aml.MLS.display;
            }
//console.log("00000000000000000000000000001");
//console.log(viewVm.exttype);
            alertsService.getAlertTemp(viewVm.alertId, viewVm.exttype).then(function (data) {
            	
/*            	dataMessagingService.setAlertIdVal( viewVm.alertId );*/
            	
//console.log("viewVm.alertId : " + viewVm.alertId);
//console.log("viewVm.primaryEntityNumber : " + viewVm.primaryEntityNumber);

//console.log("AlertController activate() JSON.stringify(data) : " + JSON.stringify(data));
//console.log("dataMessagingService.getAlertIdVal() : " + dataMessagingService.getAlertIdVal());

                viewVm.alert = data;
                
                viewVm.activateInProcess = false;
                // scenario data is returned with an alert
                viewVm.scenario = data.scenario;
                viewVm.entityId = entityService.normalizeEntityId(viewVm.entityId, viewVm.alert.alertedEntityLevelCode, viewVm.alert.alertedEntityNumber, viewVm.alert.alertedEntityKey);
                if (viewVm.alert && viewVm.alert.caseId) {
                    casesService.getCase(viewVm.alert.caseId).then(
                        function success (data) {
                            viewVm.case = data;
                        }
                    );
                }

                // If there's a segment on the alert, get the current segment
                if(data.entitySegmentId) {
                    alertsService.getCurrentSegment(
                        data.alertLevel,
                        data.primaryEntityNumber
                    ).then(function(data) {
                        viewVm.alert.currentSegmentName = data.segmentName;
                    });
                }
            });
        }
        
        function handleDoubleClick(selectedEntity) {
        	console.log("alert controller dbclick");
        }
    }
})();

(function () {
    'use strict';

    QueueListController.$inject = ["$scope", "$rootScope", "amlLov", "amlConstants", "$state", "$q", "queueListService", "resources", "kendoGridRendererService", "messageService"];
    angular
        .module('aml.admin')
        .controller('QueueListController', QueueListController);


    function QueueListController($scope, $rootScope, amlLov, amlConstants, $state, $q,
                                 queueListService, resources, kendoGridRendererService, messageService) {

        var vm = this;
        vm.state = $state.$current;
        vm.queues = []; //null is handled well by kendo-grid too, but we use [] to be consistent
        vm.grid = {};
        vm.amlGridActions = [];
        vm.resources = resources;
        vm.editRowId = -1; //this is the queueKey of the current line that you are updating
        vm.disableDelete = false;
        vm.invalidNameChars = amlConstants.config.invalidCharactersForMetadataName;

        vm.preventAction = false;

        queueListService.getQueues().then(
            function (data) {
                vm.queues = data.items;
                activate();
            }
        );


        function activate() {

            /*      Create Queue Code Filter, currently not used, decided that text input filter is best at the moment
            var queuesFilter = kendoGridRendererService.getCheckboxFilter('queueName');
            var queueNames = amlLov.queueName;
            var filterList = [];

            var createQueueFilter = function () {
                for (var i = 0; i < vm.queues.length; i++) {         //vm.queues[i].queueCode --> queueCode
                    if (queueNames[vm.queues[i].queueCode] !== undefined) {
                        filterList.push({
                            name: queueNames[vm.queues[i].queueCode].description,
                            value: vm.queues[i].queueCode
                        });
                    } else {
                        filterList.push({name: vm.queues[i].queueDescription, value: vm.queues[i].queueCode});

                    }
                }

                var map = Object.keys(queueNames).map(function (key) {
                    return {key: key, order: queueNames[key].order, description: queueNames[key].description};
                });
                map.sort(kendoGridRendererService.compareLovValues);

                //filterList is set at this point
                queuesFilter = kendoGridRendererService.getCheckboxFilterForValues(filterList);
            };

            createQueueFilter();
            */

            var maxPageSizeForGrids = amlConstants.config.maxPageSizeForGrids; //get string 'two, all", etc for maxPageSize found in preferences
            if (!maxPageSizeForGrids) {
                maxPageSizeForGrids = 15000;
            } else {
                if (maxPageSizeForGrids !== 'all') {
                    if (isNaN(parseInt(maxPageSizeForGrids, 10))) { //if there is none them use back-up variables
                        maxPageSizeForGrids = 202;
                    } else {
                        if (maxPageSizeForGrids < 100) {
                            maxPageSizeForGrids = 201;
                        }
                    }
                }
            }

            var logicalDeleteIndRenderingFilter = kendoGridRendererService.enum('logicalDeleteInd', 'yesOrNo');
            var activeIndRenderingFilter = kendoGridRendererService.enum('activeInd', 'yesOrNo');
            //filter object gets status (Y/N) and converts to (Yes/No), it is based on the value of activeInd field

            vm.selectYesOrNo = amlLov.getAsArray(amlLov.yesOrNo);

            vm.gridColumns = [          //grid layout
                {
                    field: 'queueCode', title: resources.aml.queue.header.queueCode,
                    width: '8%',
                   // filterable: queuesFilter,     //checkbox filter, commented out to use text input instead
                    template: '{{dataItem.queueCode | queueName:true}}'
                },
                {
                    field: 'queueDescription', title: resources.aml.queue.header.queueDescription,
                    width: '15%'
                },
                {
                    field: 'accessRoleName', title: resources.aml.queue.header.accessRoleName,
                    width: '15%'
                },
                {
                    field: 'lstUpdateUser', title: resources.aml.queue.header.lstUpdateUser,
                    width: '9%',
                    template: '{{dataItem.lstUpdateUser | userName:true}}'
                },
                {
                    field: 'logicalDeleteInd', title: resources.aml.queue.header.logicalDeleteInd,
                    width: '12%',
                    template: logicalDeleteIndRenderingFilter,
                    editor: function (container, options) {
                        var input = $('<input id="logicalDeleteInd" name="logicalDeleteInd" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            autoBind: true,
                            dataTextField: 'value',
                            dataValueField: 'key',
                            dataSource: vm.selectYesOrNo
                        });
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(logicalDeleteIndRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
                },
                {
                    field: 'activeInd', title: resources.aml.queue.header.activeInd,
                    width: '8%',
                    template: activeIndRenderingFilter,
                    editor: function (container, options) {
                        var input = $('<input id="activeInd" name="activeInd" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            autoBind: true,
                            dataTextField: 'value',
                            dataValueField: 'key',
                            dataSource: vm.selectYesOrNo
                        });
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(activeIndRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
                },
                {

                    command: [
                        'edit',
                        {
                            name: 'destroy',
                            text: '{{ dataItem.logicalDeleteInd === "N"  ? "Delete" : "Undelete"}}',
                            iconClass: 'k-icon k-delete'
                        },
                    ],
                    width: '13%'
                }
            ];


            var isQueueCodeUnique = function (queueCodeInput) {
                if (queueCodeInput === '') {
                    return true;
                }                       //we have to make sure that vm.queues is always updated

                var isUnique = true;

                for (var i = 0; i < vm.queues.length; i++) {
                    if (vm.queues[i].queueKey !== vm.editRowId && vm.queues[i].queueCode.trim().toLowerCase() === queueCodeInput.trim().toLowerCase()) {
                        isUnique = false;
                        break;
                    }
                }

                return isUnique;
            };

            function isRoleNameValid(name) {
                if (vm.invalidNameChars) {
                    for (var i = 0; i < vm.invalidNameChars.length; i++) {
                        if (name.indexOf(vm.invalidNameChars.charAt(i)) >= 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function setEnabled(enabled) {
                //mark Edit and Delete buttons so we can find them later, this has to be done each time
                //because Kendo removes them when going into edit mode and replaces with Update and Cancel
                //and then adds them back after edit is complete
                $('.k-grid-delete', '#queuesList').addClass('k-delete-button');
                $('.k-grid-edit', '#queuesList').addClass('k-edit-button');

                //disable all buttons except Update and Cancel when in Edit mode, so that row cannot be closed unfinished
                if (enabled) {
                    //restore Kendo expected classes and attributes based on our marker classes
                    $('.k-add-button', '#queuesList').removeClass('k-state-disabled').addClass('k-grid-add').attr('disabled', false);
                    $('.k-edit-button', '#queuesList').removeClass('k-state-disabled').addClass('k-grid-edit').attr('href', '#');
                    $('.k-delete-button', '#queuesList').removeClass('k-state-disabled').addClass('k-grid-delete').attr('href', '#');
                }
                else {
                    //remove Kendo classes and attributes to disable buttons
                    $('.k-add-button', '#queuesList').addClass('k-state-disabled').removeClass('k-grid-add').attr('disabled', true);
                    $('.k-edit-button', '#queuesList').addClass('k-state-disabled').removeClass('k-grid-edit').removeAttr('href');
                    $('.k-delete-button', '#queuesList').addClass('k-state-disabled').removeClass('k-grid-delete').removeAttr('href');
                }
            }

            vm.dataSourceOptions = new kendo.data.DataSource({      //custom grid option - data handling
                transport: {
                    create: createQueue,        //intercept the CRUD methods to affect kendo
                    read: getQueues,
                    update: editQueue,
                    destroy: deleteQueue
                },
                batch: false,
                schema: {
                    model: {
                        id: 'queueKey',     //need to have id, update should only apply to index 0 element when clicking "create queue"
                        fields: {
                            queueKey: {type: 'number'},     //this will be overwritten with random id, here it is used as an index in grid
                            queueCode: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.queue.inputMessages.queueCodeMissingErrorTxt},
                                    pattern: {
                                        value: '^[^]{0,32}$',
                                        message: resources.aml.queue.inputMessages.queueCodeTooLongErrorTxt
                                    },
                                    unique: function (input) {
                                        // console.log(input.kendoBindingTarget.source);
                                        if (input.is('[name=\'queueCode\']')) {     //see if input type is of type queueCode
                                            if (input.val().trim().length === 0) {  //trim to make sure input is not blank spaces
                                                input.attr('data-unique-msg', resources.aml.queue.inputMessages.queueCodeMissingErrorTxt);
                                                return false;
                                            } else {
                                                if (isQueueCodeUnique(input.val())) {
                                                    return true;
                                                } else {
                                                    //set custom error message
                                                    input.attr('data-unique-msg', resources.aml.queue.inputMessages.queueCodeIsNotUniqueErrorTxt);
                                                    return false;
                                                }
                                            }
                                        }
                                        return true;
                                    }
                                }
                            },
                            queueDescription: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.queue.inputMessages.queueDescriptionMissingErrorTxt},
                                    pattern: {
                                        value: '^[^]{0,100}$',
                                        message: resources.aml.queue.inputMessages.queueDescriptionTooLongErrorTxt
                                    }
                                }
                            },     //these are the column fields
                            accessRoleName: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.queue.inputMessages.queueAccessRoleNameMissingErrorTxt},
                                    pattern: {
                                        value: '^[^]{0,60}$',
                                        message: resources.aml.queue.inputMessages.roleNameTooLongErrorTxt
                                    },
                                    validMetadataName: function (input) {
                                        // console.log(input.kendoBindingTarget.source);
                                        if (input.is('[name=\'accessRoleName\']')) {     //see if input type is of type queueCode
                                            if (input.val().length === 0) {
                                                return true;
                                            } else {
                                                if (isRoleNameValid(input.val())) {
                                                    return true;
                                                } else {
                                                    //set custom error message
                                                    input.attr('data-validMetadataName-msg', vm.resources.aml.getResource('queue.invalidRoleNameErrorTxt', {list: vm.invalidNameChars}));
                                                    return false;
                                                }
                                            }
                                        }
                                        return true;
                                    }
                                },
                            },
                            lstUpdateUser: {type: 'string', editable: false},
                            logicalDeleteInd: {
                                type: 'string',
                                defaultValue: 'N',
                                editable: false
                            },
                            activeInd: {
                                type: 'string',
                                defaultValue: 'Y'
                            }
                        }
                    } //end of model
                },
                requestStart: function (e) {
                    //prevent grid navigation including paging controls, filters and sorting
                    if (vm.preventAction) {
                        e.preventDefault();
                    }
                },
                pageSize: 5,  //set default selection to first option -- 5
                serverPaging: false,
                serverSorting: false,
                serverFiltering: false
            });


            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(      //custom grid options - UI specs
                {
                    dataSource: vm.dataSourceOptions,
                    columns: vm.gridColumns,
                    pageable: {
                        pageSizes: [5, 10, 20, 50, 100, maxPageSizeForGrids],
                        numeric: false,  //this is a different way to choose page option, we are using array so disable this
                        refresh: true,
                    },
                    editable: {
                        mode: 'inline',
                        confirmation: false
                    },
                    resizable: true,
                    selectable: 'multiple',
                    allowCopy: true,
                    filterable: true,
                    batch: false,
                    toolbar: [{text: '', template: kendo.template($('#queuesGrid_toolbar').html())}], //this is to add the top buttons (Create/Cancel Changes)
                    scrollable: false,
                    sortable: {
                        mode: 'multiple',
                        allowUnsort: true       //add row editing under here
                    },
                    edit: function (e) {
                        vm.preventAction = true;
                        //update the id reference to the current row you are updating, if you are creating, value is 0
                        vm.editRowId = e.model.queueKey;

                        if (e.model.isNew() === false) {
                            $('input[name=queueCode]').parent().html(e.model.queueCode);   //take off textbox if you are editing inline
                        }
                        setEnabled(!vm.preventAction);
                    },
                    cancel: function () {
                        vm.preventAction = false;
                        setEnabled(!vm.preventAction);
                    },
                    dataBound: function () {
                        vm.preventAction = false;
                        setEnabled(!vm.preventAction);
                        //bind our own Add button click handler, so that grid could be unsorted and row will be inserted on top
                        //see https://docs.telerik.com/kendo-ui/knowledge-base/capture-the-add-event-of-the-grid
                        $('.k-grid-add').unbind('click');
                        $('.k-grid-add').bind('click', function(){
                            kendoGridRendererService.clearFilters(vm.grid);
                            kendoGridRendererService.clearSorts(vm.grid);

                        });
                    }
                });


            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'queuesList');


            function createQueue(e) {

                var queue = {
                    queueCode: e.data.queueCode,
                    queueDescription: e.data.queueDescription,
                    accessRoleName: e.data.accessRoleName,
                    lstUpdateUser: e.data.lstUpdateUser,    //user cannot input this
                    logicalDeleteInd: e.data.logicalDeleteInd,  //user cannot input this, only delete button can change it
                    activeInd: e.data.activeInd
                };

                if (validateQueue(queue)) {
                    queueListService.createQueue(queue).then(function (result) {
                        e.data.queueKey = result.queueKey;      //we have created the queue, we need to give the object and id for kendo to use
                        e.data.lstUpdateUser = result.lstUpdateUser;
                        vm.queues.push(e.data);
                        e.success(e.data);          //return the data with the new id
                    });
                } else {
                    //this should never happen if buttons are disabled correctly
                    messageService.danger(
                        vm.resources.aml.getResource('queue.queueNotValidErrorTxt'), null, -1);
                    e.error(e.data);
                }
            }


            function getQueues(e) {
                queueListService.getQueues().then(function (result) {
                    vm.queues = result.items;
                    //createQueueFilter();   checkbox filter, commented out to use text input instead
                    e.success(vm.queues);
                });
            }

            function validateQueue(q) {
                if (isQueueCodeUnique(q.queueCode) && q.queueDescription && q.accessRoleName) {
                    return true;
                }
                return false;
            }

            function editQueue(e) {

                var newQueue = {
                    queueKey: e.data.queueKey,
                    queueCode: e.data.queueCode,
                    queueDescription: e.data.queueDescription,
                    accessRoleName: e.data.accessRoleName,
                    lstUpdateUser: e.data.lstUpdateUser,
                    logicalDeleteInd: e.data.logicalDeleteInd,
                    activeInd: e.data.activeInd
                };
                if (validateQueue(newQueue)) {
                    queueListService.updateQueue(newQueue).then(function (result) {
                        e.data.queueKey = result.queueKey;      //the object is still updated and returned
                        e.data.lstUpdateUser = result.lstUpdateUser;
                        e.success(e.data);

                        //update queueKey in array without reloading grid
                        for (var i = 0; i < vm.queues.length; i++) {
                            if (vm.queues[i].queueKey === newQueue.queueKey) {
                                vm.queues[i].queueKey = result.queueKey;
                                vm.queues[i].queueCode = result.queueCode;
                                vm.queues[i].queueDescription = result.queueDescription;
                                vm.queues[i].accessRoleName = result.accessRoleName;
                                vm.queues[i].lstUpdateUser = result.lstUpdateUser;
                                vm.queues[i].logicalDeleteInd = result.logicalDeleteInd;
                                vm.queues[i].activeInd = result.activeInd;
                            }
                        }
                    });
                } else {
                    //this should never happen if buttons are disabled correctly
                    messageService.danger(
                        vm.resources.aml.getResource('queue.queueNotValidErrorTxt'), null, -1);
                    e.error(e.data);
                }
            }


            function deleteQueue(e) {

                if (vm.disableDelete) {
                    return;
                } else {
                    vm.disableDelete = true;
                }

                var setAsDelete = e.data.logicalDeleteInd === 'N' ? 'Y' : 'N';

                var queueCopy = {
                    queueKey: e.data.queueKey,
                    queueCode: e.data.queueCode,
                    queueDescription: e.data.queueDescription,
                    accessRoleName: e.data.accessRoleName,
                    lstUpdateUser: e.data.lstUpdateUser,
                    logicalDeleteInd: setAsDelete,      //value switched here and updated in midtier
                    activeInd: e.data.activeInd
                };


                queueListService.updateQueue(queueCopy).then(function (result) {
                    e.data.queueKey = result.queueKey;      //the object is still updated and returned
                    e.success(e.data);
                    reloadGrid(); //updates queues array but reloads grid on screen
                });

            }

            function reloadGrid() {
                vm.grid.dataSource.read();
                vm.disableDelete = false;
            }
        }

    }
})();
/**
 * Created by sasjrf on 10/15/2015.
 */
(function() {
    'use strict';
    RiskAssessmentController.$inject = ["resources", "$stateParams", "riskAssessmentService", "amlLov", "messageService", "$state", "exceptionResourceHandler", "tabsListService"];
    angular
        .module('aml.riskAssessments')
        .controller('RiskAssessmentController', RiskAssessmentController);

    function RiskAssessmentController(resources, $stateParams, riskAssessmentService, amlLov, messageService,
        $state, exceptionResourceHandler, tabsListService ) {

        var vm = this;
        vm.resources = resources;
        vm.assessmentId = $stateParams.assessmentId;
        vm.isNewRiskAssessment = $stateParams.newEntityFlag;
        vm.createManualRiskAssessment = createManualRiskAssessment;
        vm.riskAssessment = {};

        activate();

        /**************/

        function activate() {
            var custNum;
            var custName;
            if ( vm.isNewRiskAssessment ) {
                // for new risk assessments, we construct a new empty risk assessment for use on the page
                vm.proposedRiskClassifications = amlLov.getAsArray(amlLov.riskClassification);
                $state.$current.data.dirty = true;  // to set the tab pill to dirty
                custNum = $stateParams.customerNumber;
                custName = $stateParams.customerName;
                vm.riskAssessment = riskAssessmentService.constructNewRiskAssessment( custNum, custName );
            }
            else {
                // for an existing risk assessment details; retrieve the risk assessment
                riskAssessmentService.getRiskAssessment($stateParams.assessmentId).then(function (data) {
                    vm.riskAssessment = data;
                });
            }
        }

        /**
         * Handle creating manual risk assessment
         */
        function createManualRiskAssessment() {
            vm.riskAssessment.proposedRiskClassification = vm.proposedRiskClassification;
            riskAssessmentService.createManualRiskAssessment( vm.riskAssessment ).then(
                function(addedRiskAssessment) {
                    var msg = resources.aml.getResource( 'riskAssessment.triage.createManualRiskAssessmentActionSuccessMessage',
                        {riskAssessmentId: addedRiskAssessment.assessmentId });
                    messageService.success( msg, null, 4000);
                },
                function (error) {
                    exceptionResourceHandler.handleResourceError( error, {
                        409: function () {
                            messageService.danger(
                                resources.aml.getResource(
                                    'riskAssessment.triage.createManualRiskAssessmentActionConflictsErrorMessage',
                                    {customerNumber: vm.riskAssessment.customerNumber}), null, 4000);
                        }}
                    );
                });

            // close New Risk Assessment tab
            tabsListService.closeTab(tabsListService.getTabForCurrentState());
        }
    }
})();

/**
 * Created by dabock on 9/2/2015.
 */
(function() {
    'use strict';
    AccountSearchController.$inject = ["searchService", "amlLov", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller('AccountSearchController', AccountSearchController);

    function AccountSearchController(searchService, amlLov,
                                     resources, $scope, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.accountTypes = amlLov.getAsArray(amlLov.accountType);
        vm.accountTypes.unshift({key: '', value: ''});

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'account'),
            accountNumber: new searchService.SearchField('account_number'),
            accountName: new searchService.SearchField('account_name'),
            accountNameSortable: new searchService.SearchField('account_name_sortable'),
            accountType: new searchService.SearchField('account_type', '')
        };

        // Don't use wildcards for fields selected by dropdown
        vm.model.accountType.noWildcard = true;

        var fields = {
            'account_number': {type: 'string'},
            'account_name': {type: 'string'},
            'account_type': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'account_number',
                title: vm.resources.aml.search.columns.accountNumber
            },
            {
                field: 'account_name_sortable',
                title: vm.resources.aml.search.columns.accountName
            },
            {
                field: 'account_type',
                title: vm.resources.aml.search.columns.accountType,
                template: '{{dataItem.account_type | accountType}}'
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'account_number',
            'account_name',
            amlConstants.entityType.account
        );
    }
})();
/**
 * Created by dabock on 10/15/2015.
 */
(function() {
    'use strict';
    AlertSearchController.$inject = ["searchService", "amlLov", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller('AlertSearchController', AlertSearchController);

    function AlertSearchController(searchService, amlLov, resources, $scope,
                                   amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.displayMLS = true;
        if (amlConstants.config.aml && amlConstants.config.aml.MLS && angular.isDefined(amlConstants.config.aml.MLS.display)) {
            vm.displayMLS = amlConstants.config.aml.MLS.display;
        }

        vm.alertStatuses = amlLov.getAsArray(
            amlLov.alertStatus);
        vm.entityLevels = amlLov.getAsArray(
            amlLov.entityLevel);
        vm.alertStatuses.unshift({key: '', value: ''});
        vm.entityLevels.unshift({key: '', value: ''});

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'alert'),
            number: new searchService.SearchField('primary_entity_number'),
            numberSortable: new searchService.SearchField('primary_entity_number_sortable'),
            name: new searchService.SearchField('primary_entity_name'),
            nameSortable: new searchService.SearchField('primary_entity_name_sortable'),
            alertId: new searchService.SearchField('alertid'),
            alertIdSortable: new searchService.SearchField('alertid_sortable'),
            mlRiskScore: new searchService.SearchField(
                'money_laundering_risk_score', [null, null], 'number'),
            alertStatus: new searchService.SearchField('alert_status_code', ''),
            createDate: new searchService.SearchField('create_date', [null, null], 'date'),
            runDate: new searchService.SearchField('run_date', [null, null], 'date'),
            closeDate: new searchService.SearchField('close_date', [null, null], 'date'),
            entityLevel: new searchService.SearchField('primary_entity_level_code', ''),
            scenarioDesc: new searchService.SearchField('scenario_desc'),
            scenarioDescSortable: new searchService.SearchField('scenario_desc_sortable')
        };

        // Don't use wildcards for fields selected by dropdown
        vm.model.entityLevel.noWildcard = true;
        vm.model.alertStatus.noWildcard = true;

        var fields = {
            'primary_entity_level_code': {type: 'string'},
            'primary_entity_number': {type: 'string'},
            'primary_entity_name': {type: 'string'},
            'alertid': {type: 'string'},
            'money_laundering_risk_score': {type: 'number'},
            'alert_status_code': {type: 'string'},
            'scenario_desc': {type: 'string'},
            'create_date': {type: 'date'},
            'run_date': {type: 'date'},
            'close_date': {type: 'date'}
        };

        vm.gridColumns = [
            {
                field: 'primary_entity_level_code',
                title: vm.resources.aml.search.columns.subjectType,
                width: 80,
                template: '{{dataItem.primary_entity_level_code | entityLevel}}'
            },
            {
                field: 'primary_entity_number_sortable',
                title: vm.resources.aml.search.columns.subjectNumber,
                width: 80
            },
            {
                field: 'primary_entity_name_sortable',
                title: vm.resources.aml.search.columns.subjectName,
                width: 80
            },
            {
                field: 'alertid_sortable',
                title: vm.resources.aml.search.columns.alertId,
                width: 80
            },
            {
                field: 'money_laundering_risk_score',
                hidden: !vm.displayMLS,
                title: vm.resources.aml.search.columns.mlRiskScore,
                width: 80
            },
            {
                field: 'alert_status_code',
                title: vm.resources.aml.search.columns.alertStatus,
                width: 80,
                template: '{{dataItem.alert_status_code | alertStatus}}'
            },
            {
                field: 'scenario_desc_sortable',
                title: vm.resources.aml.search.columns.scenarioDesc,
                width: 80
            },
            {
                field: 'create_date',
                title: vm.resources.aml.search.columns.createDate,
                width: 80,
                template: '{{dataItem.create_date | date}}'
            },
            {
                field: 'run_date',
                title: vm.resources.aml.search.columns.runDate,
                width: 80,
                template: '{{dataItem.run_date | date}}'
            },
            {
                field: 'close_date',
                title: vm.resources.aml.search.columns.closeDateTxt,
                width: 80,
                template: '{{dataItem.close_date | date}}'
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'alertid',
            'primary_entity_name',
            amlConstants.entityType.alert
        );
    }
})();
(function() {
    'use strict';
    CaseSearchController.$inject = ["resources", "amlLov", "searchService", "$scope", "amlConstants"];
    angular.module('aml.search').controller('CaseSearchController', CaseSearchController);

    function CaseSearchController(resources, amlLov, searchService, $scope,
                                    amlConstants) {
        var vm = this;
        vm.resources = resources;

        vm.caseStatuses = amlLov.getAsArray(amlLov.caseStatus);
        vm.caseCategories = amlLov.getAsArray(amlLov.caseCategory);
        vm.caseCategories.forEach(combineKeyAndValue);
        vm.caseSubcategories = amlLov.getAsArray(amlLov.caseSubcategory);
        vm.caseSubcategories.forEach(combineKeyAndValue);

        vm.caseStatuses.unshift({key: '', value: ''});
        vm.caseCategories.unshift({key: '', value: ''});
        vm.caseSubcategories.unshift({key: '', value: ''});

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'case'),
            caseId: new searchService.SearchField('case_id'),
            caseCategory: new searchService.SearchField('case_category_code'),
            caseSubcategory: new searchService.SearchField('case_sub_category_code'),
            caseStatus: new searchService.SearchField('case_status_code'),
            owner: new searchService.SearchField('owner_user_long_id'),
            createDate: new searchService.SearchField('create_date', [null, null], 'date'),
            closeDate: new searchService.SearchField('case_close_date', [null, null], 'date')
        };

        // Don't use wildcards for fields selected by dropdown
        vm.model.caseStatus.noWildcard = true;
        vm.model.caseCategory.noWildcard = true;
        vm.model.caseSubcategory.noWildcard = true;

        var fields = {
            'case_id': {type: 'string'},
            'case_category_code': {type: 'string'},
            'case_sub_category_code': {type: 'string'},
            'case_status_code': {type: 'string'},
            'owner_user_long_id': {type: 'string'},
            'create_date': {type: 'date'},
            'close_date': {type: 'date'}
        };

        vm.gridColumns = [
            {
                field: 'case_id',
                title: vm.resources.aml.search.columns.caseIdTxt,
                width: 80
            },
            {
                field: 'case_category_code',
                title: vm.resources.aml.search.columns.caseCategoryTxt,
                width: 80,
                template: '{{dataItem.case_category_code}} {{dataItem.case_category_code | caseCategory}}'
            },
            {
                field: 'case_sub_category_code',
                title: vm.resources.aml.search.columns.caseSubcategoryTxt,
                width: 80,
                template: '{{dataItem.case_sub_category_code}} {{dataItem.case_sub_category_code | caseSubcategory}}'
            },
            {
                field: 'case_status_code',
                title: vm.resources.aml.search.columns.caseStatusTxt,
                width: 80,
                template: '{{dataItem.case_status_code | caseStatus}}'
            },
            {
                field: 'owner_user_long_id',
                title: vm.resources.aml.search.columns.ownerTxt,
                width: 80,
                template: '{{dataItem.owner_user_long_id | userName:true}}'
            },
            {
                field: 'create_date',
                title: vm.resources.aml.search.columns.createDateTxt,
                width: 80,
                template: '{{dataItem.create_date | date}}'
            },
            {
                field: 'case_close_date',
                title: vm.resources.aml.search.columns.closeDateTxt,
                width: 80,
                template: '{{dataItem.case_close_date | date}}'
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'case_id',
            'case_id',
            amlConstants.entityType.case
        );

        function combineKeyAndValue(item) {
            item.value = item.key + ' ' + item.value;
        }
    }
})();
/**
 * Created by dabock on 10/14/2015.
 */
(function() {
    'use strict';
    CustomerSearchController.$inject = ["searchService", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller('CustomerSearchController', CustomerSearchController);

    function CustomerSearchController(searchService, resources, $scope, amlConstants) {
        var vm = this;
        vm.resources = resources;

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'customer'),
            partyNumber: new searchService.SearchField('party_number'),
            taxId: new searchService.SearchField('party_tax_id'),
            partyName: new searchService.SearchField('party_name'),
            partyNameSortable: new searchService.SearchField('party_name_sortable')
        };

        var fields = {
            // Gulp complains about the underscores if these
            // names aren't in quotes.
            'party_number': {type: 'string'},
            'party_tax_id': {type: 'string'},
            'party_name': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'party_number',
                title: vm.resources.aml.search.columns.customerNumber
            },
            {
                field: 'party_tax_id',
                title: vm.resources.aml.search.columns.customerTaxId
            },
            {
                field: 'party_name_sortable',
                title: vm.resources.aml.search.columns.customerName
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'party_number',
            'party_name',
            amlConstants.entityType.customer
        );
    }
})();
/**
 * Created by dabock on 10/15/2015.
 */
(function() {
    'use strict';
    ExternalPartySearchController.$inject = ["searchService", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller(
        'ExternalPartySearchController', ExternalPartySearchController);

    function ExternalPartySearchController(searchService, resources, $scope, amlConstants) {
        var vm = this;
        vm.resources = resources;

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'ext'),
            extPartyNumber: new searchService.SearchField('ext_party_number'),
            taxId: new searchService.SearchField('party_tax_id'),
            fullName: new searchService.SearchField('full_name'),
            fullNameSortable: new searchService.SearchField('full_name_sortable'),
            key: new searchService.SearchField('ext_party_account_key')
        };

        var fields = {
            'ext_party_number': {type: 'string'},
            'party_tax_id': {type: 'string'},
            'full_name': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'ext_party_number',
                title: vm.resources.aml.search.columns.externalPartyNumber
            },
            {
                field: 'party_tax_id',
                title: vm.resources.aml.search.columns.partyTaxId
            },
            {
                field: 'full_name_sortable',
                title: vm.resources.aml.search.columns.fullName
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'ext_party_number',
            'full_name',
            amlConstants.entityType.externalParty
        );
    }
})();
/**
 * Created by dabock on 10/12/2015.
 */
(function() {
    'use strict';
    HouseholdSearchController.$inject = ["searchService", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller('HouseholdSearchController', HouseholdSearchController);

    function HouseholdSearchController(searchService, resources, $scope, amlConstants) {
        var vm = this;
        vm.resources = resources;

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'hhd'),
            householdNumber: new searchService.SearchField('household_number'),
            householdName: new searchService.SearchField(['head_of_household_name', 'hhd_customer_name']),
            householdNameSortable: new searchService.SearchField('head_of_household_name_sortable')
        };

        var fields = {
            // Gulp complains about the underscores if these
            // names aren't in quotes.
            'household_number': {type: 'string'},
            'head_of_household_name': {type: 'string'},
            'hhd_customer_name': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'household_number',
                title: vm.resources.aml.search.columns.householdNumber
            },
            {
                field: 'head_of_household_name_sortable',
                title: vm.resources.aml.search.columns.headOfHouseholdName
            },
            {
                field: 'hhd_customer_name',
                title: vm.resources.aml.search.columns.householdCustomerName,
                sortable: false
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'household_number',
            'head_of_household_name',
            amlConstants.entityType.household
        );
    }
})();
/**
 * Created by dabock on 10/23/2015.
 */
(function() {
    'use strict';
    RiskAssessmentSearchController.$inject = ["searchService", "amlLov", "resources", "$scope", "amlConstants"];
    angular.module('aml.search').controller(
        'RiskAssessmentSearchController', RiskAssessmentSearchController);

    function RiskAssessmentSearchController(searchService, amlLov,
                                            resources, $scope, amlConstants) {
        var vm = this;
        vm.resources = resources;

        vm.riskAssessmentStatuses =
            amlLov.getAsArray(amlLov.riskAssessmentStatus);
        vm.closeReasons =
            amlLov.getAsArray(amlLov.closeReason);

        var riskClassifications =
            amlLov.getAsArray(amlLov.riskClassification);

        vm.riskClassifications = riskClassifications.filter(function(value) {
            // array has e.g. 3 - high and 3.0 - high. Filter out the .0s.
            return value.key.indexOf('.0') === -1;
        }).sort(function(a, b) {
            // Results in order High, Medium, Low, N/A.
            return b.key - a.key;
        });

        vm.riskAssessmentStatuses.unshift({key: '', value: ''});
        vm.closeReasons.unshift({key: '', value: ''});
        vm.riskClassifications.unshift({key: '', value: ''});

        vm.model = {
            docType:
                new searchService.SearchField('doc_type', 'risk'),
            riskAssessmentId:
                new searchService.SearchField('risk_assessment_id'),
            riskAssessmentIdSortable:
                new searchService.SearchField('risk_assessment_id_sortable'),
            proposedRiskClassification:
                new searchService.SearchField('proposed_risk_classification', ''),
            riskAssessmentStatus:
                new searchService.SearchField('risk_assessment_status_code', ''),
            customerNumber:
                new searchService.SearchField('risk_party_number'),
            customerNumberSortable:
                new searchService.SearchField('risk_party_number_sortable'),
            customerName:
                new searchService.SearchField('risk_party_name'),
            customerNameSortable:
                new searchService.SearchField('party_name_sortable'),
            createDate:
                new searchService.SearchField('create_date', [null, null], 'date'),
            currentRiskClassification:
                new searchService.SearchField('risk_classification', ''),
            closeReason:
                new searchService.SearchField('event_type_code', '')
        };

        // Don't use wildcards for fields selected by dropdown
        vm.model.proposedRiskClassification.noWildcard = true;
        vm.model.riskAssessmentStatus.noWildcard = true;
        vm.model.closeReason.noWildcard = true;
        vm.model.currentRiskClassification.noWildcard = true;

        var fields = {
            'risk_assessment_id': {type: 'string'},
            'proposed_risk_classification': {type: 'string'},
            'risk_assessment_status_code': {type: 'string'},
            'risk_party_number': {type: 'string'},
            'risk_party_name': {type: 'string'},
            'create_date': {type: 'string'},
            'risk_classification': {type: 'string'},
            'event_type_code': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'risk_assessment_id_sortable',
                title: vm.resources.aml.search.columns.riskAssessmentId
            },
            {
                field: 'proposed_risk_classification',
                title: vm.resources.aml.search.columns.proposedRiskClassification,
                template: '{{dataItem.proposed_risk_classification | riskClassification}}'
            },
            {
                field: 'risk_assessment_status_code',
                title: vm.resources.aml.search.columns.riskAssessmentStatus,
                template: '{{dataItem.risk_assessment_status_code | riskAssessmentStatus}}'
            },
            {
                field: 'risk_party_number_sortable',
                title: vm.resources.aml.search.columns.customerNumber,
                width: 80
            },
            {
                field: 'party_name_sortable',
                title: vm.resources.aml.search.columns.customerName
            },
            {
                field: 'create_date',
                title: vm.resources.aml.search.columns.createDate,
                template: '{{dataItem.create_date | date}}'
            },
            {
                field: 'risk_classification',
                title: vm.resources.aml.search.columns.currentRiskClassification,
                template: '{{dataItem.risk_classification | riskClassification}}'
            },
            {
                field: 'event_type_code',
                title: vm.resources.aml.search.columns.closeReason,
                template: '{{dataItem.event_type_code | closeReason}}'
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'risk_assessment_id',
            'risk_party_name',
            amlConstants.entityType.riskAssessment
        );
    }
})();
/**
 * Created by dabock on 10/26/2015.
 */
(function() {
    'use strict';
    WatchListSearchController.$inject = ["searchService", "resources", "$scope", "amlConstants", "amlLov"];
    angular.module('aml.search').controller('WatchListSearchController', WatchListSearchController);

    function WatchListSearchController(searchService, resources, $scope,
                                       amlConstants, amlLov) {
        var vm = this;
        vm.resources = resources;

        vm.yesNo = amlLov.getAsArray(amlLov.yesOrNo);
        vm.yesNo.unshift({key: '', value: ''});

        vm.model = {
            docType: new searchService.SearchField('doc_type', 'watch list'),
            programs: new searchService.SearchField('programs'),
            programsSortable: new searchService.SearchField('programs_sortable'),
            watchListNumber: new searchService.SearchField('watch_list_number'),
            watchListNumberSortable: new searchService.SearchField('watch_list_number_sortable'),
            entityName: new searchService.SearchField('entity_name'),
            entityNameSortable: new searchService.SearchField('entity_name_sortable'),
            country: new searchService.SearchField(['org_country_of_business_code',
                'org_country_of_business_name', 'country_code', 'country_name',
                'citizenship_country_code','citizenship_country_name',
                'nationality_country_code', 'nationality_country_name']),
            politicallyExposedPerson:
                new searchService.SearchField('politically_exposed_person_ind', ''),
            watchListKey: new searchService.SearchField('entity_watch_list_key')
        };

        // Don't use wildcards for fields selected by dropdown
        vm.model.politicallyExposedPerson.noWildcard = true;

        var fields = {
            'entity_name': {type: 'string'},
            'politically_exposed_person_ind': {type: 'string'},
            'programs': {type: 'string'},
            'watch_list_number': {type: 'string'},
            'org_country_of_business_name': {type: 'string'},
            'country_name': {type: 'string'},
            'citizenship_country_name': {type: 'string'},
            'nationality_country_name': {type: 'string'}
        };

        vm.gridColumns = [
            {
                field: 'entity_name_sortable',
                title: vm.resources.aml.search.columns.entityName
            },
            {
                field: 'politically_exposed_person_ind',
                title: vm.resources.aml.search.columns.polExpPerson,
                template: '{{dataItem.politically_exposed_person_ind | yesOrNo}}'
            },
            {
                field: 'programs_sortable',
                title: vm.resources.aml.search.columns.programs
            },
            {
                field: 'watch_list_number_sortable',
                title: vm.resources.aml.search.columns.watchListNumber
            },
            {
                field: 'org_country_of_business_name',
                title: vm.resources.aml.search.columns.orgCobName
            },
            {
                field: 'country_name',
                title: vm.resources.aml.search.columns.countryName
            },
            {
                field: 'citizenship_country_name',
                title: vm.resources.aml.search.columns.citCountryName
            },
            {
                field: 'nationality_country_name',
                title: vm.resources.aml.search.columns.natCountryName
            }
        ];

        searchService.commonSearch(
            vm,
            fields,
            $scope,
            'entity_watch_list_key',
            'entity_name',
            amlConstants.entityType.watchList
        );
    }
})();
(function () {
    'use strict';

    SegmentListController.$inject = ["$scope", "$rootScope", "amlLov", "amlConstants", "$state", "$q", "segmentListService", "resources", "kendoGridRendererService", "messageService"];
    angular
        .module('aml.admin')
        .controller('SegmentListController', SegmentListController);


    function SegmentListController($scope, $rootScope, amlLov, amlConstants, $state, $q,
                                 segmentListService, resources, kendoGridRendererService, messageService) {

        var vm = this;
        vm.state = $state.$current;
        vm.segments = []; //null is handled well by kendo-grid too, but we use [] to be consistent
        vm.grid = {};
        vm.amlGridActions = [];
        vm.resources = resources;
        vm.editRowId = -1; //this is the segmentKey of the current line that you are updating
        vm.disableDelete = false;

        vm.preventAction = false;


        var maxPageSizeForGrids = amlConstants.config.maxPageSizeForGrids; //get string 'two, all", etc for maxPageSize found in preferences
        if (!maxPageSizeForGrids) {
            maxPageSizeForGrids = 15000;
        } else {
            if (maxPageSizeForGrids !== 'all') {
                if (isNaN(parseInt(maxPageSizeForGrids, 10))) { //if there is none them use back-up variables
                    maxPageSizeForGrids = 202;
                } else {
                    if (maxPageSizeForGrids < 100) {
                        maxPageSizeForGrids = 201;
                    }
                }
            }
        }

        var logicalDeleteIndRenderingFilter = kendoGridRendererService.enum('logicalDeleteInd', 'yesOrNo');
        var activeIndRenderingFilter = kendoGridRendererService.enum('activeInd', 'yesOrNo');
        //filter object gets status (Y/N) and converts to (Yes/No), it is based on the value of activeInd field

        vm.selectYesOrNo = amlLov.getAsArray(amlLov.yesOrNo);

        vm.gridColumns = [          //grid layout
            {
                field: 'entitySegmentId', title: resources.aml.segment.header.entitySegmentId,
                width: '8%',
                //filterable: kendoGridRendererService.getCheckboxFilter('segmentName'),
                //template: '{{dataItem.entitySegmentId | segmentName:true}}'
            },
            {
                field: 'segmentName', title: resources.aml.segment.header.segmentCode,
                width: '12%'
            },
            {
                field: 'segmentDescription', title: resources.aml.segment.header.segmentDescription,
                width: '15%'
            },
            {
                field: 'lstUpdateUser', title: resources.aml.segment.header.lstUpdateUser,
                width: '9%',
                template: '{{dataItem.lstUpdateUser | userName:true}}'
            },
            {
                field: 'logicalDeleteInd', title: resources.aml.segment.header.logicalDeleteInd,
                width: '12%',
                template: logicalDeleteIndRenderingFilter,
                editor: function (container, options) {
                    var input = $('<input id="logicalDeleteInd" name="logicalDeleteInd" data-bind="value: ' + options.field + '" />');
                    input.appendTo(container);

                    input.kendoDropDownList({
                        autoBind: true,
                        dataTextField: 'value',
                        dataValueField: 'key',
                        dataSource: vm.selectYesOrNo
                    });
                },
                sortable: {compare: kendoGridRendererService.getFilterSortFunction(logicalDeleteIndRenderingFilter)},       //changed to sort logical delete
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'activeInd', title: resources.aml.segment.header.activeInd,
                width: '8%',
                template: activeIndRenderingFilter,
                editor: function (container, options) {
                    var input = $('<input id="activeInd" name="activeInd" data-bind="value: ' + options.field + '" />');
                    input.appendTo(container);

                    input.kendoDropDownList({
                        autoBind: true,
                        dataTextField: 'value',
                        dataValueField: 'key',
                        dataSource: vm.selectYesOrNo
                    });
                },
                sortable: {compare: kendoGridRendererService.getFilterSortFunction(activeIndRenderingFilter)},
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {

            command: [
                 'edit',
                {
                    name: 'destroy',
                    text: '{{ dataItem.logicalDeleteInd === "N"  ? "Delete" : "Undelete"}}',
                    iconClass: 'k-icon k-delete'
                },
            ],
                width: '13%'
            }
        ];


        var isEntitySegmentIdUnique = function (entitySegmentIdInput) {
            if (entitySegmentIdInput === '') {
                return true;
            }                       //we have to make sure that vm.segment is always updated

            var isUnique = true;

            for(var i=0; i<vm.segments.length; i++) {
                if(vm.segments[i].entitySegmentKey !== vm.editRowId && vm.segments[i].entitySegmentId === parseInt(entitySegmentIdInput)) {
                    isUnique = false;
                    break;
                }
            }

            return isUnique;
        };

        var isEntitySegmentNameUnique = function (entitySegmentNameInput) {
            if (entitySegmentNameInput === '') {
                return true;
            }                       //we have to make sure that vm.segment is always updated

            var isUnique = true;

            for(var i=0; i<vm.segments.length; i++) {
                if(vm.segments[i].entitySegmentKey !== vm.editRowId && vm.segments[i].segmentName.trim().toLowerCase() === entitySegmentNameInput.trim().toLowerCase()) {
                    isUnique = false;
                    break;
                }
            }

            return isUnique;
        };

        function setEnabled(enabled) {
            //mark Edit and Delete buttons so we can find them later, this has to be done each time
            //because Kendo removes them when going into edit mode and replaces with Update and Cancel
            //and then adds them back after edit is complete
            $('.k-grid-delete', '#segmentsList').addClass('k-delete-button');
            $('.k-grid-edit', '#segmentsList').addClass('k-edit-button');

            //disable all buttons except Update and Cancel when in Edit mode, so that row cannot be closed unfinished
            if (enabled) {
                //restore Kendo expected classes and attributes based on our marker classes
                $('.k-add-button', '#segmentsList').removeClass('k-state-disabled').addClass('k-grid-add').attr('disabled', false);
                $('.k-edit-button', '#segmentsList').removeClass('k-state-disabled').addClass('k-grid-edit').attr('href', '#');
                $('.k-delete-button', '#segmentsList').removeClass('k-state-disabled').addClass('k-grid-delete').attr('href', '#');
            }
            else {
                //remove Kendo classes and attributes to disable buttons
                $('.k-add-button', '#segmentsList').addClass('k-state-disabled').removeClass('k-grid-add').attr('disabled', true);
                $('.k-edit-button', '#segmentsList').addClass('k-state-disabled').removeClass('k-grid-edit').removeAttr('href');
                $('.k-delete-button', '#segmentsList').addClass('k-state-disabled').removeClass('k-grid-delete').removeAttr('href');
            }
        }

        vm.dataSourceOptions = new kendo.data.DataSource({      //custom grid option - data handling
            transport: {
                create: createSegment,        //intercept the CRUD methods to affect kendo
                read: getSegments,
                update: editSegment,
                destroy: deleteSegment
            },
            batch: false,
            schema: {
                model: {
                    id: 'entitySegmentKey',     //need to have id, update should only apply to index 0 element when clicking "create segment"
                    fields: {
                        entitySegmentKey: {type: 'number'},     //this will be overwritten with random id, here it is used as an index in grid
                        entitySegmentId: {
                            type: 'number',
                            validation: {
                               required: {message: resources.aml.segment.inputMessages.idRequiredErrorTxt},
                                pattern: {
                                    value: '^-?\\d+$',
                                    message: resources.aml.segment.inputMessages.idNotANumber
                                },
                                uniqueID: function (input) {
                                    if (input.is('[name=\'entitySegmentId\']')) {
                                        if (input.val().length === 0) {
                                            input.attr('data-uniqueID-msg', resources.aml.segment.inputMessages.idRequiredErrorTxt);
                                            return false;
                                        } else if (input.val().length > 12)  {
                                            input.attr('data-uniqueID-msg', resources.aml.segment.inputMessages.idTooLongErrorTxt);
                                            return false;
                                        }
                                        else {
                                            if (isEntitySegmentIdUnique(input.val())) {
                                                return true;
                                            } else {
                                                //set custom error message
                                                input.attr('data-uniqueID-msg', resources.aml.segment.inputMessages.idIsNotUniqueErrorTxt);
                                                return false;
                                            }
                                        }
                                    }
                                    return true;
                                }
                            }
                        },
                        segmentName: {
                            type: 'string',
                            validation: {
                                required: {message: resources.aml.segment.inputMessages.nameRequiredErrorTxt},
                                pattern: {
                                    value: '^[^]{0,50}$',
                                    message: resources.aml.segment.inputMessages.nameTooLongErrorTxt
                                },
                                uniqueName: function (input) {
                                    if (input.is('[name=\'segmentName\']')) {
                                        if (input.val().trim().length === 0) {
                                            input.attr('data-uniqueName-msg', resources.aml.segment.inputMessages.nameRequiredErrorTxt);
                                            return false;
                                        } else {
                                            if (isEntitySegmentNameUnique(input.val())) {
                                                return true;
                                            } else {
                                                //set custom error message
                                                input.attr('data-uniqueName-msg', resources.aml.segment.inputMessages.nameIsNotUniqueErrorTxt);
                                                return false;
                                            }
                                        }
                                    }
                                    return true;
                                }
                            }
                        },
                        segmentDescription: {
                            type: 'string',
                            validation: {
                                required: {message: resources.aml.segment.inputMessages.descriptionRequiredErrorTxt},
                                pattern: {
                                    value: '^[^]{0,100}$',
                                    message: resources.aml.segment.inputMessages.descriptionTooLongErrorTxt
                                }
                            }
                        },     //these are the column fields
                        lstUpdateUser: {type: 'string', editable: false},
                        logicalDeleteInd: {
                            type: 'string',
                            defaultValue: 'N',
                            editable: false
                        },
                        activeInd: {
                            type: 'string',
                            defaultValue: 'Y'
                        }
                    }
                }
            },
            requestStart: function (e) {
                //prevent grid navigation including paging controls, filters and sorting
                if (vm.preventAction) {
                    e.preventDefault();
                }
            },
            pageSize: 20,  //set default selection to first option -- 20
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        });


        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(      //custom grid options - UI specs
            {
                dataSource: vm.dataSourceOptions,
                columns: vm.gridColumns,
                pageable: {
                    pageSizes: [5, 10, 20, 50, 100, maxPageSizeForGrids],
                    numeric: false,  //this is a different way to choose page option, we are using array so disable this
                    refresh: true,
                },
                editable: {
                    mode: 'inline',
                    confirmation: false
                },
                resizable: true,
                selectable: 'multiple',
                allowCopy: true,
                filterable: true,
                batch: false,
                toolbar: [{text: '', template: kendo.template($('#segmentsGrid_toolbar').html())}], //this is to add the top buttons (Create/Cancel Changes)
                scrollable: false,
                sortable: {
                    mode: 'multiple',
                    allowUnsort: true       //add row editing under here
                },
                edit: function (e) {
                    vm.preventAction = true;
                    //update the id reference to the current row you are updating, if you are creating, value is 0
                    vm.editRowId = e.model.entitySegmentKey;

                    if(e.model.isNew() ===false) {
                        $('td[data-container-for=entitySegmentId]').html(e.model.entitySegmentId);   //take off textbox if you are editing inline
                    }
                    setEnabled(!vm.preventAction);
                },
                cancel: function () {
                    vm.preventAction = false;
                    setEnabled(!vm.preventAction);
                },
                dataBound: function () {
                    vm.preventAction = false;
                    setEnabled(!vm.preventAction);
                    //bind our own Add button click handler, so that grid could be unsorted and row will be inserted on top
                    //see https://docs.telerik.com/kendo-ui/knowledge-base/capture-the-add-event-of-the-grid
                    $('.k-grid-add').unbind('click');
                    $('.k-grid-add').bind('click', function(){
                        kendoGridRendererService.clearFilters(vm.grid);
                        kendoGridRendererService.clearSorts(vm.grid);
                    });
                }
            });


       kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'segmentsList');


        function createSegment(e) {

            var segment = {
                entitySegmentId: e.data.entitySegmentId,
                segmentName: e.data.segmentName,
                segmentDescription: e.data.segmentDescription,
                //lstUpdateUser: e.data.lstUpdateUser,    //user cannot input this
               // logicalDeleteInd: e.data.logicalDeleteInd,  //user cannot input this, only delete button can change it
                activeInd: e.data.activeInd
            };


            if (validateSegment(segment)) {
                segmentListService.createSegment(segment).then(function(result) {
                    e.data.entitySegmentKey = result.entitySegmentKey;      //we have created the segment, we need to give the object and id for kendo to use
                    e.data.lstUpdateUser = result.lstUpdateUser;
                    vm.segments.push(e.data);
                    e.success(e.data);          //return the data with the new id
                });
            } else {
                //this should never happen if buttons are disabled correctly
                messageService.danger(
                    vm.resources.aml.getResource('segment.segmentNotValidErrorTxt'), null, -1);
                e.error(e.data);
            }

        }


        function getSegments (e) {
            segmentListService.getSegments().then(function(result) {
                vm.segments = result.items;
                e.success(vm.segments);
            });
        }

        function validateSegment(s) {
            if (isEntitySegmentIdUnique(s.entitySegmentId) && s.segmentName && s.segmentDescription) {
                return true;
            }
            return false;
        }


        function editSegment(e) {

            var newSegment = {
                entitySegmentKey: e.data.entitySegmentKey,
                entitySegmentId: e.data.entitySegmentId,
                segmentName: e.data.segmentName,
                segmentDescription: e.data.segmentDescription,
                lstUpdateUser: e.data.lstUpdateUser,
                logicalDeleteInd: e.data.logicalDeleteInd,
                activeInd: e.data.activeInd
            };



            if (validateSegment(newSegment)) {
                segmentListService.updateSegment(newSegment).then(function(result) {
                    e.data.entitySegmentKey = result.entitySegmentKey;      //the object is still updated and returned
                    e.data.lstUpdateUser = result.lstUpdateUser;
                    e.success(e.data);

                    //update entitySegment in array without reloading grid
                    for(var i=0; i<vm.segments.length; i++) {
                        if(vm.segments[i].entitySegmentKey === newSegment.entitySegmentKey) {
                            vm.segments[i].entitySegmentKey = result.entitySegmentKey;
                            vm.segments[i].entitySegmentId = result.entitySegmentId;
                            vm.segments[i].segmentName = result.segmentName;
                            vm.segments[i].segmentDescription = result.segmentDescription;
                            vm.segments[i].lstUpdateUser = result.lstUpdateUser;
                            vm.segments[i].logicalDeleteInd = result.logicalDeleteInd;
                            vm.segments[i].activeInd = result.activeInd;
                        }
                    }
                });
            } else {
                //this should never happen if buttons are disabled correctly
                messageService.danger(
                    vm.resources.aml.getResource('segment.segmentNotValidErrorTxt'), null, -1);
                e.error(e.data);
            }

        }


        function deleteSegment(e) {

            if(vm.disableDelete) {
                return;
            } else {
                vm.disableDelete = true;
            }

            var setAsDelete = e.data.logicalDeleteInd === 'N' ? 'Y' : 'N';

            var segmentCopy = {
                entitySegmentKey: e.data.entitySegmentKey,
                entitySegmentId: e.data.entitySegmentId,
                segmentName: e.data.segmentName,
                segmentDescription: e.data.segmentDescription,
                lstUpdateUser: e.data.lstUpdateUser,
                logicalDeleteInd: setAsDelete,      //value switched here and updated in midtier
                activeInd: e.data.activeInd
            };


            segmentListService.updateSegment(segmentCopy).then(function(result){
                e.data.entitySegmentKey = result.entitySegmentKey;      //the object is still updated and returned
                e.success(e.data);
                reloadGrid();       //this updates segments array
            });

        }

        function reloadGrid() {
            vm.grid.dataSource.read();
            vm.disableDelete = false;
        }
    }
})();
(function() {
    'use strict';
    TransactionDetailsController.$inject = ["resources", "amlConstants", "dataMessagingServiceFactory", "$stateParams", "transactionDetailsService", "alertsService", "$scope"];
    angular.module('aml.customer').controller('TransactionDetailsController', TransactionDetailsController);

    function TransactionDetailsController(resources, amlConstants, dataMessagingServiceFactory, $stateParams, transactionDetailsService, alertsService, $scope) {
//console.log("TransactionDetailsController Call 00001");
        var vm = this;
        vm.resources = resources;
        vm.entityNumber = $stateParams.transactionid;
        vm.useDateOnlyForTransactions = amlConstants.config.useDateOnlyForTransactions;

        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        vm.entityId = {
            entityKey: 0,
            entityNumber: $stateParams.transactionid,
            entityLevelCode: amlConstants.entityType.transaction
        };
        
        dataMessagingService.setEntityId( vm.entityId );
//console.log("===== vm =====");
//console.log("vm : " + JSON.stringify(vm));
//console.log("===== vm.alertIdVal =====");
//console.log("TransactionDetailsController vm.alertIdVal : " + vm.alertIdVal);
//console.log("$stateParams : " + JSON.stringify($stateParams));

//console.log("dataMessagingService.getAlertIdVal() : " + dataMessagingService.getAlertIdVal());
/*        
        function getAlertIdVal() {
            return dataMessagingService.getAlertIdVal();
        }
        
        vm.alertIdVal = getAlertIdVal;
        
console.log("vm.alertIdval : " + vm.alertIdVal);
*/      
        activate();

        function activate() {
        	
//console.log("dataMessagingService.getAlertIds('alertids') : " + dataMessagingService.getAlertIds('alertids'));

//console.log("TransactionDetailsController activate() Call 00002");
//console.log("JSON.stringify($stateParams) : " + JSON.stringify($stateParams));
//console.log("dataMessagingService.getAlertIdVal() : " + dataMessagingService.getAlertIdVal());

            transactionDetailsService.getTransaction($stateParams.transactionid).then(function(data) {
                vm.transaction = data;
//console.log("JSON.stringify(data) : " + JSON.stringify(data));
								
                dataMessagingService.setCustomerName( vm.transaction.transactionDescription );
                
            });

//console.log("vm.alertId : " + vm.alertId);
						alertsService.getAlert($stateParams.alertIdVal).then(function (data) {
//console.log("%%%% data : " + data);
//console.log("alertsService.getAlert scenarioName : " + data.scenarioName);
							
							vm.alertData = data;
							
/*
                viewVm.alert = data;
                viewVm.activateInProcess = false;
                // scenario data is returned with an alert
                viewVm.scenario = data.scenario;
                viewVm.entityId = entityService.normalizeEntityId(viewVm.entityId, viewVm.alert.alertedEntityLevelCode, viewVm.alert.alertedEntityNumber, viewVm.alert.alertedEntityKey);
                if (viewVm.alert && viewVm.alert.caseId) {
                    casesService.getCase(viewVm.alert.caseId).then(
                        function success (data) {
                            viewVm.case = data;
                        }
                    );
                }

                // If there's a segment on the alert, get the current segment
                if(data.entitySegmentId) {
                    alertsService.getCurrentSegment(
                        data.alertLevel,
                        data.primaryEntityNumber
                    ).then(function(data) {
                        viewVm.alert.currentSegmentName = data.segmentName;
                    });
                }
                
*/
            });

        }
	
    }
})();

/**
 * Created by fikhas on 1/22/2015.
 */

(function() {
    'use strict';
    TxMetricsController.$inject = ["transactionsService", "$filter", "entityService", "$scope", "resources", "kendoGridRendererService", "amlCoreUtils", "dataMessagingServiceFactory"];
    angular.module('aml.customer.details').controller('TxMetricsController', TxMetricsController);

    function TxMetricsController(transactionsService, $filter, entityService, $scope, resources,
                                 kendoGridRendererService, amlCoreUtils, dataMessagingServiceFactory) {
        // init
        var vm = this;

        vm.entityId = entityService.normalizeEntityId( vm.entityId,
            vm.entityLevelCode, vm.entityNumber, vm.entityKey );

        vm.aggregates = [];
        vm.showMetrics = false;
        vm.selectedGroupBy = 'PRI';
        //vm.groupByLabel = resources.aml.getResource('graphs.txtype');

        if(vm.grpBy === 'CDI') {
            vm.groupByLabel = resources.aml.getResource('graphs.cdi');
        }
        if(vm.grpBy === 'PRI') {
            vm.groupByLabel = resources.aml.getResource('graphs.txtype');
        }

        vm.elementId = vm.grpBy + 'Chart' + '-' + amlCoreUtils.stripInvalidIdCharacters(vm.entityId.entityNumber);
        var metricPanel = '#' + vm.elementId;
        vm.totalAmount = 0;
        vm.dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.filterStr = 'na';
        vm.selectedIds = 'na';
        vm.loadingChart = true;
        vm.resources = resources;
        vm.selectedAlertid = -1;

        //For HHD and ACC use all alerts if no alerts are selected.
        // Those entities do not have aggregated data in datamart, so need to use alerts
        function getAllAlertsFilter () {
            var selectedAlertsFilter =  'all';
            var allAlerts = vm.dataMessagingService.getSelectedAlertCount() > 0 ? vm.dataMessagingService.getSelectedAlerts() : vm.dataMessagingService.getAllAlerts();
            if ( allAlerts && allAlerts.length ) {
                    if (allAlerts.length > 0) {
                        //when multiple selection is enabled data is array
                        selectedAlertsFilter = 'in(alertId';
                        for (var i = 0; i < allAlerts.length; i++) {
                            if (allAlerts[i].alertId) {
                                selectedAlertsFilter = selectedAlertsFilter + ', ' + allAlerts[i].alertId;
                            }
                        }
                        selectedAlertsFilter = selectedAlertsFilter + ')';
                    }
            }
            return selectedAlertsFilter;
        }

        $scope.$watch(function () {
            return vm.dataMessagingService.getAlertIds('alertids');
        }, function (newVal, oldVal) {
            if(newVal !== 'na') {
                vm.filterStr = newVal;
                if ( !vm.filterStr ) {
                    vm.selectedAlertid = -1;
                }
                else {
                    var numberPattern = /\d+/g;
                    vm.selectedAlertid = newVal.match(numberPattern) === null?-1:newVal.match(numberPattern)[0];
                }
                if ( vm.entityId && vm.entityId.entityLevelCode === 'HHD' ) {
                    vm.filterStr = getAllAlertsFilter();
                    vm.selectedAlertid = 1;
                }

                activate();
            }
        });

        vm.onChange = function(){
            vm.loadingChart = true;
            if(vm.selectedGroupBy === 'CDI') {
                vm.groupByLabel = resources.aml.getResource('graphs.cdi');
            }
            if(vm.selectedGroupBy === 'PRI') {
                vm.groupByLabel = resources.aml.getResource('graphs.txtype');
            }
            activate();
        };
        /*
         var formatCurrency = function(value){
         return $filter('currency')(value, vm.currencySymbol,2);
         };*/

        var rtl = kendoGridRendererService.getTextDirection();
        var labelTextAnchor = 'end';
        var legendTextAnchor = 'start';

        if(rtl === true){
            labelTextAnchor = 'start';
            legendTextAnchor = 'end';
        }
        function plotPieChart(){
            var margin = {top: 30, right: 75, bottom: 100, left: 85},
                width = 450 - margin.left - margin.right,
                height = 450 - margin.top - margin.bottom;
            var radius = Math.min(width, height) / 2;
            var donutWidth = 60;
            var legendRectSize = 18;
            var legendSpacing = 4;
            var dataset = [];
            // Remove any aggregates with zero amount
            _.each(vm.aggregates,function (aggregate){
                if(aggregate.amount !== 0){
                    dataset.push(aggregate);
                }
            });
            //var dataset = vm.aggregates;
            var color = d3.scale.ordinal().range(['#ff7f0e','#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']);
            d3.select(metricPanel).select('svg').remove();
            var svg = d3.select(metricPanel)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', 'translate(' + (width * 6.5/10) +  ',' + (height * 7/10) + ')');

            // Title
            var title = '', subtitle = '';
            if(!vm.filterStr || vm.filterStr === 'all' || vm.filterStr === null){
                title = vm.resources.aml.getResource('graphs.title1', {  totalAmount: vm.totalAmount });
                subtitle = vm.resources.aml.getResource('graphs.subtitle1', {  totalAmount: vm.totalAmount });
            }else{
                title = vm.resources.aml.getResource('graphs.title2', {  totalAmount: vm.totalAmount });
                subtitle = vm.resources.aml.getResource('graphs.subtitle2',
                    { selectedAlertid: vm.selectedAlertid, selectedAlerts: vm.dataMessagingService.getSelectedAlertCount(), totalAmount: vm.totalAmount});
            }
            d3.select(metricPanel).select('svg').append('text')
                .attr('x', (width * 6/10))
                .attr('y', 15 + (margin.top/3))
                .attr('text-anchor', 'middle')
                .attr('class', 'graph-title text-primary')
                //.style('text-decoration', 'underline')
                //.text(title);
                .text(vm.groupByLabel);
            d3.select(metricPanel).select('svg').append('text')
                .attr('x',(width * 6/10))
                .attr('y', 35 + (margin.top/3))
                .attr('text-anchor', 'middle')
                .attr('class', 'graph-title text-primary')
                .text(subtitle);

            var arc = d3.svg.arc()
                .innerRadius(radius - donutWidth)
                .outerRadius(radius);
            var pie = d3.layout.pie()
                .value(function(d) { return d.amount; })
                .sort(null);
            var path = svg.selectAll('path')
                .data(pie(dataset))
                .enter()
                .append('path')
                .attr('d', arc)
                .attr('fill', function(d, i) {
                    return color(d.data.groupByValue);
                });

            var legend = svg.selectAll('.legend')
                .data(color.domain())
                .enter()
                .append('g')
                .attr('class', 'legend')
                .attr('transform', function(d, i) {
                    var height = legendRectSize + legendSpacing;
                    var offset = height * color.domain().length / 2;
                    var horz = -2 * legendRectSize;
                    var vert = i * height - offset;
                    return 'translate(' + horz + ',' + vert + ')';
                });

            legend.append('rect')
                .attr('width', legendRectSize)
                .attr('height', legendRectSize)
                .style('fill', color)
                .style('stroke', color);

            legend.append('text')
                .attr('x', legendRectSize + legendSpacing)
                .attr('y', legendRectSize - legendSpacing)
                .text(function(d) { return d; })
                .attr('text-anchor', legendTextAnchor);

            var tooltip = d3.select(metricPanel)
                .append('div')
                .attr('class', 'pietooltip');

            tooltip.append('div')
                .attr('class', 'groupByValue');

            tooltip.append('div')
                .attr('class', 'amount');

            tooltip.append('div')
                .attr('class', 'percent');
            path.on('mouseover', function(d) {
                var total = d3.sum(dataset.map(function(d) {
                    return d.amount;
                }));
                var percent = Math.round(1000 * d.data.amount / total) / 10;
                tooltip.select('.groupByValue').html(d.data.groupByValue);
                tooltip.select('.amount').html(kendoGridRendererService.formatCurrency(parseFloat(d.data.amount)));
                tooltip.select('.percent').html(percent + '%');
                tooltip.style('display', 'block');
            });

            path.on('mouseout', function() {
                tooltip.style('display', 'none');
            });

            /*
             svg.append('text')
             .attr('x', 0)
             .attr('y', height * 6.2/10)
             .attr('text-anchor', 'middle')
             .style('text-anchor', 'middle')
             .attr('class', 'graph-axis-title')
             .text(vm.groupByLabel);
             */
        }

        function plotD3Metric() {
            var seps = kendoGridRendererService.getNumSeparators();
            var grpSep = seps.grpSep;
            var decSep = seps.decSep;
            var localeFormatter = d3.locale({
                'decimal': decSep,
                'thousands': grpSep,
                'grouping': [3],
                'currency': ['$', ''],
                'dateTime': '%a %b %e %X %Y',
                'date': '%m/%d/%Y',
                'time': '%H:%M:%S',
                'periods': ['AM', 'PM'],
                'days': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                'shortDays': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                'months': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                'shortMonths': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            });

            var numberFormat = localeFormatter.numberFormat(',.0f');
            var tooltip = d3.selectAll('#tooltip');
            var dataset = [];
            // Remove any aggregates that have zero amount
            _.each(vm.aggregates,function (aggregate){
                if(aggregate.amount !== 0){
                    dataset.push(aggregate);
                }
            });
            //var margin = {top: 30, right: 75, bottom: 100, left: 85},
            var margin = {top: 80, right: 70, bottom: 90, left: 90},
                w = 650 - margin.left - margin.right,
                h = 380 - margin.top - margin.bottom;
            //var padding = 10;


            var xScale = d3.scale.ordinal()
                .domain(d3.range(dataset.length))
                .rangeRoundBands([0, w], 0.05);
            // ternary operator to determine if global or local has a larger scale
            var yMax = d3.max(dataset, function(d) { return (d.amount * 1.20);});
            var yMaxData = d3.max(dataset, function(d) { return (d.amount);});
            var commaFormat = d3.format(',');
            //var colors =	['#377EB8','#4DAF4A','#00FF00'];
            var colors =	[['> 1% of ' + commaFormat(yMaxData), '#377EB8'], ['<= 1% of ' + commaFormat(yMaxData), '#4DAF4A']];
            var yScale = d3.scale.linear()
                .domain([0, yMax])
                .range([h, 0]);
            var xAxis = d3.svg.axis()
                .scale(xScale)
                .tickFormat(function(d) { return $filter('titleCase')(dataset[d].groupByValue); })
                .orient('bottom');
            var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient('left')
                .ticks(10)
                .tickFormat(numberFormat);




            //SVG element
            d3.select(metricPanel).select('svg').remove();
            var svg = d3.select(metricPanel)
                .append('svg')
                .attr('width', w)
                .attr('height', h)
                //.attr('width', w + margin.left + margin.right)
                //.attr('height', h + margin.top + margin.bottom)
                .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Graph Bars
            var sets = svg.selectAll('.set')
                .data(dataset)
                .enter()
                .append('g')
                .attr('class','set')
                .attr('transform',function(d,i){
                    return 'translate(' + xScale(i) + ',0)';
                })	;

            sets.append('rect')
                .attr('width', xScale.rangeBand())
                .attr('y', function(d) {
                    if(d.amount <= 0.01 * yMaxData) {
                        return yScale(0.01 * yMax);
                    }
                    if(d.amount > 0.01 * yMaxData) {
                        return yScale(d.amount);
                    }
                })
                //.attr('x', xScale.rangeBand()/2)
                .attr('height', function(d){
                    if(d.amount <= 0.01 * yMaxData){
                        return h - yScale(0.01 * yMax);
                    }
                    if(d.amount > 0.01 * yMaxData){
                        return h - yScale(d.amount);
                    }
                })
                .attr('fill', function(d){
                    if(d.amount <= 0.01 * yMaxData) {
                        return colors[0][1];
                        //return '#4DAF4A';
                    }
                    return colors[0][1];
                })
                .on('mouseover', function(d,i) {
                    //Get this bar's x/y values, then augment for the tooltip
                    var xPosition = parseFloat(xScale(i) + xScale.rangeBand() );
                    var yPosition = h / 2;
                    var offset = $(metricPanel).offset();

                    //Update Tooltip Position & value
                    d3.select('#tooltip')
                        .select('#groupBy')
                        .style('color', colors[1][1])
                        .text(vm.groupByLabel);
                    d3.select('#tooltip')
                        .select('#amount')
                        .text(kendoGridRendererService.formatCurrency(d.amount));
                    d3.select('#tooltip')
                        .select('#amountHeading')
                        .style('color', colors[1][1])
                        .text(vm.resources.aml.graphs.ttamount);
                    d3.select('#tooltip')
                        .style('left', offset.left + xPosition + 'px')
                        .style('top', offset.top + yPosition + 'px')
                        .select('#group')
                        .text($filter('titleCase')(d.groupByValue));
                    d3.select('#tooltip').classed('hidden', false);
                    return tooltip.style('visibility', 'visible');
                })
                .on('mouseout', function() {
                    //Remove the tooltip
                    d3.select('#tooltip').classed('hidden', true);
                });

            // Labels
            /*
             sets.append('text')
             //.attr('class', 'local')
             .attr('width', xScale.rangeBand()/2)
             .attr('y', function(d) {
             return yScale(d.amount);
             })
             .attr('dy', -10)
             //.attr('dx', (xScale.rangeBand()/1.6) )
             //.attr('dx', (xScale.rangeBand()/10) )
             .attr('dx', 0 )
             //.attr('text-anchor', 'middle')
             .attr('font-family', 'sans-serif')
             .attr('font-size', '8px')
             .attr('fill', 'black')
             //.attr('fill', '#4DAF4A')
             .text(function(d) {
             return formatCurrency(d.amount);
             });
             */
            // xAxis
            svg.append('g') // Add the X Axis
                .attr('class', 'x axis')
                .attr('transform', 'translate(0,' + (h) + ')')
                .call(xAxis)
                .selectAll('text')
                .style('text-anchor', labelTextAnchor)
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', function(d) {
                    return 'rotate(-45)';
                })
            ;
            // yAxis
            svg.append('g')
                .attr('class', 'y axis')
                .attr('transform', 'translate(0 ,0)')
                .call(yAxis)
                .selectAll('text')
                .style('text-anchor', labelTextAnchor)
            ;
            // xAxis label
            /*
             svg.append('text')
             .attr("text-anchor", "end")
             .attr("x", w)
             .attr("y", h + 110)
             //.attr('transform', 'translate(' + (w / 2) + ' ,' + (h + margin.bottom + 10) +')')
             .style('text-anchor', 'middle')
             .attr('class', 'graph-axis-title')
             .text(vm.groupByLabel);
             */
            //yAxis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (h / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .attr('class', 'graph-axis-title')
                .text(vm.resources.aml.graphs.amount + ' (' + amlCoreUtils.getBaseCurrencySymbol() + ')');

            // Title
            var title = '', subtitle = '';
            if(!vm.filterStr || vm.filterStr === 'all' || vm.filterStr === null){
                title = vm.resources.aml.getResource('graphs.title1', {  totalAmount: vm.totalAmount });
                subtitle = vm.resources.aml.getResource('graphs.subtitle1', {  totalAmount: vm.totalAmount });
            }else{
                title = vm.resources.aml.getResource('graphs.title2', { totalAmount: vm.totalAmount });
                subtitle = vm.resources.aml.getResource('graphs.subtitle2',
                    { selectedAlertid: vm.selectedAlertid, selectedAlerts: vm.dataMessagingService.getSelectedAlertCount(), totalAmount: vm.totalAmount});
            }
            vm.aggTitle = title;
            svg.append('text')
                .attr('x', (w / 2))
                .attr('y', 25 - (margin.top))
                .attr('text-anchor', 'middle')
                .attr('class', 'graph-title text-primary')
                //.style('text-decoration', 'underline')
                //.text(title);
                .text(vm.groupByLabel);
            svg.append('text')
                .attr('x',(w / 2))
                .attr('y', 45 - margin.top)
                .attr('text-anchor', 'middle')
                .attr('class', 'graph-title text-primary')
                .text(subtitle);

            // add legend
            /*
             var legend = svg.append('g')
             .attr('class', 'legend')
             .attr('x', w - 65)
             .attr('y', 10)
             .attr('x', 0)
             .attr('y', 0)
             .attr('height', 50)
             .attr('width', 100)
             .attr('transform',0,0)
             //.attr('transform', 'translate(20,' + h + ')')
             .attr('transform', 'translate(' + (w) + ' ,' + (h + margin.bottom - 5) +')')
             ;

             var legendRect = legend.selectAll('rect').data(colors);

             legendRect.enter()
             .append('rect')
             .attr('x', w - 113)
             //	.attr('y', 0)										// use this to flip horizontal
             .attr('width', 10)
             .attr('height', 10)
             .attr('y', function(d, i) {
             return i * 20;
             })
             //.attr('x', function(d, i){return w - 65 - i * 70}) // use this to flip horizontal
             .style('fill', function(d) {
             return d[1];
             });

             var legendText = legend.selectAll('text').data(colors);

             legendText.enter()
             .append('text')
             .attr('x', w - 100)
             .attr('y', function(d, i) {
             return i * 20 + 9;
             })
             .text(function(d) {
             return d[0];
             });
             */
        }

        function activate(){
            //for Account and Household entities there is no transaction aggregation data, so use alerts aggregated data instead
            var saveFilter = vm.filterStr;
            if ( vm.entityId && vm.entityId.entityLevelCode === 'HHD' || vm.entityId && vm.entityId.entityLevelCode === 'ACC' ) {
                vm.filterStr = getAllAlertsFilter();
                vm.selectedAlertid = 1;
            }
            getTransactionsAggregates(vm.entityId, vm.grpBy, vm.filterStr);
            vm.filterStr = saveFilter;
        }

        function getTransactionsAggregates(entityId, groupBy, filterStr){
            transactionsService.getTransactionsAggregates(entityId,groupBy,filterStr).then(function(data){
                vm.aggregates = data.items;

                // if there were no results, just set to an empty array. This can happen if a selected alert was
                // not captured in the FSK_ALRT_TX_AGG table
                if ( !vm.aggregates || vm.aggregates.length === 0 ) {
                    vm.aggregates = [];
                }

                var total = 0;
                _.each( vm.aggregates, function( aggregate ){
                    total = total + aggregate.amount;
                });
                vm.totalAmount = kendoGridRendererService.formatCurrency(total);
                vm.dataMessagingService.setTotalAmount(vm.totalAmount);
                //vm.aggAmount = total;
                //vm.currencySymbol = $filter('currencyCode')(vm.currencyCode);
                vm.showMetrics = true;
                vm.loadingChart= false;
                if(vm.grpBy === 'PRI') {
                    d3.select(metricPanel).select('svg').remove();
                    plotD3Metric();
                }
                if(vm.grpBy === 'CDI'){
                    d3.select(metricPanel).select('svg').remove();
                    plotPieChart();
                }
            });
        }
    }

})();

(function () {
    'use strict';
    FundsTrackerViewController.$inject = ["$stateParams", "resources"];
    angular.module('aml').controller('FundsTrackerViewController',
        FundsTrackerViewController);

    function FundsTrackerViewController($stateParams, resources) {
        var vm = this;
        vm.resources = resources;
        vm.params = {};
        vm.params.entityNumber = $stateParams.accountid;


        vm.params.fromNode = '';
        vm.params.toNode = '';

    }


})();
/**
 * Created by omkulk on 1/22/2015.
 */

(function() {
    'use strict';
    FundsTrackerController.$inject = ["fundsTrackerService", "entityService", "resources", "$stateParams", "amlCoreUtils"];
    angular.module('aml').controller('FundsTrackerController', FundsTrackerController);

    function FundsTrackerController(fundsTrackerService, entityService, resources,
                               $stateParams, amlCoreUtils) {
        // init
        var vm = this;

        /**
         * This accountId will be contatenated with 'fundstracker' to create unique svg div for
         * respective accounts. This will append node, links and other svg's to their respective divs
         * associated with the accounts
         * @type {*|any}
         */
        vm.accountId = $stateParams.accountid;
        vm.entityId = entityService.normalizeEntityId( vm.entityId,
            vm.entityLevelCode, vm.entityNumber, vm.entityKey );

        vm.resources = resources;
        vm.refreshEnabled = true;

        /**
         * creating a unique fundsTrackerId which will be used as an id while creating the base svg
         * in the service. this variable can be searched in the fundstracker.service.js to understand
         * the usage.
         * This utility is helpful when the user will open multiple fundstrackers on the page.
         * The new svgs created will then be appended to their respective accounts' fundstrackers
         * @type {string}
         */
        vm.fundsTrackerId =  'fundstracker-' + amlCoreUtils.stripInvalidIdCharacters(vm.accountId);
        var domId = '#' + vm.fundsTrackerId;

        /**
         * unique domID for the Network logger. the tracking of clicks
         * will be appended to respective network loggers with multiple fundstracker open on the AML
         * @type {string}
         */
        vm.domIdLog = domId + 'Log';

        /**
         * This is another REST call where the transactions between two accounts are pulled
         * using fromNode or the remitter acoount and the toNode or the beneficiary account.
         * @param d
         */
        function onLinkSelect(d){
            vm.params.fromNode = d.source.name;
            vm.params.toNode = d.target.name;
            vm.params.reload();
        }

        var accountNumber = $stateParams.accountid, links;

        /**
         * activate function will essential store the promise in the links array.
         * Here in debug mode or dev mode, links can be printed in console to see
         * how the data is structured inside.
         *
         * @param accountNumber
         * @param minThreshold
         * @param maxThreshold
         */
        function activate(accountNumber, minThreshold, maxThreshold){
            fundsTrackerService.setonLinkSelect(onLinkSelect);
            fundsTrackerService.getNetwork(accountNumber).then(function(data) {

                links = data.items;

                d3.select(domId).select('svg').remove();
                fundsTrackerService.sankey(links, vm.params.entityNumber, activate, minThreshold, maxThreshold, vm.fundsTrackerId, 'svg' + vm.fundsTrackerId);
                /**
                 * vm.min and vm.max are the min and max amount of transaction
                 * in the pulled transaction data
                 */
                vm.max = fundsTrackerService.maxCurrencyAmount(links);
                vm.min = fundsTrackerService.minCurrencyAmount(links);
                vm.refreshEnabled = true;
            });
        }

        activate(accountNumber);

        vm.filter = function(){
            // vm.minRangeValue and vm.maxRangeValue are the input fields on the html form of the fundstracker page
            if(vm.minRangeValue || vm.maxRangeValue){
                if (vm.refreshEnabled) {
                    vm.refreshEnabled = false;
                    fundsTrackerService.clearLinks(vm.fundsTrackerId);
                    activate(accountNumber, vm.minRangeValue, vm.maxRangeValue); //will reset vm.refreshEnabled flag
                }
            }
        };

        //clear the range values in inputbox
        function clearFunction(){
            vm.minRangeValue = null;
            vm.maxRangeValue = null;
        }

        //this function will refresh the fundtracker chart to reset it to original state.
        vm.refresh = function(){
            if (vm.refreshEnabled) {
                vm.refreshEnabled = false;
                fundsTrackerService.clearLinks(vm.fundsTrackerId);
                document.getElementById(vm.domIdLog).innerHTML = '';
                clearFunction();
                activate(accountNumber); //will reset vm.refreshEnabled flag
            }
        };
    }

})();

(function () {
    'use strict';
    AuditEventViewController.$inject = ["$stateParams"];
    angular.module('aml.admin').controller('AuditEventViewController', AuditEventViewController);

    /**
     * This is the overall controller for the Audit Events Details view.
     *
     * @param $stateParams
     * @constructor
     */
    function AuditEventViewController($stateParams ) {
        var viewVm = this;
        viewVm.objectId = $stateParams.id;
        viewVm.objectTypeCode = $stateParams.objectType;
    }

})();

/**
 * Created by tomutd on 4/10/2015.
 */
(function() {
    'use strict';
    LogViewController.$inject = ["adminService", "linksProcessor", "_", "$window", "resources", "usersService"];
    angular.module('aml.admin').controller('LogViewController', LogViewController);

    function LogViewController(adminService, linksProcessor, _, $window, resources, usersService) {
        var vm = this;
        vm.resources = resources;
        vm.logFolders = null;
        vm.clearFilter = clearFilter;
        vm.openDefaultLogLink = openDefaultLogLink;

        activate();

        //////////////////

        function activate() {
            adminService.getLogs().then( function(logFolderCollection) {
                vm.logFolders = logFolderCollection.items;

                _.each(vm.logFolders, function(logFolder) {
                    _.each( logFolder.logs, function( log ) {
                        log.htmlLink = linksProcessor.getLinkHrefForRel(log.links, log.name);
                        log.textLink = linksProcessor.getLinkHrefForRel(log.links, 'text');
                        log.tailLink = linksProcessor.getLinkHrefForRel(log.links, 'tail');
                    });
                });
            });
        }

        function openDefaultLogLink( log ) {
            $window.open(log.htmlLink, '_blank' );
        }

        function clearFilter() {
            vm.logFilter = '';
        }


    }
})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    AlertTriageController.$inject = ["$uibModal", "riskAssessmentService", "$state", "$rootScope", "reviewsService", "dataMessagingServiceFactory", "alertsService", "casesService", "resources", "messageService", "linksProcessor", "usersService", "amlConstants", "entityTriageService", "entityListDataMessagingService", "tabsListService", "entityService", "$q", "_"];
    angular.module('aml.customer.details').controller('AlertTriageController', AlertTriageController);

    /*jshint maxparams: 19 */
    function AlertTriageController($uibModal, riskAssessmentService, $state, $rootScope, reviewsService,
                                   dataMessagingServiceFactory, alertsService, casesService, resources,
                                   messageService, linksProcessor, usersService, amlConstants, entityTriageService,
                                   entityListDataMessagingService, tabsListService, entityService, $q, _) {
        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        var entityId = dataMessagingService.getEntityId();
        // var entityNumber = null;


        function setButtonsVisibility () {
            var currentUser = usersService.getCurrentUserId();

            vm.userCanSuppress = usersService.currentUserHasCapability(amlConstants.capabilities.suppressAlert) && currentUser === vm.ownerUserId ||
                                 usersService.currentUserHasCapability(amlConstants.capabilities.suppressAllAlerts);
            vm.userCanRoute = usersService.currentUserHasCapability( amlConstants.capabilities.routeEntity ) && currentUser === vm.ownerUserId ||
                              usersService.currentUserHasCapability( amlConstants.capabilities.routeAllEntities );
            vm.userCanClose = usersService.currentUserHasCapability(amlConstants.capabilities.closeAlert) && currentUser === vm.ownerUserId ||
                              usersService.currentUserHasCapability(amlConstants.capabilities.closeAllAlerts);
            //can entity be routed
            vm.canRouteEntity = entityService.canRouteEntity(vm.objectTypeCode);
            //
            vm.canAddToCase = (usersService.currentUserHasCapability(amlConstants.capabilities.addToCaseEntityMy) && currentUser === vm.ownerUserId ||
                                usersService.currentUserHasCapability(amlConstants.capabilities.addToCaseEntityAll)) &&
                                usersService.currentUserHasCapability( amlConstants.capabilities.createCaseFromAlerts );
        }

        function activate () {
            vm.commentsOptions = {};
            vm.resources = resources;
            vm.navigateBackToEntitiesList = navigateBackToEntitiesList;
            vm.openSuppressAlertsDialog = openSuppressAlertsDialog;
            vm.openCloseAlertsDialog = openCloseAlertsDialog;
            vm.openRouteAlertsDialog = openRouteAlertsDialog;
            vm.openAddToInvestigationDialog = openAddToInvestigationDialog;
            vm.openCreateManualAlertDialog = openCreateManualAlertDialog;
            vm.getAlertCount = getAlertCount;
            vm.createRiskAssessment = createRiskAssessment;
            vm.createCDDReview = createCDDReview;
            vm.riskSource = 'AML'; // default value

            vm.alertedEntity = null;
            vm.ownerUserId = null;
            vm.queueCode = entityId.queueCode;

            if ( amlConstants.config && amlConstants.config.fcf && amlConstants.config.fcf.riskScore ) {
                vm.riskSource = amlConstants.config.fcf.riskScore.source;
            }

            if ( typeof vm.alertable === 'undefined' || vm.alertable === null) {
                vm.alertable = true;
            }

            vm.userCanSuppress = false;
            vm.userCanRoute = false;
            vm.userCanClose = false;

            vm.userCanCreateManualAlert = usersService.currentUserHasCapability(amlConstants.capabilities.createManualAlert);
            vm.userCanCreateInvestigation = usersService.currentUserHasCapability( amlConstants.capabilities.createCaseFromAlerts );
            vm.userCanCreateRiskAssessment = usersService.currentUserHasCapability( amlConstants.capabilities.createRiskAssessment );
            vm.userCanCreateCDDReview = usersService.currentUserHasCapability( amlConstants.capabilities.createCDDReview );

            //var entityId = entityService.getEntityIdForState( $state.current.name, $stateParams );
            // if ( entityId !== null ) {
            //     entityNumber = entityId.entityNumber;
            // }
            setButtonsVisibility();
            //household, account and transaction cannot be alerted entity, do not call REST service
            //to avoid exception in the Java log
            if (entityId.entityLevelCode !== amlConstants.entityType.transaction &&
                entityId.entityLevelCode !== amlConstants.entityType.household &&
                entityId.entityLevelCode !== amlConstants.entityType.account) {
                entityService.getAlertedEntity(entityId.entityLevelCode, entityId.entityNumber).then(
                    function (data) {
                        vm.alertedEntity = data;
                        if (vm.alertedEntity && vm.alertedEntity.ownerUserId) {
                            vm.ownerUserId = vm.alertedEntity.ownerUserId;
                        }
                        setButtonsVisibility();

                        // Attach the queue code to entityId so it gets sent to the server
                        // if the user routes the entity.
                        // entityId.queueCode = vm.alertedEntity.queueCode;
                    },
                    function (error) {
                        //entity has no alerts
                        setButtonsVisibility();
                    }
                );
            }
        }

        activate();

        //////

        /**
         * Get customer name
         *
         * @param alerts
         * @returns {string}
         */
        function getEntityName( ) {
            return dataMessagingService.getCustomerName();
        }

        function getAlertCount() {
            return dataMessagingService.getActiveAlertsCount();
        }

        function openSuppressAlertsDialog(size) {
            var modalInstance = $uibModal.open({
                templateUrl: 'alerts/triage/dialogs/suppressAlerts.html',
                controller: 'SuppressAlertsModalController as vm',
                size: size,
                backdrop: 'static' // don't allow to click outside of modal
            });

            modalInstance.result.then(function (result) {
                var entityName = getEntityName();
                var alertNumber = result.allAlerts.length;
                alertsService.suppressAlerts(result.allAlerts,
                    result.suppressionDate, result.suppressionReason).then(function(data) {
                        var msg = vm.resources.aml.getPluralizedResource( alertNumber,
                            'alerts.triage.suppressActionSuccessMessageOne',
                            'alerts.triage.suppressActionSuccessMessageOther',
                            { alertNumber:alertNumber, entityName: entityName});
                        messageService.success( msg, null, 4000);

                        // TODO: Set the correct number of alerts for the entities
                        refreshEntityAlertCount([entityId]);
                    },
                    function( error ) {
                        messageService.danger(
                            vm.resources.aml.getResource('alerts.triage.suppressActionErrorMessage',
                                {  entityName: entityName}), null, 4000);
                    }
                );

                // after performing action, return back to customer list
                navigateBackToEntitiesList();
            }, function () {
                //$log.info('Modal dismissed at: ' + new Date());
            });

        }

        /**
         * Redirect to New Risk Assessment page, and prefill in the current associated customer details
         */
        function createRiskAssessment() {
            var entityId = dataMessagingService.getEntityId();
            var entityNumber = null;
            if ( entityId !== null ) {
                entityNumber = entityId.entityNumber;
            }

            var riskAssessmentParams = {
                assessmentId: riskAssessmentService.NEW_RISK_ASSESSMENT_ID + entityNumber, // assign "new_id"
                name: getEntityName() || entityNumber,
                newEntityFlag: true,
                customerNumber: entityNumber,
                customerName: getEntityName(),
                riskClassification: null
            };

            $state.go('riskAssessmentDetails', riskAssessmentParams);
            
        }
        /**
         * Redirect to New CDD Review  page, and prefill in the current associated party details
         */
        function createCDDReview() {
            var entityId = dataMessagingService.getEntityId();
            var entityNumber = null;
            var entityLevel = null;
            if ( entityId !== null ) {
                entityNumber = entityId.entityNumber;
                entityLevel = entityId.entityLevelCode;
            }
            reviewsService.hasOpenReview(entityNumber).then(
                function (hasReview) {
                    if (hasReview) {
                        messageService.danger(
                            vm.resources.aml.getResource('reviews.reviewAlreadyOpenErrorText'
                            ), null, 4000);

                    } else {
                        $state.go('cddReviewDetails', {
                            reviewKey: riskAssessmentService.NEW_RISK_ASSESSMENT_ID + entityNumber, // assign "new_id"
                            newEntityFlag: true, // indicate it's a new risk assessment
                            name: getEntityName() || entityNumber,
                            partyName: getEntityName(),
                            partyNumber: entityNumber,
                            partyLevel: entityLevel
                        });
                    }
                },
                function (error) {
                    messageService.danger(
                        vm.resources.aml.getResource('reviews.couldNotLoadReviewsErrorText'
                            ), null, 4000);
                }
            );
        }

        function openCloseAlertsDialog(size) {
            var modalInstance = $uibModal.open({
                templateUrl: 'alerts/triage/dialogs/closeAlerts.html',
                controller: 'CloseAlertsModalController as vm',
                size: size,
                backdrop: 'static' // don't allow to click outside of modal
            });

            modalInstance.result.then(function (result) {
                var entityName = getEntityName();
                var alertNumber = result.alertsToBeClosed ? result.alertsToBeClosed.length : 0;
                // var alertsToBeIgnored = result.alertsToBeIgnored;
                var alertsToBeClosed = result.alertsToBeClosed;

                if (alertsToBeClosed && alertsToBeClosed.length > 0) {
                    alertsService.closeAlerts(result.alertsToBeClosed, result.closeReason).then(
                        function () {
                            var msg = vm.resources.aml.getPluralizedResource(alertNumber,
                                'alerts.triage.closeActionSuccessMessageOne',
                                'alerts.triage.closeActionSuccessMessageOther',
                                {alertNumber: alertNumber, entityName: entityName});
                            messageService.success(msg, null, 4000);

                            refreshEntityAlertCount([entityId]);
                        },
                        function (error) {
                            messageService.danger(
                                vm.resources.aml.getResource('alerts.triage.closeActionErrorMessage',
                                    {entityName: entityName}), null, 4000);
                        });

                    // after performing action, return back to customer list
                    navigateBackToEntitiesList();
                }

            }, function () {
                //$log.info('Modal dismissed at: ' + new Date());
            });
        }

        function openRouteAlertsDialog(size) {
            // call route customer
            var entityName = dataMessagingService.getCustomerName();
            var selectedEntityIds = [entityId];
            entityTriageService.openRouteEntitiesDialog(
                selectedEntityIds,
                entityName,
                (vm.alertedEntity && vm.alertedEntity.ownerUserId ? vm.alertedEntity.ownerUserId : ''), //alertedEntity could be null, for household, as an example
                vm.queueCode,
                refreshEntityOwner
            ).then(
                function( ) {
                    // after performing action, return back to customer list
                    navigateBackToEntitiesList();
                }
            );
        }


        function openCreateManualAlertDialog(size) {

            var modalInstance = $uibModal.open({
                templateUrl: 'alerts/triage/dialogs/createManualAlert.html',
                controller: 'CreateManualAlertModalController as vm',
                size: size,
                backdrop: 'static' // don't allow to click outside of modal
            });

            modalInstance.result.then(function (result) {
                // var alertCount = getAlertCount();
                alertsService.createManualAlert(result).then(function (createdAlert) {
                        var msg;
                        // created an alert
                        msg = vm.resources.aml.getResource('alerts.triage.createManualAlertActionSuccessMessage',
                            {
                                alertId: createdAlert.alertId
                            });

                        messageService.success(msg, null, 10000);

                        // update alert count on entity list screen to include newly created alert
                        refreshEntityAlertCount([entityId]);
                    },
                    function (error) {
                        messageService.danger(
                            vm.resources.aml.getResource('alerts.triage.createManualAlertActionErrorMessage'),
                            null, 4000);
                    });

                // after performing action, return back to customer list
                navigateBackToEntitiesList();
            }, function () {
                //$log.info('Modal dismissed at: ' + new Date());
            });
        }

        function refreshEntityOwner(entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner) {
            entityListDataMessagingService.entitiesOwnerChanged(entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner);
        }

        function refreshEntityAlertCount( entityIds) {
            entityListDataMessagingService.refreshEntityAlertCount(entityIds);
        }

        function openAddToInvestigationDialog(size) {
            var modalInstance = $uibModal.open({
                templateUrl: 'alerts/triage/dialogs/addToInvestigation.html',
                controller: 'AddToInvestigationModalController as vm',
                size: size,
                backdrop: 'static' // don't allow to click outside of modal
            });
            modalInstance.userCanClose = vm.userCanClose;
            modalInstance.result.then(function (result) {
                var entityName = getEntityName();
                // close the unselected alerts, and create investigation for all selected alerts
                var alertsToBeAddedToCase = result.alertsToBeAddedToCase;
                var alertsToBeClosed = result.alertsToBeClosed;
                // var alertsToBeIgnored = result.alertsToBeIgnored;
                var entitiesToBeAddedToCase = result.entities;

                // sanitize the entity list
                for (var i = 0; i < entitiesToBeAddedToCase.length; i++){
                    delete entitiesToBeAddedToCase[i].links;
                }
                // To avoid Teradata deadlocks execute CLOSE ALERTS and CREATE CASE transactions sequentially
                // see defect S1305421 for details
                var defer = $q.defer();

                // if any alerts were unselected to not include in the case investigation, we will close them
                if ( alertsToBeClosed && alertsToBeClosed.length > 0 ) {
                    alertsService.closeAlerts(alertsToBeClosed, result.closeReason).then(
                        function () {
                            // if there are alerts added to case, then don't report the Close action success message;
                            // we'll just display the Added to Case success message.
                            if ( alertsToBeAddedToCase.length <= 0  ) {
                                var msg = vm.resources.aml.getPluralizedResource(alertsToBeClosed.length,
                                    'alerts.triage.closeActionSuccessMessageOne',
                                    'alerts.triage.closeActionSuccessMessageOther',
                                    {alertNumber: alertsToBeClosed.length, entityName: entityName});
                                messageService.success(msg, null, 4000);

                                refreshEntityAlertCount([entityId]);
                            }
                            defer.resolve(true);
                        },
                        function (error) {
                            messageService.danger(
                                vm.resources.aml.getResource('alerts.triage.closeActionErrorMessage',
                                    {entityName: entityName}), null, 4000);
                            defer.resolve(false);
                        });
                } else {
                    defer.resolve(true);
                }

                defer.promise.then (
                    function () {
                        if ( result.selectedCaseId === null ) {
                            casesService.createCase(alertsToBeAddedToCase, entitiesToBeAddedToCase, result.priority, result.description,
                                result.investigator, result.category, result.subcategory, result.queueCode, result.employeeIndicator).then(function (createdCase) {
                                    var investigationId;
                                    var msg;

                                    // if created an ECM case construct an ECM-specific message containing a link to the
                                    // ECM case
                                    if (amlConstants.config.defaultCaseDestination &&
                                        amlConstants.config.defaultCaseDestination.toLowerCase() === 'ecm') {
                                        investigationId = createdCase.id;
                                        // add the ECM case link when displaying the success message alert
                                        var caseLink = linksProcessor.getLinkHrefForRel(createdCase.links, 'investigationDisplay');
                                        msg = vm.resources.aml.getPluralizedResource(alertsToBeAddedToCase.length,
                                            'alerts.triage.createInvestigationECMActionSuccessMessageOneText',
                                            'alerts.triage.createInvestigationECMActionSuccessMessageOtherText',
                                            {
                                                alertNumber: alertsToBeAddedToCase.length,
                                                entityName: entityName,
                                                investigationId: investigationId,
                                                caseLink: caseLink
                                            });
                                    }
                                    else { // construct message for AML case
                                        // add the case link when displaying the success message alert
                                        investigationId = createdCase.caseId;
                                        var numberOfAlerts = alertsToBeAddedToCase.length;
                                        var numberOfEntities = entitiesToBeAddedToCase.length;
                                        var numberOfExtraEntities = entitiesToBeAddedToCase.length - 1;
                                        var msgString = getSuccessMessage(numberOfExtraEntities, numberOfAlerts);
                                        msg = vm.resources.aml.getResource(msgString,
                                            {
                                                numberOfAlerts: numberOfAlerts,
                                                numberOfEntities: numberOfEntities,
                                                numberOfExtraEntities: numberOfExtraEntities,
                                                entityName: entityName,
                                                entityLevel: entityId.entityLevelCode,
                                                entityNumber: entityId.entityNumber,
                                                entityKey: entityId.entityKey,
                                                investigationId: investigationId
                                            });
                                    }

                                    messageService.success(msg, null, 10000);

                                    refreshEntityAlertCount([entityId]);

                                    $rootScope.$broadcast('caseListRefresh');
                                },
                                function (error) {
                                    messageService.danger(
                                        vm.resources.aml.getResource('alerts.triage.createInvestigationActionErrorMessage',
                                            {entityName: entityName}), null, 4000);
                                });

                        }
                        else {
                            // Add to an existing Case
                            casesService.addCaseEntity(
                                alertsToBeAddedToCase,
                                entitiesToBeAddedToCase,
                                result.investigator,
                                result.selectedCaseId
                            ).then(function (updatedCase) {

                                    var investigationId = result.selectedCaseId;

                                    var numberOfAlerts = alertsToBeAddedToCase.length;
                                    var numberOfEntities = entitiesToBeAddedToCase.length;
                                    var numberOfExtraEntities = entitiesToBeAddedToCase.length - 1;

                                    var msgString = getSuccessMessage(numberOfExtraEntities, numberOfAlerts);

                                    var msg = vm.resources.aml.getResource(msgString,
                                        {
                                            numberOfAlerts: numberOfAlerts,
                                            numberOfEntities: numberOfEntities,
                                            numberOfExtraEntities: numberOfExtraEntities,
                                            entityName: entityName,
                                            entityLevel: entityId.entityLevelCode,
                                            entityNumber: entityId.entityNumber,
                                            entityKey: entityId.entityKey,
                                            investigationId: investigationId
                                        });
                                    messageService.success(msg, null, 10000);

                                    $rootScope.$broadcast('caseListRefresh');

                                    refreshEntityAlertCount([entityId]);
                                },
                                function (error) {
                                    messageService.danger(
                                        vm.resources.aml.getResource('alerts.triage.createInvestigationActionErrorMessage',
                                            {entityName: entityName}), null, 4000);
                                });

                        }
                    },
                    function (error) {

                    }
                );

                // after performing action, return back to customer list
                navigateBackToEntitiesList();


            }, function () {
                //$log.info('Modal dismissed at: ' + new Date());
            });
        }

        function navigateBackToEntitiesList() {
            // close current tab for the current state
            tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);

            // go back to entities list
            $state.go('entities');
            //$state.go('entities', {}, {
            //    reload: true,
            //    inherit: false,
            //    notify: true
            //});
        }

        function getSuccessMessage ( numberOfExtraEntities , numberOfAlerts ) {

            /*jshint maxcomplexity:9 */

            var msgString = '';

            var noAlertsNoEntities = 'alerts.triage.createInvestigationActionSuccessMessageNoAlertsNoEntities';
            var noAlertsOneEntity = 'alerts.triage.createInvestigationActionSuccessMessageNoAlertsOneEntity';
            var noAlertsEntities = 'alerts.triage.createInvestigationActionSuccessMessageNoAlertsEntities';
            var oneAlertNoEntities = 'alerts.triage.createInvestigationActionSuccessMessageOneAlertNoEntities';
            var oneAlertOneEntity = 'alerts.triage.createInvestigationActionSuccessMessageOneAlertOneEntity';
            var oneAlertEntities = 'alerts.triage.createInvestigationActionSuccessMessageOneAlertEntities';
            var alertsNoEntities = 'alerts.triage.createInvestigationActionSuccessMessageAlertsNoEntities';
            var alertsOneEntity = 'alerts.triage.createInvestigationActionSuccessMessageAlertsOneEntity';
            var alertsEntities = 'alerts.triage.createInvestigationActionSuccessMessageAlertsEntities';


            if( numberOfAlerts === 0 ) {
                if( numberOfExtraEntities === 0) {
                    // if no alerts and no extra entities
                    msgString = noAlertsNoEntities;
                } else if ( numberOfExtraEntities === 1 ){
                    // if no alerts, but one extra entity
                    msgString = noAlertsOneEntity;
                } else {
                    // if no alerts, but more than one entity
                    msgString = noAlertsEntities;
                }
            } else if ( numberOfAlerts === 1 ){
                if( numberOfExtraEntities === 0) {
                    // if one alert and no extra entities
                    msgString = oneAlertNoEntities;
                } else if ( numberOfExtraEntities === 1 ){
                    // if one alert and one extra entity
                    msgString = oneAlertOneEntity;
                } else {
                    // if one alert and more than one entity
                    msgString = oneAlertEntities;
                }
            } else {
                if( numberOfExtraEntities === 0) {
                    // if alerts and no extra entities
                    msgString = alertsNoEntities;
                } else if ( numberOfExtraEntities === 1 ){
                    // if alerts, and one extra entity
                    msgString = alertsOneEntity;
                } else {
                    // if alerts, and more than one entity
                    msgString = alertsEntities;
                }
            }
            return msgString;
        }

    }
})();

/**
 * Created by dabock on 5/16/2017.
 */
(function() {
    'use strict';
    WatchListDirectiveController.$inject = ["watchListService", "resources", "kendoGridRendererService"];
    angular.module('aml.customer.details').controller(
        'WatchListDirectiveController', WatchListDirectiveController);

    function WatchListDirectiveController(watchListService, resources, kendoGridRendererService) {
        var vm = this;
        vm.resources = resources;

        vm.customerGridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                pageable: false,
                selectable: false,
                filterable: false
            }
        );

        vm.customerGridColumns = [
            {
                // This is a blank column in the customer grid.
                field: 'watchListName',
                title: ' ',
                width: 80
            },
            {
                field: 'firstName',
                title: vm.resources.aml.watchList.firstNameHeaderTitle,
                width: 80
            },
            {
                field: 'middleName',
                title: vm.resources.aml.watchList.middleNameHeaderTitle,
                width: 80
            },
            {
                field: 'lastName',
                title: vm.resources.aml.watchList.lastNameHeaderTitle,
                width: 80
            },
            {
                field: 'country',
                title: vm.resources.aml.watchList.countryHeaderTitle,
                width: 80
            },
            {
                field: 'dateOfBirth',
                title: vm.resources.aml.watchList.dateOfBirthHeaderTitle,
                width: 80
            },
            {
                field: 'fullAddress',
                title: vm.resources.aml.watchList.addressHeaderTitle,
                width: 160
            },
            {
                field: 'taxId',
                title: vm.resources.aml.watchList.taxIdHeaderTitle,
                width: 80
            },
            {
                field: 'citizenshipCountry',
                title: vm.resources.aml.watchList.countryOfCitizenshipHeaderTitle,
                width: 80
            },
            {
                field: 'orgCountryOfBusiness',
                title: vm.resources.aml.watchList.countryOfBusinessHeaderTitle,
                width: 80
            }
        ];

        // Columns for the 2nd grid are identical to the 1st, except the first column
        // actually has a header and data.
        vm.possibleMatchesGridColumns = vm.customerGridColumns.slice();
        vm.possibleMatchesGridColumns[0] = {
            field: vm.customerGridColumns[0].field,
            title: vm.resources.aml.watchList.watchListHeaderTitle,
            width: vm.customerGridColumns[0].width
        };

        vm.loadCustomerGrid = function(gridCallback) {
            watchListService.getWatchListAlertDetails(vm.alertId).then(function (data) {
                if(data.customer) {
                    gridCallback.success(data.customer);
                    vm.list = data.list;
                }
                else {
                    // The server didn't return any data.
                    vm.hideCustomerGrid = true;
                }
            });
        };

        // ng-if ensures this is not loaded until vm.list exists.
        vm.loadPossibleMatchesGrid = function(gridCallback) {
            gridCallback.success(vm.list);
        };

        vm.handleRowSelect = function(rowData) {
            vm.rowData = rowData;
        };
    }
})();
/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    CaseDetailsController.$inject = ["$scope", "amlLov", "resources", "amlConstants", "usersService", "casesService"];
    angular.module('aml.cases.details').controller('CaseDetailsController', CaseDetailsController);

    function CaseDetailsController($scope, amlLov, resources, amlConstants, usersService, casesService) {
        var vm = this;
        vm.resources = resources;
        vm.caseCategories = amlLov.getAsArray(amlLov.caseCategory);
        vm.caseSubcategories = amlLov.getAsArray(amlLov.caseSubcategory);
        vm.priorityList = amlLov.getAsArray(amlLov.priority);
        vm.caseStatusList = amlLov.getAsArray(amlLov.caseStatus);

        activate();

        vm.toggleEmpInd = function () {
            if ($scope.formCtrl) {
                $scope.formCtrl.$dirty = true;
            }
            if (vm.case.employeeIndicator && vm.case.employeeIndicator === 'N') {
                vm.case.employeeIndicator = 'Y';
            } else {
                vm.case.employeeIndicator = 'N';
            }
        };
        /*
         Suppressing cyclomatic complexity checking because this really isn't
         all that complex. Using nested IFs increases the complexity.
         */
        function activate() {
            /*jshint maxcomplexity:11*/
            $scope.$on('caseLoaded', function (event, args) {
                vm.readonly = casesService.isCaseReadonly(args.val);

                if (vm.case && !vm.case.employeeIndicator) {
                    vm.case.employeeIndicator = 'N';
                }

                //Restrict the case status choices if the user doesn't have correct capability
                vm.caseStatusList.forEach(function(status) {
                    status.disable = false;

                    if (!vm.readonly) {
                        //Investigator - Only select O, CR, I
                        if ( (status.key === 'C' || status.key === 'R') &&
                             !usersService.currentUserHasCapability(amlConstants.capabilities.closeCase)) {
                            status.disable = true;
                        } //Manager - O, CR, I, C, R (normally set batch, but can be set for DOEP report now) - enabled by default

                        //only SAR90 cases that user owns can be suspended
                        if (status.key === 'S' && args.val.caseCategoryCode !== 'SAR90') {
                                status.disable = true;
                        }

                        if (args.val.caseCategoryCode === 'SAR90') {
                            // if user does not own the case then it cannot suspend it
                            if (status.key === 'S' && args.val.ownerUserLongId !== usersService.getCurrentUserId() && args.val.statusCode !== 'S') {
                                    status.disable = true;
                            }
                            //Suspended SAR90 case can be activated only if user has appropriate capability
                            if (args.val.statusCode === 'S') {
                                if (status.key !== 'S' && status.key !== 'C' && status.key !== 'R' ) {
                                    if (args.val.ownerUserLongId === usersService.getCurrentUserId() && usersService.currentUserHasCapability(amlConstants.capabilities.activateCase) ||
                                        args.val.ownerUserLongId !== usersService.getCurrentUserId() && usersService.currentUserHasCapability(amlConstants.capabilities.activateAllCases) ) {
                                        status.disable = false;
                                    } else  {
                                        status.disable = true;
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }
    }
})();

(function () {
    'use strict';
    CaseDetailsViewController.$inject = ["$scope", "$stateParams", "casesService", "resources", "_", "dataMessagingServiceFactory"];
    angular.module('aml.cases.details').controller('CaseDetailsViewController', CaseDetailsViewController);

    /**
     * This is the overall controller for the Case Details view.
     * It sets things that all directives on the details page may need, such
     * as the current selected caseId taken from the current route/state,
     * and the current case object itself
     *
     * @param $scope
     * @param $stateParams
     * @constructor
     * @param casesService
     * @param resources
     * @param _
     */
    function CaseDetailsViewController($scope, $stateParams, casesService, resources, _, dataMessagingServiceFactory) {
        var viewVm = this;
        viewVm.caseId = $stateParams.caseid;
        viewVm.resources = resources;
        viewVm.isEmpty = isEmpty;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        activate();

        function activate() {
            casesService.getCase(viewVm.caseId).then(function (data) {
                    viewVm.case = data;

                    //De-serialize dates as JS dates
                    //... but only if they are not null...  If they are null/undefined then they get set to today
                    // by the moment code and that's not what we want...
                    viewVm.case.lawEnforcementContactDate = viewVm.case.lawEnforcementContactDate ? moment(viewVm.case.lawEnforcementContactDate).toDate() : '';
                    viewVm.case.firstTransactionDate = viewVm.case.firstTransactionDate ? moment(viewVm.case.firstTransactionDate).toDate() : '';
                    viewVm.case.lastTransactionDate = viewVm.case.lastTransactionDate ? moment(viewVm.case.lastTransactionDate).toDate() : '';

                    //Check to see if the user can edit the case
                    viewVm.readonly = casesService.isCaseReadonly(viewVm.case);

                    $scope.$broadcast('caseLoaded', {'val': viewVm.case});
                });

            setupWatches();
            setupListeners();
        }

        function setupListeners() {
            //S1302009, S1398018: Listen for case save event and set to read only if case is closed.
            $scope.$on('caseSave', function(event, args) {
                if(args.savedCase && args.savedCase.caseId === Number(viewVm.caseId)) {
                    viewVm.readonly = casesService.isCaseReadonly(args.savedCase);
                }
            });
        }

        function setupWatches() {
            $scope.$watch(
                function () {
                    return dataMessagingService.getEntityId();
                },
                function () {
                    viewVm.entityId = dataMessagingService.getEntityId();
                },
                true
            );

            $scope.$watch(function () {
                return dataMessagingService.getAlertIds('alertids');
            }, function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    if (newVal && newVal !== 'all') {
                        viewVm.alertIsSelected = true;
                    }
                    else {
                        viewVm.alertIsSelected = false;
                    }
                }
            });

            //$scope.$watch('readonly', function (newVal, oldVal) {
            //    if (newVal !== oldVal) {
            //        $scope.$broadcast('readonlyChange', {'val': newVal});
            //    }
            //});
        }

        function isEmpty(obj){

            for(var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }

            return true;
        }
    }
})();

(function() {
    'use strict';

    CaseEntitiesController.$inject = ["amlConstants", "resources", "casesService", "entityService", "dataMessagingServiceFactory", "kendoGridRendererService", "$stateParams", "$state", "$scope", "_"];
    angular.module('aml.cases.details').controller('CaseEntitiesController', CaseEntitiesController);

    function CaseEntitiesController(amlConstants, resources, casesService, entityService,
                                    dataMessagingServiceFactory, kendoGridRendererService, $stateParams, $state, $scope, _) {
        var vm = this;
        vm.caseId = $stateParams.caseid;
        vm.entities = [];
        vm.grid = {};
        vm.resources = resources;
        vm.filterString = null;
        vm.maxLength = amlConstants.defaultDescLength;
        vm.maxCharErrMsg = null;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();


        var dataSourceOptions = {
            transport: {
                read: getEntities,
                update: updateEntity
            },
            schema: {
                model: {
                    id: 'id',
                    fields: {
                        reportRequired: {type:'boolean', editable: true},
                        entityLevelCode: { type: 'string', editable: false, nullable: false},
                        entityNumber: { type: 'string', editable: false, nullable: false },
                        entityName: { type: 'string', editable: false, nullable: false},
                        entityKey: { type: 'string', editable: false, nullable: false},
                        relationDescription: {
                            type: 'string',
                            validation: {
                                maxlength:
                                    function(input) {
                                        if (input.val().length > vm.maxLength) {
                                            vm.maxCharErrMsg = vm.resources.aml.getResource(
                                                'casedetails.entity.descMaxLength',
                                                {maxChar: vm.maxLength}
                                            );
                                            input.attr('data-maxlength-msg', vm.maxCharErrMsg);

                                            return false;
                                        }
                                        return true;
                                    }

                            }
                        }
                    }
                }
            },
            pageSize: vm.pageSize || 10

        };

        vm.gridColumns = [
            {
                field: 'reportRequired', title: resources.aml.casedetails.entity.reportRequired,
                width: 90, template: '<input type=\'checkbox\' #= data.reportRequired ? \'checked=checked\' : \'\' # disabled=\'disabled\' ></input>'
            },
            {
                field: 'entityLevelCode', title: resources.aml.casedetails.entity.type,
                template: kendoGridRendererService.enum('entityLevelCode','caseEntityLevel'),
                filterable: kendoGridRendererService.getCheckboxFilter('caseEntityLevel'),
                width: 90
            },
            {
                field: 'entityNumber', title: resources.aml.casedetails.entity.number,
                width: 170
            },
            {
                field: 'entityName', title: resources.aml.casedetails.entity.name,
                width: 190, template: kendoGridRendererService.titleCase( 'entityName' )

            },
            {
                field: 'relationDescription', title: resources.aml.casedetails.entity.relationDescription,
                width: 190
            }
        ];

        if ( !vm.readonly ){
            vm.gridColumns.push(
                {
                    command:
                        [
                            {
                                name: 'edit',
                                text:
                                {
                                    edit: resources.aml.casedetails.entity.edit,
                                    update: resources.aml.casedetails.entity.save,
                                    cancel: resources.aml.casedetails.entity.cancel}
                            }
                        ],
                    title: '&nbsp;',
                    width: '132px'
                }
            );
        }

        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({

            dataSource: dataSourceOptions,
            editable: {
                mode: 'popup',
                window :
                {
                    title: resources.aml.casedetails.entity.title
                },
                template: null,
                update: true
            }

        });



        vm.handleRowSelect = function (data) {

            if (data && data.caseId) {
                dataMessagingService.setEntity(data.entityNumber, data.entityLevelCode, data.entityKey);
            } else {
                dataMessagingService.setEntity(null, null, null);
            }
        };

        // on double-click, go to entity detail page
        function handleDoubleClick( evt) {
            var selectedEntity  = vm.grid.dataItem(evt.currentTarget);
            if (selectedEntity && selectedEntity.entityNumber && selectedEntity.entityLevelCode) {
                var entityState = entityService.getStateForEntity( selectedEntity );
                $state.go(entityState.stateName, entityState.stateParams);
            }
        }

        activate();



        function getEntities(gridCallback) {
            casesService.getCaseEntities(vm.caseId).then(function(data) {

                    _.each(
                        data.items,function ( item ){

                            item.id=item.entityLevelCode + item.entityNumber;
                            if(item.reportRequired==='Y'){
                                item.reportRequired=true;
                            } else {
                                item.reportRequired=false;
                            }
                    });

                    vm.entities = data.items;
                    vm.entityCount = data.count;

                    gridCallback.success(vm.entities);

                });
        }

        function updateEntity(gridCallback) {

            var data = gridCallback.data;
            delete data.id;

            if(data.reportRequired===true){
                data.reportRequired='Y';
            } else {
                data.reportRequired='N';
            }

            gridCallback.success();

            casesService.updateCaseEntity(data).then(function(newData) {
                var id=data.entityLevelCode + data.entityNumber;
                updateVersionNumber(id,newData.versionNumber);
            });
      }

        function updateVersionNumber(id, versionNumber ) {
            kendoGridRendererService.updateDataItems( [id], 'id',
                function(entity) {
                    entity.versionNumber = versionNumber;
                }, vm.grid);
        }

        function activate() {
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, (vm.idPrefix || '') + 'caseEntitiesGrid');

        }
    }


})();

(function () {
    'use strict';

    RuleDetailsViewController.$inject = ["$rootScope", "$scope", "$stateParams", "$uibModal", "amlLov", "logger", "$state", "$q", "ruleService", "ruleGroupService", "datasetService", "resources", "tabsListService", "kendoGridRendererService", "messageService", "_"];
    angular
        .module('cdd.rule')
        .controller('RuleDetailsViewController', RuleDetailsViewController);
    /* jshint maxparams: 17 */
    /* jshint maxstatements: 73 */
    function RuleDetailsViewController($rootScope, $scope, $stateParams, $uibModal, amlLov,
                                       logger, $state, $q,
                                       ruleService, ruleGroupService, datasetService,
                                       resources, tabsListService, kendoGridRendererService,
                                       messageService, _) {
        var vm = this;
        vm.state = $state.$current;

        //value for the next new row id, set as row index, see below, cannot be 0
        var paramNextId = 100;
        //id of the parameters row currently being edited (0 is valid value for the very frst row until saved)
        var editRowId = -1;
        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;

        vm.resources = resources;
        vm.showDetails = true;
        vm.showLogic = false;
        vm.newRule = false;
        vm.loading = true;
        vm.forms = {};
        vm.rule = {parms: []};
        vm.parms = [];
        vm.parmsForm = {$dirty: false, $error: {}};
        vm.forms.parmsForm = vm.parmsForm;
        vm.datasetColumns = [];
        vm.ruleGroupName = '';
        vm.ruleGroup = {};  //currently ruleGroup is loaded only for new rules to get ruleGroup name and dataset name
        vm.idError = false;
        //change rule id support
        vm.origRuleId = '';
        vm.allowIdChange = false;

        //parameters grid data
        vm.grid = {};
        vm.amlGridActions = [];
        vm.filterString = '';

        function disableUnsafeActions () {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('rule.ruleActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }
        function enableUnsafeActions () {
            disableUnsafeActionsFlag = false;
        }

        vm.isEmpty = function isEmpty(str) {
            return (!str || 0 === str.length);
        };

        function updateTabTitle() {
            var tabInfo = tabsListService.getTabInfo(vm.state.name);
            if (tabInfo) {
                tabInfo.title = vm.rule.ruleName;
                tabInfo.params.ruleName = vm.rule.ruleName;
                tabsListService.updateTabInfo(tabInfo, true);
            }
        }

        function loadParms() {
            vm.parms = [];
            if (!vm.newRule) {
                for (var i = 0; i < vm.rule.parms.length; i++) {
                    var parm = vm.rule.parms[i];
                    vm.parms.push({
                        parmId: i + 1,
                        name: parm.name,
                        description: parm.description,
                        type: parm.type,
                        value: parm.value
                    });
                }
            }
        }

        // strip parmId field, server will not accept it
        function updateParms (parmsIn) {
            var newParms = [];
            for (var i = 0; i < parmsIn.length; i++) {
                var row = parmsIn[i];
                newParms.push({name: row.name, description: row.description, type: row.type, value: row.value});
            }
            return newParms;
        }

        //when page is initialized rule data may be not loaded yet, so parameters table
        //may be empty because read function on the transport object was invoked
        //before the data was loaded.
        //One way to resolve this is to use k-ng-delay on kendo-grid,
        //this was used initially but was refactored to work around 'Invalid Argument' exception in IE.
        //Alternative way is to re-load grids after the data was loaded and not to use k-ng-delay, this is the purpose
        //of the setInitialGridState function.
        function setInitialGridState(type) {
                vm.cancelParamChanges();
                return;
        }

        function updateRuleGroupID(loadRuleGroupFlag) {
            vm.rule.ruleGroupId = vm.ruleGroupId;
            if (!vm.rule.ruleGroupId || vm.rule.ruleGroupId === 'none' || vm.rule.ruleGroupId === '') {
                vm.rule.ruleGroupId = '';
                vm.rule.ruleGroupName = '';
                vm.rule.ruleGroupInputDsName = '';
                vm.ruleGroup = {};
                vm.datasetColumns = [];
            }
            if (vm.rule.ruleGroupId && loadRuleGroupFlag) {
                var hprom = ruleGroupService.getRuleGroup(vm.rule.ruleGroupId);
                var both = $q.all([hprom]);

                both.then(function (data) {
                        vm.ruleGroup = data[0];
                        vm.rule.ruleGroupName = vm.ruleGroup.ruleGroupName;
                        vm.rule.ruleGroupInputDsName = vm.ruleGroup.ruleGroupInputDsName;
                        if (vm.rule.ruleGroupInputDsName && vm.rule.ruleGroupInputDsName !== '') {
                            //ruleGroup with id=-1 has data set name as N/A
                            if (vm.rule.ruleGroupInputDsName === 'N/A' || vm.rule.ruleGroupId === '' || vm.rule.ruleGroupId === 'none') {
                                vm.rule.ruleGroupInputDsName = '';
                            } else {
                                vm.loadDataset(vm.rule.ruleGroupInputDsName);
                            }
                        }
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('ruleGroup.ruleGroupReadErrorTxt',
                            {'ruleGroupId': vm.rule.ruleGroupId}), null, -1);
                    });
            }
        }

        function formsAreDirty () {
            var names = Object.getOwnPropertyNames(vm.forms);
            for (var i = 0; i < names.length; i++) {
                if (vm.forms[names[i]].$dirty) {
                    return true;
                }
            }
            return false;
        }

        function updateRule (ruleIn, discardFlag) {
            var defer = $q.defer();
            var uprom;
            var idChanged = vm.allowIdChange && vm.origRuleId !== ruleIn.ruleId;
            if (vm.newRule) {
                uprom = ruleService.createNewRule(ruleIn);
            } else {
                if (idChanged) {
                    uprom = ruleService.changeRuleId(ruleIn, vm.origRuleId);
                } else {
                    uprom = ruleService.updateRule(ruleIn);
                }
            }

            if (uprom) {
                uprom.then(function (data) {
                        vm.rule = data;
                        vm.state.data.dirty = false; //to allow tab be closed without callback
                        if (!discardFlag) {
                            if (vm.newRule || idChanged) {
                                tabsListService.closeTab(tabsListService.getTabForCurrentState(), false).then(
                                    function (data) {
                                        $state.go('ruleDetails',
                                            {
                                                ruleId: vm.rule.ruleId,
                                                ruleName: vm.rule.ruleName,
                                                ruleGroupId: (vm.rule.ruleGroupId === '' ? null : vm.rule.ruleGroupId),
                                                newRule: 'no'
                                            });
                                    }
                                );
                            }
                        }
                        vm.allowIdChange = false;
                        vm.origRuleId = '';
                        $rootScope.$broadcast( 'ruleChanged', { ruleId: vm.rule.ruleId });

                        messageService.success(
                            resources.aml.getResource('rule.ruleSavedTxt',
                                {'name': ruleIn.name}), null, 4000);
                        defer.resolve('entity updated');
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('rule.ruleSaveFailedErrorTxt',
                            {'name': ruleIn.name}), null, -1);
                        if (error.status === 409) {
                            messageService.danger(resources.aml.getResource('rule.ruleUpdateConflictErrorTxt'), null, -1);
                        }
                        defer.reject(error);
                    }).finally( function () {enableUnsafeActions();});
            } else {
                enableUnsafeActions();
                messageService.danger(resources.aml.getResource('rule.ruleSaveFailedErrorTxt',
                    {'name': ruleIn.name}), null, -1);
                logger.info('uprom is null in updateRule');
                defer.reject('promise is null while updating entity');
            }
            return defer.promise;
        }

        vm.validateRuleData = function validateRuleData() {
            //validates that rule Id is unique
            var idChanged = vm.allowIdChange && vm.origRuleId !== vm.rule.ruleId;
            vm.idError = false;
            var defer = $q.defer();
            if (vm.newRule || idChanged) {
                //new rule must have unique ID that does not exists in FSK_CDD_RULE
                var idCount = 1;
                ruleService.getRuleIdCount(vm.rule).then(function (data) {
                        idCount  = data.data;
                        vm.idError = (idCount !== 0);
                        defer.resolve('id count ' + idCount);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleReadErrorTxt',
                            {'ruleId': vm.rule.ruleId});
                        messageService.danger(msg, null, -1);
                        defer.reject('Cannot read id count');
                    });
            } else {
                // existing rule id cannot be chnaged for now
                defer.resolve('id has not changed');
            }
            return defer.promise;
        };


        function noDollarSign (aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        var unbindExecForm = $scope.$watch('vm.auditForm', function () {
            vm.forms.auditForm = vm.auditForm;
            $scope.$watch('vm.forms.auditForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindExecForm();
        });

        var unbindBasicForm = $scope.$watch('vm.basicForm', function () {
            vm.forms.basicForm = vm.basicForm;
            $scope.$watch('vm.forms.basicForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindBasicForm();
        });

        var unbindRuleGroupForm = $scope.$watch('vm.ruleGroupForm', function () {
            vm.forms.ruleGroupForm = vm.ruleGroupForm;
            $scope.$watch('vm.forms.ruleGroupForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindRuleGroupForm();
        });

        var unbindRuleCodeForm = $scope.$watch('vm.ruleCodeForm', function () {
            vm.forms.ruleCodeForm = vm.ruleCodeForm;
            $scope.$watch('vm.forms.ruleCodeForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindRuleCodeForm();
        });
        
        // ******************************************************************************************
        //                              Parameters grid
        // ******************************************************************************************
        //grid creation is delayed in html until the rule parameters are loaded,
        //otherwise transport methods update and destroy are not called for existing parameters
        //initParamGridOptions is called when rule data is loaded (existing)  or initialized (new)
        function initParamGridOptions () {
            vm.paramTypes = amlLov.getAsArray(amlLov.ruleParameterType);
            var ruleParameterTypeRenderingFilter = kendoGridRendererService.enum('type', 'ruleParameterType');
            var getIndexById = function (array, id) {
                var l = array.length;
                for (var j=0; j < l; j++) {
                    if (array[j].parmId === id) {
                        return j;
                    }
                }
                return null;
            };

            var isParamNameUnique = function (name) {
                if (name === '') {
                    return true;
                }
                var match = _.where(vm.parms, {name: name});
                // param name must be unique
                if (match.length > 1) {
                    return false;
                }
                if (match.length === 1) {
                    //need to verify when length === 1 that it the same row as the one that is being validated
                    var parmMatch = _.find(vm.parms, function (parm) {
                        return parm.name === name;
                    });
                    return parmMatch.parmId === editRowId;
                }
                return true;

            };
            //cancel parameters grid changes
            vm.cancelParamChanges = function (e) {
                loadParms();
                vm.grid.dataSource.read();
                //refresh not needed: http://www.telerik.com/forums/show-progress-spinner-during-load-refresh
                //vm.grid.refresh();
                editRowId = -1;
            };

            vm.gridColumns = [
                {
                    field: 'name', title: resources.aml.rule.params.name,
                    width: '25%'
                },
                {
                    field: 'type', title: resources.aml.rule.params.type,
                    width: '10%',
                    template: ruleParameterTypeRenderingFilter,
                    editor: function (container, options) {
                        var input = $('<input id="paramType" name="paramType" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            autoBind: true,
                            dataTextField: 'value',
                            dataValueField: 'key',
                            dataSource: vm.paramTypes
                        }); //.appendTo(container)
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(ruleParameterTypeRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('ruleParameterType')
                },
                {
                    field: 'description', title: resources.aml.rule.params.description,
                    width: '25%'
                },
                {
                    field: 'value', title: resources.aml.rule.params.value,
                    width: '25%'
                },
                {
                    command: ['edit', 'destroy'],
                    width: '15%'
                }
            ];

            vm.dataSourceOptions = new kendo.data.DataSource({
                transport: {
                    read: function (e) {
                        vm.parmsForm.$dirty = false;
                        paramNextId = vm.rule.parms.length + 1;
                        e.success(vm.parms);
                    },
                    create: function (e) {
                        e.data.parmId = paramNextId++;
                        vm.parms.push(e.data);
                        vm.parmsForm.$dirty = true;
                        e.success(e.data);
                    },
                    update: function (e) {
                        vm.parms[getIndexById(vm.parms, e.data.parmId)] = e.data;
                        vm.parmsForm.$dirty = true;
                        e.success();
                    },
                    destroy: function (e) {
                        vm.parms.splice(getIndexById(vm.parms, e.data.parmId), 1);
                        vm.parmsForm.$dirty = true;
                        e.success();
                    }
                },
                batch: false,
                schema: {
                    model: {
                        id: 'parmId',
                        fields: {
                            parmId: {type: 'number', editable: false, nullable: false},
                            name: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.rule.ruleNameMissingErrorTxt},
                                    pattern: {
                                        value: '^[^\\d\\W]\\w{0,31}$',
                                        message: resources.aml.rule.ruleNameTooLongErrorTxt
                                    },
                                    unique: function (input) {
                                        if (input.is('[name=\'name\']') && input.val().length > 0) {
                                            if (isParamNameUnique(input.val())) {
                                                return true;
                                            } else {
                                                //set custom error message
                                                input.attr('data-unique-msg', resources.aml.rule.nameIsNotUniqueErrorTxt);
                                                return false;
                                            }
                                        } else {
                                            return true;
                                        }
                                    }
                                }
                            },
                            description: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.rule.descriptionRequiredErrorTxt},
                                    pattern: {
                                        value: '^[^]{1,255}$',
                                        message: resources.aml.rule.descriptionTooLongErrorTxt
                                    }
                                }
                            },
                            type: {type: 'string', validation: {required: true},
                                defaultValue: 'Numeric Constant'
                            },
                            value: {
                                type: 'string', validation: {
                                    required: {message: resources.aml.rule.valueIsRequiredErrorTxt},
                                    pattern: {
                                        value: '^[^]{1,1024}$',
                                        message: resources.aml.rule.valueIsTooLongErrorTxt
                                    }
                                }
                            }
                        }
                    }
                },
                serverPaging: false,
                serverSorting: false,
                serverFiltering: false
            });
            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
                {
                    dataSource: vm.dataSourceOptions,
                    columns: vm.gridColumns,
                    pageable: false,
                    editable: {
                        mode: 'inline',
                        confirmation: false
                    },
                    //isCancel : true,
                    resizable: true,
                    selectable: 'multiple cell',
                    allowCopy: true,
                    filterable: true,
                    batch: false,
                    toolbar: [{text: '', template: kendo.template($('#grid_toolbar').html())}],
                    scrollable: false,
                    sortable: {
                        mode: 'multiple',
                        allowUnsort: true
                    },
                    //true value for navigatable causes 'Invalid Argument' exception in IE 11
                    navigatable: false,
                    edit: function (e) {
                        //if (editRowId > -1) {
                        //TODO: this means that another row has not being saved - prevent this if possible
                        //or show a warning
                        //}
                        editRowId = e.model.parmId;
                    },
                    save: function (e) {
                        editRowId = -1;
                    },
                    cancel: function (e) {
                        editRowId = -1;
                    }
                });

            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'ruleParameters');
        }

        // ******************************************************************************************
        //                  initialize
        // ******************************************************************************************

        function init() {
            vm.state.data.dirty = false;

            vm.actionsDisabled = function () {
                return disableUnsafeActionsFlag;
            };

            vm.loadDataset = function (ruleGroupInputDsName) {
                datasetService.getDataset(ruleGroupInputDsName, 'CDD').then(function (data) {
                        vm.datasetColumns = data.datasetColumns;
                        var msg = resources.aml.getResource('ruleGroup.datasetLoadedTxt',
                            {'name': ruleGroupInputDsName});
                        messageService.info(msg, null, 2000);
                    },
                    function (error) {
                        vm.loading = false;
                        var msg = resources.aml.getResource('ruleGroup.datasetReadErrorTxt',
                            {'name': ruleGroupInputDsName});
                        messageService.danger(msg, null, -1);
                    });
            };

            //vm.getRuleNames = function () {
            //    var defer = $q.defer();
            //    ruleService.getRuleNames(true).then(function (ruleNames) {
            //            vm.ruleNames = ruleNames;
            //            defer.resolve(true);
            //        },
            //        function (reason) {
            //            defer.resolve(false);
            //        });
            //    return defer.promise;
            //
            //};

            vm.updateTab = function (e) {
                if (!vm.basicForm.biName.$error.ruleName && angular.isDefined(vm.rule.ruleName) && vm.rule.ruleName !== '') {
                    updateTabTitle();
                }
            };


            vm.getRuleData = function (ruleId) {
                vm.state.data.dirty = false;  // to set the tab pill to not
                ruleService.getRule(ruleId).then(function (data) {
                        vm.rule = data;
                        if (!vm.rule.ruleGroupId) {
                            vm.rule.ruleGroupId = 'none';
                        }
                        vm.ruleGroupId = vm.rule.ruleGroupId;
                        vm.ruleGroupName = vm.rule.ruleGroupName; //could be empty
                        $scope.currentRule = vm.rule;
                        vm.loading = false;
                        // load data set column list for the dropdown
                        if (vm.rule.ruleGroupInputDsName && vm.rule.ruleGroupInputDsName !== '') {
                            //ruleGroup with id=-1 has dataset name as N/A
                            if (vm.rule.ruleGroupInputDsName === 'N/A' || vm.rule.ruleGroupId === -1) {
                                vm.rule.ruleGroupInputDsName = '';
                            } else {
                                vm.loadDataset(vm.rule.ruleGroupInputDsName);
                            }
                        }
                        vm.getRuleGroupNames();
                        updateTabTitle();
                        setInitialGridState();
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleReadErrorTxt',
                            {'ruleId': ruleId});
                        messageService.danger(msg, null, -1);
                        vm.state.data.dirty = false; //to allow tab be closed without callback
                        tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
                        $state.go('ruleGroups');
                    });
            };

            vm.saveRule = function saveRule (discardFlag) {
                var defer = $q.defer();
                if (editRowId > -1) {
                    messageService.danger(resources.aml.getResource('rule.parameterNotSavedErrorTxt'), null, -1);
                    return;
                }
                disableUnsafeActions();
                vm.validateRuleData().then(
                    function (result) {
                        if (vm.formsHaveErrors()) {
                            defer.reject('form has errors');
                            var modalInstance = $uibModal.open({
                                animation: true,
                                templateUrl: 'modalRule.html',
                                controller: 'RuleModalController as viewVm',
                                size: 'm',
                                backdrop: 'static'
                            });
                            modalInstance.forms = vm.forms;

                            modalInstance.result.then(function () {
                            }, function () {
                                var names = Object.getOwnPropertyNames(vm.forms);
                                for (var i = 0; i < names.length; i++) {
                                    vm.dirtyAll(vm.forms[names[i]]);
                                }
                            });
                            enableUnsafeActions();
                        } else {
                            if (formsAreDirty()) {
                                vm.state.data.dirty = false;  // to set the tab pill not to show an asterisk (dirty)
                            }
                            vm.rule.parms = updateParms(vm.parms);
                            updateRuleGroupID(false); //no need to load ruleGroup
                            var uprom = updateRule(vm.rule, discardFlag);
                            if (uprom && uprom !== null) {
                                uprom.then (
                                    function success (data) {
                                        defer.resolve(data);
                                    },
                                    function failure (reason) {
                                        //save failed,  so do not close the tab
                                        defer.reject(reason);
                                    }
                                );
                            } else {
                                // save failed, tab cannot be closed
                                defer.reject('update failed (promise is null)');
                            }
                        }
                    },
                    function (reason) {
                        enableUnsafeActions();
                        messageService.danger(resources.aml.getResource('rule.ruleListReadErrorTxt'), null, -1);
                        defer.reject(reason);
                    }
                );
                return defer.promise;
            };

            vm.deleteRule = function () {
                disableUnsafeActions();
                ruleService.markRuleAsDeleted(vm.rule.ruleId).then(function (data) {
                        vm.rule.logicalDeleteInd = 'Y';
                        var msg = resources.aml.getResource('rule.ruleMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.undeleteRule = function () {
                disableUnsafeActions();
                ruleService.markRuleAsUndeleted(vm.rule.ruleId).then(function (data) {
                        vm.rule.logicalDeleteInd = 'N';
                        var msg = resources.aml.getResource('rule.ruleMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleMarkedUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.activateRule = function () {
                disableUnsafeActions();
                ruleService.activateRule(vm.rule).then(function (data) {
                        var msg = resources.aml.getResource('rule.ruleActivatedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleActivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.deactivateRule = function () {
                disableUnsafeActions();
                ruleService.deactivateRule(vm.rule).then(function (data) {
                        var msg = resources.aml.getResource('rule.ruleDeactivatedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleDeactivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.runRule = function () {
            };

            vm.ruleEditRuleGroup = function () {
                if (!vm.isEmpty(vm.rule.ruleGroupId) && vm.rule.ruleGroupId !== 'none') {
                    $state.go('ruleGroupDetails',
                        {ruleGroupId: vm.rule.ruleGroupId,
                         ruleGroupName: vm.ruleGroupName,
                         newRuleGroup: 'no'});
                }
            };

            vm.ruleNewRuleGroup = function () {
                var id = ruleGroupService.getNextId();
                $state.go('ruleGroupDetails', {ruleGroupId: 'CDDRG_new_' + id.toString(), ruleGroupName: 'Rule Group ' + id.toString(), newRuleGroup: 'yes'});
            };

            // directive callback function
            vm.callback = function (item) {
                vm.fromCallback = 'User selected ' + angular.toJson(item);
            };

            //display all non-deleted ruleGroups, if rule is included in the deleted group then that
            // group only will be included in the list
            vm.getRuleGroupNames = function () {
                ruleGroupService.getAllRuleGroups().then(function (data) {
                        var ruleGroups = data.items;
                        var names = [];
                        var displayName = '';
                        for (var i = 0; i < ruleGroups.length; i++) {
                            displayName = ruleGroups[i].ruleGroupName;
                            if (ruleGroups[i].logicalDeleteInd === 'Y') {
                                // for new rules do not display deleted rules
                                if (!vm.newRule && vm.ruleGroupId === ruleGroups[i].ruleGroupId) {
                                    displayName = vm.resources.aml.getResource('rule.deletedIndicator',{groupName: ruleGroups[i].ruleGroupName});
                                    names.push({code: ruleGroups[i].ruleGroupId, value: displayName});
                                }
                            } else {
                                names.push({code: ruleGroups[i].ruleGroupId, value: displayName});
                            }
                        }
                        vm.ruleGroupNames = _.sortBy(names, function (ruleGroup) {
                            return ruleGroup.value.toLowerCase();
                        });
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.ruleReadRuleGroupsErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            };

            vm.selectDetails = function () {
                vm.showDetails = true;
                vm.showLogic = false;
            };
            vm.selectLogic = function () {
                vm.showDetails = false;
                vm.showLogic = true;
            };

            vm.formsHaveErrors = function () {
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (Object.getOwnPropertyNames(vm.forms[name].$error).length > 0) {
                        return true;
                    }
                }
                return vm.idError; //set by validateRuleData
            };

            vm.ruleGroupSelected = function (ruleGroupId) {
                updateRuleGroupID(true);
            };

            vm.toggleIdChange = function toggleIdChange () {
                if (vm.allowIdChange) {
                    vm.rule.ruleId = vm.origRuleId;
                    vm.origRuleId = '';
                    vm.idError = false;
                } else {
                    vm.origRuleId = vm.rule.ruleId;
                }
                vm.allowIdChange = !vm.allowIdChange;
            };

            vm.toggleCollapsed = function (prefix) {
                if (prefix === 'b') { //basic info
                    vm.bcollapsed = !vm.bcollapsed;
                } else if (prefix === 'h') {  //rule group info
                    vm.hcollapsed = !vm.hcollapsed;
                } else if (prefix === 'e') {  //audit info
                    vm.ecollapsed = !vm.ecollapsed;
                } else if (prefix === 'p') {
                    vm.pcollapsed = !vm.pcollapsed;
                } else if (prefix === 'parms') {
                    vm.parmscollapsed = !vm.parmscollapsed;
                } else if (prefix === 'c') { // source code
                    vm.ccollapsed = !vm.ccollapsed;
                } else if (prefix === 'd') { // data set variables
                    vm.dcollapsed = !vm.dcollapsed;
                }
            };
            vm.statusSelected = function (status) {
            };

            vm.dirtyAll = function (formIn) {
                var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
                for (var i = 0; i < names.length; i++) {
                    formIn[names[i]].$dirty = true;
                }
            };
            $scope.$watch('vm.forms.parmsForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });

            vm.bindChange = false;
            vm.status = amlLov.getAsArray(amlLov.ruleStatus);
            vm.risks = amlLov.getAsArray(amlLov.yesOrNo);
            vm.ruleTypes = amlLov.getAsArray(amlLov.ruleType, true);

            initParamGridOptions();

            if (!$stateParams.ruleId || $stateParams.ruleId === 'null' || $stateParams.ruleId === '') {
                var msg = resources.aml.getResource('rule.ruleReadErrorTxt',
                    {'ruleId': $stateParams.ruleId});
                messageService.danger(msg, null, -1);
            } else {
                if ($stateParams.newRule && $stateParams.newRule === 'yes') {
                    //generate new object
                    if (!$stateParams.ruleName) {
                        //in case we came to the state with bookmarked URL
                        $stateParams.ruleName = 'Rule ' + ruleService.getNextId().toString();
                        $stateParams.ruleGroupId = 'none';
                    }
                    vm.newRule = true;
                    vm.rule = ruleService.newRule($stateParams.ruleName, $stateParams.ruleId);
                    vm.ruleGroupId = $stateParams.ruleGroupId;
                    updateRuleGroupID(true); //will load ruleGroup data
                    vm.ruleGroupName = vm.rule.ruleGroupName; //could be empty
                    if (vm.rule.ruleGroupInputDsName && vm.rule.ruleGroupInputDsName !== '') {
                        vm.loadDataset(vm.rule.ruleGroupInputDsName);
                    }
                    vm.loading = false;
                    updateTabTitle();
                    //for new rule use only undeleted rule groups
                    vm.getRuleGroupNames();
                    //need to wait for the grid to be created otherwise data source read method will fail
                    var uregisterParmsModelWatch = $scope.$watch('vm.parmsDummyModel', function (newValue, oldValue) {
                        setInitialGridState('parms');
                        uregisterParmsModelWatch();
                    });
                } else {
                    // existing rule
                    vm.ruleGroupId = $stateParams.ruleGroupId;
                    vm.ruleId = $stateParams.ruleId;
                    vm.newRule = false;
                    vm.getRuleData(vm.ruleId);
                    //vm.getRuleData will invoke vm.getRuleGroupNames(); when ruleGroupId is known
                    //so deleted groups will be excluded from the list
                }

                // add a modal dialog to allow pill to be closed
                // return true to close...false to keep pill
                tabsListService.registerCloseCallback(vm.state, function ruleCallback() {
                    var defer = $q.defer();
                    if (vm.state.data.dirty === true) {
                        var modalInstance = $uibModal.open({
                            animation: true,
                            templateUrl: 'modalCloseRule.html',
                            controller: 'RuleModalDispositionController as viewVm',
                            size: 'sm',
                            backdrop: 'static'
                        });
                        modalInstance.ruleName = vm.rule.ruleName;

                        modalInstance.result.then(
                            function () {}, //modal close - not use
                            function (buttonValue) { //modal dismiss
                            if (buttonValue === 'discard') {
                                defer.resolve(true);
                                $state.go('rules');
                            } else if (buttonValue === 'save') {
                                var save = vm.saveRule(true);// call save method on rule
                                if (save === null) {
                                    //page has errors, cannot be saved, so do not close the tab
                                    defer.resolve(false);
                                } else {
                                    save.then (
                                        function success () {
                                            defer.resolve(true);
                                            $state.go('rules');
                                        },
                                        function failure () {
                                            //save failed,  so do not close the tab
                                            defer.resolve(false);
                                        }
                                    );
                                }
                            } else if (buttonValue === 'cancel') {
                                defer.resolve(false);
                            }
                        });
                    } else {
                        defer.resolve(true);
                        $state.go('rules');
                    }
                    return defer.promise;
                });
            }
        }

        init();
    }
})();

(function() {
    'use strict';

    RuleModalDispositionController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.rule')
        .controller('RuleModalDispositionController', RuleModalDispositionController);

    function RuleModalDispositionController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;
        viewVm.ruleName = $uibModalInstance.ruleName;

        viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
        };
        viewVm.save = function () {
            $uibModalInstance.dismiss('save');
        };
        viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

(function() {
    'use strict';

    RuleModalController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.rule')
        .controller('RuleModalController', RuleModalController);

    function RuleModalController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;

        viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
        };
    }
})();

(function () {
    'use strict';

    RuleGroupListDirectiveController.$inject = ["ruleGroupService", "$scope", "resources", "kendoGridRendererService", "messageService", "$state", "logger", "_"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupListDirectiveController', RuleGroupListDirectiveController);
    /* jshint maxparams: 16*/
    /* jshint maxstatements: 63 */
    function RuleGroupListDirectiveController(ruleGroupService, $scope, resources,
                                           kendoGridRendererService, messageService,
                                           $state, logger, _) {
        var vm = this;
        //vm.ruleGroups = [];
        vm.resources = resources;
        vm.grid = {};
        vm.amlGridActions = [];
        vm.ruleGroupCount = 0;
        vm.filterString = null;

        var dataSourceOptions = {
            transport: {
                read: getRuleGroups
            },
            schema: {
                model: {
                    fields: {
                        ruleGroupId: {type: 'string'},
                        ruleGroupName: {type: 'string'},
                        ruleGroupInputDsName: {type: 'string'},
                        ruleGroupLevel: {type: 'number'},
                        ruleGroupOrderInLevel: {type: 'number'},
                        ruleGroupDescription: {type: 'string'},
                        ruleGroupCategoryCode: {type: 'string'},
                        ruleGroupType: {type: 'string'},
                        ruleGroupSaveToKcFlg: {type: 'string'},
                        updateDateShort: {type: 'date'},
                        updateDate: {type: 'date'}
                    }
                },
                parse: function(d) {
                    _.each(d.items, function(elem) {
                        //Compute date fields without time component so that filter operations work as expected (using only date portion adjusted for timezone)
                        elem.updateDateShort = kendoGridRendererService.getLocalDateOnlyValue(elem.updateDate);
                    });
                    return d;
                },
                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            // when local datagrid is filtered, we want to update the count displayed in the title label similar to
            // how naturally occurs on remote grids
            change: function(e) {
                vm.ruleGroupCount = e.items.length;
            },
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        };

        //var saveToKcFlgRenderingFilter = kendoGridRendererService.enum('ruleGroupSaveToKcFlg', 'yesOrNo');
        var ruleGroupCategoryCodeRenderingFilter = kendoGridRendererService.enum('ruleGroupCategoryCode', 'ruleGroupCategory');
        var ruleGroupTypeRenderingFilter = kendoGridRendererService.enum('ruleGroupType', 'ruleGroupType');

        vm.gridColumns = [
            {
                field: 'ruleGroupLevel', title: vm.resources.aml.ruleGroup.stepNumberHeaderTitle,
                width: '6%',
                attributes:  {class: 'number-display'}  //right alignment
            },
            {
                field: 'ruleGroupId', title: resources.aml.ruleGroup.ruleGroupIdHeaderTitle,
                width: '9%'
            },
            {
                field: 'ruleGroupName', title: vm.resources.aml.ruleGroup.nameHeaderTitle,
                width: '12%'
            },
            {
                field: 'ruleGroupDescription', title: vm.resources.aml.ruleGroup.ruleGroupDescriptionHeaderTitle,
                width: '20%'
            },
            {
                field: 'ruleGroupOrderInLevel', title: vm.resources.aml.ruleGroup.orderNumberHeaderTitle,
                attributes:  {class: 'number-display'},  //right alignment
                width: '6%'
            },
            {
                field: 'ruleGroupInputDsName', title: vm.resources.aml.ruleGroup.ruleGroupInputDsNameHeaderTitle,
                width: '17%'
            },
            {
                field: 'ruleGroupCategoryCode', title: vm.resources.aml.ruleGroup.ruleGroupCategoryCodeHeaderTitle,
                template: ruleGroupCategoryCodeRenderingFilter,
                width: '8%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(ruleGroupCategoryCodeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('ruleGroupCategory')
            },
            {
                field: 'ruleGroupType', title: vm.resources.aml.ruleGroup.ruleGroupTypeHeaderTitle,
                template: ruleGroupTypeRenderingFilter,
                width: '14%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(ruleGroupTypeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('ruleGroupType')
            },
            //{
            //    field: 'ruleGroupSaveToKcFlg', title: vm.resources.aml.ruleGroup.ruleGroupSaveToKcFlgHeaderTitle,
            //    template: saveToKcFlgRenderingFilter,
            //    width: '6%',
            //    sortable: { compare: kendoGridRendererService.getFilterSortFunction(saveToKcFlgRenderingFilter) },
            //    filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            //},
            {
                field: 'updateDateShort', title: resources.aml.rule.updatedHeaderTitle,
                template: '{{dataItem.updateDate | date:"short"}}',
                width: '9%'
            }
        ];


        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                dataSource: dataSourceOptions,
                height: 750,
                pageable: false,
                resizable: true,
                //navigatable: true,
                selectable: 'multiple',
                scrollable: {
                    virtual: true
                }
            });

        activate();

        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'ruleGroupsList');
            //init callbacks for the parent scope
            if (angular.isDefined(vm.callback)) {
                vm.callback.getSelectedRuleGroupIdsFromSelectedRows = getSelectedRuleGroupIdsFromSelectedRows;
                vm.callback.reloadGrid = reloadGrid;
            }
        }

        function handleDoubleClick(evt, data) {
            var ruleGroup = vm.grid.dataItem(evt.currentTarget);
            if (ruleGroup && ruleGroup.ruleGroupId) {
                $state.go('ruleGroupDetails',
                    {
                        ruleGroupId: ruleGroup.ruleGroupId,
                        ruleGroupName: ruleGroup.ruleGroupName,
                        newRuleGroup: 'no'
                    });
            }
        }

        function getSelectedRuleGroupIdsFromSelectedRows(type) {
            var entityIds = [];
            if ( vm.grid ) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var entity  = vm.grid.dataItem(rowSelection);
                    if (entity && entity.ruleGroupId) {
                        if(type) {
                            if (entity.ruleGroupType === type) {
                                entityIds.push(entity.ruleGroupId);
                            }
                        } else {
                            entityIds.push(entity.ruleGroupId);
                        }
                    }
                });
            }
            return entityIds;
        }

        function reloadGrid(showDeleted) {
            vm.showDeleted = showDeleted;
            vm.grid.dataSource.read();
        }

        function getRuleGroups(e) {
            ruleGroupService.getRuleGroups(vm.showDeleted).then(
                function (data) {
                    // on server response success
                    vm.loading = null;
                    vm.ruleGroupCount = data.items.length;
                    e.success(data);
                },
                function (data, status, ruleGroups, config) {
                    var msg = resources.aml.getResource('ruleGroup.ruleGroupsReadErrorTxt');
                    messageService.danger(msg, null, -1);
                });
        }
    }
})();

(function() {
    'use strict';

    RuleGroupListViewController.$inject = ["$scope", "ruleGroupService", "$state", "ruleService", "$uibModal", "resources", "messageService"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupListViewController', RuleGroupListViewController);

    function RuleGroupListViewController($scope, ruleGroupService, $state, ruleService,
                                         $uibModal, resources, messageService) {
        var viewVm = this;
        viewVm.loading=true;
        viewVm.showDeleted = false;
        viewVm.resources = resources;

        viewVm.gridCallbacks = {
            getSelectedRuleGroupIdsFromSelectedRows : function () {return [];},
            reloadGrid : function () {return [];}
        };
        activate();

        function activate () {
            $scope.$on('ruleGroupChanged', function(event, changedData) {
                viewVm.reloadList();
            });
        }

        viewVm.newRuleGroup= function() {
            var id = ruleGroupService.getNextId();
            $state.go('ruleGroupDetails',{ruleGroupId: 'CDDRG_new_'+id.toString(), ruleGroupName: 'Rule Group ' +id.toString(), newRuleGroup: 'yes'});
        };

        viewVm.markRuleGroupsDeleted = function() {
            var ids =  viewVm.gridCallbacks.getSelectedRuleGroupIdsFromSelectedRows();
            if (ids.length > 0) {
                ruleGroupService.markRuleGroupsAsDeleted(ids).then(function (data) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupsMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupsMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            } else {
                var msg = resources.aml.getResource('ruleGroup.noRuleGroupsSelectedErrorTxt');
                messageService.danger(msg, null, -1);
            }
        };

        viewVm.markRuleGroupsUndeleted = function() {
            var ids =  viewVm.gridCallbacks.getSelectedRuleGroupIdsFromSelectedRows();
            if (ids.length > 0) {
                ruleGroupService.markRuleGroupsAsUndeleted(ids).then(function (data) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupsMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupsMarkedUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            } else {
                var msg = resources.aml.getResource('ruleGroup.noRuleGroupsSelectedErrorTxt');
                messageService.danger(msg, null, -1);
            }
        };

        viewVm.reloadList = function reloadList() {
            viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
        };

        viewVm.runRuleGroups = function () {
            //only active rules can be executed
            var ids = viewVm.gridCallbacks.getSelectedRuleGroupIdsFromSelectedRows('ATTR');
            var allIds = viewVm.gridCallbacks.getSelectedRuleGroupIdsFromSelectedRows();
            if (ids.length !== allIds.length && ids.length > 0) {
                messageService.warning(resources.aml.getResource('ruleGroup.aggrRuleGroupsErrorTxt'),
                    null, 4000);
            }
            if (ids.length > 0) {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'ruleGroupTest.html',
                    controller: 'RuleGroupTestController as vm',
                    size: 'lg',
                    backdrop: 'static'
                });
                modalInstance.ids = ids;
                modalInstance.params = ruleService.runParameters;
                modalInstance.result.then(
                    //ok
                    function (result) {
                    });
            } else {
                messageService.danger(resources.aml.getResource('ruleGroup.noAttrRuleGroupsSelectedErrorTxt'),
                    null, 3000);
            }
        };

        viewVm.toggleDeleted = function () {
            viewVm.showDeleted = !viewVm.showDeleted;
            viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
        };

    }
})();

(function () {
    'use strict';

    RuleGroupTestController.$inject = ["$scope", "$uibModalInstance", "resources", "ruleService", "messageService", "$sce", "amlLov"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupTestController', RuleGroupTestController);

    function RuleGroupTestController($scope, $uibModalInstance, resources, ruleService, messageService, $sce, amlLov) {
        var vm = this;
        vm.resources = resources;
        vm.testResults = vm.resources.aml.getResource('rule.clickRunTxt');
        //use saved parameters from previous run
        vm.params = $uibModalInstance.params;
        vm.params.ids = $uibModalInstance.ids;
        vm.yesOrNo = amlLov.getAsArray(amlLov.yesOrNo);

        vm.run = function () {
            vm.testResults = resources.aml.getResource('rule.waitForResultsTxt') +
                '<span class="sas-icon sas-icon-refresh sas-icon-spin-backwards"></span>';

            ruleService.runRules(vm.params).then(function (data) {
                    messageService.success(resources.aml.getResource('rule.rulesTestTxt'), null, 4000);
                    vm.testResults = $sce.trustAsHtml(data.data);
                },
                function (error) {
                    var msg = vm.resources.aml.getResource('rule.rulesTestErrorTxt');
                    messageService.danger(msg, null, -1);
                    vm.testResults = msg;
                }
            );
        };

        vm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

(function () {
    'use strict';

    RuleListController.$inject = ["ruleService", "$scope", "$log", "$state", "$q", "kendoGridRendererService", "amlLov", "resources", "_"];
    angular
        .module('cdd.rule')
        .controller('RuleListDirectiveController', RuleListController);

    function RuleListController(ruleService, $scope, $log,
                                $state, $q, kendoGridRendererService,
                                amlLov, resources, _) {
        var vm = this;
        vm.createWidget = true;
        vm.rules = [];
        vm.ruleCount = 0;
        vm.firstDataLoad = true;
        vm.showDeleted = false;
        vm.grid = {};
        vm.amlGridActions = [];
        vm.resources = resources;
        vm.filterString = null;

        var dataSourceOptions = {
            transport: {
                read: getRules
            },
            schema: {
                model: {
                    fields: {
                        ruleId: {type: 'string'},
                        ruleName: {type: 'string'},
                        ruleDescription: {type: 'string'},
                        ruleGroupName: {type: 'string'},
                        ruleOrderInGroup: {type: 'number'},
                        ruleStatusCode: {type: 'string'},
                        ruleTypeCode: {type: 'string'},
                        ruleSaveIdFlg: {type: 'string'},
                        updateDateShort: {type: 'date'},
                        updateDate: {type: 'date'}
                    }
                },
                parse: function(d) {
                    _.each(d.items, function(elem) {
                        //Compute date fields without time component so that filter operations work as expected (using only date portion adjusted for timezone)
                        elem.updateDateShort = kendoGridRendererService.getLocalDateOnlyValue(elem.updateDate);
                    });
                    return d;
                },
                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            // when local data grid is filtered, we want to update the count displayed in the title label similar to
            // how naturally occurs on remote grids
            change: function(e) {
                vm.ruleCount = e.items.length;
            },
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        };

        var yesNoRenderingFilter = kendoGridRendererService.enum('ruleSaveIdFlg', 'yesOrNo');
        var statusRenderingFilter = kendoGridRendererService.enum('ruleStatusCode', 'ruleStatus');
        var ruleTypeRenderingFilter =  kendoGridRendererService.enum('ruleTypeCode', 'ruleType');

        vm.gridColumns = [
            {
                field: 'ruleId', title: resources.aml.rule.ruleIdHeaderTitle,
                width: '7%'
            },
            {
                field: 'ruleName', title: resources.aml.rule.ruleNameHeaderTitle,
                width: '17%'
            },
            {
                field: 'ruleDescription', title: resources.aml.rule.shortDescriptionHeaderTitle,
                width: '23%'
            },
            {
                field: 'ruleGroupName', title: resources.aml.rule.ruleGroupNameHeaderTitle,
                width: '15%'
            },
            {
                field: 'ruleOrderInGroup', title: resources.aml.rule.orderInGroupHeaderTitle,
                width: '6%',
                attributes:  {class: 'number-display'}  //right alignment
            },
            {
                field: 'ruleStatusCode', title: resources.aml.rule.ruleStatusHeaderTitle,
                template: statusRenderingFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(statusRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('ruleStatus'),
                width: '6%'
            },
            {
                field: 'ruleTypeCode', title: resources.aml.rule.typeCodeHeaderTitle,
                template: ruleTypeRenderingFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(ruleTypeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('ruleType'),
                width: '10%'
            },
            {
                field: 'ruleSaveIdFlg', title: resources.aml.rule.ruleSaveIdFlgHeaderTitle,
                template: yesNoRenderingFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(yesNoRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo'),
                width: '6%'
            },
            {
                field: 'updateDateShort', title: resources.aml.rule.updatedHeaderTitle,
                template: '{{dataItem.updateDate | date:"short"}}',
                width: '10%'
            }
        ];

        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                dataSource: dataSourceOptions,
                height: 750,
                pageable: false,
                selectable: 'multiple',
                resizable: true,
                scrollable: {
                    virtual: true
                }
            });


        // on double-click, open the rule
        function handleDoubleClick(evt, data) {
            var rule = vm.grid.dataItem(evt.currentTarget);
            //routing does not work if string is empty
            if (rule.ruleGroupId === '') {
                    rule.ruleGroupId = null;
            }
            if (rule && rule.ruleId) {
                $state.go('ruleDetails', {
                    ruleId: rule.ruleId,
                    ruleName: rule.ruleName,
                    ruleGroupId: rule.ruleGroupId,
                    newRule: 'no'
                });
            }
        }

        function getRules(e) {
            ruleService.getRules(vm.showDeleted).then(function (data) {
                    // on server response success
                    vm.loading = null;
                    vm.ruleCount = data.items.length;
                    _.each (data.items, function rgName (rule) {
                        if (rule.ruleGroupLogicalDeleteInd === 'Y') {
                            rule.ruleGroupName = vm.resources.aml.getResource('rule.deletedIndicator',{groupName: rule.ruleGroupName});
                        }
                    });
                    e.success(data);
                },
                function (data, status, headers, config) {
                    $log.info('getRules failed');
                });
        }

        function getIdsFromSelectedRows(status) {
            var entityIds = [];
            if ( vm.grid ) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var entity  = vm.grid.dataItem(rowSelection);
                    if (entity && entity.ruleId) {
                        if(status) {
                            if (entity.status === status) {
                                entityIds.push(entity.ruleId);
                            }
                        } else {
                            entityIds.push(entity.ruleId);
                        }
                    }
                });
            }
            return entityIds;
        }

        function reloadGrid(showDeleted) {
            vm.showDeleted = showDeleted;
            vm.grid.dataSource.read();
        }

        ////////////////

        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'rulesList');
            if (angular.isDefined(vm.callback)) {
                vm.callback.getIdsFromSelectedRows = getIdsFromSelectedRows;
                vm.callback.reloadGrid = reloadGrid;
            }
        }
        activate();

    }
})();
(function () {
    'use strict';

    RuleListViewController.$inject = ["$scope", "$state", "ruleService", "$uibModal", "messageService", "amlLov", "resources", "_"];
    angular
        .module('cdd.rule')
        .controller('RuleListViewController', RuleListViewController);

    function RuleListViewController($scope, $state, ruleService,
                                    $uibModal, messageService, amlLov,
                                    resources, _) {
        var vm = this;
        vm.loading = true;
        vm.resources = resources;
        vm.showDeleted = false;
        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;

        activate();

        function activate () {
            $scope.$on('ruleChanged', function(event, changedData) {
                vm.reloadList();
            });
        }

        function disableUnsafeActions() {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('rule.ruleActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }

        function enableUnsafeActions() {
            disableUnsafeActionsFlag = false;
        }

        vm.actionsDisabled = function () {
            return disableUnsafeActionsFlag;
        };

        vm.actionRunning = function () {
            return vm.gridCallbacks.importRunning || vm.gridCallbacks.exportRunning || vm.gridCallbacks.copyRunning || vm.actionsDisabled();
        };


        vm.gridCallbacks = {
            getIdsFromSelectedRows: function () {
                return [];
            },
            reloadGrid: function () {
                return [];
            },
            exportRunning: false,
            importRunning: false,
            copyRunning: false
        };

        vm.ruleGroupCopyAction = [
            {
                key: 'COPY',
                value: resources.aml.getResource('rule.copyRuleGroupActionLabel'),
                tip: resources.aml.getResource('rule.copyRuleGroupTip')
            },
            {
                key: 'NONE',
                value: resources.aml.getResource('rule.noneRuleGroupActionLabel'),
                tip: resources.aml.getResource('rule.noneRuleGroupTip')
            },
            {
                key: 'SAME',
                value: resources.aml.getResource('rule.sameRuleGroupActionLabel'),
                tip: resources.aml.getResource('rule.sameRuleGroupTip')
            }];

        vm.toggleDeleted = function () {
            vm.showDeleted = !vm.showDeleted;
            vm.gridCallbacks.reloadGrid(vm.showDeleted);
        };

        ruleService.getRules().then(function (data) {
                vm.rules = data.items;
                vm.loading = false;
            },
            function (error) {
                console.log('Rule List Error: ' + error); // TODO: externalize this
            });

        //$rootScope.$on('stateChangeError',
        //    function(event, toState, toParams, fromState, fromParams, error){
        //        console.log(error);
        //    });
        vm.newRule = function newRule () {
            var id = ruleService.getNextId();
            $state.go('ruleDetails', {
                ruleId: 'CDDR_new_rule_' + id.toString(),
                ruleName: 'Rule_' + id.toString(),
                ruleGroupId: 'none',
                newRule : 'yes'
            });
        };

        vm.ruleActivate = function ruleActivate () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                ruleService.activateRules(ids).then(function (data) {
                        var msg = resources.aml.getResource('rule.rulesActivatedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesActivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.reloadList = function reloadList() {
            vm.gridCallbacks.reloadGrid(vm.showDeleted);
        };

        vm.ruleDeactivate = function ruleDeactivate () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                ruleService.deactivateRules(ids).then(function (data) {
                        var msg = resources.aml.getResource('rule.rulesDeactivatedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesDeactivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.ruleDelete = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                ruleService.deleteRules(ids).then(function (data) {
                        var msg = resources.aml.getResource('rule.rulesDeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.ruleUndelete = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                ruleService.undeleteRules(ids).then(function (data) {
                        var msg = resources.aml.getResource('rule.rulesUndeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        var saveToPc = function (data, filename) {
            if (!data) {
                //console.error('No data');
                return;
            }

            if (!filename) {
                filename = 'download.json';
            }

            if (typeof data === 'object') {
                data = JSON.stringify(data, undefined, 2);
            }

            var blob = new Blob([data], {type: 'text/json'});
            if (window.navigator.msSaveOrOpenBlob) {
                // Internet Explorer
                window.navigator.msSaveOrOpenBlob(blob, filename);
            }
            else {
                var hiddenLinkElement = document.createElement('a');
                hiddenLinkElement.download = filename;
                hiddenLinkElement.href = window.URL.createObjectURL(blob);
                hiddenLinkElement.dataset.downloadurl = ['text/json', hiddenLinkElement.download, hiddenLinkElement.href].join(':');
                document.body.appendChild(hiddenLinkElement);
                hiddenLinkElement.click();
                document.body.removeChild(hiddenLinkElement);
            }
        };

        vm.ruleExport = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                vm.gridCallbacks.exportRunning = true;
                ruleService.exportRules(ids).then(function (data) {
                        saveToPc(data, 'RuleExport.json');
                        messageService.success(resources.aml.getResource('rule.rulesExportTxt'), null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesExportErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    vm.gridCallbacks.exportRunning = false;
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        var parseStatus = function (ActionStatus) {
            var ruleGroupsFailed = _.pluck(_.where(ActionStatus, {
                entityType: 'ruleGroup',
                actionStatus: 'failed'
            }), 'entityName');
            var ruleGroupsUpdated = _.pluck(_.where(ActionStatus, {
                entityType: 'ruleGroup',
                actionStatus: 'updated'
            }), 'entityName');
            var ruleGroupsCreated = _.pluck(_.where(ActionStatus, {
                entityType: 'ruleGroup',
                actionStatus: 'created'
            }), 'entityName');
            var rulesFailed = _.pluck(_.where(ActionStatus, {
                entityType: 'rule',
                actionStatus: 'failed'
            }), 'entityName');
            var rulesUpdated = _.pluck(_.where(ActionStatus, {
                entityType: 'rule',
                actionStatus: 'updated'
            }), 'entityName');
            var rulesCreated = _.pluck(_.where(ActionStatus, {
                entityType: 'rule',
                actionStatus: 'created'
            }), 'entityName');
            return {
                ruleGroupsFailed: ruleGroupsFailed,
                ruleGroupsUpdated: ruleGroupsUpdated,
                ruleGroupsCreated: ruleGroupsCreated,
                rulesFailed: rulesFailed,
                rulesUpdated: rulesUpdated,
                rulesCreated: rulesCreated
            };
        };

        vm.ruleImport = function () {

            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'modalFileSelect.html',
                controller: 'ModalFileSelectController as vm',
                size: 'm',
                backdrop: 'static'
            });

            modalInstance.result.then(
                //ok
                function (selectedFile) {
                    //console.log(selectedFile);
                    if (selectedFile) {
                        vm.gridCallbacks.importRunning = true;
                        var reader = new FileReader();
                        reader.onload = function (e) {
                            var jsonString = reader.result;
                            var json = JSON.parse(jsonString);

                            ruleService.importRules(json).then(function (data) {
                                    var status = parseStatus(data.ActionStatus);
                                    var modalInstanceStatus = $uibModal.open({
                                        animation: true,
                                        templateUrl: 'statusMessage.html',
                                        controller: 'CddStatusMessageController as vm',
                                        size: 'm',
                                        backdrop: 'static'
                                    });
                                    modalInstanceStatus.status = status;
                                    modalInstanceStatus.title = resources.aml.getResource('rule.importMessageWindowTitle');
                                    modalInstanceStatus.result.then(
                                        function (ok) {
                                        }
                                    );
                                    vm.gridCallbacks.reloadGrid(vm.showDeleted);
                                },
                                function (error) {
                                    messageService.danger(resources.aml.getResource(
                                        'rule.rulesImportErrorTxt', {'fileName': selectedFile.name}), null, -1);
                                }).finally(function () {
                                vm.gridCallbacks.importRunning = false;
                                enableUnsafeActions();
                            });

                        };
                        reader.onerror = function (e) {
                            messageService.danger(resources.aml.getResource(
                                'rule.rulesFileReadErrorTxt', {'fileName': selectedFile.name}), null, -1);
                            vm.gridCallbacks.importRunning = false;
                            enableUnsafeActions();
                        };
                        disableUnsafeActions();
                        reader.readAsText(selectedFile);
                    } else {
                        messageService.danger(resources.aml.getResource(
                            'rule.noFileSelectedErrorTxt'), null, 4000);
                    }
                },
                //cancel
                function (reason) {
                    messageService.warning(resources.aml.getResource(
                        'rule.importCanceledTxt'), null, 4000);
                });
        };

        vm.ruleCopy = function (hdrAction) {
            ruleService.runParameters.ruleGroupAction = hdrAction;
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                vm.gridCallbacks.copyRunning = true;
                disableUnsafeActions();
                ruleService.copyRules(ids, ruleService.runParameters.ruleGroupAction).then(function (data) {
                        var status = parseStatus(data.ActionStatus);
                        var modalInstanceStatus = $uibModal.open({
                            animation: true,
                            templateUrl: 'statusMessage.html',
                            controller: 'CddStatusMessageController as vm',
                            size: 'm',
                            backdrop: 'static'
                        });
                        modalInstanceStatus.status = status;
                        modalInstanceStatus.title = resources.aml.getResource('rule.copyMessageWindowTitle');
                        modalInstanceStatus.result.then(
                            function (ok) {
                            }
                        );
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('rule.rulesCopyErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    vm.gridCallbacks.copyRunning = false;
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('rule.noRulesSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };
    }
})();

(function () {
    'use strict';

    ModalFileSelectController.$inject = ["$scope", "$uibModalInstance", "resources", "messageService"];
    angular
        .module('cdd.rule')
        .controller('ModalFileSelectController', ModalFileSelectController);

    function ModalFileSelectController($scope, $uibModalInstance, resources, messageService) {
        var vm = this;
        vm.resources = resources;
        vm.selectedFile = '';

        $scope.fileSelectionChanged = function (element) {
            $scope.$apply(function (scope) {
                vm.selectedFile = element.files[0];
            });
        };
        vm.ok = function () {
            if (vm.selectedFile && vm.selectedFile !== '') {
                $uibModalInstance.close(vm.selectedFile);
            } else {
                messageService.danger(resources.aml.getResource('rule.noFileSelectedErrorTxt'), null, 4000);
            }
        };
        vm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

(function () {
    'use strict';

    RuleTestController.$inject = ["$scope", "$uibModalInstance", "resources", "ruleService", "messageService", "$sce", "amlLov"];
    angular
        .module('cdd.rule')
        .controller('RuleTestController', RuleTestController);

    function RuleTestController($scope, $uibModalInstance, resources, ruleService, messageService, $sce, amlLov) {
        var vm = this;
        vm.resources = resources;
        vm.testResults = vm.resources.aml.getResource('rule.clickRunTxt');
        //use saved parameters from previous run
        vm.params = $uibModalInstance.params;
        vm.params.ids = $uibModalInstance.ids;
        vm.yesOrNo = amlLov.getAsArray(amlLov.yesOrNo);


        vm.run = function () {
            vm.testResults = resources.aml.getResource('rule.waitForResultsTxt') +
                '<span class="sas-icon sas-icon-refresh sas-icon-spin-backwards"></span>';

            ruleService.runRules(vm.params).then(function (data) {
                    messageService.success(resources.aml.getResource('rule.rulesTestTxt'), null, 4000);
                    vm.testResults = $sce.trustAsHtml(data.data);
                },
                function (error) {
                    var msg = vm.resources.aml.getResource('rule.rulesTestErrorTxt');
                    messageService.danger(msg, null, -1);
                    vm.testResults = msg;
                }
            );
        };

        vm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();


(function () {
    'use strict';

    CddStatusMessageController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.rule')
        .controller('CddStatusMessageController', CddStatusMessageController);

    function CddStatusMessageController($uibModalInstance, resources) {
        var vm = this;
        vm.status = $uibModalInstance.status;
        vm.resources = resources;
        if ($uibModalInstance.title) {
            vm.title = $uibModalInstance.title;
        } else {
            vm.title = resources.aml.getResource('rule.statusMessageWindowTitle');
        }

        vm.ok = function () {
            $uibModalInstance.close('ok');
        };
    }
})();

(function () {
    'use strict';

    RuleGroupDetailsViewController.$inject = ["$rootScope", "$scope", "$stateParams", "$state", "$q", "logger", "amlLov", "resources", "kendoGridRendererService", "tabsListService", "$uibModal", "datasetService", "ruleGroupService", "messageService", "_"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupDetailsViewController', RuleGroupDetailsViewController);

    /* jshint maxparams: 17 */
    /* jshint maxstatements: 63 */
    function RuleGroupDetailsViewController($rootScope, $scope, $stateParams, $state, $q, logger, amlLov,
                                         resources, kendoGridRendererService, tabsListService, $uibModal,
                                         datasetService, ruleGroupService, messageService, _) {
        var vm = this;
        vm.state = $state.$current;

        vm.forms = {};
        vm.resources = resources;
        vm.origRuleGroupName = 'NULL';
        vm.byVariableError = false;
        vm.showDeleted = false;
        vm.loading = true;
        //vm.observableArray = new kendo.data.ObservableArray([]);
        vm.rules = [];
        vm.datasetColumns = [];
        vm.ruleCount = 0;
        vm.newRuleGroup = false;
        vm.idError = false;
        //rule list table
        vm.grid = {};
        vm.amlGridActions = [];
        vm.filterString = '';
        //change rule group id support
        vm.origRuleGroupId = '';
        vm.allowIdChange = false;


        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;
        var yesNoRenderingFilter = kendoGridRendererService.enum('ruleSaveIdFlg', 'yesOrNo');
        var statusRenderingFilter = kendoGridRendererService.enum('ruleStatusCode', 'ruleStatus');
        var ruleTypeRenderingFilter =  kendoGridRendererService.enum('ruleTypeCode', 'ruleType');

        function disableUnsafeActions () {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('rule.ruleActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }
        function enableUnsafeActions () {
            disableUnsafeActionsFlag = false;
        }

        function updateTabTitle() {
            var tabInfo = tabsListService.getTabInfo(vm.state.name);
            if (tabInfo) {
                tabInfo.title = vm.ruleGroup.ruleGroupName;
                tabInfo.params.ruleGroupName = vm.ruleGroup.ruleGroupName;
                $stateParams.ruleGroupName = vm.ruleGroup.ruleGroupName;
                tabsListService.updateTabInfo(tabInfo, true);
            }
        }

        function noDollarSign (aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        function createSource() {
            if (!angular.isDefined(vm.ruleGroup.headerSource)) {
                vm.ruleGroup.headerSource = '';
            }
            if (!angular.isDefined(vm.ruleGroup.footerSource)) {
                vm.ruleGroup.footerSource = '';
            }
        }

        function init() {
            vm.actionsDisabled = function () {
                return disableUnsafeActionsFlag;
            };

            vm.selectDetails = function () {
                vm.showDetails = true;
                vm.showRules = false;
            };

            vm.selectRules = function () {
                vm.showDetails = false;
                vm.showRules = true;
            };

            //vm.getRuleGroupNames = function () {
            //    //get all ruleGroups, name must be unique in the entire FSK_HEADER table
            //    var defer = $q.defer();
            //    ruleGroupService.getRuleGroupNames(true).then(function (ruleGroupNames) {
            //            vm.ruleGroupNames = ruleGroupNames;
            //            defer.resolve(true);
            //        },
            //        function (reason) {
            //            defer.resolve(false);
            //        });
            //    return defer.promise;
            //};

            vm.updateTab = function (e) {
                if (!vm.basicForm.biName.$error.ruleGroupName && angular.isDefined(vm.ruleGroup.ruleGroupName) && vm.ruleGroup.ruleGroupName !== '') {
                    updateTabTitle();
                }
            };

            vm.loadDataset = function (ruleGroupInputDsName) {
                datasetService.getDataset(ruleGroupInputDsName, 'CDD').then(function (data) {
                        vm.datasetColumns = data.datasetColumns;
                        var msg = resources.aml.getResource('ruleGroup.datasetLoadedTxt',
                            {'name': ruleGroupInputDsName});
                        messageService.info(msg, null, 2000);
                    },
                    function (error) {
                        vm.loading = false;
                        var msg = resources.aml.getResource('ruleGroup.datasetReadErrorTxt',
                            {'name': ruleGroupInputDsName});
                        messageService.danger(msg, null, -1);
                    });
            };

            vm.getRuleGroupData = function (ruleGroupId) {
                var hprom = ruleGroupService.getRuleGroup(ruleGroupId);

                var both = $q.all([hprom]);

                both.then(function (data) {
                        vm.ruleGroup = data[0];
                        vm.origRuleGroupName = vm.ruleGroup.ruleGroupName;
                        //refresh list of rules
                        vm.grid.dataSource.read();

                        //var rules = vm.ruleGroup.rules;
                        //for (var i = 0; i < rules.length; i++) {
                        //    vm.observableArray.push(rules[i]);
                        //}
                        if (vm.ruleGroup.ruleGroupInputDsName && vm.ruleGroup.ruleGroupInputDsName !== '') {
                            if (vm.ruleGroup.ruleGroupId === '') {
                                vm.ruleGroup.ruleGroupInputDsName = '';
                            } else {
                                vm.loadDataset(vm.ruleGroup.ruleGroupInputDsName);
                            }
                        }
                        vm.loading = false;
                        vm.showDetails = true;
                        vm.state.data.dirty = false;
                        //vm.isPrepDataSetValid();
                        updateTabTitle();
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('ruleGroup.ruleGroupReadErrorTxt', {'ruleGroupId': ruleGroupId}), null, -1);
                        vm.state.data.dirty = false;  // to set the tab pill to not call callbacks
                        tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
                        vm.loading = false;
                        $state.go('ruleGroups');
                    });
            };

            vm.updateRuleGroup = function (ruleGroupIn, discardFlag) {
                var defer = $q.defer();
                var uprom;
                var idChanged = vm.allowIdChange && vm.origRuleGroupId !== ruleGroupIn.ruleGroupId;
                ruleGroupIn.rules = null; // rules are not used when updating rule group, set to null to avoid
                                          // updateDateShort deserialization error
                if (vm.newRuleGroup) {
                    uprom = ruleGroupService.createNewRuleGroup(ruleGroupIn);
                } else {
                    if (idChanged) {
                        uprom = ruleGroupService.changeRuleGroupId(ruleGroupIn, vm.origRuleGroupId);
                    } else {
                        uprom = ruleGroupService.updateRuleGroup(ruleGroupIn);
                    }
                }

                if (uprom) {
                    uprom.then(function (data) {
                            vm.ruleGroup = data;
                            //if ruleGroup id has changed need to create new state to
                            //avoid creating duplicate tabs, ruleGroup id may change for the new ruleGroup
                            //or when id edit is enabled
                            vm.state.data.dirty = false;
                            //if called from discard dialog do not change state, callback will do that
                            // moreover it will be infinite loop because it will call discard dialog again
                            if (!discardFlag) {
                                //regular Save
                                if (vm.newRuleGroup || idChanged) {
                                    tabsListService.closeTab(tabsListService.getTabForCurrentState(), false).then(
                                        function (data) {
                                            $state.go('ruleGroupDetails',
                                                {
                                                    ruleGroupId: vm.ruleGroup.ruleGroupId,
                                                    ruleGroupName: vm.ruleGroup.ruleGroupName,
                                                    newRuleGroup: 'no'
                                                });
                                        }
                                    );
                                }
                            }
                            vm.allowIdChange = false;
                            vm.origRuleGroupId = '';
                            $rootScope.$broadcast( 'ruleGroupChanged', { ruleGroupId: vm.ruleGroup.ruleGroupId });

                            var msg = resources.aml.getResource('ruleGroup.ruleGroupSavedTxt', {'name': ruleGroupIn.ruleGroupName});
                            messageService.success(msg, null, 4000);
                            defer.resolve('group updated');
                        },
                        function (error) {
                            var msg = resources.aml.getResource('ruleGroup.ruleGroupSaveFailedErrorTxt',
                                {'name': ruleGroupIn.ruleGroupName});
                            messageService.danger(msg, null, -1);
                            if (error.status === 409) {
                                messageService.danger(resources.aml.getResource('ruleGroup.ruleGroupUpdateConflictErrorTxt'), null, -1);
                            }
                            defer.reject(error);
                        }).finally( function () {enableUnsafeActions();});
                } else {
                    enableUnsafeActions();
                    var msg = resources.aml.getResource('ruleGroup.ruleGroupSaveFailedErrorTxt',
                        {'name': ruleGroupIn.ruleGroupName});
                    messageService.danger(msg, null, -1);
                    logger.error('uprom is null in updateRuleGroup:' + ruleGroupIn.ruleGroupName);
                    defer.reject('promise is null while updating group');
                }
                return defer.promise;
            };

            function getRules (e) {
                var data = {};
                if (vm.ruleGroup && vm.ruleGroup.rules) {
                    data.items = vm.ruleGroup.rules;
                    data.count = vm.ruleGroup.rules.length;
                } else {
                    data.items = [];
                    data.count = 0;
                }
                e.success(data);
            }

            vm.gridColumns = [
                {
                    field: 'ruleId', title: resources.aml.rule.ruleIdHeaderTitle,
                    width: '7%'
                },
                {
                    field: 'ruleName', title: resources.aml.rule.ruleNameHeaderTitle,
                    width: '17%'
                },
                {
                    field: 'ruleDescription', title: resources.aml.rule.shortDescriptionHeaderTitle,
                    width: '26%'
                },
                {
                    field: 'ruleGroupName', title: resources.aml.rule.ruleGroupNameHeaderTitle,
                    width: '15%'
                },
                {
                    field: 'ruleOrderInGroup', title: resources.aml.rule.orderInGroupHeaderTitle,
                    width: '5%'
                },
                {
                    field: 'ruleStatusCode', title: resources.aml.rule.ruleStatusHeaderTitle,
                    template: statusRenderingFilter,
                    sortable: { compare: kendoGridRendererService.getFilterSortFunction(statusRenderingFilter) },
                    filterable: kendoGridRendererService.getCheckboxFilter('ruleStatus'),
                    width: '6%'
                },
                {
                    field: 'ruleTypeCode', title: resources.aml.rule.typeCodeHeaderTitle,
                    template: ruleTypeRenderingFilter,
                    sortable: { compare: kendoGridRendererService.getFilterSortFunction(ruleTypeRenderingFilter) },
                    filterable: kendoGridRendererService.getCheckboxFilter('ruleType'),
                    width: '10%'
                },
                {
                    field: 'ruleSaveIdFlg', title: resources.aml.rule.ruleSaveIdFlgHeaderTitle,
                    template: yesNoRenderingFilter,
                    sortable: { compare: kendoGridRendererService.getFilterSortFunction(yesNoRenderingFilter) },
                    filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo'),
                    width: '7%'
                },
                {
                    field: 'updateDateShort', title: resources.aml.rule.updatedHeaderTitle,
                    template: '{{dataItem.updateDate | date:"short"}}',
                    width: '10%'
                }
            ];

            var dataSourceOptions = {
                transport: {
                    read: getRules
                },
                schema: {
                    model: {
                        fields: {
                            ruleId: {type: 'string'},
                            ruleName: {type: 'string'},
                            ruleDescription: {type: 'string'},
                            ruleGroupName: {type: 'string'},
                            ruleOrderInGroup: {type: 'number'},
                            ruleStatusCode: {type: 'string'},
                            ruleTypeCode: {type: 'string'},
                            ruleSaveIdFlg: {type: 'string'},
                            updateDateShort: {type: 'date'},
                            updateDate: {type: 'date'}
                        }
                    },
                    parse: function(d) {
                        _.each(d.items, function(elem) {
                            //Compute date fields without time component so that filter operations work as expected (using only date portion adjusted for timezone)
                            elem.updateDateShort = kendoGridRendererService.getLocalDateOnlyValue(elem.updateDate);
                        });
                        return d;
                    },
                    data: 'items', // records are returned in the 'items' field of the response
                    total: 'count' // total number of results
                },
                serverPaging: false,
                serverSorting: false,
                serverFiltering: false
            };

            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
                {
                    dataSource: dataSourceOptions,
                    height: 400,
                    pageable: false,
                    selectable: 'multiple',
                    resizable: true,
                    sortable: true,
                    filterable: true,
                    scrollable: {
                        virtual: true
                    }
                });

            // on double-click, open the rule
            function handleDoubleClick(evt, data) {
                var rule = vm.grid.dataItem(evt.currentTarget);
                if (rule && rule.ruleId) {
                    $state.go('ruleDetails', {
                        ruleGroupId: rule.ruleGroupId,
                        ruleId: rule.ruleId,
                        ruleName: rule.ruleName,
                        newRule: 'no'
                    });
                }
            }

            vm.toggleIdChange = function toggleIdChange () {
                if (vm.allowIdChange) {
                    vm.ruleGroup.ruleGroupId = vm.origRuleGroupId;
                    vm.origRuleGroupId = '';
                    vm.idError = false;
                } else {
                    vm.origRuleGroupId = vm.ruleGroup.ruleGroupId;
                }
                vm.allowIdChange = !vm.allowIdChange;
            };

            vm.validateRuleGroupData = function validateRuleGroupData() {
                //validates that rule Id is unique
                vm.idError = false;
                var idChanged = vm.allowIdChange && vm.origRuleGroupId !== vm.ruleGroup.ruleGroupId;
                var defer = $q.defer();
                if (vm.newRuleGroup || idChanged) {
                    //new rule must have unique ID that does not exists in FSK_CDD_RULE
                    var idCount = 1;
                    ruleGroupService.getRuleGroupIdCount(vm.ruleGroup).then(function (data) {
                            idCount  = data.data;
                            vm.idError = (idCount !== 0 ); //|| vm.ruleGroup.ruleGroupId.indexOf('_new_') !== -1);
                            defer.resolve('id count ' + idCount);
                        },
                        function (error) {
                            var msg = resources.aml.getResource('ruleGroup.ruleGroupReadErrorTxt',
                                {'ruleGroupId': vm.ruleGroup.ruleGroupId});
                            messageService.danger(msg, null, -1);
                            defer.reject('Cannot read id count');
                        });
                } else {
                    // existing rule id is always unique
                    defer.resolve('id has not changed');
                }
                return defer.promise;
            };

            vm.saveRuleGroup = function (discardFlag) {
                var defer = $q.defer();
                disableUnsafeActions();
                vm.validateRuleGroupData().then(
                    function (result) {
                        if (vm.formsHaveErrors()) {
                            // tab cannot be closed because of form errors
                            defer.reject('form has errors');
                            var modalInstance = $uibModal.open({
                                animation: true,
                                templateUrl: 'modalRuleGroup.html',
                                controller: 'RuleGroupModalController as viewVm',
                                size: 'm',
                                backdrop: 'static'
                            });
                            modalInstance.forms = vm.forms;

                            modalInstance.result.then(
                                function () {}, //modal.close - not used
                                function () { //modal.dismiss - OK button
                                    var names = Object.getOwnPropertyNames(vm.forms);
                                    for (var i = 0; i < names.length; i++) {
                                        vm.dirtyAll(vm.forms[names[i]]);
                                    }
                                }
                            ).finally(
                                function () {
                                    enableUnsafeActions();
                                }
                            );
                        } else {
                            // rest call to save
                            createSource();
                            var uprom = vm.updateRuleGroup(vm.ruleGroup, discardFlag);
                            if (uprom && uprom !== null) {
                                uprom.then (
                                    function success (data) {
                                        defer.resolve(data);
                                    },
                                    function failure (reason) {
                                        //save failed,  so do not close the tab
                                        defer.reject(reason);
                                    }
                                );
                            } else {
                                // save failed, tab cannot be closed
                                defer.reject('update failed (promise is null)');
                            }
                        }
                    },
                    //page has errors
                    function (reason) {
                        enableUnsafeActions();
                        messageService.danger(resources.aml.getResource('ruleGroup.ruleGroupListReadErrorTxt'), null, -1);
                        //tab cannot be closed because of form errors
                        defer.reject(reason);
                    }
                );
                return defer.promise;
            };

            vm.deleteRuleGroup = function () {
                disableUnsafeActions();
                ruleGroupService.markRuleGroupAsDeleted(vm.ruleGroup.ruleGroupId).then(function (data) {
                        vm.ruleGroup.logicalDeleteInd = 'Y';
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {
                    enableUnsafeActions();
                });
            };

            vm.undeleteRuleGroup = function () {
                disableUnsafeActions();
                ruleGroupService.markRuleGroupAsUndeleted(vm.ruleGroup.ruleGroupId).then(function (data) {
                        vm.ruleGroup.logicalDeleteInd = 'N';
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('ruleGroup.ruleGroupMarkedUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {
                    enableUnsafeActions();
                });
            };

            vm.formsHaveErrors = function () {
                vm.isPrepDataSetValid();
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (Object.getOwnPropertyNames(vm.forms[name].$error).length > 0) {
                        console.log('Error in '+name);
                        console.log(vm.forms[name].$error);
                        return true;
                    }
                }
                return vm.byVariableError || vm.idError;
            };

            vm.formsAreDirty = function () {
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    if (vm.forms[names[i]].$dirty) {
                        return true;
                    }
                }
                return false;
            };


            vm.dirtyAll = function (formIn) {
                var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
                for (var i = 0; i < names.length; i++) {
                    formIn[names[i]].$dirty = true;
                }
            };

            vm.unbindSourceCodeForm = $scope.$watch('vm.sourceCodeForm', function () {
                vm.forms.sourceCodeForm = vm.sourceCodeForm;
                $scope.$watch('vm.forms.sourceCodeForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindSourceCodeForm();
            });

            vm.unbindExecForm = $scope.$watch('vm.execForm', function () {
                vm.forms.execForm = vm.execForm;
                $scope.$watch('vm.forms.execForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindExecForm();
            });

            vm.unbindBasicForm = $scope.$watch('vm.basicForm', function () {
                vm.forms.basicForm = vm.basicForm;
                $scope.$watch('vm.forms.basicForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindBasicForm();
            });

            vm.unbindAuditForm = $scope.$watch('vm.auditForm', function () {
                vm.forms.auditForm = vm.auditForm;
                $scope.$watch('vm.forms.auditForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindAuditForm();
            });


            vm.datasetSelected = function (datasetName) {
                if (angular.isDefined(datasetName) && datasetName !== '') {
                    if (vm.ruleGroup.ruleGroupInputDsName && vm.ruleGroup.ruleGroupInputDsName !== '') {
                        vm.loadDataset(vm.ruleGroup.ruleGroupInputDsName);
                    }
                }
            };

            vm.showDetails = true;
            vm.showRules = false;

            vm.toggleCollapsed = function (prefix) {
                if (prefix === 'bi') {
                    vm.bcollapsed = !vm.bcollapsed;
                } else if (prefix === 'pds') {
                    vm.hcollapsed = !vm.hcollapsed;
                } else if (prefix === 'code') {
                    vm.ccollapsed = !vm.ccollapsed;
                } else if (prefix === 'e') {
                   vm.ecollapsed = !vm.ecollapsed;
                }
            };

            vm.isPrepDataSetValid = function () {
                vm.byVariableError = false;
                //if (angular.isDefined(vm.ruleGroup) && angular.isDefined(vm.ruleGroup.ruleGroupType) && angular.isDefined(vm.ruleGroup.ruleGroupSaveToKcFlg)) {
                //    if (vm.ruleGroup.ruleGroupType === 'SAS Datastep' && vm.ruleGroup.ruleGroupSaveToKcFlg === 'Y') {
                //        vm.byVariableError = !ruleGroupService.isByVariableValid(vm.ruleGroup);
                //    }
                //}
                return !vm.byVariableError;
            };

            vm.hasSource = function () {
                return ruleGroupService.hasSource(vm.ruleGroup);
            };


            vm.isDatasetVisible = function () {
                if (angular.isDefined(vm.ruleGroup) && angular.isDefined(vm.ruleGroup.ruleGroupType)) {
                    return vm.ruleGroup.ruleGroupType === 'ATTR';
                }
                return true;
            };

            if ($stateParams.newRuleGroup && $stateParams.newRuleGroup === 'yes') {
                //create new ruleGroup
                vm.loading = false;
                vm.newRuleGroup = true;
                if (!$stateParams.ruleGroupId) {
                    //in case we came to the state with bookmarked URL
                    $stateParams.ruleGroupId = 'CDDRG_new_' + ruleGroupService.getNextId().toString();
                }
                if (!$stateParams.ruleGroupName) {
                    //in case we came to the state with bookmarked URL
                    $stateParams.ruleGroupName = $stateParams.ruleGroupId;
                }
                vm.ruleGroup = ruleGroupService.newRuleGroup($stateParams.ruleGroupName, $stateParams.ruleGroupId);
                createSource();
                vm.origRuleGroupName = vm.ruleGroup.ruleGroupName;
                updateTabTitle();
            } else {
                //assume existing ruleGroup
                vm.ruleGroupId = $stateParams.ruleGroupId;
                vm.newRuleGroup = false;
                vm.getRuleGroupData(vm.ruleGroupId);
            }
            // add a modal dialog to allow tab to be closed
            // return true to close tab, false to keep tab open
            tabsListService.registerCloseCallback(vm.state, function ruleGroupCallback() {
                var defer = $q.defer();
                if (vm.state.data.dirty === true) {
                    var modalInstance = $uibModal.open({
                        animation: true,
                        templateUrl: 'modalCloseRuleGroup.html',
                        controller: 'RuleGroupModalDispositionController as viewVm',
                        size: 'md',
                        backdrop: 'static'
                    });
                    modalInstance.ruleGroupName = vm.ruleGroup.ruleGroupName;

                    modalInstance.result.then(
                        function () {}, //modal closed - not used
                        function (buttonValue) { //modal dismissed
                            if (buttonValue === 'discard') {
                                defer.resolve(true);
                            } else if (buttonValue === 'save') {
                                var save = vm.saveRuleGroup(true);
                                if (save === null) {
                                    //page has errors, cannot be saved, so do not close the tab
                                    defer.resolve(false);
                                } else {
                                    save.then (
                                        function success () {
                                            defer.resolve(true);
                                            $state.go('ruleGroups');
                                        },
                                        function failure () {
                                            //save failed,  so do not close the tab
                                            defer.resolve(false);
                                        }
                                    );
                                }
                            } else if (buttonValue === 'cancel') {
                                defer.resolve(false);
                            }
                        }
                    );
                } else {
                    defer.resolve(true);
                    $state.go('ruleGroups');
                }
                return defer.promise;
            });

            datasetService.getDatasets('CDD').then(function (data) {
                    vm.datasets = data.items;
                    vm.datasetNames = [];
                    for (var i = 0; i < vm.datasets.length; i++) {
                        vm.datasetNames.push(vm.datasets[i].name);
                    }
                },
                function (error) {
                    logger.error('datasets Error: ');
                    logger.error(error);
                });

            vm.unbindDummy = $scope.$watch('vm.ruleGroupRulesModel', function (oldval, newval) {
                kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick);
                vm.unbindDummy();
            });
            vm.ruleGroupCategories = amlLov.getAsArray(amlLov.ruleGroupCategory);
            vm.typeCodes = amlLov.getAsArray(amlLov.ruleGroupType);
            vm.yesOrNo = amlLov.getAsArray(amlLov.yesOrNo);
        }
        init();
    }
})();

(function () {
    'use strict';

    RuleGroupModalDispositionController.$inject = ["$uibModalInstance", "resources", "$state"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupModalDispositionController', RuleGroupModalDispositionController);

    function RuleGroupModalDispositionController($uibModalInstance, resources, $state) {
        var viewVm = this;
        viewVm.resources = resources;
        viewVm.ruleGroupName = $uibModalInstance.ruleGroupName;

        viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
            $state.go('ruleGroups');
        };
        viewVm.save = function () {
            $uibModalInstance.dismiss('save');
        };
        viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

(function() {
    'use strict';

    RuleGroupModalController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.rule')
        .controller('RuleGroupModalController', RuleGroupModalController);

    function RuleGroupModalController($uibModalInstance, resources) {
        var viewVm = this;
        viewVm.resources = resources;

        viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
        };
    }
})();

/**
 * This controller sets an inactivity timer that will automatically
 * log out the user after a period of inactivity.  If the inactivity timeout is reached, a
 * dialog is displayed asking whether the user wishes to remain logged in; otherwise the user
 * is logged out automatically. Each user browser action is recorded and the timeout is extended
 * from the time of the last user action.
 *
 * Created by tommut on 1/22/2015.
 */
(function() {
    'use strict';
    AutoLogoutController.$inject = ["$document", "$interval", "$timeout", "$uibModal", "amlConstants", "usersService"];
    angular.module('aml.core').controller('AutoLogoutController', AutoLogoutController);

    function AutoLogoutController($document, $interval, $timeout, $uibModal, amlConstants, usersService) {
        var eventsThatKeepUserActive = 'keydown DOMMouseScroll mousewheel mousedown touchstart'; /*mousemove*/
        var defaultTimeout = null;
        var lastActivityTime; // time of the last recorded user activity

        activate();

        /////////

        function activate() {
            enableListeners(); //monitor events

            recordActivityTime();

            // using interval/cancel instead of timeout on startup as protractor
            // waits for all timeouts to complete, but ignores intervals
            var intervalCanceller = $interval(function() {
                //hide notification
                $interval.cancel(intervalCanceller);
                checkInactivityTimeout();
            }, getInactivityTimeoutDuration().asMilliseconds());
        }

        /**
         * If no timeout is specified in the config file, use a default value (20 minutes);
         * The very first time use a value of 5; this is because if this component is initialized before the
         * resource-service loads the aml.config.json properties, we need to set a default value, which will be corrected
         * and set from the property the next time getIdleEndTimeUntil gets called.
         * @returns {*}
         */
        function getDefaultTimeout() {
            if ( !defaultTimeout ) {
                defaultTimeout = 20;
                return 5;  // return initial timeout
            }
            else {
                return defaultTimeout;
            }
        }


        function getInactivityTimeoutDuration() {
            var idleTimeoutInMin =  amlConstants.config.logout ?
                amlConstants.config.logout.automaticInactivityTimeout : getDefaultTimeout();
            return moment.duration( {minutes: idleTimeoutInMin });
        }

        function enableListeners() {
            $document.find('body').on(eventsThatKeepUserActive, recordActivityTime); //monitor
        }

        function turnOffListeners() {
            $document.find('body').off(eventsThatKeepUserActive); //un-monitor
        }

        function checkInactivityTimeout() {
            // check if this is proper time for inactivity... if so fire the dialog; otherwise set timeout for new time
            var current = moment();
            var timeoutTime = moment(lastActivityTime).add( getInactivityTimeoutDuration() );

            if ( current.isSame( timeoutTime ) || current.isAfter(timeoutTime) ) {
                // we will un-monitor events when we open the modal dialog, as we don't want to capture
                // events and continue to fire off events while we're inside of the modal
                turnOffListeners();

                // open filter modal
                var modalInstance = $uibModal.open({
                    templateUrl: 'core/autoLogout/logoutKeepAliveDialog.html',
                    controller: 'LogoutKeepAliveDialogController as vm',
                    size: 'med', animation: false, backdrop: 'static'
                });

                // get resulting filters and set on the grid
                modalInstance.result.then(function dialogOkayed() {
                    //monitor events
                    enableListeners();

                    // extend timeout
                    recordActivityTime();

                    $timeout( checkInactivityTimeout, getInactivityTimeoutDuration().asMilliseconds());
                }, function dialogCanceled( result ) {
                    // modal dialog canceled/dismissed
                    turnOffListeners(); //un-monitor

                    // logoff current user
                    if (result.timedOut) {
                        // if screen timed out without user interaction, we will go to the 'user session timed out'
                        // screen
                        usersService.logoffCurrentUserTimedOut();
                    }
                    else {
                        // user initiated logoff
                        usersService.logoffCurrentUser();
                    }
                });
            }
            else {
                var diff = timeoutTime.diff( current );
                // set timeout for the time until the scheduled inactivity check (minus the time since last activity)
                $timeout( checkInactivityTimeout, diff);
            }
        }

        function recordActivityTime() {
            lastActivityTime = moment();
        }
    }
})();

/**
 * Created by tommut on 1/22/2015.
 */
(function() {
    'use strict';
    LogoutKeepAliveDialogController.$inject = ["$uibModalInstance", "resources", "$interval", "amlConstants"];
    angular.module('aml.core').controller('LogoutKeepAliveDialogController', LogoutKeepAliveDialogController);

    function LogoutKeepAliveDialogController($uibModalInstance, resources, $interval, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.extend = extend;
        vm.logout = logout;
        vm.timeoutSeconds = amlConstants.config.logout.keepAliveDialogCountdownTime;  // defaults to 300 seconds
        var countDownInterval;
        activate();

        //

        function activate() {
            // we'll start a countdown timer (displayed on the page) which will auto-logout if the
            // user doesn't act
            countDownInterval = $interval( function() {
                vm.timeoutSeconds--;

                // if user doesn't intervene before countdown finishes, then we'll auto-logout
                if (vm.timeoutSeconds <= 0) {
                    logout(true);
                }
            }, 1000 );
        }

        function extend() {
            $interval.cancel(countDownInterval);
            $uibModalInstance.close();
        }

        function logout(timedOut) {
            $interval.cancel(countDownInterval);
            $uibModalInstance.dismiss( { timedOut: timedOut });
        }
    }
})();

/**
 * Created by tomutd on 4/10/2015.
 */
(function() {
    'use strict';
    NoAccessController.$inject = ["resources", "$stateParams", "messageService"];
    angular.module('aml.admin').controller('NoAccessController', NoAccessController);

    function NoAccessController(resources, $stateParams, messageService) {
        var vm = this;
        vm.resources = resources;

        vm.invalidUrl = $stateParams.invalidUrl;
        vm.message = $stateParams.message;

        // clear any open alerts, as the invalid access state page provides
        // the details already
        messageService.closeAllAlerts();

    }
})();

/**
 * handle redirecting to the first visible area that the user has access to when navigating to the
 * root 'welcome' state.
 */
(function () {
    'use strict';
    AmlRedirectController.$inject = ["areaNavigationService"];
    angular.module('aml.core').controller('AmlRedirectController', AmlRedirectController);

    function AmlRedirectController(areaNavigationService) {
        activate();

        //////

        function activate() {
           areaNavigationService.redirectToFirstVisibleArea();
        }
    }
})();

/**
 * handle the review triage actions
 */
(function (){
    'use strict';
    CddReviewDetailsController.$inject = ["amlLov", "resources", "$stateParams", "$state", "$scope", "usersService", "amlConstants", "messageService", "$uibModal"];
    angular.module('cdd.reviews')
        .controller('CddReviewDetailsController', CddReviewDetailsController);

    function CddReviewDetailsController(amlLov, resources, $stateParams, $state, $scope, usersService, amlConstants, messageService, $uibModal) {
        var vm = this;
        usersService.setCddReviewsVm(vm);

//console.log("CddReviewDetailsController!!!");
//console.log(vm);
        var currentUser = usersService.getCurrentUserId();
//console.log("currentUser : " + currentUser);
//console.log(vm.reviewDetail.initialRiskRating);

//usersService.getUsersForGroup

        vm.state = $state.$current;
        vm.isNewReview = $stateParams.newEntityFlag;
        vm.resources = resources;
        vm.lastValidStatus = null;
        vm.statusList = amlLov.getAsArray(amlLov.reviewStatus);
        vm.finalDispositionList = amlLov.getAsArray(amlLov.finalDisposition);
        vm.scoreClassificationList  = amlLov.getAsArray(amlLov.scoreClassification);
        vm.userCanClose = canUserClose();
        vm.isIndividual = true;
        vm.transStatus = null;
        
        //capture initial value for status code and re-check if user can close
        $scope.$watch('vm.reviewDetail.statusCode', function(newValue, oldValue) {
//console.log("@@@@ vm.reviewDetail.statusCode");
            if (!vm.lastValidStatus && vm.reviewDetail) {
                vm.lastValidStatus = vm.reviewDetail.statusCode;
            }
            vm.userCanClose = canUserClose();
        });

        $scope.$watch('vm.currentCustomer', function (newValue, oldValue) {
//console.log("@@@vm.currentCustomer");
            if (newValue) {
                vm.isIndividual = newValue.partyTypeDesc === 'INDIVIDUAL';
            }
        });
        function canUserClose () {
//console.log("@@@canUserClose");
            if (vm.reviewDetail) {
                return  usersService.currentUserHasCapability(amlConstants.capabilities.closeCDDReview) && currentUser === vm.reviewDetail.ownerUserLongId ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.closeAllCDDReviews);
            }
            return false;
        }
        vm.statusChanged = function statusChanged () {
        	
					var sp_URI2 = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_CDD_User_Group(StoredProcess)";
					var param2={
							_program     : sp_URI2,
							_result     : "STREAMFRAGMENT"
						}
						$.ajax({
							url: "/SASStoredProcess/do?",
							data: param2,
							cache:false,
							dataType: 'json',
							async: true,
							beforeSend: function() {
								//$("#progressIndicatorWIP").show();
							},
							success : function(data2){           
								console.log("STP Success.....CddReviewDetailsController_Compliance_CDD_User_Group");
								//console.log("JSON.stringify(data) : " + JSON.stringify(data));
								console.log(data2);
								vm.grpLevel = data2[0].grp_level;
								
								
								
					
//console.log("-----------------------00002");
			//console.log(vm);
			
								// level 2    H     
								if(parseInt(vm.grpLevel) == 2 && vm.reviewDetail.initialRiskRating == 'H' && vm.reviewDetail.statusCode === 'C'){
									var modalInstance = $uibModal.open({
			                animation: true,
			                templateUrl: 'modalCddReviewLevelCheck.html',
			                controller: 'CddReviewModalController as viewVm',
			                size: 'm',
			                backdrop: 'static'
			            });
			            
									vm.reviewDetail.statusCode = 'O';
								}else{
				          if (vm.reviewDetail && vm.reviewDetail.statusCode !== 'C') {
				              // reset disposition values for open review
				              vm.reviewDetail.finalDispositionCode = '';
				              vm.reviewDetail.ratingOverride = '';
				          }
				/*
				console.log("vm.forms.grpLevel : " + vm.grpLevel);
				console.log("vm.reviewDetail.initialRiskRating : " + vm.reviewDetail.initialRiskRating);
				*/
				          if(vm.reviewDetail.statusCode === 'C'){
				              //if user cannot close rollback status change
				              if (!vm.userCanClose) {
				                  if (vm.lastValidStatus) {
				                      vm.reviewDetail.statusCode = vm.lastValidStatus;
				                  } else {
				                      vm.reviewDetail.statusCode = 'O';
				                  }
				                  messageService.danger(vm.resources.aml.getResource('reviews.notAuthorizedToClose'),null, 4000);
				              }
				          }
				          vm.lastValidStatus = vm.reviewDetail.statusCode;
				          vm.validator.validateReview();
				          
				          if(vm.reviewDetail.initialRiskRating == "H"){
				          	if(parseInt(vm.grpLevel) == 3 && parseInt(usersService.getCommentsVm().commentsOptions.commentsCount) > 0){
				          		//console.log("show!!");
					          	$("#tranStatusShow").show();
					          }else{
					          	//console.log("hide!!");
					          	$("#tranStatusShow").hide();
					          }
				          }else{
					          if(parseInt(usersService.getCommentsVm().commentsOptions.commentsCount) > 0){
					          	//console.log("show2!!");
					          	$("#tranStatusShow").show();
					          }else{
					          	//console.log("hide2!!");
					          	$("#tranStatusShow").hide();
					          }
					        }
				      	}
								
								
								
							},
							error : function(request,status, e){
								//console.log("code 001 : " + request.status);
								console.log("message : " + request.responseText);
								console.log("Error : " + e);
							}
						});

        };

        var unbindDispositionForm = $scope.$watch('vm.dispositionForm', function () {
            vm.forms.dispositionForm = vm.dispositionForm;
            $scope.$watch('vm.forms.dispositionForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindDispositionForm();
        });

    }
})();

/**
 * handle the review triage actions
 */
(function () {

    'use strict';

    CddReviewDetailsView.$inject = ["amlLov", "$stateParams", "reviewsService", "usersService", "amlConstants", "resources", "reviewTriageService", "tabsListService", "customerService", "$q", "$uibModal", "$state", "messageService", "$rootScope", "reviewsListDataMessagingService", "$scope", "entityService", "dataMessagingServiceFactory", "ruleGroupService"];
    angular.module('cdd.reviews')
        .controller('cddReviewDetailsView', CddReviewDetailsView);
//console.log("CddReviewDetailsView !!!");
//console.log($(window));
    /* jshint maxparams: 18 */
    function CddReviewDetailsView(amlLov, $stateParams, reviewsService, usersService, amlConstants, resources, reviewTriageService,
                                  tabsListService, customerService, $q, $uibModal, $state, messageService, $rootScope,
                                  reviewsListDataMessagingService, $scope, entityService, dataMessagingServiceFactory, ruleGroupService) {

        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        vm.state = $state.$current;
        vm.isNewReview = $stateParams.newEntityFlag;
        vm.resources = resources;
        vm.eddDetails = [];
        vm.readOnly = isReviewReadOnly();
        vm.saveIsRunning = false;
        vm.forms = {};

        vm.commentsOptions = {};
        vm.cddReviewKey = $stateParams.reviewKey;
        vm.eddStepList  = amlLov.getAsArray(amlLov.eddStep);
        vm.validator = {};
        vm.userCanEdit = false; //set after review is loaded

        var currentUserId = usersService.getCurrentUserId();

        vm.isReviewValid = function () {
            vm.validator.eddStepsError = !vm.areEddStepsValid();
            return !vm.formsHaveErrors() && !vm.validator.eddStepsError;
        };

        vm.validator.eddStepsError = false;
        vm.validator.validateReview = vm.isReviewValid;

        vm.entityId = entityService.normalizeEntityId( vm.entityId, null, null, null );
        dataMessagingService.setEntityId( vm.entityId );

        function noDollarSign (aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        vm.dirtyAll = function (formIn) {
            var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
            for (var i = 0; i < names.length; i++) {
                formIn[names[i]].$dirty = true;
            }
        };

        vm.formsHaveErrors = function () {
            var names = Object.getOwnPropertyNames(vm.forms);
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                if (Object.getOwnPropertyNames(vm.forms[name].$error).length > 0) {
                    return true;
                }
            }
            return false;
        };
        
        function fnMsg(){
        	return $uibModal.open({
                    animation: true,
                    templateUrl: 'modalCddReview.html',
                    controller: 'CddReviewModalController as viewVm',
                    size: 'm',
                    backdrop: 'static'
                });
        }
        
        function fnMsgNoti(){
        	return $uibModal.open({
                    animation: true,
                    templateUrl: 'modalCddReviewNoti.html',
                    controller: 'CddReviewModalController as viewVm',
                    size: 'm',
                    backdrop: 'static'
                });
        }

        vm.areEddStepsValid = function () {
            if (vm.reviewView.statusCode === 'C') {
                //if user is closing the review then all required edd steps must be completed
                for (var i = 0; i < vm.eddDetails.length; i++) {
                    if (vm.eddDetails[i].stepRequired === 'Y' && (!vm.eddDetails[i].stepCompleted || vm.eddDetails[i].stepCompleted === 'N')) {
                        return false;
                    }
                }
            }
            return true;
        };

        vm.saveReview =  function saveReview(keepOpen) {
            //if keepOpen then page must stay open after save, if false then close the page (in case of Save/Discard/Cancel dialog)
            var defer = $q.defer();
						$(".has-error").removeClass();
//console.log(vm);
//console.log("vm.reviewView.statusCode : " + vm.reviewView.statusCode);
//console.log("vm.reviewView.initialRiskRating : " + vm.reviewView.initialRiskRating);
//console.log("vm.grpLevel : " + vm.grpLevel);
//console.log("vm.commentsOptions.commentsCount : " + vm.commentsOptions.commentsCount);
//console.log("vm.reviewView.transStatus : " + vm.reviewView.transStatus);



            if (!vm.isReviewValid()) {
//console.log("case 001");
                defer.reject('form has errors');
                var modalInstance = fnMsg();
                modalInstance.forms = vm.forms;

                modalInstance.result.then(function () {
                }, function () {
                    var names = Object.getOwnPropertyNames(vm.forms);
                    for (var i = 0; i < names.length; i++) {
                        vm.dirtyAll(vm.forms[names[i]]);
                    }
                });

            } else {
            	
							var sp_URI1 = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_CDD_User_Group(StoredProcess)";
							var param1={
									_program     : sp_URI1,
									_result     : "STREAMFRAGMENT"
								}
								$.ajax({
									url: "/SASStoredProcess/do?",
									data: param1,
									cache:false,
									dataType: 'json',
									async: true,
									beforeSend: function() {
										//$("#progressIndicatorWIP").show();
									},
									error : function(request,status, e){
										console.log("code 002 : " + request.status);
										console.log("message : " + request.responseText);
										console.log("Error : " + e);
									},
									success : function(data1){           
										console.log("STP Success.....CddReviewDetailsView");
										//console.log("JSON.stringify(data) : " + JSON.stringify(data));
										console.log(data1);
										vm.grpLevel = data1[0].grp_level;
										
										
										
										
										var str = vm.reviewView.transStatus;
										
			//if(vm.reviewView.transStatus == undefined){	console.log("11111111111 : " + str);}
			//if(vm.reviewView.transStatus == 'undefined'){	console.log("22222222222 : " + str);}
			//if(str == undefined){	console.log("11111111111 : " + str);}
			//if(str == 'undefined'){	console.log("22222222222 : " + str);}
			
										
			//console.log($("#tranStatusShow").css("display"));
			//console.log("str : " + str);
			
			//console.log(vm);
			//console.log(dataMessagingService);
			
			//console.log(vm.commentsOptions.commentsCount);
										if(vm.reviewView.statusCode === 'C' && parseInt(vm.commentsOptions.commentsCount) == 0){	//  -  /  0  
			//console.log("case 002");
											defer.reject('form has errors');
			                var modalInstance = $uibModal.open({
			                    animation: true,
			                    templateUrl: 'modalCddReviewNote.html',
			                    controller: 'CddReviewModalController as viewVm',
			                    size: 'm',
			                    backdrop: 'static'
			                });
			                
										}else if(vm.reviewView.initialRiskRating == "H" && $("#eddChecklist1").val() == ""){	//  -  / eddchecklist1 
			//console.log("case 003");
											defer.reject('form has errors');
			                var modalInstance = fnMsgNoti();
											$("#eddChecklist1").closest("div").addClass("has-error");
										}else if(vm.reviewView.initialRiskRating == "H" && $("#eddChecklist2").val() == ""){	//  -  / eddchecklist2 
			//console.log("case 004");
											defer.reject('form has errors');
			                var modalInstance = fnMsgNoti();
											$("#eddChecklist2").closest("div").addClass("has-error");
										}else if(vm.reviewView.initialRiskRating == "H" && $("#eddChecklist3").val() == ""){	//  -  / eddchecklist3 
			//console.log("case 004");
											defer.reject('form has errors');
			                var modalInstance = fnMsgNoti();
											$("#eddChecklist3").closest("div").addClass("has-error");
										}else if(vm.reviewView.initialRiskRating == "H" && $("#eddChecklist4").val() == ""){	//  -  / eddchecklist4 
			//console.log("case 005");
											defer.reject('form has errors');
			                var modalInstance = fnMsgNoti();
											$("#eddChecklist4").closest("div").addClass("has-error");
										}else if(vm.reviewView.statusCode === 'C' 
														&& vm.reviewView.initialRiskRating == "H" 
														&& parseInt(vm.grpLevel) == 3
														&& vm.reviewView.transStatus != 'AC' 
														&& vm.reviewView.transStatus != 'NC'){	// - /  -  /   3 / Transaction Status   
			//console.log("case 006");
											defer.reject('form has errors');
			                var modalInstance = fnMsg();                
											$("#tranStatusShow div").addClass("has-error");
										}else if(vm.reviewView.statusCode === 'C' 
														&& vm.reviewView.initialRiskRating != "H" 
														&& parseInt(vm.grpLevel) == 3
														&& vm.reviewView.transStatus != 'AC' 
														&& vm.reviewView.transStatus != 'NC'){	// - /  -    /   3 / Transaction Status   
			//console.log("case 007");
											defer.reject('form has errors');
			                var modalInstance = fnMsg();
											$("#tranStatusShow div").addClass("has-error");
										}else if(vm.reviewView.statusCode === 'C' 
														&& vm.reviewView.initialRiskRating != "H" 
														&& parseInt(vm.grpLevel) != 3
														&& vm.reviewView.transStatus != 'AC' 
														&& vm.reviewView.transStatus != 'NC'){	// - /  -    /   3  / Transaction Status   
			//console.log("case 008");
											defer.reject('form has errors');
			                var modalInstance = fnMsg();
											$("#tranStatusShow div").addClass("has-error");
										}else{
											
			
			//console.log("case 009");
			
			                vm.saveIsRunning = true;
			                setUIFlags();
			                vm.state.data.dirty = false;
			                var uprom;
			                if (vm.isNewReview) {
			                    uprom = reviewsService.createReview(vm.reviewView);
			                } else {
			                    uprom = reviewsService.saveReview(vm.reviewView);
			                }
			                
			                var transStatus = vm.reviewView.transStatus;
			                delete vm.reviewView.transStatus;
			
			//console.log("JSON.stringify(vm.reviewView) : " + JSON.stringify(vm.reviewView));
			//console.log("##########################");
			
			                if (uprom && uprom !== null) {
			                    uprom.then(
			                        function success(data) {
			                            vm.reviewView = data;
			                            vm.saveIsRunning = false;
			                            setUIFlags();
			                            defer.resolve(data);
			                            messageService.success(
			                                resources.aml.getResource('admin.cddReview.reviewSavedTxt',
			                                    {'key': vm.reviewView.key}), null, 4000);
			
			                            if (vm.reviewView.statusCode === 'C') {
			                                //update review list if this review it is on the current page
			                                reviewsListDataMessagingService.reviewsStatusChanged([vm.reviewView.key], vm.reviewView.statusCode);
			
																			var sp_URI = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_CDD_Accept(StoredProcess)";
																			var param={
																					_program     : sp_URI,
																					_result     : "STREAMFRAGMENT",
																					_action     : "background",
																					review_key	: vm.reviewView.key,
																					trans_status: transStatus
																				}
																				$.ajax({
																					url: "/SASStoredProcess/do?",
																					data: param,
																					cache:false,
																					dataType: 'html',
																					async: true,
																					beforeSend: function() {
																						//$("#progressIndicatorWIP").show();
																					},
																					success : function(data){           
																						console.log("STP Success.....");
																						console.log("JSON.stringify(data) : " + JSON.stringify(data));
																						$("#tranStatusShow div").removeClass("has-error");
																						$("select[name=transactionStatus]").val(str);
																					},
																					error : function(request,status, e){
																						console.log("code : " + request.status);
																						console.log("message : " + request.responseText);
																						console.log("Error : " + e);
																					}
																				});
			                            }
		
																			var sp_URI = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_CDD_EDD_Update(StoredProcess)";
																			var param={
																					_program     : sp_URI,
																					//_result     : "STREAMFRAGMENT",
																					//_action     : "background",
																					review_key	: vm.reviewView.key,
																					eddChecklist1: $("#eddChecklist1").val(),
																					eddChecklist2: $("#eddChecklist2").val(),
																					eddChecklist3: $("#eddChecklist3").val(),
																					eddChecklist4: $("#eddChecklist4").val()
																				}
																				$.ajax({
																					url: "/SASStoredProcess/do?",
																					data: param,
																					cache:false,
																					dataType: 'json',
																					async: true,
																					beforeSend: function() {
																						//$("#progressIndicatorWIP").show();
																					},
																					success : function(data){           
																						console.log("STP Success.....");
																						console.log("JSON.stringify(data) : " + JSON.stringify(data));
																						$("div").removeClass("has-error");
																					},
																					error : function(request,status, e){
																						console.log("code : " + request.status);
																						console.log("message : " + request.responseText);
																						console.log("Error : " + e);
																					}
																				});
			                            
			                            if (keepOpen && vm.isNewReview) {
			//console.log("00001");
			                                //if new review then reload the page to use assigned review key
			                                tabsListService.closeTab(tabsListService.getTabForCurrentState(), false).then(
			                                    function (data) {
			                                        $state.go('cddReviewDetails', {
			                                            reviewKey: vm.reviewView.key,
			                                            //newEntityFlag: false,
			                                            name: vm.reviewView.primaryEntityNumber,
			                                            partyName: '',
			                                            partyNumber: vm.reviewView.primaryEntityNumber,
			                                            partyLevel: vm.reviewView.primaryEntityLevelCode
			                                        });
			                                    }
			                                );
			                            }
			                        },
			                        function failure(reason) {
			//console.log("00002");
			                            //save failed,  so do not close the tab
			                            vm.saveIsRunning = false;
			                            setUIFlags();
			                            defer.reject(reason);
			                        }
			                    );
			                } else {
			//console.log("00003");
			                    // save failed, tab cannot be closed
			                    vm.saveIsRunning = false;
			                    setUIFlags();
			                    defer.reject('update failed (promise is null)');
			                }
			
			        			}     
										
										
										
										
									},
								});

  
        			
        			
        			
        			
        			
        			
        			
        			
        			
        			
        			
        			
        			
        			 
            }
            return defer.promise;
        };



        vm.openRouteReviewDialog = function openRouteReviewDialog() {
            reviewTriageService.openRouteReviewsDialog(
                [vm.reviewView.key],
                vm.reviewView.key,
                vm.reviewView.ownerUserLongId,
                vm.reviewView.queueCode,
                setReviewOwner
            ).then(
                function () {}
            );
        };

        vm.checkoutReview = function checkoutReview() {
            reviewTriageService.checkoutReviews([vm.reviewView.key], vm.reviewView.key, setReviewOwner);
        };

        vm.checkinReview = function checkinReview() {
            reviewTriageService.checkinReviews([vm.reviewView.key], vm.reviewView.key, setReviewOwner);
        };

        function setButtonsVisibility () {
            if (vm.readOnly) {
                vm.userCanRoute = false;
                vm.userCanCheckin = false;
                vm.userCanCheckout = false;
            } else {
                vm.userCanRoute =!vm.isNewReview &&
                                  ( ( currentUserId === vm.reviewView.ownerUserLongId && usersService.currentUserHasCapability(amlConstants.capabilities.routeCDDReview) ) ||
                                  usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCDDReviews) );
                vm.userCanCheckin = !vm.isNewReview &&
                                    ( currentUserId === vm.reviewView.ownerUserLongId && usersService.currentUserHasCapability(amlConstants.capabilities.checkinCDDReview) );
                vm.userCanCheckout = !vm.isNewReview && !vm.reviewView.ownerUserLongId && usersService.currentUserHasCapability(amlConstants.capabilities.checkoutCDDReview);
            }
        }

        function setReviewOwner(reviewNumbers, owner) {
            vm.reviewView.ownerUserLongId = owner;
            setButtonsVisibility ();
        }


        // add a modal dialog to allow pill to be closed
        // return true to close...false to keep pill
        tabsListService.registerCloseCallback(vm.state, function cddReviewCallback() {
            var defer = $q.defer();
            if (vm.state.data.dirty === true) {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'modalCloseCddReview.html',
                    controller: 'CddReviewModalDispositionController as viewVm',
                    size: 'sm',
                    backdrop: 'static'
                });
                modalInstance.key = vm.reviewView.key;
                modalInstance.readOnly = vm.readOnly;

                modalInstance.result.then(
                    function () {}, //modal close - not use
                    function (buttonValue) { //modal dismiss
                        if (buttonValue === 'discard') {
                            defer.resolve(true);
                            $state.go('cddreviewsList');
                        } else if (buttonValue === 'save') {
                            var save = vm.saveReview(false);// call save method on cddReview, close tab
                            if (save === null) {
                                //page has errors, cannot be saved, so do not close the tab
                                defer.resolve(false);
                            } else {
                                save.then (
                                    function success () {
                                        defer.resolve(true);
                                        $state.go('cddreviewsList');
                                    },
                                    function failure () {
                                        //save failed,  so do not close the tab
                                        defer.resolve(false);
                                    }
                                );
                            }
                        } else if (buttonValue === 'cancel') {
                            defer.resolve(false);
                        }
                    });
            } else {
                defer.resolve(true);
                $state.go('cddreviewsList');
            }
            return defer.promise;
        });

        function isReviewReadOnly () {
            return vm.reviewView && vm.reviewView.statusCode === 'C' || vm.saveIsRunning || !vm.userCanEdit;
        }

        function setUIFlags() {
            vm.readOnly = isReviewReadOnly();
            setButtonsVisibility ();
        }

        function activate() {
//console.log("active Call 7499!!");
            if ($stateParams.reviewKey.startsWith('new_') && !$stateParams.partyNumber) {
                //browser refresh on new review page - ERROR condition, should be prevented
                // in app.config.js by $stateChangeStart handler
                tabsListService.closeTab(tabsListService.getTabForCurrentState(), false).then(
                    function (data) {
                        $state.go('cddreviewsList');
                    }
                );
                return;
            }
            if (vm.isNewReview) {
                vm.reviewView = reviewsService.createNewReview($stateParams.partyNumber, $stateParams.partyLevel, 'H', null, currentUserId, vm.eddStepList);
                vm.eddDetails = vm.reviewView.eddReviews;
                vm.state.data.dirty = true; //new review is not saved yet, mark as dirty
                vm.userCanEdit = (currentUserId === vm.reviewView.ownerUserLongId && usersService.currentUserHasCapability(amlConstants.capabilities.editCDDReview)) ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.editCDDReviewsAll);
                vm.entityId = entityService.normalizeEntityId( vm.entityId, 'PTY', $stateParams.partyNumber, null );
                dataMessagingService.setEntityId( vm.entityId );
                setUIFlags();
            } else {
                reviewsService.getReview(vm.cddReviewKey).then(function (data) {
                	
//console.log("DATA : " + JSON.stringify(data));
                    vm.reviewView = data;
                    vm.eddDetails = vm.reviewView.eddReviews;
                    vm.userCanEdit = (currentUserId === vm.reviewView.ownerUserLongId && usersService.currentUserHasCapability(amlConstants.capabilities.editCDDReview)) ||
                                      usersService.currentUserHasCapability(amlConstants.capabilities.editCDDReviewsAll);
                    vm.entityId = entityService.normalizeEntityId( vm.entityId, 'PTY', vm.reviewView.primaryEntityNumber, null );
                    dataMessagingService.setEntityId( vm.entityId );
                    setUIFlags();

                    if (vm.reviewView.primaryEntityNumber) {
                        customerService.getCustomer(vm.reviewView.primaryEntityNumber).then(
                            function (data) {
                                vm.currentCustomer = data;
                            }
                        );
                    }
                    
//console.log("vm.reviewView.initialRiskRating: " + vm.reviewView.initialRiskRating);

//console.log("Compliance_CDD_EDD_Info(StoredProcess) START");
										var sp_URI3 = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_CDD_EDD_Info(StoredProcess)";
										var param3={
												_program     : sp_URI3,
												//_result     : "STREAMFRAGMENT",
												//_action     : "background",
												review_key	: vm.reviewView.key
											}
											$.ajax({
												url: "/SASStoredProcess/do?",
												data: param3,
												cache:false,
												dataType: 'json',
												async: true,
												beforeSend: function() {
													//$("#progressIndicatorWIP").show();
												},
												success : function(data3){     
													console.log("STP Success.....Compliance_CDD_EDD_Info");
													console.log(data3);
													$("#eddChecklist1").val(data3[0].EDD_CHECKLIST1);
													$("#eddChecklist2").val(data3[0].EDD_CHECKLIST2);
													$("#eddChecklist3").val(data3[0].EDD_CHECKLIST3);
													$("#eddChecklist4").val(data3[0].EDD_CHECKLIST4);
												},
												error : function(request,status, e){
													console.log("code : " + request.status);
													console.log("message : " + request.responseText);
													console.log("Error : " + e);
												}
											});
//console.log("Compliance_CDD_EDD_Info(StoredProcess) END");
                });
            }
        }
        activate();

    }
})();

(function() {
    'use strict';

    CddReviewModalDispositionController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.reviews')
        .controller('CddReviewModalDispositionController', CddReviewModalDispositionController);

    function CddReviewModalDispositionController($uibModalInstance, resources) {
        var viewVm = this;
        viewVm.resources = resources;
        viewVm.key = $uibModalInstance.key;
        viewVm.readOnly = $uibModalInstance.readOnly;

        viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
        };
        viewVm.save = function () {
            $uibModalInstance.dismiss('save');
        };
        viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();


(function() {
    'use strict';

    CddReviewModalController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('cdd.reviews')
        .controller('CddReviewModalController', CddReviewModalController);

    function CddReviewModalController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;

        viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
        };
    }
})();

/**
 * Associated parties list
 */
(function() {
    'use strict';
    CustomerListDirectiveController.$inject = ["$scope", "$state", "resources", "kendoGridRendererService", "entityService", "customerService", "amlConstants", "_", "amlLov", "scenarioService", "segmentNameFilter"];
    angular.module('aml.customer.details').controller(
        'CustomerListDirectiveController', CustomerListDirectiveController);

    /* jshint maxparams: 13*/
    function CustomerListDirectiveController($scope, $state, resources, kendoGridRendererService,
                                             entityService, customerService, amlConstants, _, amlLov,
                                             scenarioService, segmentNameFilter) {
        var vm = this;
        vm.resources = resources;
        // grid options
        vm.selectedRelatedNumber = null;
        vm.selectedRelType = null;
        vm.selectedParentNumber = null;
        vm.associateAttributesGrid = {};
        var associationAttributeLookupTables = [];

        if (amlConstants.config && amlConstants.config.associationAttributeLookupTables) {
            associationAttributeLookupTables = amlConstants.config.associationAttributeLookupTables.split(' ');
        }


        var yesNoRenderingFilter = kendoGridRendererService.enum('externalPartyInd', 'yesOrNo', true);
        var associationTypeFilter = kendoGridRendererService.enum('type', 'associationType', true);
        var associationAttrCodeFilter = kendoGridRendererService.enum('attributeTypeCode', 'associationAttrCode', true);
        var partyTypeFilter = kendoGridRendererService.enum('partyTypeDesc', 'partyType', true);
        var riskClassificationFilter = kendoGridRendererService.enum('cddRiskClassification', 'scoreClassification', true);
        var attributeCharValueFilter = createCharValueEnum('attributeCharValue', associationAttributeLookupTables);

        vm.attrGrid = {};

        vm.attrGridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                selectable: false,
                filterable: true,
                sortable: true
            }
        );
        vm.attrGridColumns = [
            {
                field: 'relatedPartyNumber', type:'string',
                title: vm.resources.aml.customer.relatedPartyNumber,
                width: '15%'
            },
            {
                field: 'attributeTypeCode',
                title: vm.resources.aml.customer.attributeTypeCode,
                width: '16%',
                template: associationAttrCodeFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(associationAttrCodeFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('associationAttrCode')

            },
            {
                field: 'attributeNumValue', type:'number',
                title: vm.resources.aml.customer.attributeNumValue,
                width: '15%'
            },
            {
                field: 'attributeCharValue', type:'string',
                template: attributeCharValueFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(associationAttrCodeFilter) },
                title: vm.resources.aml.customer.attributeCharValue,
                width: '15%'
            },
            {
                field: 'attributeDateValue', type:'date', templateType: 'longDateMediumTime',
                title: vm.resources.aml.customer.attributeDateValue,
                width: '10%'
            }
        ];

///////
        vm.customersGrid = {};

        vm.customerGridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                selectable: 'row',
                filterable: true,
                sortable: true
            }
        );

        vm.customerGridColumns = [
            {
                field: 'parentPartyNumber', type:'string',
                template: '<a href="\\#/customers/{{dataItem.parentPartyNumber}}">{{dataItem.parentPartyNumber}}</a>',
                title: vm.resources.aml.reviews.entityNumberHeaderTitle,
                width: '10%'
            },
            {
                field: 'partyName', type:'string', templateType: 'titleCase',
                title: vm.resources.aml.reviews.entityNameHeaderTitle,
                width: '15%'
            },
            {
                field: 'number', type:'string',
                template: '<a href="\\#/customers/{{dataItem.number}}">{{dataItem.number}}</a>',
                title: vm.resources.aml.customer.relatedPartyNumber,
                width: '15%'
            },
            {
                field: 'name', type:'string', templateType: 'titleCase',
                title: vm.resources.aml.reviews.relatedEntityNameHeaderTitle,
                width: '15%'
            },
            {
                field: 'partyTypeDesc', type:'string',
                title: vm.resources.aml.customersummary.type,
                width: '15%',
                template: partyTypeFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(partyTypeFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('partyType')

            },
            {
                field: 'type', type:'string',
                title: vm.resources.aml.customer.relationshipType,
                width: '15%',
                template: associationTypeFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(associationTypeFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('associationType')
            },
            {
                field: 'externalPartyInd', type:'string',
                title: vm.resources.aml.customer.externalPartyInd,
                width: '8%',
                template: yesNoRenderingFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(yesNoRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'entitySegmentId', type: 'string',
                title: vm.resources.aml.segment.segmentLabel,
                width: '8%',
                template: segmentNameFilter,
                sortable: {compare: kendoGridRendererService.getFilterSortFunction(segmentNameFilter)},
                filterable: kendoGridRendererService.getCheckboxFilterForValues(
                    scenarioService.getSegments('nondeleted'),
                    true,
                    'segmentName',
                    'entitySegmentId',
                    'localizedSegmentName'
                )
            },
            {
                field: 'cddRiskClassification', type:'string',
                title: vm.resources.aml.customer.risk,
                width: '10%',
                template: riskClassificationFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(riskClassificationFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification')
            }
        ];

        vm.loadCustomerGrid = function(gridCallback) {
            if (vm.customerList) {
                gridCallback.success(vm.customerList);
            }
            else {
                gridCallback.success([]);
            }
        };

        vm.loadAttrGrid = function(gridCallback) {
            if (vm.selectedParentNumber) {
                customerService.getAssociatedCustomerAttributes(vm.selectedParentNumber,vm.selectedRelatedNumber, vm.selectedRelType).then(
                    function success (data) {
                        gridCallback.success(data.items);
                    },
                    function error (err) {
                        gridCallback.success([]);
                    }
                );
            }
            else {
                gridCallback.success([]);
            }
        };

        vm.handleRowSelect = function(rowData) {
            if (rowData && rowData.number) {
                vm.selectedRelatedNumber =  rowData.number;
                vm.selectedRelType = rowData.type;
                vm.selectedParentNumber = rowData.parentPartyNumber;
            } else {
                vm.selectedRelatedNumber = null;
                vm.selectedRelType = null;
                vm.selectedParentNumber = null;
            }
            kendoGridRendererService.refreshGrid( vm.attrGrid );
        };

        // on double-click, go to alert detail page
        vm.handleDoubleClick = function( selectedEntity) {
            if (selectedEntity && selectedEntity.number) {
                var entityId = entityService.normalizeEntityId( entityId, 'PTY', selectedEntity.number, selectedEntity.key );
                var entityState = entityService.getStateForEntity( entityId );
                $state.go(entityState.stateName, entityState.stateParams);
                // }
            }
        };

        function charValueFilter (input) {
            var value = input;
            if (!input) {return '';}
            _.each(associationAttributeLookupTables, function (tableName) {
                if (tableName !== '') {
                    var messageMap = amlLov.getByLovTableName(tableName);
                    if (messageMap) {
                        var filteredVal = messageMap[input];
                        if (filteredVal && filteredVal.description) {
                            value = filteredVal.description;
                            return value;
                        }
                    }
                }
            });
            return value;
        }

        function createCharValueEnum(field, associationAttributeLookupTables)
        {
            return function (dataItem) {
                if (dataItem && field) {
                    var input = dataItem[field];
                    return charValueFilter(input);
                }
                return '';
            };
        }

        function activate () {
            $scope.$watch('vm.customerList', function(newValue, oldValue){
                // refresh grid
                if (newValue) {
                    kendoGridRendererService.refreshGridSelectFirstRow( vm.customersGrid );
                }
            });
        }

        activate();
    }
})();
(function() {
    'use strict';
    AccountController.$inject = ["resources", "$stateParams", "accountService", "amlConstants", "dataMessagingServiceFactory", "titleCaseFilter"];
    angular.module('aml.customer').controller('AccountController', AccountController);

  function AccountController(resources, $stateParams, accountService, amlConstants, dataMessagingServiceFactory,
    titleCaseFilter) {

        var vm = this;
        vm.resources = resources;
        vm.entityNumber = $stateParams.accountid;

        vm.entityId = {
            entityNumber: vm.entityNumber,
            entityLevelCode: amlConstants.entityType.account,
            queueCode: $stateParams.queueCode
        };
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        dataMessagingService.setEntityId( vm.entityId );

        activate();

        function activate() {
            accountService.getAccount($stateParams.accountid).then(function(data) {

                vm.account = data;
//                console.log(vm.account);

                if ( vm.account ) {
                    vm.accountName = titleCaseFilter(vm.account.accountName);
                    dataMessagingService.setCustomerName(vm.account.accountName);
                    dataMessagingService.setEntityKey(vm.account.key);
                    dataMessagingService.setEmployeeIndicator( vm.account.employeeInd );

                    vm.account.address = {
                        street: data.address1,
                        street2: null,
                        city: data.city,
                        state: data.state || data.stateCode,
                        country: data.country,
                        postalcode: data.postal
                    };
                }
            });
        }
    }
})();

(function () {
    'use strict';
    AssociateController.$inject = ["resources", "$stateParams", "associateService", "amlConstants", "amlCoreUtils", "dataMessagingServiceFactory"];
    angular.module('aml.customer').controller('AssociateController', AssociateController);

    function AssociateController(resources, $stateParams, associateService, amlConstants, amlCoreUtils, dataMessagingServiceFactory) {

        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.resources = resources;
        vm.entityNumber = $stateParams.associateid;

        vm.entityId = {
            entityNumber: $stateParams.associateid,
            entityLevelCode: amlConstants.entityType.associate,
            queueCode: $stateParams.queueCode
        };
        dataMessagingService.setEntityId(vm.entityId);

        activate();

        function activate() {
            associateService.getAssociate($stateParams.associateid).then(function (data) {

                vm.associate = data;

                // set name and key on the datamessaging service

                var fullName = null;
                if (!vm.associate.associateMiddleName) {
                    fullName = amlCoreUtils.titleCase(vm.associate.associateFirstName + ' ' + vm.associate.associateLastName);
                } else {
                    fullName = amlCoreUtils.titleCase(vm.associate.associateFirstName + ' ' + vm.associate.associateMiddleName + ' ' + vm.associate.associateLastName);
                }

                dataMessagingService.setCustomerName(fullName);
                dataMessagingService.setEntityKey(vm.associate.associateKey);

            });
        }


    }
})();

(function () {
    'use strict';
    BankController.$inject = ["resources", "$stateParams", "bankService", "amlConstants", "dataMessagingServiceFactory"];
    angular.module('aml.customer').controller('BankController', BankController);

    function BankController(resources, $stateParams, bankService, amlConstants, dataMessagingServiceFactory) {

        var vm = this;
        vm.resources = resources;
        vm.entityNumber = $stateParams.bankid;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.entityId = {
            entityNumber: vm.entityNumber,
            entityLevelCode: amlConstants.entityType.bank,
            queueCode: $stateParams.queueCode
        };
        dataMessagingService.setEntityId(vm.entityId);

        activate();

        function activate() {
            bankService.getBank($stateParams.bankid).then(function (data) {
                vm.bank = data;

                dataMessagingService.setCustomerName(vm.bank.bankName);
                dataMessagingService.setEntityKey(vm.bank.key);

                vm.bank.bankAddress = {
                    street: data.bankAddress1,
                    street2: null,
                    city: data.bankCityName,
                    state: data.bankStateName,
                    country: data.bankCountryCode,
                    postalcode: data.bankPostalCode
                };
            });
        }
    }
})();

(function() {
  'use strict';
  BranchController.$inject = ["resources", "$stateParams", "branchService"];
  angular.module('aml.customer').controller('BranchController', BranchController);

  function BranchController(resources, $stateParams, branchService) {

    var vm = this;
    vm.resources = resources;

    activate();

    function activate() {
      branchService.getBranch($stateParams.branchid).then(function(data) {
        vm.branch = data;
        vm.branch.branchAddress = {
          street: data.streetAddress1,
          street2: null,
          city: data.streetCityName,
          state: data.streetStateName,
          country: data.streetCountryCode,
          postalcode: data.streetPostalCode
        };
      });
    }
  }
})();

(function () {
    'use strict';
    ExternalPartyController.$inject = ["resources", "$stateParams", "externalPartyService", "amlConstants", "dataMessagingServiceFactory"];
    angular.module('aml.customer').controller('ExternalPartyController', ExternalPartyController);

    function ExternalPartyController(resources, $stateParams, externalPartyService, amlConstants, dataMessagingServiceFactory) {

//console.log("ExternalPartyController $stateParams : " + JSON.stringify($stateParams));

        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.resources = resources;
        vm.entityNumber = $stateParams.externalpartyid; //S1387974 externalpartyid contains external party number

        //set queueCode immediately for Route button
        vm.entityId = {
            entityKey: null,
            entityNumber: vm.entityNumber,
            entityLevelCode: amlConstants.entityType.externalParty,
            queueCode: $stateParams.queueCode
        };
        dataMessagingService.setEntityId(vm.entityId);

        activate();

        function activate() {
        	
//console.log("ExternalPartyController activate");
            externalPartyService.getExternalParty($stateParams.externalpartyid).then(function (data) {

                vm.externalParty = data;

                // for external parties we have to wait for the data to come back with the actual entity number
                //override entityId so that key is also populated
                vm.entityId = {
                    entityKey: vm.externalParty.extPartyAccountKey,
                    entityNumber: vm.externalParty.externalPartyNumber,
                    entityLevelCode: amlConstants.entityType.externalParty,
                    queueCode: $stateParams.queueCode
                };
                dataMessagingService.setEntityId(vm.entityId);
                dataMessagingService.setCustomerName(vm.externalParty.fullName);
                dataMessagingService.setEmployeeIndicator(vm.externalParty.employeeInd);

                vm.externalParty.address = {
                    street: data.streetAddress1,
                    street2: null,
                    city: data.streetCityName,
                    state: null,
                    country: data.streetCountryName,
                    postalcode: data.streetPostalCode
                };
            });
        }
    }
})();

(function () {
    'use strict';
    HouseholdController.$inject = ["resources", "$stateParams", "householdService", "amlConstants", "dataMessagingServiceFactory"];
    angular.module('aml.customer').controller('HouseholdController', HouseholdController);

    function HouseholdController(resources, $stateParams, householdService, amlConstants, dataMessagingServiceFactory) {

        var vm = this;
        vm.resources = resources;
        vm.entityNumber = $stateParams.householdNumber;

        vm.entityId = {
            entityNumber: vm.entityNumber,
            entityLevelCode: amlConstants.entityType.household,
            queueCode: $stateParams.queueCode
        };
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        dataMessagingService.setEntityId(vm.entityId);

        activate();

        function activate() {
            householdService.getHousehold($stateParams.householdNumber).then(function (data) {

                vm.household = data;

                dataMessagingService.setCustomerName(vm.household.headOfHousehold);
                dataMessagingService.setEntityKey(vm.household.key);
                dataMessagingService.setEmployeeIndicator(vm.household.employeeInd);

                vm.household.address = {
                    street: data.address1,
                    street2: null,
                    city: data.city,
                    state: data.state || data.stateCode,
                    country: data.country,
                    postalcode: data.postalcode
                };
            });
        }
    }
})();

/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    EfileDetailsController.$inject = ["$rootScope", "$scope", "$stateParams", "$sce", "$filter", "logger", "amlLov", "resources", "kendoGridRendererService", "efilesService", "dialogService"];
    angular.module('aml.efiles.details').controller('EfileDetailsController', EfileDetailsController);

    /* jshint maxparams: 11*/
    function EfileDetailsController($rootScope, $scope, $stateParams, $sce, $filter, logger, amlLov, resources,
                                    kendoGridRendererService, efilesService, dialogService) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        vm.efileKey = $stateParams.efilekey;
        vm.efileStatusList = amlLov.getAsArray(amlLov.efileStatus);
        vm.reportKeys = [];
        vm.viewResponseReport = viewResponseReport;
        vm.rejectEfile = rejectEfile;
        vm.selectRow = selectRow;

        var dataSourceOptions = {
            transport: {
                read: getEfileReports
            },
            schema: {
                model: {
                    fields: {
                        reportReOpen: {type: 'boolean', editable: true},
                        reportKey: {type: 'number'},
                        reportAgencyRefId: {type: 'string'},
                        reportDescription: {type: 'string'},
                        fileStatusCode: {type: 'string'},
                        reportSequenceNumber: {type: 'number'}
                    }
                },
                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            sort: {
                field: 'reportSequenceNumber',
                dir: 'asc'
            },
            pageSize: 100
        };

        vm.gridColumns = [
            {
                field: 'reportReOpen', title: resources.aml.efiles.header.reportReOpen,
                width: '10%',
                filterable: false,
                template: '<input type=\'checkbox\' ng-click="vm.selectRow(dataItem.reportKey)" ng-disabled="vm.efile.statusCode ===\'RJ\'"/>'
            },
            {
                field: 'reportSequenceNumber', title: resources.aml.efiles.header.reportSequenceNumber,
                width: '13%',
                filterable: false
            },
            {
                field: 'reportKey', title: resources.aml.efiles.header.reportKey,
                width: '10%',
                template: '<a ui-sref=\'reportDetails({reportkey:{{dataItem.reportKey}}, reporttype:vm.reportTypeLabel})\'>{{dataItem.reportKey}}</a>',
                filterable: false
            },
            {
                field: 'fileStatusCode', title: resources.aml.efiles.header.efileStatusCode,
                template: kendoGridRendererService.enum('fileStatusCode', 'reportStatus'),
                filterable: false,
                width: '15%'
            },
            {
                field: 'reportDescription', title: resources.aml.efiles.header.reportDescription,
                filterable: false
            },
            {
                field: 'reportAgencyRefId', title: resources.aml.efiles.header.reportAgencyRefId,
                width: '15%',
                filterable: false
            }
        ];

        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                dataSource: dataSourceOptions,
                height: 300,
                pageable: false,
                selectable: 'multiple',
                scrollable: {
                    virtual: true
                }
            });

        activate();

        function activate() {

            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });

            $scope.$on('efileReportListRefresh', function (event) {
                kendoGridRendererService.refreshGrid(vm.grid);
            });

            $scope.$on('efileLoaded', function (event, args) {
                vm.reportTypeLabel = $filter('reportType')(args.val.formConfigKey);
                efilesService.getEfileEntityInfo(vm.efileKey, 'FINCEN_TRANSMITTER_' + args.val.formConfigKey).then(
                    function (data) {
                        vm.transmitterInfo = data.items[0];
                        vm.transmitterInfo.uiJSON.transmitterStateCode =
                            $filter('allCountriesStates')(vm.transmitterInfo.uiJSON.transmitterStateCode,
                                                          vm.transmitterInfo.uiJSON.transmitterCountryCode);
                    },
                    function (data, status, headers, config) {
                        logger.error('Could not get transmitter information.');
                    });
            });
        }

        function getEfileReports(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);

            //var previousCount = null;
            //if (pageInfo.start > 0) {
            //    previousCount = vm.efileReportsCount;
            //}

            efilesService.getEfileReports(vm.efileKey, pageInfo.start, pageInfo.limit, sortCols, filterStr).then(
                function (data) {
                    vm.efileReportsCount = data.count;
                    e.success(data);
                },
                function (data, status, headers, config) {
                    logger.error('Could not get efile reports');
                });
        }

        function viewResponseReport() {
            //Call the stored process
            $scope.loading = true;
            efilesService.viewResponseReport(vm.efileKey).then(
                //Handle the results
                function (data) {
                    $scope.loading = false;
                    dialogService.openInformationDialog(vm.resources.aml.getResource('efiles.responseReportTitle',
                        {efileKey: vm.efileKey}), $sce.trustAsHtml(data.data));
                },
                function (error) {
                    $scope.loading = false;
                }
            );
        }

        function rejectEfile() {
            //Confirmation dialog to warn user
            dialogService.openConfirmDialog(resources.aml.efiles.rejectEFileWindowTitle,
                resources.aml.getResource(
                    'efiles.rejectConfirmationText', {efileId: vm.efile.efileId}))
                .then(function okayPressed() {
                    $scope.rejectLoading = true;
                    //Reject the E-File
                    efilesService.rejectEfile(vm.efileKey, vm.reportKeys).then(
                        //Handle the results
                        function (data) {
                            $scope.rejectLoading = false;
                        },
                        function (error) {
                            $scope.rejectLoading = false;
                        }
                    );
                    //Refesh list of reports in efile detail window
                    $rootScope.$broadcast('efileReportListRefresh');
                    //Refresh the list of efiles
                    $rootScope.$broadcast('efileListRefresh');
                });
        }

        function selectRow(reportKey) {
            var index = vm.reportKeys.indexOf(reportKey);

            //Currently selected - remove
            if (index > -1) {
                vm.reportKeys.splice(index, 1);
            } else {
                //New selection - add
                vm.reportKeys.push(reportKey);
            }
        }
    }
})();

(function () {
    'use strict';
    EfileDetailsViewController.$inject = ["$scope", "$stateParams", "efilesService", "resources", "_", "dataMessagingServiceFactory"];
    angular.module('aml.efiles.details').controller('EfileDetailsViewController', EfileDetailsViewController);

    /**
     * This is the overall controller for the Efile Details view.
     * It sets things that all directives on the details page may need, such
     * as the current selected efileId taken from the current route/state,
     * and the current efile object itself
     *
     * @param $scope
     * @param $stateParams
     * @constructor
     * @param efilesService
     * @param resources
     * @param _
     */
    function EfileDetailsViewController($scope, $stateParams, efilesService, resources, _, dataMessagingServiceFactory) {
        var viewVm = this;
        viewVm.efileKey = $stateParams.efilekey;
        viewVm.resources = resources;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        activate();

        function activate() {
            efilesService.getEfile(viewVm.efileKey).then(function (data) {
                    viewVm.efile = data;

                    //Check to see if the user can edit the efile
                    $scope.readonly = efilesService.isEfileReadonly(viewVm.efile);
                    $scope.$broadcast('efileLoaded', {'val': viewVm.efile});
                });

            setupWatches();
        }

        function setupWatches() {
            $scope.$watch(
                function () {
                    return dataMessagingService.getEntityId();
                },
                function () {
                    viewVm.entityId = dataMessagingService.getEntityId();
                },
                true
            );

            $scope.$watch('readonly', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    $scope.$broadcast('readonlyChange', {'val': newVal});
                }
            });
        }
    }
})();

(function () {
    'use strict';
    CustomReportDetailsViewController.$inject = ["$scope", "$stateParams", "$sce", "amlConfig", "resources", "_", "linksProcessor"];
    angular.module('aml.reports.details').controller('CustomReportDetailsViewController', CustomReportDetailsViewController);

    /**
     * This is the overall controller for the Custom Report Details view.
     * It sets things that all directives on the details page may need, such
     * as the current selected reportKey taken from the current route/state,
     * and the current report object itself
     *
     * @param $scope
     * @param $stateParams
     * @param reportsService
     * @param resources
     * @param _
     * @constructor
     */
    function CustomReportDetailsViewController($scope, $stateParams, $sce, amlConfig, resources, _, linksProcessor) {
        var viewVm = this;
        viewVm.reportKey = $stateParams.reportkey;
        viewVm.resources = resources;

        activate();

        function activate() {
            //$scope.loadingCustomReport = true;
            viewVm.reportFormHtml = $sce.trustAsResourceUrl(linksProcessor.getBusinessUnitLink( amlConfig.baseUrl +
                '/regulatoryReports/' + viewVm.reportKey + '/callStp.html?stpName=rc_custom_form'));

            setupWatches();
        }

        function setupWatches() {
            $scope.$watch('readonly', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    $scope.$broadcast('readonlyChange', {'val': newVal});
                }
            });
        }
    }
})();

/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    ReportDetailsController.$inject = ["$scope", "amlLov", "resources", "usersService", "amlConstants"];
    angular.module('aml.reports.details').controller('ReportDetailsController', ReportDetailsController);

    function ReportDetailsController($scope, amlLov, resources, usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.statusCodeList = amlLov.getAsArray(amlLov.reportStatus);

        activate();

        function activate() {
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;

                //Restrict the report status choices if the user doesn't have correct capability
                vm.statusCodeList.forEach(function (status) {
                    status.disable = false;

                    //E-Filer has the resetReportStatus capability and can edit reports, so don't filter list
                    if (!vm.readonly && !usersService.currentUserHasCapability(amlConstants.capabilities.resetReportStatus )) {
                        //Investigator - Only select D and E
                        if (status.key === 'D' || status.key === 'E') {
                            status.disable = false;
                        }
                        else {
                            status.disable = true;
                        }

                        //Manager - D, E, R, C
                        if (status.key === 'R' &&
                            usersService.currentUserHasCapability(amlConstants.capabilities.reportReadyToSubmit)) {
                            status.disable = false;
                        }
                        if (status.key === 'C' &&
                            usersService.currentUserHasCapability(amlConstants.capabilities.closeReport)) {
                            status.disable = false;
                        }

                        //E-filer?
                    }

                });
            });
        }
    }
})();

(function () {
    'use strict';
    ReportDetailsViewController.$inject = ["$scope", "$stateParams", "$state", "$filter", "reportsService", "tabsListService", "resources", "_"];
    angular.module('aml.reports.details').controller('ReportDetailsViewController', ReportDetailsViewController);

    /**
     * This is the overall controller for the Report Details view.
     * It sets things that all directives on the details page may need, such
     * as the current selected reportKey taken from the current route/state,
     * and the current report object itself
     *
     * @param $scope
     * @param $stateParams
     * @param reportsService
     * @param resources
     * @param _
     * @constructor
     */
    function ReportDetailsViewController($scope, $stateParams, $state, $filter, reportsService, tabsListService, resources, _) {
        var viewVm = this;
        viewVm.reportKey = $stateParams.reportkey;
        viewVm.resources = resources;

        activate();

        function activate() {
//console.log("reportsService.getReport Call !!");
            reportsService.getReport(viewVm.reportKey).then(function (data) {

                //When coming from a report listing the implementation type code has already been determined.
                //This means the function will be called twice for "regular" types of reports.
                var implementationTypeCode = reportsService.getImplementationTypeCode(data);
                if (implementationTypeCode === 'CUSTOM' ) {//CUSTOM report of some kind.
                    viewVm.report = data;
                    //This code is included so that URLs going directly to the report URL will be redirected to the custom report.
                    //It will flash
                    // close current tab for the current state
                    tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);

                    $state.go('customReportDetails', {
                        reportkey: viewVm.report.reportKey,
                        reporttype: $filter('reportType')(viewVm.report.reportFormTypeKey)
                    }, {location:false});
                }
                else {
                    var templateCode = (!implementationTypeCode || implementationTypeCode === '') ? data.reportFormTypeKey : implementationTypeCode;
                    viewVm.reportFormHtml = 'regulatoryReports/reportDetails/forms/' + templateCode + '.html';
                    //do not set report field before form name is set, otherwise from could be null
                    viewVm.report = data;

                    //Check to see if the user can edit the report
                    $scope.readonly = reportsService.isReportReadonly(viewVm.report);

                    $scope.$broadcast('reportLoaded', {'val': viewVm.report});
                }

								
                
//console.log("#$#$#$ viewVm : " + JSON.stringify(viewVm.report));            
//console.log("reportsService.getReport Call End !!");

								var checkStr = "N";
		            reportsService.runReportValidation(viewVm.report).then(
		                //Handle the results
		                function (data) {
//console.log("validateReport data : " + JSON.stringify(data));
											if(data.data.indexOf("No Data Validation errors found for report:") != -1){
												checkStr = "Y";
											}
											
											
											if(viewVm.report.statusCode != 'undefined' 
													&& viewVm.report.statusCode != '' 
													&& viewVm.report.statusCode == "D" 
													&& checkStr == "Y"){
												$("#btnEfile").show();
												$("#reqKeyValue").val(viewVm.reportKey);
											}
		                },
		                function (error) {
		                    $scope.loading = false;
		                }
		            );
            });

//console.log("validateReport vm.aReport : " + JSON.stringify(vm.aReport));



            setupWatches();
        }

        function setupWatches() {
            $scope.$watch('readonly', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    $scope.$broadcast('readonlyChange', {'val': newVal});
                }
            });
        }
    }
})();

(function () {
    'use strict';

    HeaderListDirectiveController.$inject = ["headerService", "$scope", "resources", "kendoGridRendererService", "messageService", "$state", "logger", "_"];
    angular
        .module('aml.scenario')
        .controller('HeaderListDirectiveController', HeaderListDirectiveController);
    /* jshint maxparams: 16*/
    /* jshint maxstatements: 63 */
    function HeaderListDirectiveController(headerService, $scope, resources,
                                           kendoGridRendererService, messageService,
                                           $state, logger, _) {
        var vm = this;
        //vm.headers = [];
        vm.resources = resources;
        vm.grid = {};
        vm.amlGridActions = [];
        vm.headerCount = 0;
        vm.filterString = null;

        var dataSourceOptions = {
            transport: {
                read: getHeaders
            },
            schema: {
                model: {
                    fields: {
                        name: {type: 'string'},
                        datasetName: {type: 'string'},
                        typeCode: {type: 'string'},
                        entityLevelCode: {type: 'string'},
                        autogenInd: {type: 'string'}
                    }
                },
                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            change: function(e) {
                vm.headerCount = e.items.length;
            },
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        };

        var autogenRenderingFilter = kendoGridRendererService.enum('autogenInd', 'yesOrNo');
        var entityLevelRenderingFilter = kendoGridRendererService.enum('entityLevelCode', 'entityLevel');
        var typeCodeRenderingFilter = kendoGridRendererService.enum('typeCode', 'headerTypeCode');

        vm.gridColumns = [
            {
                field: 'name', title: vm.resources.aml.scenarioHeader.name,
                width: '35%'
            },
            {
                field: 'datasetName', title: vm.resources.aml.scenarioHeader.datasetName,
                width: '35%'
            },
            {
                field: 'typeCode', title: vm.resources.aml.scenarioHeader.typeCode,
                template: typeCodeRenderingFilter,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(typeCodeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('headerTypeCode')
            },
            {
                field: 'entityLevelCode', title: vm.resources.aml.scenarioHeader.entityLevelCode,
                template: entityLevelRenderingFilter,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(entityLevelRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('entityLevel')
            },
            {
                field: 'autogenInd', title: vm.resources.aml.scenarioHeader.autogenInd,
                template: autogenRenderingFilter,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(autogenRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            }
        ];


        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                dataSource: dataSourceOptions,
                height: 750,
                pageable: false,
                resizable: true,
                //navigatable: true,
                selectable: 'multiple',
                scrollable: {
                    virtual: true
                }
            });

        activate();

        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'headersList');
            //init callbacks for the parent scope
            if (angular.isDefined(vm.callback)) {
                vm.callback.getSelectedHeaderIdsFromSelectedRows = getSelectedHeaderIdsFromSelectedRows;
                vm.callback.reloadGrid = reloadGrid;
            }
        }

        function handleDoubleClick(evt, data) {
            var header = vm.grid.dataItem(evt.currentTarget);
            if (header && header.headerID) {
                $state.go('headerDetails', {headerID: header.headerID, headerName: header.name});
            }
        }

        function getSelectedHeaderIdsFromSelectedRows() {
            var entityIds = [];
            if ( vm.grid ) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var entity  = vm.grid.dataItem(rowSelection);
                    if (entity && entity.headerID) {
                        entityIds.push(entity.headerID);
                    }
                });
            }
            return entityIds;
        }

        function reloadGrid(showDeleted) {
            vm.showDeleted = showDeleted;
            vm.grid.dataSource.read();
        }

        function getHeaders(e) {
            headerService.getHeaders(vm.showDeleted).then(function (data) {
                    // on server response success
                    vm.loading = null;
                    vm.headerCount = data.items.length;
                    e.success(data);
                },
                function (data, status, headers, config) {
                    var msg = resources.aml.getResource('header.headersReadErrorTxt');
                    messageService.danger(msg, null, -1);
                });
        }
    }
})();

(function() {
    'use strict';

    HeaderListViewController.$inject = ["$scope", "headerService", "$state", "$log", "resources", "resourceService", "messageService"];
    angular
        .module('aml.scenario')
        .controller('HeaderListViewController', HeaderListViewController);

    function HeaderListViewController($scope, headerService, $state, $log, resources, resourceService, messageService) {
        var viewVm = this;
        viewVm.loading=true;
        viewVm.showDeleted = false;
        viewVm.resources = resources;

        viewVm.gridCallbacks = {
            getSelectedHeaderIdsFromSelectedRows : function () {return [];},
            reloadGrid : function () {return [];}
        };

        activate();

        function activate () {
            $scope.$on('headerChanged', function(event, changedData) {
                viewVm.reloadList();
            });
        }

        viewVm.newHeader= function() {
            var id = headerService.getNextId();
            $state.go('headerDetails',{headerID: 'new_'+id.toString(), headerName: 'HDR_'+id.toString(), newEntityFlag: true});
        };

        viewVm.markHeadersDeleted = function() {
            var ids =  viewVm.gridCallbacks.getSelectedHeaderIdsFromSelectedRows();
            if (ids.length > 0) {
                headerService.markHeadersAsDeleted(ids).then(function (data) {
                        var msg = resources.aml.getResource('header.headersMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('header.headersMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            } else {
                var msg = resources.aml.getResource('header.noHeadersSelectedErrorTxt');
                messageService.danger(msg, null, -1);
            }
        };

        viewVm.markHeadersUndeleted = function() {
            var ids =  viewVm.gridCallbacks.getSelectedHeaderIdsFromSelectedRows();
            if (ids.length > 0) {
                headerService.markHeadersAsUndeleted(ids).then(function (data) {
                        var msg = resources.aml.getResource('header.headersMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('header.headersMarkedUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            } else {
                var msg = resources.aml.getResource('header.noHeadersSelectedErrorTxt');
                messageService.danger(msg, null, -1);
            }
        };

        viewVm.toggleDeleted = function () {
            viewVm.showDeleted = !viewVm.showDeleted;
            viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
        };

        viewVm.reloadList = function reloadList() {
            viewVm.gridCallbacks.reloadGrid(viewVm.showDeleted);
        };


    }
})();
(function () {
    'use strict';

    HeaderDetailsViewController.$inject = ["$rootScope", "$scope", "$stateParams", "$state", "$q", "logger", "amlLov", "resources", "kendoGridRendererService", "tabsListService", "$uibModal", "datasetService", "headerService", "messageService", "_"];
    angular
        .module('aml.scenario')
        .controller('HeaderDetailsViewController', HeaderDetailsViewController);

    /* jshint maxparams: 17 */
    /* jshint maxstatements: 63 */
    function HeaderDetailsViewController($rootScope, $scope, $stateParams, $state, $q, logger, amlLov,
                                         resources, kendoGridRendererService, tabsListService, $uibModal,
                                         datasetService, headerService, messageService, _) {
        var vm = this;
        vm.state = $state.$current;

        vm.forms = {};
        vm.newScenario = false;
        vm.resources = resources;
        vm.origHeaderName = 'NULL';
        vm.byVariableError = false;
        vm.showDeleted = false;
        vm.loading = true;
        vm.observableArray = new kendo.data.ObservableArray([]);
        vm.scenarios = [];
        vm.scenarioCount = 0;
        vm.newHeader = false;
        vm.nameError = false;
        //parameters grid data
        vm.grid = {};
        vm.amlGridActions = [];
        vm.filterString = '';

        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;
        var scenarioStatusFilter = kendoGridRendererService.enum('status', 'scenarioStatus');
        var scenarioCategoryFilter = kendoGridRendererService.enum('categoryCode', 'scenarioCategory');
        var scenarioTypeFilter = kendoGridRendererService.enum('scenarioTypeCode', 'scenarioType');

        function disableUnsafeActions () {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('scenario.scenarioActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }
        function enableUnsafeActions () {
            disableUnsafeActionsFlag = false;
        }

        function updateTabTitle() {
            var tabInfo = tabsListService.getTabInfo(vm.state.name);
            tabInfo.title = vm.header.name;
            tabInfo.params.headerName = vm.header.name;
            $stateParams.headerName = vm.header.name;
            tabsListService.updateTabInfo(tabInfo, true);
        }

        function validateName () {
            vm.nameError = !isHeaderNameValid();
        }

        function isHeaderNameValid() {
            //if the name has not changed still need to verify other headers
            //because table does not have unique constraint
            var match = _.where(vm.headerNames, {code: vm.header.name});
            // new header name must be unique
            if (vm.newHeader && match.length > 0) {
                return false;
            }
            // existing header name must be unique
            if (!vm.newHeader) {
                if (vm.header.name === vm.origHeaderName) {
                    //if name has not changed then there must be only one match
                    return (match.length === 1);
                }
                //if name has changed then it cannot match any existing header
                if (match.length > 0) {
                    return false;
                }
            }
            return true;
        }

        function noDollarSign (aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        function createSource() {
            if (!angular.isDefined(vm.header.source) && vm.hasSource()) {
                vm.header.source = '';
            }
        }

        function init() {
            vm.actionsDisabled = function () {
                return disableUnsafeActionsFlag;
            };

            vm.selectDetails = function () {
                vm.showDetails = true;
                vm.showScenarios = false;
            };

            vm.selectScenarios = function () {
                vm.showDetails = false;
                vm.showScenarios = true;
            };

            vm.getHeaderNames = function () {
                //get all headers, name must be unique in the entire FSK_HEADER table
                var defer = $q.defer();
                headerService.getHeaderNames(true).then(function (headerNames) {
                        vm.headerNames = headerNames;
                        defer.resolve(true);
                    },
                    function (reason) {
                        defer.resolve(false);
                    });
                return defer.promise;
            };

            vm.updateTab = function (e) {
                if (!vm.basicForm.biName.$error.headerName && angular.isDefined(vm.header.name) && vm.header.name !== '') {
                    updateTabTitle();
                }
            };

            vm.getHeaderData = function (headerId) {
                var hprom = headerService.getHeader(headerId);

                var both = $q.all([hprom]);

                both.then(function (data) {
                        vm.header = data[0];
                        vm.origHeaderName = vm.header.name;

                        var scenarios = vm.header.scenarios;
                        for (var i = 0; i < scenarios.length; i++) {
                            vm.observableArray.push(scenarios[i]);
                        }
                        vm.loading = false;
                        vm.showDetails = true;
                        vm.state.data.dirty = false;
                        vm.isPrepDataSetValid();
                        updateTabTitle();
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('header.headerReadErrorTxt', {'headerId': headerId}), null, -1);
                        vm.state.data.dirty = false;  // to set the tab pill to not call callbacks
                        tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
                        vm.loading = false;
                        $state.go('headers');
                    });
            };

            vm.updateHeader = function (headerIn, discardFlag) {
                var defer = $q.defer();
                var uprom;
                if (vm.newHeader) {
                    uprom = headerService.createNewHeader(headerIn);
                } else {
                    uprom = headerService.updateHeader(headerIn);
                }

                if (uprom) {
                    uprom.then(function (data) {
                            vm.header = data;
                            //if header id has changed need to create new state to
                            //avoid creating duplicate tabs, header id only changes for the new header
                            vm.state.data.dirty = false;
                            if (!discardFlag) {
                                if (vm.newHeader) {
                                    tabsListService.closeTab(tabsListService.getTabForCurrentState(), false).then(
                                        function (data) {
                                            $state.go('headerDetails',
                                                {headerID: vm.header.headerID, headerName: vm.header.name},
                                                {
                                                    location: 'replace',
                                                    inherit: false,
                                                    notify: true,
                                                    reload: true
                                                });
                                        }
                                    );
                                }
                            }
                            var msg = resources.aml.getResource('header.headerSavedTxt',
                                {'name': headerIn.name});
                            messageService.success(msg, null, 4000);
                            $rootScope.$broadcast( 'headerChanged', { headerID: vm.header.headerID });
                            defer.resolve('entity updated');
                        },
                        function (error) {
                            var msg = resources.aml.getResource('header.headerSaveFailedErrorTxt',
                                {'name': headerIn.name});
                            messageService.danger(msg, null, -1);
                            if (error.status === 409) {
                                messageService.danger(resources.aml.getResource('header.headerUpdateConflictErrorTxt'), null, -1);
                            }
                            defer.reject(error);
                        }).finally( function () {enableUnsafeActions();});
                } else {
                    enableUnsafeActions();
                    var msg = resources.aml.getResource('header.headerSaveFailedErrorTxt',
                        {'name': headerIn.name});
                    messageService.danger(msg, null, -1);
                    logger.error('uprom is null in updateHeader:' + headerIn.name);
                    defer.reject('promise is null while updating entity');
                }
                return defer.promise;
            };

            vm.gridColumns = [
                {
                    field: 'name', title: vm.resources.aml.scenario.scenarioNameHeaderTitle,
                    width: '30%'
                },
                {
                    field: 'shortDescription', title: vm.resources.aml.scenario.shortDescriptionHeaderTitle,
                    width: '35%'
                },
                {
                    field: 'status', title: vm.resources.aml.scenario.scenarioStatusHeaderTitle,
                    template: scenarioStatusFilter,
                    width: '10%',
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(scenarioStatusFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('scenarioStatus')
                },
                {
                    field: 'scenarioTypeCode', title: vm.resources.aml.scenario.typeCodeHeaderTitle,
                    template: scenarioTypeFilter,
                    width: '10%',
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(scenarioTypeFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('scenarioType')
                },
                {
                    field: 'categoryCode', title: vm.resources.aml.scenario.categoryCodeHeaderTitle,
                    template: scenarioCategoryFilter,
                    width: '15%',
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(scenarioCategoryFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('scenarioCategory')
                }
            ];

            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
                {
                    dataSource: vm.observableArray,
                    pageable: false,
                    selectable: 'multiple',
                    scrollable: {
                        virtual: true
                    },
                    sortable: true,
                    filterable: true,
                    dataBound: function (val) {
                    }
                });

            vm.handleDoubleClick = function (evt, data) {
                var dataRows = vm.grid.items();
                var rowIndex = dataRows.index(vm.grid.select());
                //var lnks = vm.headers[rowIndex].links;
                var scenario = vm.observableArray[rowIndex];
                var scenarioID = scenario.scenarioID;
                var headerID = scenario.headerID;
                $state.go('scenarioDetails', {headerID: headerID, scenarioID: scenarioID, scenarioName: scenario.name});
            };
            //TODO: re-write function above
            //function handleDoubleClick(evt, data) {
            //    var selectedCase = vm.grid.dataItem(evt.currentTarget);
            //    if (selectedCase && selectedCase.caseId) {
            //        $state.go('caseDetails', { caseid: selectedCase.caseId });
            //    }
            //}

            vm.saveHeader = function (discardFlag) {
                var defer = $q.defer();
                disableUnsafeActions();
                //reload header names for validation in case other users made changes
                vm.getHeaderNames().then(function (result) {
                        if (vm.formsHaveErrors()) {
                            defer.reject('form has errors');
                            var modalInstance = $uibModal.open({
                                animation: true,
                                templateUrl: 'modalHeader.html',
                                controller: 'HeaderModalController as viewVm',
                                size: 'm',
                                backdrop: 'static'
                            });
                            modalInstance.forms = vm.forms;

                            modalInstance.result.then(function () {
                            }, function () {
                                var names = Object.getOwnPropertyNames(vm.forms);
                                for (var i = 0; i < names.length; i++) {
                                    vm.dirtyAll(vm.forms[names[i]]);
                                }
                            }).finally( function () {enableUnsafeActions();});
                        } else {
                            if (!vm.hasSource()) {
                                vm.header.source = '';
                            }
                            // rest call and state change
                            var uprom = vm.updateHeader(vm.header, discardFlag);
                            if (uprom && uprom !== null) {
                                uprom.then (
                                    function success (data) {
                                        defer.resolve(data);
                                    },
                                    function failure (reason) {
                                        //save failed,  so do not close the tab
                                        defer.reject(reason);
                                    }
                                );
                            } else {
                                // save failed, tab cannot be closed
                                defer.reject('update failed (promise is null)');
                            }
                        }
                    },
                    function (reason) {
                        enableUnsafeActions();
                        messageService.danger(resources.aml.getResource('header.headerListReadErrorTxt'), null, -1);
                        defer.reject(reason);
                    }
                );
                return defer.promise;
            };

            vm.deleteHeader = function () {
                disableUnsafeActions();
                headerService.markHeaderAsDeleted(vm.header.headerID).then(function (data) {
                        vm.header.logicalDeleteInd = 'Y';
                        var msg = resources.aml.getResource('header.headerMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('header.headerMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.undeleteHeader = function () {
                disableUnsafeActions();
                headerService.markHeaderAsUndeleted(vm.header.headerID).then(function (data) {
                        vm.header.logicalDeleteInd = 'N';
                        var msg = resources.aml.getResource('header.headerMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('header.headerMarkedUneletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.refreshDataset = function () {
                if (vm.header.datasetName) {
                    disableUnsafeActions();
                    messageService.success(resources.aml.getResource('header.datasetLoadingTxt'), null, 4000);
                    datasetService.getDataset(vm.header.datasetName).then(function (data) {
                            vm.parameterForm.$dirty = true;
                            var newColumns = data.datasetColumns;
                            var updCnt = 0, addCnt = 0, delCnt = 0;
                            for (var i = 0; i < newColumns.length; i++) {
                                var col = _.findWhere(vm.header.datasetColumns, {name: newColumns[i].name});
                                //update existing and add new columns
                                if (col) {
                                    col.label = newColumns[i].label;
                                    col.length = newColumns[i].length;
                                    col.typeCode = newColumns[i].typeCode;
                                    col.format = newColumns[i].format;
                                    updCnt++;
                                } else {
                                    newColumns[i].usageCode = 'Array element';
                                    vm.header.datasetColumns.push(newColumns[i]);
                                    addCnt++;
                                }
                            }
                            if (vm.header.datasetColumns.length !== newColumns.length) {
                                //some columns were deleted, remove them
                                var j = vm.header.datasetColumns.length;
                                while (j--) {
                                    var newCol = _.findWhere(newColumns, {name: vm.header.datasetColumns[j].name});
                                    if (!newCol) {
                                        vm.header.datasetColumns.splice(j, 1);
                                        delCnt++;
                                    }
                                }
                            }
                            var msg = resources.aml.getResource('header.datasetRefreshTxt',
                                {'upd': updCnt, 'add': addCnt, 'del': delCnt});
                            messageService.success(msg, null, -1);
                            //validate that By Variable has not been deleted
                            vm.isPrepDataSetValid();
                        },
                        function (error) {
                            //vm.loading = false;
                            var msg = resources.aml.getResource('header.datasetReadErrorTxt',
                                {'name': vm.header.datasetName});
                            messageService.danger(msg, null, -1);
                        }).finally( function () {enableUnsafeActions();});
                }
            };

            vm.formsHaveErrors = function () {
                vm.isPrepDataSetValid();
                validateName();
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (Object.getOwnPropertyNames(vm.forms[name].$error).length > 0) {
                        return true;
                    }
                }
                return vm.byVariableError || vm.nameError;
            };

            vm.formsAreDirty = function () {
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    if (vm.forms[names[i]].$dirty) {
                        return true;
                    }
                }
                return false;
            };


            vm.dirtyAll = function (formIn) {
                var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
                for (var i = 0; i < names.length; i++) {
                    formIn[names[i]].$dirty = true;
                }
            };

            vm.unbindSourceCodeForm = $scope.$watch('vm.sourceCodeForm', function () {
                vm.forms.sourceCodeForm = vm.sourceCodeForm;
                $scope.$watch('vm.forms.sourceCodeForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindSourceCodeForm();
            });

            vm.unbindExecForm = $scope.$watch('vm.execForm', function () {
                vm.forms.execForm = vm.execForm;
                $scope.$watch('vm.forms.execForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindExecForm();
            });

            vm.unbindBasicForm = $scope.$watch('vm.basicForm', function () {
                vm.forms.basicForm = vm.basicForm;
                $scope.$watch('vm.forms.basicForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindBasicForm();
            });

            vm.unbindParamaterForm = $scope.$watch('vm.parameterForm', function () {
                vm.forms.parameterForm = vm.parameterForm;
                $scope.$watch('vm.forms.parameterForm.$dirty', function (newValue, oldValue) {
                    if (newValue) {
                        vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                    }
                });
                vm.unbindParamaterForm();
            });

            vm.datasetSelected = function (datasetName) {
                vm.parameterForm.$dirty = true;
                if (angular.isDefined(datasetName) && datasetName !== '') {
                    //vm.loading = true;
                    datasetService.getDataset(datasetName).then(function (data) {
                            vm.header.datasetColumns = data.datasetColumns;
                            vm.loading = false;
                        },
                        function (error) {
                            //vm.loading = false;
                            var msg = resources.aml.getResource('header.datasetReadErrorTxt',
                                {'name': datasetName});
                            messageService.danger(msg, null, -1);
                        });
                }
            };

            vm.showDetails = true;
            vm.showScenarios = false;

            vm.toggleCollapsed = function (prefix) {
                if (prefix === 'bi') {
                    vm.bcollapsed = !vm.bcollapsed;
                } else if (prefix === 'pds') {
                    vm.hcollapsed = !vm.hcollapsed;
                } else if (prefix === 'code') {
                    vm.ccollapsed = !vm.ccollapsed;
                }
            };

            vm.isPrepDataSetValid = function () {
                vm.byVariableError = false;
                if (angular.isDefined(vm.header) && angular.isDefined(vm.header.typeCode) && angular.isDefined(vm.header.autogenInd)) {
                    if (vm.header.typeCode === 'SAS Datastep' && vm.header.autogenInd === 'Y') {
                        vm.byVariableError = !headerService.isByVariableValid(vm.header);
                    }
                }
                return !vm.byVariableError;
            };

            vm.hasSource = function () {
                return headerService.hasSource(vm.header);
            };

            vm.typeCodeSelected = function () {
                headerService.typeCodeSelected(vm.header, vm.header.typeCode);
                createSource();
            };

            vm.autogenSelected = function () {
                headerService.autogenSelected(vm.header, vm.header.autogenInd);
                createSource();
            };

            vm.isAutogenVisible = function () {
                if (angular.isDefined(vm.header) && angular.isDefined(vm.header.typeCode)) {
                    return vm.header.typeCode !== 'Custom';
                }
                return true;
            };

            vm.isDatasetVisible = function () {
                if (angular.isDefined(vm.header) && angular.isDefined(vm.header.typeCode) && angular.isDefined(vm.header.autogenInd)) {
                    return vm.header.typeCode === 'SAS Datastep' && vm.header.autogenInd === 'Y';
                }
                return true;
            };

            if (!angular.isDefined(vm.headerNames)) {
                vm.getHeaderNames();
            }

            if ($stateParams.headerID.indexOf('new_') === -1) {
                //assume existing header
                vm.headerId = $stateParams.headerID;
                vm.getHeaderData(vm.headerId);
            } else {
                //create new header
                vm.loading = false;
                vm.newHeader = true;
                if (!$stateParams.headerName) {
                    //in case we came to the state with bookmarked URL
                    $stateParams.headerName = 'HDR_' + headerService.getNextId().toString();
                }
                vm.header = headerService.newHeader($stateParams.headerName);
                vm.origHeaderName = vm.header.name;
                updateTabTitle();
            }

            // add a modal dialog to allow pill to be closed
            // return true to close...false to keep pill
            tabsListService.registerCloseCallback(vm.state, function headerCallback() {
                var defer = $q.defer();
                if (vm.state.data.dirty === true) {
                    var modalInstance = $uibModal.open({
                        animation: true,
                        templateUrl: 'modalCloseHeader.html',
                        controller: 'HeaderModalDispositionController as viewVm',
                        size: 'md',
                        backdrop: 'static'
                    });
                    modalInstance.headerName = vm.header.name;

                    modalInstance.result.then(
                        function () {},
                        function (buttonValue) {
                            if (buttonValue === 'discard') {
                                defer.resolve(true);
                            } else if (buttonValue === 'save') {
                                var save = vm.saveHeader(true);// call save method on scenario
                                if (save === null) {
                                    //page has errors, cannot be saved, so do not close the tab
                                    defer.resolve(false);
                                } else {
                                    save.then (
                                        function success () {
                                            defer.resolve(true);
                                            $state.go('headers');
                                        },
                                        function failure () {
                                            //save failed,  so do not close the tab
                                            defer.resolve(false);
                                        }
                                    );
                                }
                            } else if (buttonValue === 'cancel') {
                                defer.resolve(false);
                            }
                        }
                    );
                } else {
                    defer.resolve(true);
                    $state.go('headers');
                }
                return defer.promise;
            });

            datasetService.getDatasets().then(function (data) {
                    vm.datasets = data.items;
                    vm.datasetNames = [];
                    for (var i = 0; i < vm.datasets.length; i++) {
                        vm.datasetNames.push(vm.datasets[i].name);
                    }
                },
                function (error) {
                    logger.error('datasets Error: ');
                    logger.error(error);
                });

            vm.unbindDummy = $scope.$watch('vm.headerScenariosModel', function (oldval, newval) {
                kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, vm.handleDoubleClick);
                vm.unbindDummy();
            });
            vm.categories = amlLov.getAsArray(amlLov.scenarioCategory);
            vm.statuss = amlLov.getAsArray(amlLov.scenarioStatus);
            vm.risks = amlLov.getAsArray(amlLov.riskClassification);
            vm.frequencies = amlLov.getAsArray(amlLov.scenarioFrequency);
            vm.entityLevels = amlLov.getAsArray(amlLov.entityLevel);
            vm.headerElementUsageCodes = amlLov.getAsArray(amlLov.headerElementUsage);
            vm.typeCodes = amlLov.getAsArray(amlLov.headerTypeCode);
            vm.yesOrNo = amlLov.getAsArray(amlLov.yesOrNo);
        }
        init();
    }
})();
(function () {
    'use strict';

    ScenarioDetailsViewController.$inject = ["$scope", "$rootScope", "$stateParams", "$uibModal", "amlLov", "logger", "$state", "$q", "scenarioService", "headerService", "datasetService", "resources", "tabsListService", "kendoGridRendererService", "messageService", "_", "segmentNameFilter"];
    angular
        .module('aml.scenario')
        .controller('ScenarioDetailsViewController', ScenarioDetailsViewController);
    /* jshint maxparams: 17 */
    /* jshint maxstatements: 73 */
    function ScenarioDetailsViewController($scope, $rootScope, $stateParams, $uibModal, amlLov,
                                           logger, $state, $q,
                                           scenarioService, headerService, datasetService,
                                           resources, tabsListService, kendoGridRendererService,
                                           messageService, _, segmentNameFilter) {
        var vm = this;
        vm.state = $state.$current;

        // id generator for alert variables grid
        var acNextId = 100;
        //id of the alert variables row currently being edited (0 is valid value for the very first row until saved)
        vm.acEditRowId = -1;
        //value for the next new row id, set as row index, see below, cannot be 0
        var paramNextId = 1;
        //id of the parameters row currently being edited (0 is valid value for the very first row until saved)
        vm.editRowId = -1;
        vm.editModel = {};
        vm.lastValidatedName = '';
        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;

        vm.resources = resources;
        vm.showDetails = true;
        vm.showLogic = false;
        vm.newScenario = false;
        vm.origScenarioName = 'NULL';
        vm.loading = true;
        vm.forms = {};
        vm.scenario = {parms: [], alertColumns: []};
        vm.segments = [];
        vm.usedActiveSegments = [];
        vm.parms = [];
        vm.parmsForm = {$dirty: false, $error: {}};
        vm.forms.parmsForm = vm.parmsForm;
        vm.alertColumns = [];
        vm.acForm = {$dirty: false, $error: {}};
        vm.forms.acForm = vm.acForm;
        vm.showDeleted = false;
        vm.newScenario = false;
        vm.datasetColumns = [];
        vm.validSegmentationStatus = true; //set to false when segmentation is enabled by data set does not have ENTITY_SEGMENT_ID column
        vm.headerName = '';
        vm.header = {};  //currently header is loaded only for new scenarios to get header name and dataset name
        vm.nameError = false;
        vm.acError = false;
        //parameters grid data
        vm.grid = {};
        vm.amlGridActions = [];
        vm.filterString = '';
        //alert columns grid data
        vm.ac = {};
        vm.ac.grid = {};
        vm.ac.amlGridActions = [];
        vm.ac.filterString = '';

        vm.preventActionParam = false;
        vm.preventActionAlert = false;

        function disableUnsafeActions () {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('scenario.scenarioActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }
        function enableUnsafeActions () {
            disableUnsafeActionsFlag = false;
        }

        function updateTabTitle() {
            var tabInfo = tabsListService.getTabInfo(vm.state.name);
            tabInfo.title = vm.scenario.name;
            tabInfo.params.scenarioName = vm.scenario.name;
            tabsListService.updateTabInfo(tabInfo, true);
        }

        function loadParms() {
            vm.parms = [];
            paramNextId = 1;
            if (!vm.newScenario) {
                for (var i = 0; i < vm.scenario.parms.length; i++) {
                    var parm = vm.scenario.parms[i];
                    vm.parms.push({
                        parmId: i + 1,
                        entitySegmentId: parm.entitySegmentId,
                        activeSegmentInd : parm.activeSegmentInd ? parm.activeSegmentInd : 'N',
                        name: parm.name,
                        description: parm.description,
                        type: parm.type,
                        value: parm.value,
                        btlValue: parm.btlValue
                    });
                }
                paramNextId = vm.parms.length + 1;
            }
        }

        function loadAlertColumns() {
            vm.alertColumns = [];
            if (!vm.newScenario) {
                for (var i = 0; i < vm.scenario.alertColumns.length; i++) {
                    var ac = vm.scenario.alertColumns[i];
                    vm.alertColumns.push({
                        acId: i + 1,
                        columnName: ac.columnName,
                        usageCode: ac.usageCode
                    });
                }
            }
        }
        // strip parmId, segmentName, etc, server will not accept them
        function updateParms (parmsIn) {
            var newParms = [];
            for (var i = 0; i < parmsIn.length; i++) {
                var row = parmsIn[i];
                newParms.push({name: row.name, entitySegmentId: row.entitySegmentId, activeSegmentInd: row.activeSegmentInd,
                               description: row.description, type: row.type, value: row.value, btlValue: row.btlValue});
            }
            return newParms;
        }
        // strip acId field, server will not accept it
        function updateAlertColumns (acIn) {
            var newAC = [];
            for (var i = 0; i < acIn.length; i++) {
                var row = acIn[i];
                newAC.push({columnName: row.columnName, usageCode: row.usageCode});
            }
            return newAC;
        }

        //when page is initialized scenario data may be not loaded yet, so parameters table and
        //alert variables table may be empty because read function on the transport object was invoked
        //before the data was loaded. One way to resolve this is to use k-ng-delay on kendo-grid,
        //this was used initially but was refactored in attempt to get rid of  "Invalid Argument" exception in IE.
        //Another way is to re-load grids after the data was loaded and not to use k-ng-delay, this is the purpose
        //of the setInitialGridState function.
        function setInitialGridState(type) {
            if (!type) {
                vm.cancelParamChanges();
                vm.configureParamGrid();
                vm.cancelACChanges();
                return;
            } else if (type === 'parms') {
                vm.cancelParamChanges();
                vm.configureParamGrid();
                return;
            } else if (type === 'ac') {
                vm.cancelACChanges();
                return;
            }
        }

        function updateHeaderID(loadHeaderFlag) {
            vm.scenario.headerID = parseInt(vm.headerID, 10);
            if (isNaN(vm.scenario.headerID) || vm.scenario.headerID === -1) {
                vm.scenario.headerID = -1;
                vm.scenario.headerName = '';
                vm.scenario.datasetName = '';
                vm.header = {};
                vm.datasetColumns = [];
                vm.scenario.primaryEntityNumberVariableName = '';
                vm.scenario.entityLevelCode = '';
            }
            if (vm.scenario.headerID > 0 && loadHeaderFlag) {
                var hprom = headerService.getHeader(vm.scenario.headerID);
                var both = $q.all([hprom]);

                both.then(function (data) {
                        vm.header = data[0];
                        vm.scenario.headerName = vm.header.name;
                        vm.scenario.datasetName = vm.header.datasetName;
                        if (vm.scenario.datasetName && vm.scenario.datasetName !== '') {
                            //header with id=-1 has dataset name as N/A
                            if (vm.scenario.datasetName === 'N/A' || vm.scenario.headerID === -1) {
                                vm.scenario.datasetName = '';
                            } else {
                                vm.loadDataset(vm.scenario.datasetName);
                            }
                        }
                        //if (vm.newScenario && vm.loading && vm.header.scenarios && vm.header.scenarios.length > 0) {
                        //    vm.scenario.orderInHeader = _.max(vm.header.scenarios, 'orderInHeader') + 10;
                        //}
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('header.headerReadErrorTxt',
                            {'headerId': vm.scenario.headerID}), null, -1);
                    });
            }
        }

        function formsAreDirty () {
            var names = Object.getOwnPropertyNames(vm.forms);
            for (var i = 0; i < names.length; i++) {
                if (vm.forms[names[i]].$dirty) {
                    return true;
                }
            }
            return false;
        }

        function updateScenario (scenarioIn, discardFlag) {
            var defer = $q.defer();
            var uprom;
            if (vm.newScenario) {
                uprom = scenarioService.createNewScenario(scenarioIn);
            } else {
                uprom = scenarioService.updateScenario(scenarioIn);
            }

            if (uprom) {
                uprom.then(function (data) {
                        vm.scenario = data;
                        vm.state.data.dirty = false; //to allow tab be closed without callback
                        if (!discardFlag) {
                            tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
                            $state.go('scenarioDetails',
                                {
                                    headerID: vm.scenario.headerID,
                                    scenarioName: vm.scenario.name,
                                    scenarioID: vm.scenario.scenarioID
                                }
                            );
                        }
                        messageService.success(
                            resources.aml.getResource('scenario.scenarioSavedTxt',
                                {'name': scenarioIn.name}), null, 4000);
                        defer.resolve('entity updated');
                    },
                    function (error) {
                        messageService.danger(resources.aml.getResource('scenario.scenarioSaveFailedErrorTxt',
                            {'name': scenarioIn.name}), null, -1);
                        if (error.status === 409) {
                            messageService.danger(resources.aml.getResource('scenario.scenarioUpdateConflictErrorTxt'), null, -1);
                        }
                        defer.reject(error);
                    }).finally( function () {enableUnsafeActions();});
            } else {
                enableUnsafeActions();
                messageService.danger(resources.aml.getResource('scenario.scenarioSaveFailedErrorTxt',
                    {'name': scenarioIn.name}), null, -1);
                logger.info('uprom is null in updateScenario');
                defer.reject('promise is null while updating entity');
            }
            return defer.promise;
        }
        //validate that all alert columns that have usage code as Prep Data Set Var
        //are actual prep data set variables. This is needed because prep data set may change or
        //user can type var name incorrectly.
        function validPrepVars(alertColumns, datasetColumns) {
            if (!datasetColumns) { return true;} //when dataset is not loaded yet
            if (datasetColumns.length === 0) { return true;} //when dataset is empty
             for (var i=0; i < alertColumns.length; i++) {
                if (alertColumns[i].usageCode === 'S') {
                    var match = _.where(datasetColumns, {name: alertColumns[i].columnName});
                    if (match.length !== 1) {
                        return false;
                    }
                }
            }
            return true;
        }

        function isScenarioNameValid () {
            //if the name has not changed still need to verify other headers
            //because table does not have unique constraint
            var match = _.where(vm.scenarioNames, {code: vm.scenario.name});
            // new scenario name must be unique
            if (vm.newScenario && match.length > 0) {
                return false;
            }
            // existing scenario name must be unique
            if (!vm.newScenario) {
                if (vm.scenario.name === vm.origScenarioName) {
                    // it is invalid situation if scenario names list is empty,
                    // but allow user to save scenario
                    if (!vm.scenarioNames || vm.scenarioNames.length === 0) {
                        return true;
                    }
                    //if name has not changed then there must be only one match
                    return (match.length === 1);
                }
                //if name has changed then it cannot match existing scenario
                if (match.length > 0) {
                    return false;
                }
            }
            return true;
        }

        function areParametersValid() {
            // Segments - if parameters are not empty then there must be at least one parameter for Default segment
            // this is validated in formsHaveErrors
            // Primary key must be valid: segment_id, scenario_id, parm_name
            var name = null;
            var entitySegmentId = null;
            // for each parameter validate that there is only one combination of name+entitySegmentId in the list
            for (var p = 0; p < vm.parms.length; p++) {
                name = vm.parms[p].name;
                entitySegmentId = vm.parms[p].entitySegmentId;
                var match = _.where(vm.parms, {name: name, entitySegmentId: entitySegmentId});
                if (match.length > 1) {
                    messageService.danger(resources.aml.getResource('scenario.paramNotUniqueErrorTxt',
                            {parameterName: name, segmentName: segmentNameFilter(vm.parms[p])}), null, -1);
                    return false;
                }
            }
            // validate that the list of parameters is the same for all segments
            // note that all parameter names are unique within each segment
            var parmsValid = true;
            var defaultParams = _.where(vm.parms, {entitySegmentId: -1});
            var segmentIds = _.pluck(vm.parms, 'entitySegmentId'); //all segments used
            var uniqueSegments = _.uniq(segmentIds);
            for (var j = 0; j < uniqueSegments.length; j++) {
                if (uniqueSegments[j] !== -1) {
                    var segmentParams = _.where(vm.parms, {entitySegmentId: uniqueSegments[j]});
                    if (segmentParams.length !== defaultParams.length) {
                        messageService.danger(resources.aml.getResource('scenario.numberOfParametersNotEqualErrorTxt',
                            {segmentName: segmentNameFilter(segmentParams[0])}), null, -1);
                        parmsValid = false;
                    } else {
                        // validate that each segment parameter has a match in the default parameter
                        // there will be zero or single match because all names are unique within segment
                        for (var s = 0;  s < segmentParams.length; s++) {
                            var parmMatch = _.findWhere(defaultParams, {name: segmentParams[s].name, type: segmentParams[s].type});
                            if (!parmMatch) {
                                messageService.danger(resources.aml.getResource('scenario.defaultParamNotFoundErrorTxt',
                                    {parameterName: segmentParams[s].name, segmentName: segmentNameFilter(segmentParams[s])}), null, -1);
                                parmsValid = false;
                            }
                        }
                        // if all found and because size is is equal then parameters match
                    }
                }
            }
            return parmsValid;
        }

        function noDollarSign (aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        vm.unbindSourceCodeForm = $scope.$watch('vm.sourceCodeForm', function () {
            vm.forms.sourceCodeForm = vm.sourceCodeForm;
            $scope.$watch('vm.forms.sourceCodeForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            vm.unbindSourceCodeForm();
        });

        var unbindExecForm = $scope.$watch('vm.execForm', function () {
            vm.forms.execForm = vm.execForm;
            $scope.$watch('vm.forms.execForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindExecForm();
        });

        var unbindBasicForm = $scope.$watch('vm.basicForm', function () {
            vm.forms.basicForm = vm.basicForm;
            $scope.$watch('vm.forms.basicForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindBasicForm();
        });

        var unbindHeaderForm = $scope.$watch('vm.headerForm', function () {
            vm.forms.headerForm = vm.headerForm;
            $scope.$watch('vm.forms.headerForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindHeaderForm();
        });

        var unbindParamForm = $scope.$watch('vm.paramForm', function () {
            vm.forms.paramForm = vm.paramForm;
            $scope.$watch('vm.forms.paramForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindParamForm();
        });

        function findSegmentParam (segmentId) {
            var parmMatch = _.find(vm.parms, function (parm) {
                return parm.entitySegmentId.toString() === segmentId.toString();
            });
            return parmMatch ? true : false;
        }

        //do not call this function before scenario parameters are loaded
        function checkSegmentsUsage (deleteDeleted) {
            vm.usedActiveSegments = [];
            for (var i=0; i < vm.segments.length; i++) {
                vm.segments[i].isSegmentUsed = findSegmentParam(vm.segments[i].entitySegmentId);
                if (vm.segments[i].logicalDeleteInd==='N' && vm.segments[i].activeInd==='Y' || vm.segments[i].isSegmentUsed) {
                    vm.usedActiveSegments.push(vm.segments[i]);
                }
                //delete segments that are not used and marked as deleted - this has to be done only when sceanrio is loaded
                //otherwise clear changes may restore parameters for deleted segments and will not find them
                if (deleteDeleted && !vm.segments[i].isSegmentUsed && vm.segments[i].logicalDeleteInd === 'Y') {
                    vm.segments.splice(i,1);
                    i--; //to process next element that will have the same index as just deleted
                }
            }
        }

        function checkDefaultParams () {
            vm.hasDefaultParams =  findSegmentParam(-1);
        }

        function findSegmentById (segmentId) {
            var segment = _.find(vm.segments, function (segment) {
                if (segment.entitySegmentId) {
                    return segment.entitySegmentId.toString() === segmentId.toString();
                }
            });
            return segment;
        }

        // ******************************************************************************************
        //                              Parameters grid
        // ******************************************************************************************
        //initParamGridOptions is called when scenario data is loaded (existing)  or initialized (new)
        //the execution order must be:
        //  - load segments needed for grid and html
        //  - load scenario names - for validation
        //  - load scenario data
        //  - init vm.parms - needed for grid filters and for the next step
        //  - update vm.segments - delete deleted segments that are not used
        //  - initParamGridOptions
        //  - reload grid data
        function initParamGridOptions () {
            vm.paramTypes = amlLov.getAsArray(amlLov.scenarioParameterType);
            var scenarioParameterTypeRenderingFilter = kendoGridRendererService.enum('type', 'scenarioParameterType');
            var activeSegmentIndRenderingFilter = kendoGridRendererService.enum('activeSegmentInd', 'yesOrNo');
            var segmentFilter = kendoGridRendererService.getCheckboxFilterForValues(
                vm.segments,
                true,
                'segmentName',
                'entitySegmentId',
                'localizedSegmentName'
            );



            var getIndexById = function (array, id) {
                var l = array.length;
                for (var j=0; j < l; j++) {
                    if (array[j].parmId === id) {
                        return j;
                    }
                }
                return null;
            };

            var isParamNameUnique = function (name) {
                vm.lastValidatedName = name;
                if (name === '') {
                    return true;
                }
                if (vm.editRowId < 0 || vm.parms.length === 0) {
                    return true; //first parameter
                }
                var entitySegmentId = -1;
                if (vm.editRowId > 0) {
                    entitySegmentId = vm.parms[getIndexById(vm.parms, vm.editRowId)].entitySegmentId;
                } else {
                    //for new parameter paramId will be zero
                    entitySegmentId = vm.editModel.entitySegmentId;
                }
                var match = _.where(vm.parms, {name: name, entitySegmentId: entitySegmentId});
                // param name must be unique
                if (match.length > 1) {
                    return false;
                }

                if (match.length === 1) {
                    // need to verify when length === 1 that it the same row as the one that is being validated
                    // for the new parameter editRowId will be zero, so if we found match in parms then it is an error
                    var parmMatch = _.find(vm.parms, function (parm) {
                        return parm.name === name && parm.entitySegmentId === entitySegmentId;
                    });
                    return parmMatch.parmId === vm.editRowId;
                }
                return true;
            };

            //cancel parameters grid changes
            vm.cancelParamChanges = function (e) {
                loadParms();
                vm.grid.dataSource.read();
                //refresh not needed: http://www.telerik.com/forums/show-progress-spinner-during-load-refresh
                //vm.grid.refresh();
                vm.editRowId = -1;
                checkSegmentsUsage();
                checkDefaultParams();
            };


            vm.addSegmentParameters = function(segmentId) {
                //Add button is disabled  if Edit action is not complete
                if (segmentId) {
                    var defaultParams = _.where(vm.parms, {entitySegmentId: -1});
                    var segment = _.findWhere(vm.segments, {entitySegmentId: segmentId});
                    for (var j = 0; j < defaultParams.length; j++) {
                        //copy parameter
                        var newParam = Object.assign({},defaultParams[j]);
                        newParam.entitySegmentId = segmentId;
                        newParam.isSegmentUsed = true;
                        newParam.parmId = paramNextId++;
                        if (segment) { //copy Active flag from segment, it might be Inactive
                            newParam.activeSegmentInd = segment.activeInd;
                        }
                        vm.parms.push(newParam);
                    }
                    //read resets form dirty flag
                    vm.grid.dataSource.read();
                    vm.parmsForm.$dirty = true;
                    checkSegmentsUsage();
                    checkDefaultParams();
                }
            };
            vm.deleteSegmentParameters = function(segmentId) {
                //Delete button is disabled  if Edit action is not complete
                if (segmentId) {
                    for (var j = 0; j < vm.parms.length; j++) {
                        if (vm.parms[j].entitySegmentId === segmentId) {
                            vm.parms.splice(j, 1);
                            j--; //to process next element that will have the same index as just deleted
                        }
                    }
                    //read resets form dirty flag
                    vm.grid.dataSource.read();
                    vm.parmsForm.$dirty = true;
                    checkSegmentsUsage();
                    checkDefaultParams();
                }
            };

            var btlRequired = false;

            vm.configureParamGrid = function () {
                if (vm.scenario.btlEnabledInd === 'Y') {
                    vm.grid.showColumn('btlValue');
                    btlRequired = true;
                } else {
                    vm.grid.hideColumn('btlValue');
                    btlRequired = false;
                }
                vm.grid.showColumn('segmentId');
                vm.grid.showColumn('activeSegmentInd');
                checkSegmentsUsage();
                checkDefaultParams();
            };

            vm.gridColumns = [
                {
                    field: 'name', title: resources.aml.scenario.params.name,
                    width: '20%'
                },
                {
                    field: 'entitySegmentId', title: resources.aml.scenario.params.segmentName,
                    width: '10%',
                    template: segmentNameFilter,
                    editor: function (container, options) {
                        var input = $('<input id="entitySegmentId" name="entitySegmentId" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            autoBind: true,
                            dataTextField: 'segmentName',
                            dataValueField: 'entitySegmentId',
                            dataSource: vm.usedActiveSegments
                        }); //.appendTo(container)
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(segmentNameFilter)},
                    filterable: segmentFilter
                },
                {
                    field: 'activeSegmentInd', title: resources.aml.scenario.params.activeSegmentInd,
                    width: '5%',
                    template: activeSegmentIndRenderingFilter,
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(activeSegmentIndRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
                },
                {
                    field: 'type', title: resources.aml.scenario.params.type,
                    width: '10%',
                    template: scenarioParameterTypeRenderingFilter,
                    editor: function (container, options) {
                        var input = $('<input id="paramType" name="paramType" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            autoBind: true,
                            dataTextField: 'value',
                            dataValueField: 'key',
                            dataSource: vm.paramTypes
                        }); //.appendTo(container)
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(scenarioParameterTypeRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('scenarioParameterType')
                },
                {
                    field: 'description', title: resources.aml.scenario.params.description,
                    width: '20%'
                },
                {
                    field: 'value', title: resources.aml.scenario.params.value,
                    width: '15%'
                },
                {
                    field: 'btlValue', title: resources.aml.scenario.params.btlValue,
                    width: '15%'
                },
                {
                    command: ['edit', 'destroy'],
                    width: '15%'
                }
            ];

            function setEnabledParam(enabled) {
                //mark Edit and Delete buttons so we can find them later, this has to be done each time
                //because Kendo removes them when going into edit mode and replaces with Update and Cancel
                //and then adds them back after edit is complete
                $('.k-grid-delete', '#scenarioParameters').addClass('k-delete-button');
                $('.k-grid-edit', '#scenarioParameters').addClass('k-edit-button');
                $('.dropdown-toggle', '#scenarioParameters').addClass('k-options-button');

                //disable all buttons except Update and Cancel when in Edit mode, so that row cannot be closed unfinished
                if (enabled) {
                    //restore Kendo expected classes and attributes based on our marker classes
                    $('.k-add-button', '#scenarioParameters').removeClass('k-state-disabled').addClass('k-grid-add').attr('disabled', false);
                    $('.k-cancel-button', '#scenarioParameters').removeClass('k-state-disabled').addClass('k-grid-cancel').attr('disabled', false);
                    $('.k-edit-button', '#scenarioParameters').removeClass('k-state-disabled').addClass('k-grid-edit').attr('href', '#');
                    $('.k-delete-button', '#scenarioParameters').removeClass('k-state-disabled').addClass('k-grid-delete').attr('href', '#');
                    $('.k-options-button', '#scenarioParameters').removeClass('k-state-disabled').attr('disabled', false);
                }
                else {
                    //remove Kendo classes and attributes to disable buttons
                    $('.k-add-button', '#scenarioParameters').addClass('k-state-disabled').removeClass('k-grid-add').attr('disabled', true);
                    $('.k-cancel-button', '#scenarioParameters').addClass('k-state-disabled').removeClass('k-grid-cancel').attr('disabled', true);
                    $('.k-edit-button', '#scenarioParameters').addClass('k-state-disabled').removeClass('k-grid-edit').removeAttr('href');
                    $('.k-delete-button', '#scenarioParameters').addClass('k-state-disabled').removeClass('k-grid-delete').removeAttr('href');
                    $('.k-options-button', '#scenarioParameters').addClass('k-state-disabled').attr('disabled', true);
                }
            }

            vm.dataSourceOptions = new kendo.data.DataSource({
                transport: {
                    read: function (e) {
                        vm.parmsForm.$dirty = false;
                        e.success(vm.parms);
                    },
                    create: function (e) {
                        //this is called after all the validation has been done and they are successful
                        e.data.parmId = paramNextId++;
                        // set active flag for UI (when new parm is created deault value Yes is used
                        e.data.activeSegmentInd = findSegmentById(e.data.entitySegmentId).activeInd;
                        //this is workaround for the following kendo grid issue:
                        //name is entered but it is duplicate within currently selected segment, so kendo does not update the model
                        //segment is changed, name is no longer duplicate, kendo does not update the model because segment cell is in focus
                        //Update is clicked, all cell are validated and correct, but name in the model is not updated!!!
                        //not sure if this is kendo bug or not
                        if (!e.data.name || e.data.name === '') {
                            e.data.name = vm.lastValidatedName; // validation was successful since we are here
                            vm.lastValidatedName = null;
                        }
                        vm.parms.push(e.data);
                        vm.parmsForm.$dirty = true;
                        checkSegmentsUsage();
                        checkDefaultParams();
                        e.success(e.data);
                    },
                    update: function (e) {
                        //see comment in create event above
                        if (!e.data.name || e.data.name === '') {
                            e.data.name = vm.lastValidatedName; // validation was successful since we are here
                            vm.lastValidatedName = null;
                        }
                        vm.parms[getIndexById(vm.parms, e.data.parmId)] = e.data;
                        vm.parmsForm.$dirty = true;
                        checkSegmentsUsage();
                        checkDefaultParams();
                        e.success();
                    },
                    destroy: function (e) {
                        vm.parms.splice(getIndexById(vm.parms, e.data.parmId), 1);
                        vm.parmsForm.$dirty = true;
                        checkSegmentsUsage();
                        checkDefaultParams();
                        e.success();
                    }
                },
                batch: false,
                schema: {
                    model: {
                        id: 'parmId',
                        fields: {
                            parmId: {type: 'number', editable: false, nullable: false},
                            name: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.scenario.nameMissingErrorTxt},
                                    pattern: {
                                        value: '^[^\\d\\W]\\w{0,31}$',
                                        message: resources.aml.scenario.nameTooLongErrorTxt
                                    },
                                    unique: function (input) {
                                        if (input.is('[name=\'name\']') && input.val().length > 0) {
                                            if (isParamNameUnique(input.val())) {
                                                return true;
                                            } else {
                                                //set custom error message
                                                input.attr('data-unique-msg', resources.aml.scenario.nameIsNotUniqueErrorTxt);
                                                return false;
                                            }
                                        } else {
                                            return true;
                                        }
                                    }
                                }
                            },
                            description: {
                                type: 'string',
                                validation: {
                                    required: {message: resources.aml.scenario.descriptionRequiredErrorTxt},
                                    pattern: {
                                        value: '^[^]{1,255}$',
                                        message: resources.aml.scenario.descriptionTooLongErrorTxt
                                    }
                                }
                            },
                            type: {type: 'string', validation: {required: true},
                                defaultValue: 'Numeric Constant'
                            },
                            entitySegmentId: {type: 'number',
                                validation: {required: true},
                                defaultValue: -1
                            },
                            activeSegmentInd: {type: 'string', editable: false, defaultValue: 'Y' },
                            value: {
                                type: 'string', validation: {
                                    required: {message: resources.aml.scenario.valueIsRequiredErrorTxt},
                                    pattern: {
                                        value: '^[^]{1,1024}$',
                                        message: resources.aml.scenario.valueIsTooLongErrorTxt
                                    }
                                }
                            },
                            btlValue: {
                                type: 'string', validation: {
                                    btlreq: function (input) {
                                        if (input.is('[name=\'btlValue\']') && btlRequired) {
                                            if (input.val().length > 0) {
                                                return true;
                                            } else {
                                                //set custom error message
                                                input.attr('data-btlreq-msg', resources.aml.scenario.valueIsRequiredErrorTxt);
                                                return false;
                                            }
                                        } else {
                                            return true;
                                        }
                                    },
                                    pattern: {
                                        value: '^[^]{1,1024}$',
                                        message: resources.aml.scenario.valueIsTooLongErrorTxt
                                    }
                                }
                            }
                        }
                    }
                },
                requestStart: function (e) {
                    //prevent grid navigation including paging controls, filters and sorting
                    if (vm.preventActionParam) {
                        e.preventDefault();       //this prevents the creation of a new record when clicking on a different grid
                    }
                },
                serverPaging: false,
                serverSorting: false,
                serverFiltering: false
            });
            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
                {
                    dataSource: vm.dataSourceOptions,
                    columns: vm.gridColumns,
                    pageable: false,
                    editable: {
                        mode: 'inline',
                        confirmation: false
                    },
                    //isCancel : true,
                    resizable: true,
                    selectable: 'multiple cell',
                    allowCopy: true,
                    filterable: true,
                    batch: false,
                    toolbar: [{text: '', template: kendo.template($('#grid_toolbar').html())}],
                    scrollable: false,
                    sortable: {
                        mode: 'multiple',
                        allowUnsort: true
                    },
                    //true value for navigatable causes 'Invalid Argument' exception in IE 11
                    navigatable: false,
                    edit: function (e) {
                        vm.preventActionParam = true;

                        if (vm.editRowId > -1) {
                            // this means that another row has not being saved - prevent this if possible
                            e.preventDefault();
                            messageService.warning(resources.aml.getResource('scenario.parameterNotSavedErrorTxt'), null, -1);
                        }
                        vm.editRowId = e.model.parmId; //for new parameter paramId will be zero
                        vm.editModel = e.model; //save the model, so validation will have access to it
                        vm.lastValidatedName = vm.editModel.name;
                        setEnabledParam(!vm.preventActionParam);
                    },
                    save: function (e) {
                        vm.editRowId = -1;
                    },
                    cancel: function (e) {
                        vm.editRowId = -1;
                        vm.preventActionParam = false;
                        setEnabledParam(!vm.preventActionParam);
                    },
                    dataBound: function () {
                        vm.preventActionParam = false;
                        setEnabledParam(!vm.preventActionParam);
                        //bind our own Add button click handler, so that grid could be unsorted and row will be inserted on top
                        //see https://docs.telerik.com/kendo-ui/knowledge-base/capture-the-add-event-of-the-grid
                        $('.k-grid-add').unbind('click');
                        $('.k-grid-add').bind('click', function(){
                            kendoGridRendererService.clearFilters(vm.grid);
                            kendoGridRendererService.clearSorts(vm.grid);

                        });
                    }
                });

            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'scenarioParameters');
        }
        // ******************************************************************************************
        //                              Alert variables grid
        // ******************************************************************************************

        function initACGridOptions () {
            vm.usageCodes = amlLov.getAsArray(amlLov.alertColumnUsageCode);
            var usageCodeRenderingFilter = kendoGridRendererService.enum('usageCode', 'alertColumnUsageCode');
            vm.accollapsed = true;
            var getIndexById = function (array, id) {
                var l = array.length;
                for (var j=0; j < l; j++) {
                    if (array[j].acId === id) {
                        return j;
                    }
                }
                return null;
            };

            var isColumnNameUnique = function (name) {
                if (!name) {
                    return false;
                }
                if (name === '') {
                    return false;
                }
                var match = _.where(vm.alertColumns, {columnName: name});
                // column name must be unique
                if (match.length > 1) {
                    return false;
                }
                if (match.length === 1) {
                    //need to verify when length === 1 that it the same row as the one that is being validated
                    var columnMatch = _.find(vm.alertColumns, function (col) {
                        return col.columnName === name;
                    });
                    return columnMatch.acId === vm.acEditRowId;
                }
                return true;

            };
            vm.ac.gridColumns = [
                {
                    field: 'usageCode', title: resources.aml.scenario.ac.usageCode,
                    width: '25%',
                    template: usageCodeRenderingFilter,
                    editor: function (container, options) {
                        var input = $('<input id="acUsageCode" name="acUsageCode" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);

                        input.kendoDropDownList({
                            //autoBind: true,
                            dataTextField: 'value',
                            dataValueField: 'key',
                            dataSource: vm.usageCodes
                        });
                    },
                    sortable: {compare: kendoGridRendererService.getFilterSortFunction(usageCodeRenderingFilter)},
                    filterable: kendoGridRendererService.getCheckboxFilter('alertColumnUsageCode')
                },
                {
                    field: 'columnName', title: resources.aml.scenario.ac.name,
                    width: '60%',
                    editor: function (container, options) {
                        var input = $('<input id="dsColumnName" name="dsColumnName" data-bind="value: ' + options.field + '" />');
                        input.appendTo(container);
                        input.kendoComboBox({
                            //autoBind: true,
                            dataTextField: 'name',
                            dataValueField: 'name',
                            dataSource: vm.datasetColumns
                        });
                        //add span for error messages
                        $('$<span class="k-invalid-msg" data-for="dsColumnName"></span>').appendTo(container);
                    }
                },
                {
                    command: ['edit', 'destroy'],
                    width: '15%'
                }
            ];

            //cancel parameters grid changes
            vm.cancelACChanges = function (e) {
                loadAlertColumns();
                vm.acEditRowId = -1;
                vm.ac.grid.dataSource.read();
                vm.ac.grid.refresh();
            };



            function setEnabledAlert(enabled) {
                //mark Edit and Delete buttons so we can find them later, this has to be done each time
                //because Kendo removes them when going into edit mode and replaces with Update and Cancel
                //and then adds them back after edit is complete
                $('.k-grid-delete', '#alertColumns').addClass('k-delete-button');
                $('.k-grid-edit', '#alertColumns').addClass('k-edit-button');
                $('.dropdown-toggle', '#alertColumns').addClass('k-options-button');

                //disable all buttons except Update and Cancel when in Edit mode, so that row cannot be closed unfinished
                if (enabled) {
                    //restore Kendo expected classes and attributes based on our marker classes
                    $('.k-add-button', '#alertColumns').removeClass('k-state-disabled').addClass('k-grid-add').attr('disabled', false);
                    $('.k-cancel-button', '#alertColumns').removeClass('k-state-disabled').addClass('k-grid-cancel').attr('disabled', false);
                    $('.k-edit-button', '#alertColumns').removeClass('k-state-disabled').addClass('k-grid-edit').attr('href', '#');
                    $('.k-delete-button', '#alertColumns').removeClass('k-state-disabled').addClass('k-grid-delete').attr('href', '#');
                    $('.k-options-button', '#alertColumns').removeClass('k-state-disabled').attr('disabled', false);
                }
                else {
                    //remove Kendo classes and attributes to disable buttons
                    $('.k-add-button', '#alertColumns').addClass('k-state-disabled').removeClass('k-grid-add').attr('disabled', true);
                    $('.k-cancel-button', '#alertColumns').addClass('k-state-disabled').removeClass('k-grid-cancel').attr('disabled', true);
                    $('.k-edit-button', '#alertColumns').addClass('k-state-disabled').removeClass('k-grid-edit').removeAttr('href');
                    $('.k-delete-button', '#alertColumns').addClass('k-state-disabled').removeClass('k-grid-delete').removeAttr('href');
                    $('.k-options-button', '#alertColumns').addClass('k-state-disabled').attr('disabled', true);
                }
            }

            vm.ac.dataSourceOptions = new kendo.data.DataSource({
                transport: {
                    read: function (e) {
                        vm.acForm.$dirty = false;
                        acNextId = vm.scenario.alertColumns.length + 1;
                        vm.acError = !validPrepVars(vm.alertColumns, vm.datasetColumns);
                        e.success(vm.alertColumns);
                    },
                    create: function (e) {
                        e.data.acId = acNextId++;
                        vm.alertColumns.push(e.data);
                        vm.acForm.$dirty = true;
                        vm.acError = !validPrepVars(vm.alertColumns, vm.datasetColumns);
                        e.success(e.data);
                    },
                    update: function (e) {
                        vm.acForm.$dirty = true;
                        vm.alertColumns[getIndexById(vm.alertColumns, e.data.acId)] = e.data;
                        vm.acError = !validPrepVars(vm.alertColumns, vm.datasetColumns);
                        e.success();
                    },
                    destroy: function (e) {
                        vm.alertColumns.splice(getIndexById(vm.alertColumns, e.data.parmId), 1);
                        vm.acForm.$dirty = true;
                        vm.acError = !validPrepVars(vm.alertColumns, vm.datasetColumns);
                        e.success();
                    }
                },
                batch: false,
                schema: {
                    model: {
                        id: 'acId',
                        fields: {
                            acId: {type: 'number', editable: false, nullable: false},
                            usageCode: {
                                type: 'string',
                                validation: {required: true},
                                defaultValue: 'S'
                            },
                            columnName: {
                                type: 'string',
                                validation: {
                                    //standard validations required and pattern do not work with custom editor
                                    required: {message: resources.aml.scenario.columnNameMissingErrorTxt},
                                    pattern: {
                                        value: '^[^\\d\\W]\\w{0,31}$',
                                        message: resources.aml.scenario.nameTooLongErrorTxt
                                    },
                                    unique: function (input) {
                                        if (input.is('[name=\'dsColumnName\']')) {
                                            if (input.val().length === 0) {
                                                input.attr('data-unique-msg', resources.aml.scenario.columnNameMissingErrorTxt);
                                                return false;
                                            } else {
                                                if (isColumnNameUnique(input.val())) {
                                                    return true;
                                                } else {
                                                    //set custom error message
                                                    input.attr('data-unique-msg', resources.aml.scenario.columnNameIsNotUniqueErrorTxt);
                                                    return false;
                                                }
                                            }
                                        }
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                },
                requestStart: function (e) {
                    //prevent grid navigation including paging controls, filters and sorting
                    if (vm.preventActionAlert) {
                        e.preventDefault();
                    }
                },
                serverPaging: false,
                serverSorting: false,
                serverFiltering: false
            });

            vm.ac.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
                {
                    dataSource: vm.ac.dataSourceOptions,
                    columns: vm.ac.gridColumns,
                    pageable: false,
                    editable: {
                        mode: 'inline',
                        confirmation: false
                    },
                    //isCancel : true,
                    selectable: 'multiple cell',
                    resizable: true,
                    allowCopy: true,
                    filterable: true,
                    batch: false,
                    toolbar: [{text: '', template: kendo.template($('#ac_grid_toolbar').html())}],
                    scrollable: false,
                    sortable: {
                        mode: 'multiple',
                        allowUnsort: true
                    },
                    //true value for navigatable causes 'Invalid Argument' exception in IE 11
                    navigatable: false,
                    edit: function (e) {
                        vm.preventActionAlert = true;

                        if (vm.acEditRowId > -1) {
                            // this means that another row has not being saved - prevent this if possible
                            e.preventDefault();
                            messageService.warning(resources.aml.getResource('scenario.acNotSavedErrorTxt'), null, 5000);
                        }
                        vm.acEditRowId = e.model.acId;
                        setEnabledAlert(!vm.preventActionAlert);
                    },
                    save: function (e) {
                        vm.acEditRowId = -1;
                    },
                    cancel: function (e) {
                        vm.acEditRowId = -1;
                        vm.preventActionAlert = false;
                        setEnabledAlert(!vm.preventActionAlert);
                    },
                    dataBound: function () {
                        vm.preventActionAlert = false;
                        setEnabledAlert(!vm.preventActionAlert);
                        //bind our own Add button click handler, so that grid could be unsorted and row will be inserted on top
                        //see https://docs.telerik.com/kendo-ui/knowledge-base/capture-the-add-event-of-the-grid
                        $('.k-grid-add').unbind('click');
                        $('.k-grid-add').bind('click', function(){
                            kendoGridRendererService.clearFilters(vm.ac.grid);
                            kendoGridRendererService.clearSorts(vm.ac.grid);

                        });
                    }
                });

            kendoGridRendererService.initialize(vm.ac, vm.ac.grid, vm.ac.gridOptions, $scope, null, 'alertColumnsGrid');
        }

        vm.getScenarioNames = function () {
            var defer = $q.defer();
            scenarioService.getScenarioNames(true).then(function (scenarioNames) {
                    vm.scenarioNames = scenarioNames;
                    defer.resolve(true);
                },
                function (reason) {
                    defer.resolve(false);
                });
            return defer.promise;

        };

        // ******************************************************************************************
        //                  initialize
        // ******************************************************************************************
        // if data set does not have ENTITY_SEGMENT_ID column then segmentation should not be used
        function validateSegmentationStatus () {
            if (vm.datasetColumns.length !== 0) {
                var column = _.findWhere(vm.datasetColumns, {name: 'ENTITY_SEGMENT_ID'} );
                if (!column && vm.scenario && vm.scenario.segmentsEnabledInd === 'Y') {
                    vm.validSegmentationStatus = false;
                } else {
                    vm.validSegmentationStatus = true;
                }
            }
        }
        function init() {
            vm.state.data.dirty = false;

            vm.actionsDisabled = function () {
                return disableUnsafeActionsFlag || vm.scenario.currentInd !== 'Y';
            };

            vm.loadDataset = function (datasetName) {
                datasetService.getDataset(datasetName).then(function (data) {
                        vm.datasetColumns = data.datasetColumns;
                        validateSegmentationStatus();
                        var msg = resources.aml.getResource('header.datasetLoadedTxt',
                            {'name': datasetName});
                        messageService.info(msg, null, 2000);
                    },
                    function (error) {
                        vm.loading = false;
                        var msg = resources.aml.getResource('header.datasetReadErrorTxt',
                            {'name': datasetName});
                        messageService.danger(msg, null, -1);
                    });
            };

            vm.updateTab = function (e) {
                if (!vm.basicForm.biName.$error.scenarioName && angular.isDefined(vm.scenario.name) && vm.scenario.name !== '') {
                    updateTabTitle();
                }
            };


            vm.getScenarioData = function (scenarioId) {
                vm.state.data.dirty = false;  // to set the tab pill to not
                var defer = $q.defer();

                 scenarioService.getScenario(scenarioId).then(function (data) {
                                vm.scenario = data;
                                vm.headerID = vm.scenario.headerID.toString();
                                vm.headerName = vm.scenario.headerName; //could be empty
                                $scope.currentScenario = vm.scenario;
                                vm.origScenarioName = vm.scenario.name;
                                vm.loading = false;
                                defer.resolve(true);
                            },
                            function (error) {
                                defer.resolve(false);
                                var msg = resources.aml.getResource('scenario.scenarioReadErrorTxt',
                                    {'scenarioId': scenarioId});
                                messageService.danger(msg, null, -1);
                                vm.state.data.dirty = false; //to allow tab be closed without callback
                                tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
                                $state.go('headers');
                            });
                 return defer.promise;
            };

            vm.saveScenario = function (discardFlag) {
                var defer = $q.defer();
                if (vm.editRowId > -1) {
                    messageService.danger(resources.aml.getResource('scenario.parameterNotSavedErrorTxt'), null, -1);
                    return;
                }
                if (vm.acEditRowId > -1) {
                    messageService.danger(resources.aml.getResource('scenario.acNotSavedErrorTxt'), null, -1);
                    return;
                }
                disableUnsafeActions();
                vm.getScenarioNames().then(
                    function success (result) {
                        if (vm.formsHaveErrors()) {
                            defer.reject('form has errors');
                            var modalInstance = $uibModal.open({
                                animation: true,
                                templateUrl: 'modalScenario.html',
                                controller: 'ScenarioModalController as viewVm',
                                size: 'm',
                                backdrop: 'static'
                            });
                            modalInstance.forms = vm.forms;

                            modalInstance.result.then(function () {
                            }, function () {
                                var names = Object.getOwnPropertyNames(vm.forms);
                                for (var i = 0; i < names.length; i++) {
                                    vm.dirtyAll(vm.forms[names[i]]);
                                }
                            });
                            enableUnsafeActions();
                        } else {
                            if (formsAreDirty()) {
                                vm.state.data.dirty = false;  // to set the tab pill to show an asterisk (dirty)
                            }
                            vm.scenario.parms = updateParms(vm.parms);
                            vm.scenario.alertColumns = updateAlertColumns(vm.alertColumns);
                            updateHeaderID(false); //no need to load header
                            var uprom = updateScenario(vm.scenario, discardFlag);
                            if (uprom && uprom !== null) {
                                uprom.then (
                                    function success (data) {
                                        $rootScope.$broadcast( 'scenarioChanged', { scenarioID: vm.scenario.scenarioID });
                                        defer.resolve(data);
                                    },
                                    function failure (reason) {
                                        //save failed,  so do not close the tab
                                        defer.reject(reason);
                                    }
                                );
                            } else {
                                // save failed, tab cannot be closed
                                defer.reject('update failed (promise is null)');
                            }
                        }
                    },
                    function error (reason) {
                        enableUnsafeActions();
                        messageService.danger(resources.aml.getResource('scenario.scenarioListReadErrorTxt'), null, -1);
                        defer.reject(reason);
                    }
                );
                return defer.promise;
            };

            vm.deleteScenario = function () {
                disableUnsafeActions();
                scenarioService.markScenarioAsDeleted(vm.scenario.scenarioID).then(function (data) {
                        vm.scenario.logicalDeleteInd = 'Y';
                        var msg = resources.aml.getResource('scenario.scenarioMarkedDeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenarioMarkedDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.undeleteScenario = function () {
                disableUnsafeActions();
                scenarioService.markScenarioAsUndeleted(vm.scenario.scenarioID).then(function (data) {
                        vm.scenario.logicalDeleteInd = 'N';
                        var msg = resources.aml.getResource('scenario.scenarioMarkedUndeletedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenarioMarkedUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.activateScenario = function () {
                disableUnsafeActions();
                scenarioService.activateScenario(vm.scenario).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenarioActivatedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenarioActivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.deactivateScenario = function () {
                disableUnsafeActions();
                scenarioService.deactivateScenario(vm.scenario).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenarioDeactivatedTxt');
                        messageService.success(msg, null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenarioDeactivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally( function () {enableUnsafeActions();});
            };

            vm.runScenario = function () {
            };

            vm.scenarioEditHeader = function () {
                if (vm.scenario.headerID > 0) {
                    $state.go('headerDetails', {headerID: vm.scenario.headerID, headerName: vm.headerName});
                }
            };

            vm.scenarioNewHeader = function () {
                var id = headerService.getNextId();
                //add newEntityFlag to pass the check in app.config on $stateChangeStart
                $state.go('headerDetails', {headerID: 'new_' + id.toString(), headerName: 'HDR_' + id.toString(), newEntityFlag: true});
            };

            // directive callback function
            vm.callback = function (item) {
                vm.fromCallback = 'User selected ' + angular.toJson(item);
            };

            //display all headers, even deleted, so that from scenario page header name is always visible
            vm.getHeaderNames = function () {
                headerService.getAllHeaders().then(function (data) {
                        var headers = data.items;
                        var names = [];
                        for (var i = 0; i < headers.length; i++) {
                            names.push({code: headers[i].headerID.toString(), value: headers[i].name});
                        }
                        vm.headerNames = _.sortBy(names, function (header) {
                            return header.value.toLowerCase();
                        });
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenarioReadHeadersErrorTxt');
                        messageService.danger(msg, null, -1);
                    });
            };

            vm.selectDetails = function () {
                vm.showDetails = true;
                vm.showLogic = false;
            };
            vm.selectLogic = function () {
                vm.showDetails = false;
                vm.showLogic = true;
            };

            vm.formsHaveErrors = function () {
                checkDefaultParams();
                vm.nameError = !isScenarioNameValid();
                var names = Object.getOwnPropertyNames(vm.forms);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (Object.getOwnPropertyNames(vm.forms[name].$error).length > 0) {
                        return true;
                    }
                }
                vm.acError = !validPrepVars(vm.alertColumns, vm.datasetColumns);
                return vm.nameError || vm.acError || (!vm.hasDefaultParams && vm.parms.length >0) || !areParametersValid();
            };

            vm.headerSelected = function (headerID) {
                updateHeaderID(true);
            };

            vm.toggleCollapsed = function (prefix) {
                if (prefix === 'b') {
                    vm.bcollapsed = !vm.bcollapsed;
                } else if (prefix === 'h') {
                    vm.hcollapsed = !vm.hcollapsed;
                } else if (prefix === 'e') {
                    vm.ecollapsed = !vm.ecollapsed;
                } else if (prefix === 'p') {
                    vm.pcollapsed = !vm.pcollapsed;
                } else if (prefix === 'parms') {
                    vm.parmscollapsed = !vm.parmscollapsed;
                } else if (prefix === 'ac') {
                    vm.accollapsed = !vm.accollapsed;
                } else if (prefix === 'c') {
                    vm.ccollapsed = !vm.ccollapsed;
                }
            };
            vm.statusSelected = function (status) {
                if (status === 'INA') {
                    vm.scenario.endDate = new Date();
                }
            };

            vm.dirtyAll = function (formIn) {
                var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
                for (var i = 0; i < names.length; i++) {
                    formIn[names[i]].$dirty = true;
                }
            };
            $scope.$watch('vm.forms.parmsForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            $scope.$watch('vm.forms.acForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });

            vm.bindChange = false;
            vm.categories = amlLov.getAsArray(amlLov.scenarioCategory);
            vm.statuss = amlLov.getAsArray(amlLov.scenarioStatus);
            vm.yesno = amlLov.getAsArray(amlLov.yesOrNo);
            vm.frequencies = amlLov.getAsArray(amlLov.scenarioFrequency);
            vm.scenarioTypes = amlLov.getAsArray(amlLov.scenarioType, true);
            vm.productTypes = amlLov.getAsArray(amlLov.productType, true);
            vm.entityLevels = amlLov.getAsArray(amlLov.entityLevel);
            vm.entityLevels.unshift({key: '', value: vm.resources.aml.scenarioAdmin.noneSelectedOptionTxt});


            vm.getHeaderNames();

            vm.segments = scenarioService.getSegments();

            var namesPromise = vm.getScenarioNames();
            var allPromises = $q.all([namesPromise]);

            // need to get list of scenario names before loading scenario, so that when scenario details page loads
            // scenario name can be validated correctly, see defect S1392133

            allPromises.then(function (result) {

                    var promise = null;

                    if ($stateParams.scenarioID.indexOf('new_') === -1) {
                        // existing scenario
                        vm.headerID = $stateParams.headerID;
                        vm.scenarioID = $stateParams.scenarioID;
                        promise = vm.getScenarioData(vm.scenarioID);
                    } else {
                        //generate new object
                        var defer = $q.defer();
                        promise = defer.promise;
                        defer.resolve(true);

                        if (!$stateParams.scenarioName) {
                            //in case we came to the state with bookmarked URL
                            $stateParams.scenarioName = 'SCR_' + scenarioService.getNextId().toString();
                        }
                        vm.newScenario = true;
                        vm.scenario = scenarioService.newScenario($stateParams.scenarioName);
                        vm.headerID = $stateParams.headerID;
                        updateHeaderID(true); //will load header data
                        vm.headerName = vm.scenario.headerName; //could be empty
                        vm.origScenarioName = vm.scenario.name;
                        vm.loading = false;
                    }
                    promise.then(function success () {
                        /*jshint maxcomplexity:10*/
                        if (!vm.scenario.primaryEntityNumberVariableName) {
                            vm.scenario.primaryEntityNumberVariableName = '';
                        }
                        if (!vm.scenario.entityLevelCode) {
                            vm.scenario.entityLevelCode = '';
                        }
                        // load data set column list for the dropdown
                        if (vm.scenario.datasetName && vm.scenario.datasetName !== '') {
                            //header with id=-1 has dataset name as N/A
                            if (vm.scenario.datasetName === 'N/A' || vm.scenario.headerID === -1) {
                                vm.scenario.datasetName = '';
                            } else {
                                vm.loadDataset(vm.scenario.datasetName);
                            }
                        }
                        if (!vm.scenario.segmentsEnabledInd) {
                            vm.scenario.segmentsEnabledInd = 'N';
                        }
                        if (!vm.scenario.btlEnabledInd) {
                            vm.scenario.btlEnabledInd = 'N';
                        }
                        if (!vm.scenario.riskFactorInd) {
                            vm.scenario.riskFactorInd = 'N';
                        }
                        //see comment for initParamGridOptions function, it describes execution order below
                        updateTabTitle();
                        loadParms();
                        checkSegmentsUsage(true); //delete deleted and unused
                        initParamGridOptions();
                        initACGridOptions();
                        validateSegmentationStatus();
                        // need to wait for the grid to be created otherwise data source read method will fail
                        $scope.$watch('vm.parmsDummyModel', function (newValue, oldValue) {
                            //this will reload grid data
                            setInitialGridState('parms');
                        });
                        $scope.$watch('vm.acDummyModel', function (newValue, oldValue) {
                            setInitialGridState('ac');
                        });
                        vm.loading = false;
                    }, function error () {
                        vm.loading = false;
                        messageService.danger(resources.aml.getResource('scenario.scenariosReadErrorTxt'), null, -1);
                    });
                },
                function (reason) {
                    vm.loading = false;
                    enableUnsafeActions();
                    messageService.danger(resources.aml.getResource('scenario.scenariosReadErrorTxt'), null, -1);
                }
            );

            vm.toggleBtlEnabled = function () {
                if (vm.scenario && vm.scenario.btlEnabledInd ==='Y') {
                    vm.scenario.btlEnabledInd = 'N';
                } else {
                    vm.scenario.btlEnabledInd = 'Y';
                }
                vm.configureParamGrid();
            };

            vm.toggleSegmentsEnabled = function () {
                if (vm.scenario && vm.scenario.segmentsEnabledInd ==='Y') {
                    vm.scenario.segmentsEnabledInd = 'N';
                } else {
                    vm.scenario.segmentsEnabledInd = 'Y';
                }
                vm.configureParamGrid();
                validateSegmentationStatus();
            };

            vm.toggleRiskFactor = function () {
                if (vm.scenario && vm.scenario.riskFactorInd ==='Y') {
                    vm.scenario.riskFactorInd = 'N';
                } else {
                    vm.scenario.riskFactorInd = 'Y';
                }
            };
            // add a modal dialog to allow pill to be closed
            // return true to close...false to keep pill
            tabsListService.registerCloseCallback(vm.state, function scenarioCallback() {
                var defer = $q.defer();
                if (vm.state.data.dirty === true) {
                    var modalInstance = $uibModal.open({
                        animation: true,
                        templateUrl: 'modalCloseScenario.html',
                        controller: 'ScenarioModalDispositionController as viewVm',
                        size: 'sm',
                        backdrop: 'static'
                    });
                    modalInstance.scenarioName = vm.scenario.name;

                    modalInstance.result.then(function () {
                    }, function (buttonValue) {
                        if (buttonValue === 'discard') {
                            defer.resolve(true);
                            $state.go('scenarios');
                        } else if (buttonValue === 'save') {
                            var save = vm.saveScenario(true);// call save method on scenario
                            if (save === null) {
                                //page has errors, cannot be saved, so do not close the tab
                                defer.resolve(false);
                            } else {
                                save.then (
                                    function success () {
                                        defer.resolve(true);
                                        $state.go('scenarios');
                                    },
                                    function failure () {
                                        //save failed,  so do not close the tab
                                        defer.resolve(false);
                                    }
                                );
                            }
                        } else if (buttonValue === 'cancel') {
                            defer.resolve(false);
                        }
                    });
                } else {
                    defer.resolve(true);
                    $state.go('scenarios');
                }
                return defer.promise;
            });
        }

        init();
    }
})();
(function () {
    'use strict';

    ScenarioListDirectiveController.$inject = ["scenarioService", "$scope", "$log", "$state", "kendoGridRendererService", "amlLov", "resources", "_"];
    angular
        .module('aml.scenario')
        .controller('ScenarioListDirectiveController', ScenarioListDirectiveController);

    function ScenarioListDirectiveController(scenarioService, $scope, $log,
                                    $state, kendoGridRendererService,
                                    amlLov, resources, _) {
        var vm = this;
        vm.createWidget = true;
        vm.scenarios = [];
        vm.scenarioCount = 0;
        vm.firstDataLoad = true;
        vm.scenarioStatus = amlLov.getAsArray(amlLov.scenarioStatus);
        vm.showDeleted = false;
        vm.grid = {};
        vm.amlGridActions = [];
        vm.resources = resources;
        vm.filterString = null;

        var dataSourceOptions = {
            transport: {
                read: getScenarios
            },
            schema: {
                model: {
                    fields: {
                        name: {type: 'string'},
                        shortDescription: {type: 'string'},
                        headerName: {type: 'string'},
                        status: {type: 'string'},
                        scenarioTypeCode: {type: 'string'},
                        riskFactorInd: {type: 'string'},
                        categoryCode: {type: 'string'}
                    }
                },
                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            change: function(e) {
                vm.scenarioCount = e.items.length;
            },
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        };

        var yesNoRenderingFilter = kendoGridRendererService.enum('riskFactorInd', 'yesOrNo');
        var statusRenderingFilter = kendoGridRendererService.enum('status', 'scenarioStatus');
        var scenarioTypeRenderingFilter =  kendoGridRendererService.enum('scenarioTypeCode', 'scenarioType');
        var scenarioCategoryRenderingFilter = kendoGridRendererService.enum('categoryCode', 'scenarioCategory');

        vm.gridColumns = [
            {
                field: 'name', title: resources.aml.scenario.scenarioNameHeaderTitle,
                width: '20%'
            },
            {
                field: 'shortDescription', title: resources.aml.scenario.shortDescriptionHeaderTitle,
                width: '20%'
            },
            {
                field: 'headerName', title: resources.aml.scenario.scenarioHeaderNameHeaderTitle,
                width: '20%'
            },
            {
                field: 'status', title: resources.aml.scenario.scenarioStatusHeaderTitle,
                template: statusRenderingFilter,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(statusRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('scenarioStatus')
            },
            {
                field: 'scenarioTypeCode', title: resources.aml.scenario.typeCodeHeaderTitle,
                template: scenarioTypeRenderingFilter,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(scenarioTypeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('scenarioType')
            },
            {
                field: 'riskFactorInd', title: resources.aml.scenario.riskFactorIndHeaderTitle,
                template: yesNoRenderingFilter,
                width: '5%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(yesNoRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'categoryCode', title: resources.aml.scenario.categoryCodeHeaderTitle,
                template: scenarioCategoryRenderingFilter,
                width: '15%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(scenarioCategoryRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('scenarioCategory')
            }
        ];

        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(
            {
                dataSource: dataSourceOptions,
                height: 750,
                pageable: false,
                selectable: 'multiple',
                resizable: true,
                scrollable: {
                    virtual: true
                }
            });


        // on double-click, open the case in ECM UI inside a separate tab
        function handleDoubleClick(evt, data) {
            var scenario = vm.grid.dataItem(evt.currentTarget);
            if (scenario && scenario.scenarioID) {
                $state.go('scenarioDetails', {
                    headerID: scenario.headerID,
                    scenarioID: scenario.scenarioID,
                    scenarioName: scenario.name
                });
            }
        }

        function getScenarios(e) {
            scenarioService.getScenarios(vm.showDeleted).then(function (data) {
                    // on server response success
                    vm.loading = null;
                    vm.scenarioCount = data.items.length;
                    e.success(data);
                },
                function (data, status, headers, config) {
                    $log.info('getScenarios failed');
                });
        }

        function getIdsFromSelectedRows(status) {
            var entityIds = [];
            if ( vm.grid ) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var entity  = vm.grid.dataItem(rowSelection);
                    if (entity && entity.scenarioID) {
                        if(status) {
                            if (entity.status === status) {
                                entityIds.push(entity.scenarioID);
                            }
                        } else {
                            entityIds.push(entity.scenarioID);
                        }
                    }
                });
            }
            return entityIds;
        }

        function reloadGrid(showDeleted) {
            vm.showDeleted = showDeleted;
            vm.grid.dataSource.read();
        }

        ////////////////

        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'scenariosList');
            if (angular.isDefined(vm.callback)) {
                vm.callback.getIdsFromSelectedRows = getIdsFromSelectedRows;
                vm.callback.reloadGrid = reloadGrid;
            }
        }
        activate();

    }
})();
(function () {
    'use strict';

    ScenarioListViewController.$inject = ["$scope", "$rootScope", "$state", "scenarioService", "$uibModal", "messageService", "resources", "_"];
    angular
        .module('aml.scenario')
        .controller('ScenarioListViewController', ScenarioListViewController);

    function ScenarioListViewController($scope, $rootScope, $state, scenarioService,
                                        $uibModal, messageService,
                                        resources, _) {
        var vm = this;
        vm.loading = true;
        vm.resources = resources;
        vm.showDeleted = false;
        // flag when unsafe operation is running
        var disableUnsafeActionsFlag = false;

        activate();

        function activate () {
            $scope.$on('scenarioChanged', function(event, changedData) {
                vm.reloadList();
            });
        }

        function disableUnsafeActions() {
            if (vm.actionsDisabled()) {
                messageService.warning(resources.aml.getResource('scenario.scenarioActionInProgressErrorTxt'), null, 3000);
                return;
            }
            disableUnsafeActionsFlag = true;
        }

        function enableUnsafeActions() {
            disableUnsafeActionsFlag = false;
        }

        vm.actionsDisabled = function () {
            return disableUnsafeActionsFlag;
        };

        vm.actionRunning = function () {
            return vm.gridCallbacks.importRunning || vm.gridCallbacks.exportRunning || vm.gridCallbacks.copyRunning || vm.actionsDisabled();
        };


        vm.gridCallbacks = {
            getIdsFromSelectedRows: function () {
                return [];
            },
            reloadGrid: function () {
                return [];
            },
            exportRunning: false,
            importRunning: false,
            copyRunning: false
        };

        vm.headerCopyAction = [
            {
                key: 'COPY',
                value: resources.aml.getResource('scenario.copyHeaderActionLabel'),
                tip: resources.aml.getResource('scenario.copyHeaderTip')
            },
            {
                key: 'NONE',
                value: resources.aml.getResource('scenario.noneHeaderActionLabel'),
                tip: resources.aml.getResource('scenario.noneHeaderTip')
            },
            {
                key: 'SAME',
                value: resources.aml.getResource('scenario.sameHeaderActionLabel'),
                tip: resources.aml.getResource('scenario.sameHeaderTip')
            }];

        vm.toggleDeleted = function () {
            vm.showDeleted = !vm.showDeleted;
            vm.gridCallbacks.reloadGrid(vm.showDeleted);
        };

        scenarioService.getScenarios().then(function (data) {
                vm.scenarios = data.items;
                vm.loading = false;
            },
            function (error) {
                console.log('Scenario List Error: ' + error); // TODO: externalize this
            });

        vm.newScenario = function () {
            //console.log(vm);
            // create a blank scenario object from scenario.json
            // var newScenario = scenarioService.newScenario();
            var id = scenarioService.getNextId();
            $state.go('scenarioDetails', {
                headerID: -1,
                scenarioID: 'new_' + id.toString(),
                scenarioName: 'SCR_' + id.toString(),
                newEntityFlag : true
            });
        };

        vm.scenarioActivate = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                scenarioService.activateScenarios(ids).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenariosActivatedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosActivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.scenarioDeactivate = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                scenarioService.deactivateScenarios(ids).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenariosDeactivatedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosDeactivatedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.scenarioDelete = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                scenarioService.deleteScenarios(ids).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenariosDeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosDeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.scenarioUndelete = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                scenarioService.undeleteScenarios(ids).then(function (data) {
                        var msg = resources.aml.getResource('scenario.scenariosUndeletedTxt');
                        messageService.success(msg, null, 4000);
                        //reload grid
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosUndeletedErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        var saveToPc = function (data, filename) {
            if (!data) {
                //console.error('No data');
                return;
            }

            if (!filename) {
                filename = 'download.json';
            }

            if (typeof data === 'object') {
                data = JSON.stringify(data, undefined, 2);
            }

            var blob = new Blob([data], {type: 'text/json'});
            if (window.navigator.msSaveOrOpenBlob) {
                // Internet Explorer
                window.navigator.msSaveOrOpenBlob(blob, filename);
            }
            else {
                var hiddenLinkElement = document.createElement('a');
                hiddenLinkElement.download = filename;
                hiddenLinkElement.href = window.URL.createObjectURL(blob);
                hiddenLinkElement.dataset.downloadurl = ['text/json', hiddenLinkElement.download, hiddenLinkElement.href].join(':');
                document.body.appendChild(hiddenLinkElement);
                hiddenLinkElement.click();
                document.body.removeChild(hiddenLinkElement);
            }
        };

        vm.scenarioExport = function () {
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                disableUnsafeActions();
                vm.gridCallbacks.exportRunning = true;
                scenarioService.exportScenarios(ids).then(function (data) {
                        saveToPc(data, 'ScenarioExport.json');
                        messageService.success(resources.aml.getResource('scenario.scenariosExportTxt'), null, 4000);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosExportErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    vm.gridCallbacks.exportRunning = false;
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        var parseStatus = function (ActionStatus) {
            var headersFailed = _.pluck(_.where(ActionStatus, {
                entityType: 'header',
                actionStatus: 'failed'
            }), 'entityName');
            var headersUpdated = _.pluck(_.where(ActionStatus, {
                entityType: 'header',
                actionStatus: 'updated'
            }), 'entityName');
            var headersCreated = _.pluck(_.where(ActionStatus, {
                entityType: 'header',
                actionStatus: 'created'
            }), 'entityName');
            var scenariosFailed = _.pluck(_.where(ActionStatus, {
                entityType: 'scenario',
                actionStatus: 'failed'
            }), 'entityName');
            var scenariosUpdated = _.pluck(_.where(ActionStatus, {
                entityType: 'scenario',
                actionStatus: 'updated'
            }), 'entityName');
            var scenariosCreated = _.pluck(_.where(ActionStatus, {
                entityType: 'scenario',
                actionStatus: 'created'
            }), 'entityName');
            return {
                headersFailed: headersFailed,
                headersUpdated: headersUpdated,
                headersCreated: headersCreated,
                scenariosFailed: scenariosFailed,
                scenariosUpdated: scenariosUpdated,
                scenariosCreated: scenariosCreated
            };
        };

        vm.scenarioImport = function () {

            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'modalFileSelect.html',
                controller: 'ModalFileSelectController as vm',
                size: 'm',
                backdrop: 'static'
            });

            modalInstance.result.then(
                //ok
                function (selectedFile) {
                    //console.log(selectedFile);
                    if (selectedFile) {
                        vm.gridCallbacks.importRunning = true;
                        var reader = new FileReader();
                        reader.onload = function (e) {
                            var jsonString = reader.result;
                            var json = JSON.parse(jsonString);

                            scenarioService.importScenarios(json).then(function (data) {
                                    var status = parseStatus(data.ActionStatus);
                                    var modalInstanceStatus = $uibModal.open({
                                        animation: true,
                                        templateUrl: 'statusMessage.html',
                                        controller: 'StatusMessageController as vm',
                                        size: 'm',
                                        backdrop: 'static'
                                    });
                                    modalInstanceStatus.status = status;
                                    modalInstanceStatus.title = resources.aml.getResource('scenario.importMessageWindowTitle');
                                    modalInstanceStatus.result.then(
                                        function (ok) {
                                        }
                                    );
                                    vm.gridCallbacks.reloadGrid(vm.showDeleted);
                                },
                                function (error) {
                                    messageService.danger(resources.aml.getResource(
                                        'scenario.scenariosImportErrorTxt', {'fileName': selectedFile.name}), null, -1);
                                }).finally(function () {
                                vm.gridCallbacks.importRunning = false;
                                enableUnsafeActions();
                            });

                        };
                        reader.onerror = function (e) {
                            messageService.danger(resources.aml.getResource(
                                'scenario.scenariosFileReadErrorTxt', {'fileName': selectedFile.name}), null, -1);
                            vm.gridCallbacks.importRunning = false;
                            enableUnsafeActions();
                        };
                        disableUnsafeActions();
                        reader.readAsText(selectedFile);
                    } else {
                        messageService.danger(resources.aml.getResource(
                            'scenario.noFileSelectedErrorTxt'), null, 4000);
                    }
                },
                //cancel
                function (reason) {
                    messageService.warning(resources.aml.getResource(
                        'scenario.importCanceledTxt'), null, 4000);
                });
        };

        vm.scenarioRun = function () {
            //only active scenarios can be executed
            var ids = vm.gridCallbacks.getIdsFromSelectedRows('ACT');
            var allIds = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length !== allIds.length && ids.length > 0) {
                messageService.warning(resources.aml.getResource('scenario.onlyActiveScenariosErrorTxt'),
                    null, 4000);
            }
            if (ids.length > 0) {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'scenarioTest.html',
                    controller: 'ScenarioTestController as vm',
                    size: 'lg',
                    backdrop: 'static'
                });
                modalInstance.ids = ids;
                modalInstance.params = scenarioService.runParameters;
                modalInstance.result.then(
                    //ok
                    function (result) {
                    });
            } else {
                messageService.danger(resources.aml.getResource('scenario.noScenariosSelectedErrorTxt'),
                    null, 3000);
            }
        };

        vm.scenarioCopy = function (hdrAction) {
            scenarioService.runParameters.headerAction = hdrAction;
            var ids = vm.gridCallbacks.getIdsFromSelectedRows();
            if (ids.length > 0) {
                vm.gridCallbacks.copyRunning = true;
                disableUnsafeActions();
                scenarioService.copyScenarios(ids, scenarioService.runParameters.headerAction).then(function (data) {
                        var status = parseStatus(data.ActionStatus);
                        var modalInstanceStatus = $uibModal.open({
                            animation: true,
                            templateUrl: 'statusMessage.html',
                            controller: 'StatusMessageController as vm',
                            size: 'm',
                            backdrop: 'static'
                        });
                        modalInstanceStatus.status = status;
                        modalInstanceStatus.title = resources.aml.getResource('scenario.copyMessageWindowTitle');
                        modalInstanceStatus.result.then(
                            function (ok) {
                            }
                        );
                        vm.gridCallbacks.reloadGrid(vm.showDeleted);
                    },
                    function (error) {
                        var msg = resources.aml.getResource('scenario.scenariosCopyErrorTxt');
                        messageService.danger(msg, null, -1);
                    }).finally(function () {
                    vm.gridCallbacks.copyRunning = false;
                    enableUnsafeActions();
                });
            } else {
                var msg = resources.aml.getResource('scenario.noScenariosSelectedErrorTxt');
                messageService.danger(msg, null, 3000);
            }
        };

        vm.reloadList = function reloadList() {
            vm.gridCallbacks.reloadGrid(vm.showDeleted);
        };

    }
})();

(function () {
    'use strict';

    ModalFileSelectController.$inject = ["$scope", "$uibModalInstance", "resources", "messageService"];
    angular
        .module('aml.scenario')
        .controller('ModalFileSelectController', ModalFileSelectController);

    function ModalFileSelectController($scope, $uibModalInstance, resources, messageService) {
        var vm = this;
        vm.resources = resources;
        vm.selectedFile = '';

        $scope.fileSelectionChanged = function (element) {
            $scope.$apply(function (scope) {
                vm.selectedFile = element.files[0];
            });
        };
        vm.ok = function () {
            if (vm.selectedFile && vm.selectedFile !== '') {
                $uibModalInstance.close(vm.selectedFile);
            } else {
                messageService.danger(resources.aml.getResource('scenario.noFileSelectedErrorTxt'), null, 4000);
            }
        };
        vm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

(function () {
    'use strict';

    ScenarioTestController.$inject = ["$scope", "$uibModalInstance", "resources", "scenarioService", "messageService", "$sce", "amlLov"];
    angular
        .module('aml.scenario')
        .controller('ScenarioTestController', ScenarioTestController);


    function ScenarioTestController($scope, $uibModalInstance, resources, scenarioService, messageService, $sce, amlLov) {
        var vm = this;
        vm.resources = resources;
        vm.testResults = vm.resources.aml.getResource('scenario.clickRunTxt');
        //use saved parameters from previous run
        vm.params = $uibModalInstance.params;
        vm.params.ids = $uibModalInstance.ids;
        vm.yesOrNo = amlLov.getAsArray(amlLov.yesOrNo);

        if (vm.params.runAsOfDate === '') {
            vm.runDate = new Date();
        } else {
            vm.runDate = vm.params.runDate;
        }

        vm.run = function () {
            if (!vm.runDate) {
                messageService.danger(resources.aml.getResource('scenario.runDateErrorTxt'), null, 4000);
                return;
            }
            vm.params.runAsOfDate = vm.runDate.toISOString().substr(0, 10).replace(/-/g, '');
            //need to save full date to avoid time zone issues
            vm.params.runDate = vm.runDate;
            vm.testResults = resources.aml.getResource('scenario.waitForResultsTxt') +
                '<span class="sas-icon sas-icon-refresh sas-icon-spin-backwards"></span>';

            scenarioService.runScenarios(vm.params).then(function (data) {
                    messageService.success(resources.aml.getResource('scenario.scenariosTestTxt'), null, 4000);
                    vm.testResults = $sce.trustAsHtml(data.data);
                },
                function (error) {
                    var msg = vm.resources.aml.getResource('scenario.scenariosTestErrorTxt');
                    messageService.danger(msg, null, -1);
                    vm.testResults = msg;
                }
            );
        };

        vm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };


    }
})();


(function () {
    'use strict';

    StatusMessageController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('aml.scenario')
        .controller('StatusMessageController', StatusMessageController);

    function StatusMessageController($uibModalInstance, resources) {
        var vm = this;
        vm.status = $uibModalInstance.status;
        vm.resources = resources;
        if ($uibModalInstance.title) {
            vm.title = $uibModalInstance.title;
        } else {
            vm.title = resources.aml.getResource('scenario.statusMessageWindowTitle');
        }

        vm.ok = function () {
            $uibModalInstance.close('ok');
        };
    }
})();

/**
 * Created by dabock on 2/10/2016.
 */
(function () {
    'use strict';
    AmlGlobalSearchButtonController.$inject = ["$scope", "resources", "$timeout", "popoverOpenService", "usersService", "amlConstants"];
    angular.module('aml.search').controller('AmlGlobalSearchButtonController', AmlGlobalSearchButtonController);

    function AmlGlobalSearchButtonController($scope, resources, $timeout, popoverOpenService,
                                   usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.popoverContentFile = 'search/global/globalSearchPopoverContent.html';
        vm.popoverIsOpen = popoverOpenService.isGlobalSearchPopoverOpen();

        usersService.currentUserHasAnyCapabilityPromise(
            [amlConstants.capabilities.search]
        ).then(function(userCanSearch) {
            vm.userCanSearch = userCanSearch;
        });

        vm.popoverPlacement = 'bottom-left';

        var unbindTextDir = $scope.$watch('resources.aml.metadata.textDirection', function (newValue, oldValue) {
            if (newValue) {
                if (newValue==='rtl') {
                    vm.popoverPlacement = 'left-bottom';
                    unbindTextDir();
                }
            }
        });

        vm.click = function() {
            vm.popoverIsOpen = popoverOpenService.toggleGlobalSearchPopover();


            /*
            This $timeout is to set the focus on the search form input as soon
            as it appears. We tried alternate methods of doing this, namely
            setting a $watch on angular.element('#global-search-input') or on
            a variable created by ng-init in the form directive, in an attempt
            to focus the input as soon as it exists. Neither worked. There is
            apparently some delay between the element being created and being
            focusable. Setting the $timeout to 7 ms or less had inconsistent
            results on my developer desktop. 100 ms seems short enough to be
            imperceptible to the user while hopefully being long enough to
            allow the element to become focusable.
            */

            $timeout(function() {
                if(angular.element('#global-search-input')) {
                    angular.element('#global-search-input').focus();
                }
            }, 100);
        };

    }
})();


/**
 * Created by dabock on 2/10/2016.
 */
(function () {
    'use strict';
    AmlGlobalSearchFormController.$inject = ["$scope", "resources", "$state", "popoverOpenService", "$"];
    angular.module('aml.search').controller('AmlGlobalSearchFormController', AmlGlobalSearchFormController);

    function AmlGlobalSearchFormController($scope, resources, $state, popoverOpenService, $) {
        var vm = this;
        vm.resources = resources;

        vm.submitButton = function() {
            if(vm.searchTerm) {
                popoverOpenService.toggleGlobalSearchPopover();
                $state.go('globalSearchResults', {
                    searchId: popoverOpenService.getSearchCount(),
                    q: vm.searchTerm
                });
            }
        };
        //this function is used to close popover when user clicks outside of
        //popover area
        var checkDivClick = function (e) {
            //unbind in case user managed to click on the button
            if (!popoverOpenService.isGlobalSearchPopoverOpen().open) {
                $('body').unbind('click', checkDivClick);
                return;
            }
            var myContainer = $('#aml-global-search-button-id')[0];
            var target = e.target;
            if(myContainer) {
                //do nothing for search button itself, it will close itself
                if (!(target.id && target.id === 'globalSearchButton')) {
                    var inside = $.contains(myContainer, target);
                    //do nothing if click was inside the region
                    if(!inside) {
                        //if click outside toggle the flag and unbind
                        $scope.$apply(function (scope) {
                            popoverOpenService.toggleGlobalSearchPopover();
                        });
                        if (!popoverOpenService.isGlobalSearchPopoverOpen().open) {
                            $('body').unbind('click', checkDivClick);
                            return;
                        }
                    }
                }
            }
        };
        //bind to body to listen on all clicks, need to unbind when controller is
        $('body').bind('click', checkDivClick);
        $scope.$on('$destroy', function () {
            //unbind listener in case controller is disposed by angular
            $('body').unbind('click', checkDivClick);
        });
    }
})();


/**
 * Created by dabock on 2/11/2016.
 */
(function() {
    'use strict';
    GlobalSearchResultsController.$inject = ["resources", "$stateParams", "searchService", "usersService", "amlConstants"];
    angular.module('aml.search').controller('GlobalSearchResultsController', GlobalSearchResultsController);

    function GlobalSearchResultsController(resources, $stateParams, searchService, usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.q = $stateParams.q;
        vm.docs = [];
        var currentUserHasCaseSearchCapability =
            usersService.currentUserHasCapability(amlConstants.capabilities.caseSearch);

        vm.start = 0;
        var rows = 100;

        vm.loadMoreResults = function() {
            // vm.currentlyLoadingResults is used to show/hide the "Showing results 1 to 100
            // of 4507" message and "Load more results" link.
            vm.currentlyLoadingResults = true;
            searchService.globalSearch($stateParams.q, vm.start, rows).then(function(data) {
                vm.currentlyLoadingResults = false;
                vm.resultsReceived = true;
                vm.numFound = data.response.numFound;
                vm.docs = vm.docs.concat(data.response.docs);
                vm.showingResultsTxt = resources.aml.getResource(
                    'search.globalSearchShowingResultsTxt',
                    {
                        start: 1,
                        end: vm.docs.length,
                        total: data.response.numFound
                    }
                );
            });

            vm.start += rows;
        };

        /*
        Suppressing dot notation checking (e.g. "['bank_name'] is better written in
        dot notation." because jshint complains about the underscore if it's in dot
        notation.
        */

        /*jshint sub:true */
        vm.showResult = function(doc) {
            if(doc['doc_type'] === 'case' && !currentUserHasCaseSearchCapability) {
                return false;
            }
            else {
                return true;
            }
        };

        // Load the first page of results
        vm.loadMoreResults();
    }
})();
(function () {
    'use strict';
    TransactionSearchController.$inject = ["transactionsService", "resources", "searchService", "amlCoreUtils", "kendoGridRendererService", "$scope", "amlConstants", "entityService", "$state", "_", "$locale"];
    angular.module('aml.customer').controller('TransactionSearchController', TransactionSearchController);

    /* jshint maxparams: 11 */
    function TransactionSearchController(transactionsService, resources, searchService,
                                         amlCoreUtils, kendoGridRendererService, $scope,
                                         amlConstants, entityService, $state, _,
                                         $locale) {

        var vm = this;
        vm.searchSubmitted = false;
        vm.pageSize = 50;
        vm.submit = submit;
        vm.resources = resources;
        vm.transactions = [];
        vm.gridSettings = {};
        vm.createWidget = false;
        vm.currencyCode = null;
        vm.loadingTransactionsBusy = false;
        vm.sortCols = [];
        vm.selected = '';
        vm.totalAmount = 0;

        var currentQueryParams = {};
        var filterStr;

        vm.model = {
            accountNumber: {},
            referenceNumber: {},
            minAmount: {},
            maxAmount: {},
            trnDate: new searchService.SearchField('trn_date', [null, null], 'date')
        };

        vm.currencySymbol = amlCoreUtils.getBaseCurrencySymbol();

        // Determine whether to put the currency symbol before or after the
        // amount fields in the search form.
        var pattern = $locale.NUMBER_FORMATS.PATTERNS[1];
        vm.currencyBefore = pattern.posPre;
        vm.currencyAfter = pattern.posSuf;

        var dataSourceOptions = {
            transport: {read: getTransactionsKendo},
            schema: {
                model: {
                    fields: {
                        accountNumber: {type: 'string'},
                        transactionDate: {type: 'date'},
                        currencyAmount: {type: 'number'},
                        transactionDesc: {type: 'string'},
                        transactionNumber: {type: 'string'}
                    }
                },
                data: 'transactions',
                total: 'count'
            },
            pageSize: vm.pageSize || 50,
            serverPaging: true,
            serverSorting: true
        };

        vm.grid = {};

        vm.gridColumns = [
            {
                field: 'accountNumber',
                title: resources.aml.transaction.search.accountNumber
            },
            {
                field: 'transactionDate',
                title: resources.aml.transaction.search.date,
                template: '{{dataItem.transactionDate | date}}'
            },
            {
                field: 'currencyAmount',
                title: resources.aml.transaction.search.amount,
                template: kendoGridRendererService.currency('currencyAmount')
            },
            {
                field: 'transactionDesc',
                title: resources.aml.transaction.search.description,
                template: '{{dataItem.transactionDesc | sentenceCase}}'
            },
            {
                field: 'transactionNumber',
                title: resources.aml.transaction.search.referenceNumber
            }
        ];

        function handleDoubleClick(evt) {
            var selectedEntity = vm.grid.dataItem(evt.currentTarget);

            selectedEntity.entityNumber = selectedEntity.transactionNumber;
            selectedEntity.entityName = selectedEntity.transactionDesc;
            selectedEntity.entityLevelCode = amlConstants.entityType.transaction;

            var entityState = entityService.getStateForEntity(selectedEntity);
            $state.go(entityState.stateName, entityState.stateParams);
        }

        function submit() {
            removeSpecialChars();

            currentQueryParams.accountNumber = vm.model.accountNumber.value;
            currentQueryParams.referenceNumber = vm.model.referenceNumber.value;
            currentQueryParams.minAmount = vm.model.minAmount.value;
            currentQueryParams.maxAmount = vm.model.maxAmount.value;
            currentQueryParams.minDate = vm.model.trnDate.value[0];
            currentQueryParams.maxDate = vm.model.trnDate.value[1];

            if(!vm.searchSubmitted) {
                activate();
                vm.searchSubmitted = true;
            }
            else {
                vm.gridOptions.dataSource.read();
            }
        }

        function removeSpecialChars() {
            // Remove < and > from accountNumber and ReferenceNumber
            if(vm.model.accountNumber.value) {
                vm.model.accountNumber.value =
                    vm.model.accountNumber.value.replace(/[<>]/g, '');
            }

            if(vm.model.referenceNumber.value) {
                vm.model.referenceNumber.value =
                    vm.model.referenceNumber.value.replace(/[<>]/g, '');
            }
        }

        function activate() {
            vm.gridOptions = searchService.searchGridOptions(dataSourceOptions);
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'transactionsSearch');
            vm.customActions = [
                {label: resources.aml.grid.actions.exportTitle, action:vm.exportTransactions}
            ];


            // hide clear filters
            var hideActions = [ 'clearFilters'];
            // This has to be done here because the aml-grid-actions directive renders on
            // page load and this initialize activation is delayed.
            hideActions.forEach(function (actionId) {
                var actionToHide =_.findWhere( vm.amlGridActions, { id: actionId});
                if ( actionToHide ) {
                    actionToHide.hidden = true;
                }
            });

        }

        vm.exportTransactions = function() {
            transactionsService.exportTransactionsToCSV(null, {}, filterStr, null, null, 'search');
        };

        function constructFilterStr() {
            var paramArray = [];

            addSearchParameter(paramArray, 'eq', 'accountNumber', currentQueryParams.accountNumber, true);
            addSearchParameter(paramArray, 'eq', 'transactionNumber', currentQueryParams.referenceNumber, true);
            addSearchParameter(paramArray, 'ge', 'currencyAmount', currentQueryParams.minAmount);
            addSearchParameter(paramArray, 'le', 'currencyAmount', currentQueryParams.maxAmount);
            addSearchParameter(paramArray, 'ge', 'transactionDate', formatDate(currentQueryParams.minDate));
            addSearchParameter(paramArray, 'le', 'transactionDate', formatDate(currentQueryParams.maxDate));

            if(paramArray.length) {
                var returnable = 'and(' + paramArray.join(',') + ')';
                return returnable;
            }
        }

        vm.createWidget = true;

        function getTransactionsKendo(gridCallback) {
            filterStr = constructFilterStr();

            var pageInfo = kendoGridRendererService.getPageInfo(
                gridCallback.data,
                vm.gridOptions.dataSource.pageSize
            );

            transactionsService.getTransactionSearchResult(
                filterStr,
                pageInfo.start,
                pageInfo.limit,
                kendoGridRendererService.getSortColumns(gridCallback.data, 'transactionDate', 'descending')
            ).then(function (data) {
                vm.transactionsCount = data.count;
                if(data.transactions) {
                    gridCallback.success(data);
                }
            }, function (data) {

            });
        }
    }

    function addSearchParameter(paramArray, op, name, value, quotes) {
        var quoteChar = quotes ? '\'' : '';
        if(value) {
            paramArray.push(op + '(' + name + ',' + quoteChar + value + quoteChar +')');
        }
    }

    function formatDate(d) {
        if(d) {
            var mom = moment(d);
            return mom.format();
        }
        else {
            return null;
        }
    }
})();

///**
// * Created by omkulk on 3/30/2016.
// */
///**
// * Created by omkulk on 1/22/2015.
// */
//
//(function() {
//    'use strict';
//    angular.module('aml').controller('FundsTrackerForceNetworkController', FundsTrackerForceNetworkController);
//
//    function FundsTrackerForceNetworkController(fundsTrackerForceNetworkService,fundsTrackerService, $filter, entityService, $scope, resources,
//                                    amlCoreUtils, $stateParams) {
//        // init
//        var vm = this;
//
//        vm.accountId = $stateParams.accountid;
//
//        vm.entityId = entityService.normalizeEntityId( vm.entityId,
//            vm.entityLevelCode, vm.entityNumber, vm.entityKey );
//
//        //var metricPanel = '#fundsTrackerForceNetwork';
//        vm.resources = resources;
//
//        function activate(){
//
//            fundsTrackerService.getNetwork($stateParams.accountid).then(function(data) {
//
//                var links = data.items;
//                fundsTrackerForceNetworkService.forceNetwork(links, vm.accountId);
//
//
//            });
//        }
//
//        activate();
//
//    }
//
//})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    AddToInvestigationModalController.$inject = ["$uibModalInstance", "dataMessagingServiceFactory", "resources", "amlLov", "usersService", "queueListService", "entityService", "amlConstants", "$filter", "_"];
    angular.module('aml.customer.details').controller('AddToInvestigationModalController', AddToInvestigationModalController);

    /* jshint maxstatements: 50 */
    function AddToInvestigationModalController($uibModalInstance, dataMessagingServiceFactory, resources, amlLov,
                                                usersService, queueListService, entityService, amlConstants, $filter, _) {
        var vm = this;
        vm.caseCategories = amlLov.getAsArray(amlLov.caseCategory);
        vm.caseSubcategories = amlLov.getAsArray(amlLov.caseSubcategory);
        vm.priorityList = amlLov.getAsArray(amlLov.priority);
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        // sort the priority list to H,M,L
        sortPriorityList( vm.priorityList );

        vm.closeReasons = amlLov.getAsArray(amlLov.alertCloseReason);
        vm.closeReason = null;

        vm.description = null;
        // assign default value (as object, not a string) when user list is loaded for typeahed to bind correctly
        vm.investigator = null;
        vm.alerts = [];
        vm.alertCount = null;
        vm.entityCount = null;
        vm.entities = [];
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        vm.selectAll = selectAll;
        vm.clearAll = clearAll;
        vm.isCloseReasonRequired = isCloseReasonRequired;
        vm.getIncludedCount = getIncludedCount;
        vm.getClosedCount = getClosedCount;
        vm.getEntityCount = getEntityCount;
        vm.getAlertCount = getAlertCount;
        vm.selectedCaseId = null;
        vm.existingOrNew='new';
        vm.invalidName = {};
        vm.routeToUnassigned = false;

        vm.allowCreateCaseFromAlerts = usersService.currentUserHasCapability(amlConstants.capabilities.createCaseFromAlerts);
        vm.allowAddToExistingCase = vm.allowCreateCaseFromAlerts ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.createCase);

        vm.userCanClose = $uibModalInstance.userCanClose;
        vm.employeeInd = false;

        activate();

        /////////

        function activate() {
            /*jshint maxcomplexity:12 */

            // if cases are being handled by ECM, only allow to create a new case and not add to an existing case
            // as we do not support any ECM integration beyond creating new cases
            if (amlConstants.config.defaultCaseDestination &&
                amlConstants.config.defaultCaseDestination.toLowerCase() === 'ecm') {
                vm.allowAddToExistingCase = false;
            }
            if (vm.userCanClose) {
                vm.alertActionList = [
                    {key:amlConstants.createInvestigationAlertActionType.INCLUDE,
                        value:vm.resources.aml.alerts.triage.caseAction.promoteAlert},
                    {key:amlConstants.createInvestigationAlertActionType.CLOSE,
                        value:vm.resources.aml.alerts.triage.caseAction.closeAlert},
                    {key:amlConstants.createInvestigationAlertActionType.IGNORE,
                        value:vm.resources.aml.alerts.triage.caseAction.deferAlert}
                ];
            } else {
                vm.alertActionList = [
                    {key:amlConstants.createInvestigationAlertActionType.INCLUDE,
                        value:vm.resources.aml.alerts.triage.caseAction.promoteAlert},
                    {key:amlConstants.createInvestigationAlertActionType.IGNORE,
                        value:vm.resources.aml.alerts.triage.caseAction.deferAlert}
                ];
            }

            var entityId = dataMessagingService.getEntityId();
            var entities = [];


            if ( entityId.entityLevelCode === amlConstants.entityType.transaction) {
                var entity = {

                    entityKey: dataMessagingService.getEntityKey(),
                    entityNumber: entityId.entityNumber,
                    entityLevelCode: entityId.entityLevelCode,
                    entityName: dataMessagingService.getCustomerName()
                };
                vm.entities.push(entity);
            } else {
                entityService.getImpactedEntities(entityId.entityLevelCode, entityId.entityNumber, entityId.entityKey).then(function (impacts) {
                    /*jshint maxcomplexity:13 */
                    if (impacts && impacts.items) {
                        entities = impacts.items;

                        // get all entities and count
                        vm.entities = entities;
                        vm.entityCount = getEntityCount();


                        if (entities.length === 0) {
                            var entity = {
                                entityKey: dataMessagingService.getEntityKey(),
                                entityNumber: entityId.entityNumber,
                                entityLevelCode: entityId.entityLevelCode,
                                entityName: dataMessagingService.getCustomerName()
                            };
                            entities.push(entity);
                        }

                        for (var i = 0; i < entities.length; i++) {

                            var entityAlerts = [];
                            entityAlerts = entities[i].alerts;

                            if (entities[i].entityLevelCode === amlConstants.entityType.externalParty) {
                                entities[i].entityKey = entityId.entityKey;
                            }

                            if ( entityAlerts && entityAlerts.length !== 0) {
                                for (var j = 0; j < entityAlerts.length; j++) {
                                    checkAndAdd(entityAlerts[j]);
                                }
                                vm.alertCount = vm.alerts.length;
                            }
                        }
                    }
                    // get all alerts and count
                    vm.alertNumber = dataMessagingService.getActiveAlertsCount();

                    if (dataMessagingService.getSelectedAlertCount() > 0) {
                        ignoreAll();
                        selectSome(dataMessagingService.getSelectedAlerts());
                    } else {
                        selectAll();
                    }

                    for(var a=0; a<vm.alerts.length; a++) {
                        if(vm.alerts[a].employeeIndicator !== undefined && vm.alerts[a].employeeIndicator !== null && vm.alerts[a].employeeIndicator === 'Y') {
                            vm.employeeInd = true;
                            break;
                        }
                    }

                    if(vm.employeeInd === false) {
                        for(var b=0; b<vm.entities.length; b++) {
                            if(vm.entities[b].employeeIndicator !== undefined && vm.entities[b].employeeIndicator !== null && vm.entities[b].employeeIndicator === 'Y') {
                                vm.employeeInd = true;
                                break;
                            }
                        }
                    }

                });


            }

            vm.queues = [{queueCode: '', queueName: resources.aml.scenarioAdmin.noneSelectedOptionTxt }];
            queueListService.getQueues().then(function(data) {
                data.items.forEach(function (item) {
                    item.queueName = $filter('queueName')(item.queueCode, true);
                });
                if(amlConstants.config.routeToAllQueues) {
                    vm.queues = vm.queues.concat(data.items);
                }
                else {
                    var currentUserQueues = usersService.getCurrentUserQueues();
                    vm.queues = vm.queues.concat(data.items.filter(
                        function(queue) {
                            return currentUserQueues.indexOf(queue.queueCode) > -1;
                        }
                    ));

                }
            });


            vm.users = [];
            usersService.getUsersWithAnyCapability( [amlConstants.capabilities.accessCasesMy, amlConstants.capabilities.accessCasesAll,
                                                     amlConstants.capabilities.accessCasesAvailable] ).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                    vm.investigator = _.findWhere(vm.users, {userId: usersService.getCurrentUserId()});
                }
            });
        }

        //if alerts has not been added and user has access to it then add it the the lits
        function checkAndAdd(alert) {

           // console.log(vm.alerts);

            var found = vm.alerts.some(function (foundId) {
                return foundId.alertId === alert.alertId;
            });
            var hasAccess = usersService.hasQueueAccess(alert.queueCode);
            if (!found && hasAccess) {
                alert.action = amlConstants.createInvestigationAlertActionType.INCLUDE;
                vm.alerts.push(alert);
            }
        }

        function sortPriorityList( priorityList ) {
            priorityList.sort( function(a,b){
                if ( a.key === 'L' ) {
                    if (b.key === 'L' ) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else if (a.key === 'M') {
                    if (b.key === 'M') {
                        return 0;
                    }
                    else if (b.key === 'L') {
                        return -1;
                    }
                    else {
                        return 1;
                    }
                }
                else if (a.key === 'H') {
                    if (b.key === 'H') {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
            });
        }

        function getIncludedCount() {
            var selectedAlerts = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.INCLUDE });
            return selectedAlerts ? selectedAlerts.length : 0;
        }

        function getClosedCount() {
            var unselectedAlerts = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.CLOSE });
            return unselectedAlerts ? unselectedAlerts.length : 0;
        }

        function getEntityCount() {
            return vm.entities.length;
        }

        function getAlertCount() {
            return vm.alerts.length;
        }

        function ignoreAll() {
            _.each( vm.alerts, function(alert) {
                alert.action = amlConstants.createInvestigationAlertActionType.IGNORE;
            });
        }

        function clearAll() {
            _.each( vm.alerts, function(alert) {
                alert.action = amlConstants.createInvestigationAlertActionType.CLOSE;
            });
        }

        function selectAll() {
            _.each( vm.alerts, function(alert) {
                alert.action = amlConstants.createInvestigationAlertActionType.INCLUDE;
            });
        }

        function selectSome (alertsToSelect) {
            _.each( vm.alerts, function(alert) {
                if (_.find(alertsToSelect, function(alertToSelect) { return alert.alertId === alertToSelect.alertId;})) {
                    alert.action = amlConstants.createInvestigationAlertActionType.INCLUDE;
                }
            });
        }

        function isCloseReasonRequired() {
            // close reason is required if there's any *unselected* alerts in the list
            var unselectedAlertsFound = _.findWhere(vm.alerts, {action: amlConstants.createInvestigationAlertActionType.CLOSE });
            return !!unselectedAlertsFound;
        }

        vm.typeaheadOnSelect = function userSelected (item, model, label, event){
            vm.userChanged();
        };
        vm.userChanged =  function userChanged () {
console.log("vm.userChanged #02");
            vm.invalidName = {};
            if (vm.routeToUnassigned) {
                vm.investigator = null;
            } else if ( vm.investigator &&  vm.investigator.userId ) {
                //userid was bound by typeahed - use it
                vm.invalidName = {};
            } else if ( vm.investigator &&  !vm.investigator.userId ) {
                //use has typed the name but did not select from dropdown, search in the list
                var user = _.findWhere(vm.users, {userId:vm.investigator});
                if (user && user.userId) {
                    vm.investigator = user;
                } else {
                    // if did not find in the list throw an error
                    vm.invalidName = {invalid:true};
                }
            }
            else {
                // if did not bind to a model,  throw an error
                vm.invalidName = {invalid:true};
            }
        };

        function ok() {
//console.log("1111111");
            var userId = null;
            var employeeIndYesorNo = (vm.employeeInd === true) ? 'Y' : 'N';

            vm.userChanged(); //validate used
            if (vm.routeToUnassigned) {
                userId = '';
            } else if ( vm.investigator &&  vm.investigator.userId ) {
                userId = vm.investigator.userId;
            }
            else {
                // if did not bind to a model, throw an error
                userId = null;
            }

            var alertsToBeIncluded = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.INCLUDE });
            var alertsToBeClosed = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.CLOSE });
            var alertsToBeIgnored = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.IGNORE });

            var result = {
                alertsToBeAddedToCase: alertsToBeIncluded,
                alertsToBeClosed: alertsToBeClosed,
                alertsToBeIgnored: alertsToBeIgnored,
                entities: vm.entities,
                closeReason: vm.closeReason,
                description: vm.description,
                investigator: userId,
                priority: vm.priority,
                category: vm.caseCategory,
                subcategory: vm.caseSubcategory,
                selectedCaseId: vm.selectedCaseId,
                queueCode: vm.queueCode,

                employeeIndicator: employeeIndYesorNo
            };
            if (userId !== null) {
                $uibModalInstance.close(result);
            }
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

        vm.switchEmployeeInd = function switchEmployeeInd() {
            vm.employeeInd = !vm.employeeInd;
        };
    }

})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    CloseAlertsModalController.$inject = ["$uibModalInstance", "dataMessagingServiceFactory", "resources", "entityService", "amlConstants", "amlLov", "$uibModal", "$q"];
    angular.module('aml.customer.details').controller('CloseAlertsModalController', CloseAlertsModalController);

    function CloseAlertsModalController($uibModalInstance, dataMessagingServiceFactory, resources, entityService, amlConstants, amlLov, $uibModal, $q) {
        var vm = this;

        vm.closeReasons = amlLov.getAsArray(amlLov.alertCloseReason);
        vm.closeReason = null;

        vm.alertNumber = null;
        vm.alerts = [];
        vm.entities = [];
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        vm.getAlertCount = getAlertCount;
        vm.getEntityCount = getEntityCount;
        vm.getIgnoredCount = getIgnoredCount;
        vm.getClosedCount = getClosedCount;

        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        activate();

        /////////


        function activate() {
            // get all alerts count from Alerts directive
            vm.alertNumber = dataMessagingService.getActiveAlertsCount();

            if ( vm.closeReasons && vm.closeReasons.length > 0 ) {
                vm.closeReason = _.first(vm.closeReasons).key;
            }

            vm.alertActionList = [
                {key:amlConstants.createInvestigationAlertActionType.CLOSE,
                    value:vm.resources.aml.alerts.triage.caseAction.closeAlert},
                {key:amlConstants.createInvestigationAlertActionType.IGNORE,
                    value:vm.resources.aml.alerts.triage.caseAction.deferAlert}
            ];

            vm.alerts = dataMessagingService.getActiveAlerts();
            if ( vm.alerts && vm.alerts.length !== 0) {
                for (var j = 0; j < vm.alerts.length; j++) {
                    vm.alerts[j].action = amlConstants.createInvestigationAlertActionType.CLOSE;
                }
                vm.alertCount = vm.alerts.length;
            }
        }

        function ok() {
//console.log("============== externalParties");
//console.log(vm);

					if($("#closeReasonComment").val() == ""){
//console.log("closeReasonComment =====");
						var defer = $q.defer();
						$(".has-error").removeClass();
						defer.reject('form has errors');

						$uibModal.open({
                animation: true,
                templateUrl: 'modalCommentNoti.html',
                controller: 'CddReviewModalController as viewVm',
                size: 'm',
                backdrop: 'static'
            });
            
            $("#closeReasonComment").closest("div").addClass("has-error");
					}else{
						
						var hrefStr = $(location).attr('href').toUpperCase();
						// ,    
		        if(hrefStr.indexOf('EXTERNALPARTIES') != -1 || hrefStr.indexOf('CUSTOMERS') != -1){
							var appIdArr = vm.alerts;
							var appId = [];
		
							$.each(appIdArr, function(index, item){
								appId.push(item.alertId);
							});
	
	//console.log(appId);
	
							var appIdResult = JSON.stringify(appId).replace(/\"/gi, "");
							appIdResult = appIdResult.replace(/\[/gi, "");
							appIdResult = appIdResult.replace(/\]/gi, "");
		
							var sp_URI = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/Compliance_Alert_Close_Comment(StoredProcess)";
							var param={
									_program     : sp_URI,
									_result     : "STREAMFRAGMENT",
									//_action     : "background",
									appId	: appIdResult,
									comment : $("#closeReasonComment").val()
								}
								$.ajax({
									url: "/SASStoredProcess/do?",
									data: param,
									cache:false,
									dataType: 'json',
									async: true,
									beforeSend: function() {
										//$("#progressIndicatorWIP").show();
									},
									success : function(data){           
										console.log("STP Success.....");
										console.log("JSON.stringify(data) : " + JSON.stringify(data));
										//alert("Create E-File Success!");
										//location.reload();
									},
									error : function(request,status, e){
										console.log("code : " + request.status);
										console.log("message : " + request.responseText);
										console.log("Error : " + e);
									}
								});
		        }
	
	          var alertsToBeClosed = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.CLOSE });
	          var alertsToBeIgnored = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.IGNORE });
	
	          var result = {
	              alertsToBeClosed: alertsToBeClosed,
	              alertsToBeIgnored: alertsToBeIgnored,
	              closeReason: vm.closeReason
	          };
	
	          $uibModalInstance.close(result);

					}
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

        function getAlertCount() {
            var count = vm.alerts.length;
            return count;
        }

        function getEntityCount() {
            var count = vm.entities.length;
            return count;
        }

        function getIgnoredCount() {
            var selectedAlerts = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.IGNORE });
            return selectedAlerts ? selectedAlerts.length : 0;
        }

        function getClosedCount() {
            var unselectedAlerts = _.where( vm.alerts, {action: amlConstants.createInvestigationAlertActionType.CLOSE });
            return unselectedAlerts ? unselectedAlerts.length : 0;
        }
    }

})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    CreateManualInvestigationModalController.$inject = ["$uibModalInstance", "resources", "amlLov", "usersService", "amlConstants", "queueListService", "$filter", "_"];
    angular.module('aml.customer.details').controller('CreateManualInvestigationModalController', CreateManualInvestigationModalController);

    function CreateManualInvestigationModalController($uibModalInstance, resources, amlLov,
                                                usersService, amlConstants, queueListService, $filter, _) {
        var vm = this;
        vm.caseCategories = amlLov.getAsArray(amlLov.caseCategory);
        vm.caseSubcategories = amlLov.getAsArray(amlLov.caseSubcategory);
        vm.priorityList = amlLov.getAsArray(amlLov.priority);

        // sort the priority list to H,M,L
        sortPriorityList( vm.priorityList );


        vm.description = null;
        // assign default value (as object, not a string) when user list is loaded for typeahed to bind correctly
        vm.investigator = null;

        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;

        vm.selectedCaseId = null;
        vm.existingOrNew='new';
        vm.invalidName = {};
        vm.routeToUnassigned = false;

        vm.employeeInd = false;
        vm.routeToQueue = '';

        vm.queues = [{queueCode: '', queueName: resources.aml.scenarioAdmin.noneSelectedOptionTxt}];


        //we use the javascript service class to call for queues
        queueListService.getQueues().then(function(data) {
            data.items.forEach(function (item) {
                item.queueName = $filter('queueName')(item.queueCode, true);
            });
            vm.queues = vm.queues.concat(data.items);
        });


        activate();

        /////////

        function activate() {



            vm.users = [];
            usersService.getUsersWithAnyCapability( [amlConstants.capabilities.accessCasesMy, amlConstants.capabilities.accessCasesAll,
                                                     amlConstants.capabilities.accessCasesAvailable]).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                    vm.investigator = _.findWhere(vm.users, {userId: usersService.getCurrentUserId()});
                }
            });
        }



        function sortPriorityList( priorityList ) {
            priorityList.sort( function(a,b){
                if ( a.key === 'L' ) {
                    if (b.key === 'L' ) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else if (a.key === 'M') {
                    if (b.key === 'M') {
                        return 0;
                    }
                    else if (b.key === 'L') {
                        return -1;
                    }
                    else {
                        return 1;
                    }
                }
                else if (a.key === 'H') {
                    if (b.key === 'H') {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
            });
        }

        vm.typeaheadOnSelect = function userSelected (item, model, label, event){
            vm.userChanged();
        };
        vm.userChanged =  function userChanged () {
console.log("vm.userChanged #03");
            vm.invalidName = {};
            if (vm.routeToUnassigned) {
                vm.investigator = null;
            } else if ( vm.investigator &&  vm.investigator.userId ) {
                //userid was bound by typeahed - use it
                vm.invalidName = {};
            } else if ( vm.investigator &&  !vm.investigator.userId ) {
                //use has typed the name but did not select from dropdown, search in the list
                var user = _.findWhere(vm.users, {userId:vm.investigator});
                if (user && user.userId) {
                    vm.investigator = user;
                } else {
                    // if did not find in the list throw an error
                    vm.invalidName = {invalid:true};
                }
            }
            else {
                // if did not bind to a model,  throw an error
                vm.invalidName = {invalid:true};
            }
        };

        function ok() {
//console.log("333333");
            var employeeIndYesorNo = (vm.employeeInd === true) ? 'Y' : 'N';

            var userId = null;
            vm.userChanged(); //validate used
            if (vm.routeToUnassigned) {
                userId = '';
            } else if ( vm.investigator &&  vm.investigator.userId ) {
                userId = vm.investigator.userId;
            }
            else {
                // if did not bind to a model, throw an error
                userId = null;
            }

            var result = {
                description: vm.description,
                investigator: userId,
                priority: vm.priority,
                category: vm.caseCategory,
                subcategory: vm.caseSubcategory,

                queueCode: vm.routeToQueue,
                employeeIndicator: employeeIndYesorNo
            };
            if (userId !== null) {
                $uibModalInstance.close(result);
            }
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

        vm.switchEmployeeInd = function switchEmployeeInd() {
            vm.employeeInd = !vm.employeeInd;
        };
    }

})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    SuppressAlertsModalController.$inject = ["$uibModalInstance", "dataMessagingServiceFactory", "resources", "amlConstants", "amlCoreUtils"];
    angular.module('aml.customer.details').controller('SuppressAlertsModalController', SuppressAlertsModalController);

    function SuppressAlertsModalController($uibModalInstance, dataMessagingServiceFactory, resources, amlConstants,
            amlCoreUtils) {
        var vm = this;
        vm.resources = resources;
        vm.alertNumber = null;
        vm.resources = resources;
        vm.suppressionReason = null;
        vm.suppressIndefinitely = false;
        vm.ok = ok;
        vm.cancel = cancel;
        vm.suppressionDateOpen = suppressionDateOpen;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();

        ////////
        // global datepicker settings
        vm.dateFormat = 'mediumDate';
        vm.dateOptions = {
            startingDay: amlCoreUtils.getLocaleStartingDayOfWeek(),
            showWeeks: amlConstants.config.datePicker.showWeeks
        };

        var today = moment().startOf('day');
        vm.suppressionDate = today.toDate();
        vm.suppressionMinDate = today.toDate();

        activate();

        /////////

        function activate() {
            // get all alerts count from Alerts directive
            vm.alertNumber = dataMessagingService.getActiveAlertsCount();
        }

        function suppressionDateOpen($event) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.suppressionDateOpened = true;
        }

        function ok() {
//console.log("44444");
            var suppressionDate = null;
            if ( !vm.suppressIndefinitely) {
                suppressionDate = vm.suppressionDate;
            }

            var result = {
                allAlerts:  dataMessagingService.getActiveAlerts(),
                suppressionDate: suppressionDate,
                suppressionReason: vm.suppressionReason
            };

            $uibModalInstance.close(result);
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

    }
})();

/**
 * handle the case details window triage actions
 */
(function () {
    'use strict';
    CaseDetailsTriageController.$inject = ["$scope", "$state", "$stateParams", "$uibModal", "$rootScope", "$q", "$document", "resources", "casesListDataMessagingService", "casesService", "usersService", "amlConstants", "amlPreferencesService", "messageService", "tabsListService", "dialogService", "caseTriageService", "_", "commentService"];
    angular.module('aml.cases.details').controller('CaseDetailsTriageController', CaseDetailsTriageController);

    /* jshint maxparams: 18*/
    function CaseDetailsTriageController($scope, $state, $stateParams, $uibModal, $rootScope, $q, $document, resources,
                                         casesListDataMessagingService, casesService, usersService, amlConstants,
                                         amlPreferencesService, messageService, tabsListService, dialogService,
                                         caseTriageService, _, commentService) {
        var vm = this;
        vm.commentsOptions = {};
        vm.resources = resources;
        vm.changeDisplayCases = changeDisplayCases;
        vm.openCreateReportDialog = openCreateReportDialog;
        vm.openRouteCasesDialog = openRouteCasesDialog;
        vm.navigateBackToCasesList = navigateBackToCasesList;
        vm.saveCase = saveCase;

        vm.displayMyCases = false;
        vm.displayAllCases = false;
        vm.displayAvailableCases = false;
        vm.aCase = null;
        vm.readonly = false;  //set on caseLoaded depending on case ownership and capabilities
        vm.userCanRoute = false;  //set on caseLoaded depending on case ownership and capabilities
        vm.userCanCreateReport = usersService.currentUserHasCapability(amlConstants.capabilities.createReport);

        vm.caseId = $stateParams.caseid;
        vm.state = $state.$current;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [
                {
                    key: amlConstants.casesListQueueDisplayType.MY,
                    value: vm.resources.aml.casesList.displayQueueMyCases
                },
                {
                    key: amlConstants.casesListQueueDisplayType.AVAILABLE,
                    value: vm.resources.aml.casesList.displayQueueAvailableCases
                },
                {
                    key: amlConstants.casesListQueueDisplayType.ALL,
                    value: vm.resources.aml.casesList.displayQueueAllCases
                }
            ];

            //Set pill to clean initially
            $state.$current.data.dirty = false;

            //When the form is dirty then set the tab dirty
            $scope.$watch('formCtrl.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    var queryResult = $document[0].getElementById('button-toggle-comment-sidebar');
                    if (!queryResult.classList.contains('ng-dirty-add')) {
                        $state.$current.data.dirty = true;  // to set the tab pill to dirty
                    }
                    else {
                        $scope.formCtrl.$dirty = false;
                    }
                }
            });

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultCasesQueue = amlPreferencesService.getLocalPreference('defaultCasesQueue');
            if (defaultCasesQueue) {
                vm.displayOwnersType = defaultCasesQueue;
            }
            else {
                // if no preference is found, default to Available Cases
                vm.displayOwnersType = amlConstants.casesListQueueDisplayType.AVAILABLE;
            }

            $scope.$on('caseLoaded', function (event, args) {
                vm.aCase = args.val;
                vm.caseDescription = vm.aCase.description;
                vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeCase) && usersService.getCurrentUserId() === vm.aCase.ownerUserLongId ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCases)) ? true : false;
                vm.readonly = casesService.isCaseReadonly(args.val);
            });

            $scope.$on('casesOwnerChanged', function (event, changedData) {
                if (_.contains(changedData.caseNumbers, vm.aCase.caseId)) {
                    vm.aCase.ownerUserLongId = changedData.owner;
                }
            });

            // add a modal dialog to allow pill to be closed
            // return true to close...false to keep pill
            tabsListService.registerCloseCallback($state.$current, function dirtyCheckCallback() {
                var defer = $q.defer();
                if (vm.state.data.dirty === true) {
                    //Scope changes so store current form validity to check later
                    var formValidity = $scope.formCtrl.$valid;

                    dialogService.openDirtyFormDialog().then(function () {
                    }, function (buttonValue) {
                        if (buttonValue === 'discard') {
                            defer.resolve(true);
                        } else if (buttonValue === 'save') {
                            if (formValidity) {
                                casesService.saveCase(vm.aCase).then(
                                    function (savedCase) {
                                        var msg = vm.resources.aml.getResource('casedetails.triage.saveCaseActionSuccessMessage',
                                            {caseId: vm.caseId});
                                        messageService.success(msg, null, 10000);
                                        vm.state.data.dirty = false;  //Set the pill to be clean
                                        $scope.formCtrl.$setPristine(); //Set form to valid and clean
                                        $rootScope.$broadcast('caseListRefresh');
                                    },
                                    function (error) {
                                        messageService.danger(
                                            vm.resources.aml.getResource('casedetails.triage.saveCaseActionErrorMessage',
                                                {caseId: vm.caseId}), null, 4000);
                                    });

                                defer.resolve(true);
                            } else {
                                dialogService.openErrorFormDialog();
                                vm.state.data.dirty = true;  //Set the pill to be dirty
                                defer.resolve(false);
                            }
                        } else if (buttonValue === 'cancel') {
                            defer.resolve(false);
                        }
                    });
                } else {
                    defer.resolve(true);
                }
                return defer.promise;
            });

            updateDisplayCases();
        }

        function changeDisplayCases() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultCasesQueue, vm.displayOwnersType);

            updateDisplayCases();
        }

        function updateDisplayCases() {
            casesListDataMessagingService.setDisplayOwnersType(vm.displayOwnersType);

            vm.displayMyCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.MY;
            vm.displayAvailableCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.AVAILABLE;
            vm.displayAllCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.ALL;
        }

        function openRouteCasesDialog() {
            caseTriageService.openRouteCasesDialog(
                [vm.caseId],
                vm.caseId,
                vm.aCase.ownerUserLongId,
                vm.aCase.queueCode,
                function ownerChangedCallback(caseNumbers, routeToUser) {
                    $rootScope.$broadcast('caseListRefresh');
                    vm.aCase.ownerUserLongId = routeToUser;
                }
            ).then(function () {
                navigateBackToCasesList();
            });
        }

        function checkDOEPEntities(entities) {
            var repReqLst = _.where(entities, {reportRequired: 'Y'});
            return repReqLst && repReqLst.length === 1;
        }

        function openCreateReportDialog() {
            var modalInstance = $uibModal.open({
                templateUrl: 'cases/caseDetails/triage/dialogs/createReport.html',
                controller: 'CreateReportModalController as vm',
                backdrop: 'static', // don't allow to click outside of modal
                resolve: {
                    parentCaseId: function () {
                        return vm.caseId;
                    },
                    caseDescription: function () {
                        return vm.caseDescription;
                    }
                }
            });

            modalInstance.result.then(function (result) {
                casesService.getCaseEntities(vm.caseId).then(function (data) {
                    if (result && result.reportTypeKey && result.formTypeCode === 'DOEP' && !checkDOEPEntities(data.items)) {
                        messageService.danger(
                            vm.resources.aml.getResource('regulatoryReports.triage.createDOEPReportActionErrorMessage',
                                {caseId: vm.caseId}), null, 4000);
                        return;
                    }
                    casesService.createReport(vm.caseId, result.description, result.reportTypeKey).then(
                        function (createdReport) {
                            var msg = vm.resources.aml.getResource('regulatoryReports.triage.createReportActionSuccessMessage',
                                {reportKey: createdReport.reportKey, caseId: vm.caseId});
                            messageService.success(msg, null, 10000);
                            //When report created, change case status to Report Initiated and automatically save it.
                            vm.aCase.statusCode = 'I';
                            $scope.formCtrl.$dirty = true;
                            vm.saveCase();
                            $rootScope.$broadcast('reportListRefresh');
                        },
                        function (error) {
                            messageService.danger(
                                vm.resources.aml.getResource('regulatoryReports.triage.createReportActionErrorMessage',
                                    {caseId: vm.caseId}), null, 4000);
                        });
                });
            });
        }
        
        function fnCaseMsg(){
					return $uibModal.open({
              animation: true,
              templateUrl: 'modalCaseNoti.html',
              controller: 'CddReviewModalController as viewVm',
              size: 'm',
              backdrop: 'static'
          });
        }

        function saveCase() {

//console.log(vm);
//console.log(vm.aCase.statusCode);
            
						// , RFI 
						if((vm.aCase.statusCode == "C" || vm.aCase.statusCode == "R") && vm.commentsOptions.commentsCount == 0){
							fnCaseMsg();
						
						// , RFI 
						}else if((vm.aCase.statusCode == "C" || vm.aCase.statusCode == "R") && vm.commentsOptions.commentsCount > 0){
	            commentService.getComments("CAS", vm.caseId, null, 0, 20).then(function (data) {
								var attachCount = 0;
//console.log(data);
	            	$.each(data.items, function(index, item){
	          			if(item.attachments != null){
	            			if(item.attachments.length > 0){
	            				attachCount++;
	            			}
	            		}
	            	});
	            	
	            	//  
	            	if(attachCount < 1){
	            		fnCaseMsg();
	            	//  
	            	}else{
			            if ($scope.formCtrl.$valid && $scope.formCtrl.$dirty) {
			                //if SAR90 case status is changed from S to any other value for the first time then set activateDate
			                //this is done in the service but currently we do not get updated case back, so have to duplicate
			                //it here.
			                if (vm.aCase.caseCategoryCode === 'SAR90' && vm.aCase.statusCode !== 'S' && !vm.aCase.activateDate) {
			                    vm.aCase.activateDate = new Date();
			                }
			                casesService.saveCase(vm.aCase).then(
			                    function (savedCase) {
			                        var msg = vm.resources.aml.getResource('casedetails.triage.saveCaseActionSuccessMessage',
			                            {caseId: vm.caseId});
			                        messageService.success(msg, null, 10000);
			                        //Refresh the current case description so Create Report is correct.
			                        vm.caseDescription = vm.aCase.description;
			                        vm.state.data.dirty = false;  //Set the pill to be clean
			                        $scope.formCtrl.$setPristine(); //Set form to valid and clean
			                        $rootScope.$broadcast('caseListRefresh');
			                        //Broadcast save event to cases in view, but make sure only the relevant case responds
			                        //Prevents all cases in view from reacting to one case's save event
			                        $rootScope.$broadcast('caseSave', {savedCase: savedCase});
			                    },
			                    function (error) {
			                        messageService.danger(
			                            vm.resources.aml.getResource('casedetails.triage.saveCaseActionErrorMessage',
			                                {caseId: vm.caseId}), null, 4000);
			                    });
			            }
			            else if ($scope.formCtrl.$invalid) {
			                dialogService.openErrorFormDialog();
			                vm.state.data.dirty = true;  //Set the pill to be dirty
			            }
	            	}
	            });
	           
	          // , RFI 
						}else{
							
	            if ($scope.formCtrl.$valid && $scope.formCtrl.$dirty) {
	                //if SAR90 case status is changed from S to any other value for the first time then set activateDate
	                //this is done in the service but currently we do not get updated case back, so have to duplicate
	                //it here.
	                if (vm.aCase.caseCategoryCode === 'SAR90' && vm.aCase.statusCode !== 'S' && !vm.aCase.activateDate) {
	                    vm.aCase.activateDate = new Date();
	                }
	                casesService.saveCase(vm.aCase).then(
	                    function (savedCase) {
	                        var msg = vm.resources.aml.getResource('casedetails.triage.saveCaseActionSuccessMessage',
	                            {caseId: vm.caseId});
	                        messageService.success(msg, null, 10000);
	                        //Refresh the current case description so Create Report is correct.
	                        vm.caseDescription = vm.aCase.description;
	                        vm.state.data.dirty = false;  //Set the pill to be clean
	                        $scope.formCtrl.$setPristine(); //Set form to valid and clean
	                        $rootScope.$broadcast('caseListRefresh');
	                        //Broadcast save event to cases in view, but make sure only the relevant case responds
	                        //Prevents all cases in view from reacting to one case's save event
	                        $rootScope.$broadcast('caseSave', {savedCase: savedCase});
	                    },
	                    function (error) {
	                        messageService.danger(
	                            vm.resources.aml.getResource('casedetails.triage.saveCaseActionErrorMessage',
	                                {caseId: vm.caseId}), null, 4000);
	                    });
	            }
	            else if ($scope.formCtrl.$invalid) {
	                dialogService.openErrorFormDialog();
	                vm.state.data.dirty = true;  //Set the pill to be dirty
	            }
	            
						}

//console.log(CommentsSidebarDirectiveController.)
        }

        function navigateBackToCasesList() {
            // close current tab for the current state
            tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);
            // change current (originating) window back to cases list
            $state.go('cases');
        }
    }
})();

/**
 * handle the case triage actions
 */
(function () {
    'use strict';
    CaseTriageController.$inject = ["$uibModal", "$state", "resources", "caseTriageService", "casesListDataMessagingService", "messageService", "casesService", "usersService", "linksProcessor", "amlConstants", "amlPreferencesService", "_"];
    angular.module('aml.cases.details').controller('CaseTriageController', CaseTriageController);
    /* jshint maxparams: 12 */
    function CaseTriageController($uibModal, $state, resources, caseTriageService, casesListDataMessagingService,
                                  messageService, casesService, usersService, linksProcessor, amlConstants, amlPreferencesService, _) {
        var vm = this;
        vm.resources = resources;
        vm.openRouteCasesDialog = openRouteCasesDialog;
        vm.checkinCases = checkinCases;
        vm.checkoutCases = checkoutCases;
        vm.changeDisplayCases = changeDisplayCases;
        vm.openCreateManualInvestigationDialog = openCreateManualInvestigationDialog;

        vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeCase) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCases)) ? true : false;
        vm.userCanCheckin = usersService.currentUserHasCapability(amlConstants.capabilities.checkinCase);
        vm.userCanCheckout = usersService.currentUserHasCapability(amlConstants.capabilities.checkoutCase);
        vm.userCanCreateInvestigation = usersService.currentUserHasCapability(amlConstants.capabilities.createCase);

        vm.displayMyCases = false;
        vm.displayAllCases = false;
        vm.displayAvailableCases = false;

        vm.isCheckinOwner = isCheckinOwner;
        vm.isOwnerEmptyForCheckout = isOwnerEmptyForCheckout;
        vm.userCanRouteSelected = userCanRouteSelected;

        var expectedStateName = $state.$current.name;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [];
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCasesMy)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.casesListQueueDisplayType.MY,
                        value: vm.resources.aml.casesList.displayQueueMyCases
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCasesAll)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.casesListQueueDisplayType.ALL,
                        value: vm.resources.aml.casesList.displayQueueAllCases
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCasesAvailable)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.casesListQueueDisplayType.AVAILABLE,
                        value: vm.resources.aml.casesList.displayQueueAvailableCases
                    }
                );
            }

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultCasesQueue = amlPreferencesService.getLocalPreference('defaultCasesQueue');
            if (defaultCasesQueue) {
                vm.displayOwnersType = defaultCasesQueue;
            }
            else {
                // if no preference is found, default to Available Cases
                vm.displayOwnersType = amlConstants.casesListQueueDisplayType.AVAILABLE;
            }

            //if default or saved option does not exists then use first available option
            if (!_.findWhere(vm.displayOwnersTypes, { key: vm.displayOwnersType })) {
                if (vm.displayOwnersTypes[0]) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.casesListQueueDisplayType.MY;
                }
            }

            updateDisplayCases();
        }

        vm.reloadList = function () {
            casesListDataMessagingService.reloadGrid();
        };

        //For now, this is the same value case number and case name
        function getSelectedCaseId() {
            var caseId = null;
            var selectedCaseIds = casesListDataMessagingService.getSelectedCaseNumbers();
            if (selectedCaseIds && selectedCaseIds.length > 0) {
                caseId = selectedCaseIds[0];
            }
            return caseId;
        }

        function openRouteCasesDialog() {
            var selectedCaseNumbers = casesListDataMessagingService.getSelectedCaseNumbers();
            var user = '';
            var queue = '';
            if(selectedCaseNumbers.length === 1) {
                // We are routing just one case.
                user = casesListDataMessagingService.getSelectedCaseOwners()[0];
                queue = casesListDataMessagingService.getSelectedCaseQueues()[0];
            }
            caseTriageService.openRouteCasesDialog(
                selectedCaseNumbers,
                getSelectedCaseId(),
                user,
                queue,
                refreshCasesOwner
            ).then(
                function () {
                }
            );
        }

        function checkinCases() {
            caseTriageService.checkinCases(casesListDataMessagingService.getSelectedCaseNumbers(),
                getSelectedCaseId(), refreshCasesOwner);
        }

        function checkoutCases() {
            caseTriageService.checkoutCases(casesListDataMessagingService.getSelectedCaseNumbers(),
                getSelectedCaseId(), refreshCasesOwner);
        }

        function changeDisplayCases() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultCasesQueue, vm.displayOwnersType);

            updateDisplayCases();
        }

        function updateDisplayCases() {
            casesListDataMessagingService.setDisplayOwnersType(vm.displayOwnersType);

            vm.displayMyCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.MY;
            vm.displayAvailableCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.AVAILABLE;
            vm.displayAllCases = vm.displayOwnersType === amlConstants.casesListQueueDisplayType.ALL;
        }

        /**
         * To use from the UI to enable/disable the route button
         * depending on the queue and whether selected cases are assigned to current user
         * @returns {boolean}
         */
        function userCanRouteSelected() {
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                if (vm.displayOwnersType === amlConstants.casesListQueueDisplayType.MY) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeCase);
                }
                if (vm.displayOwnersType === amlConstants.casesListQueueDisplayType.ALL) {
                    return (usersService.currentUserHasCapability(amlConstants.capabilities.routeCase)  && isCheckinOwner()) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCases);
                }
                if (vm.displayOwnersType === amlConstants.casesListQueueDisplayType.AVAILABLE) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCases);
                }
            }
            return false;
        }

        /**
         * To use from the UI to enable/disable the checkin/checkout and route buttons
         * depending on whether selected cases are assigned to current user
         * @returns {boolean}
         */
        function isCheckinOwner() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var currentUser = usersService.getCurrentUserId();
                var selectedEntities = casesListDataMessagingService.getSelectedCases();
                if (!selectedEntities || selectedEntities.length === 0) {
                    allOwned = false;
                }
                else {
                    allOwned = _.every(selectedEntities, function (entity) {
                        return entity.ownerUserLongId === currentUser;
                    });
                }
            }
            return allOwned;
        }


        function isOwnerEmptyForCheckout() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var selectedEntities = casesListDataMessagingService.getSelectedCases();
                if ( !selectedEntities || selectedEntities.length === 0 ) {
                    allOwned = false;
                }
                else {
                    allOwned =_.every(selectedEntities, function(entity) {
                        return !entity.ownerUserLongId || entity.ownerUserLongId === null || entity.ownerUserLongId === '';
                    });
                }
            }
            return allOwned;
        }

        function refreshCasesOwner(caseNumbers, owner, queue) {
            casesListDataMessagingService.casesOwnerChanged(caseNumbers, owner, queue);
        }

        function openCreateManualInvestigationDialog(size) {

            var modalInstance = $uibModal.open({
                templateUrl: 'alerts/triage/dialogs/createManualInvestigation.html',
                controller: 'CreateManualInvestigationModalController as vm',
                size: size,
                backdrop: 'static' // don't allow to click outside of modal
            });

            modalInstance.result.then(function (result) {


                // We are creating a manual case, so there will be no alerts to close/include.
                // Create it as an AML case - No reason to create it as an ECM case here.
                casesService.createCase(null, null, result.priority, result.description,
                    result.investigator, result.category, result.subcategory, result.queueCode, result.employeeIndicator).then(function (createdCase) {
                        var investigationId;
                        var msg;

                        // if created an ecm case, construct an ecm message
                        if (amlConstants.config.defaultCaseDestination &&
                            amlConstants.config.defaultCaseDestination.toLowerCase() === 'ecm') {
                            investigationId = createdCase.id;
                            // add the ECM case link when displaying the success message alert
                            var caseLink = linksProcessor.getLinkHrefForRel(createdCase.links, 'investigationDisplay');
                            msg = vm.resources.aml.getResource('alerts.triage.createInvestigationECMActionSuccessMessageNoneText',
                                {
                                    investigationId: investigationId,
                                    caseLink: caseLink
                                });
                        }
                        else {
                            // created an AML case
                            investigationId = createdCase.caseId;
                            // add the case link when displaying the success message alert
                            msg = vm.resources.aml.getResource('cases.triage.createManualInvestigationActionSuccessMessage',
                                {
                                    investigationId: investigationId
                                });
                        }

                        messageService.success(msg, null, 10000);
                    },
                    function (error) {
                        messageService.danger(
                            vm.resources.aml.getResource('cases.triage.createManualInvestigationActionErrorMessage'),
                            null, 4000);
                    });

                // after performing action, return back to customer list
                navigateBackToCasesList();
            }, function () {
                //$log.info('Modal dismissed at: ' + new Date());
            });
        }

        function navigateBackToCasesList() {
            // change current (originating) window back to cases list
            $state.go('cases');
        }
    }
})();

/**
 * Created by tommut on 1/22/2015.
 */
(function() {
    'use strict';
    AddressController.$inject = ["$scope", "amlConstants", "titleCaseFilter", "resources", "amlCoreUtils"];
    angular.module('aml.core').controller('AddressController', AddressController);

    function AddressController($scope, amlConstants, titleCaseFilter, resources, amlCoreUtils) {
        var vm = this;
        vm.resources = resources;
        vm.status = { };
        vm.status.addressNotResolved = true;

        activate();

        //////////////////

        function activate() {
            // set up map configuration
            vm.mapFeatures = [];
            vm.mapOptions = { zoomControl: true,
                zoom: amlConstants.config.map.mapTileProviderStartingZoom,
                minZoom: 2,
                trackResize: false, worldCopyJump: true
            };

            vm.mapTileProviderUrl = amlConstants.config.map.mapTileProvider;

            // when the address value is set, then set it on the mapoptions object which will render
            // the map of the address
            var deregisterWatch = $scope.$watch(
                function() {return vm.address;},
                function(address) {
                    if (address) {
                        vm.mapOptions.address = address;
                        deregisterWatch();
                    }
                });
        }
    }
})();

/**
 * Created by tomutd on 1/22/2015.
 */
(function() {
    'use strict';
    AddressDisplayController.$inject = ["$scope", "titleCaseFilter", "resources", "amlCoreUtils"];
    angular.module('aml.core').controller('AddressDisplayController', AddressDisplayController);

    function AddressDisplayController($scope, titleCaseFilter, resources, amlCoreUtils) {
        var vm = this;
        vm.resources = resources;

        activate();

        //////////////////

        function activate() {
            // when the address is set, set a formatted address
            var deregisterWatch = $scope.$watch(
                function() {return vm.address;},
                function(address) {
                    if (address) {
                        // titleCase address so it shows nicely on map marker tooltip
                        _.each( vm.address, function( value, prop ) {
                            vm.address[prop] = titleCaseFilter(value);
                        });

                        vm.address2 = amlCoreUtils.formatCityStateZip(address.city, address.state, address.postalcode);
                        deregisterWatch();
                    }
                });
        }
    }
})();

(function() {
    'use strict';
    AMLCountdownController.$inject = ["$scope", "kendoGridRendererService"];
    angular.module('aml.core').controller('AMLCountdownController', AMLCountdownController);

    function AMLCountdownController($scope, kendoGridRendererService) {
        var vm = this;

        vm.updateCountdown = updateCountdown;
        vm.countdownLevel = 'low';
        vm.priorityImg = 'images/StatusLowPriority32.svg';

        activate();

        //////////
        function activate() {
            $scope.$watch(function (){return vm.startdate;},
                function (){
                    if (vm.startdate) {
                        updateCountdown();
                    }
                }
            );
        }

        function updateCountdown() {
            vm.countdownLevel = 'low';
            vm.priorityImg = 'images/StatusLowPriority32.svg';

            vm.remainingTime = kendoGridRendererService.calculateRemainingTime(moment(vm.startdate),
                moment(vm.enddate), vm.type);

            if ( vm.remainingTime ) {
                if (kendoGridRendererService.isCountdownMediumPriority(vm.remainingTime, vm.type)) {
                    vm.countdownLevel = 'medium';
                    vm.priorityImg = 'images/StatusMediumPriority32.svg';
                }
                else  if (kendoGridRendererService.isCountdownHighPriority(vm.remainingTime, vm.type)) {
                    vm.countdownLevel = 'high';
                    vm.priorityImg = 'images/StatusImportant32.svg';
                }
            }
            //return vm.countdownLevel;
        }


    }
})();

/**
 * @ngdoc controller
 * @name    aml.core:MapController
 *
 * @description
 * The map controller handles converting an address to a geocoded latitude and longitude
 */
(function() {
    'use strict';

    MapController.$inject = ["$resource", "$scope", "amlConstants"];
    angular
        .module('aml.core')
        .controller('MapController', MapController);

    /* @ngInject */
    function MapController( $resource, $scope, amlConstants ) {
        var scope = $scope;
        if ( scope.status ) {
            scope.status.addressNotResolved = false;
        }

        activate();

        function activate() {

            // if the mapTileProvider is not defined in the custom config file, then
            // we will not activate the map widget
            if ( !amlConstants.config.map || !amlConstants.config.map.mapTileProvider ) {
                scope.status.addressNotResolved = true;
                return;
            }

            // if an address is already set, use it
            if ( scope.sngOptions && scope.sngOptions.address ) {
                getAndUpdateLatitudeForAddress(scope.sngOptions.address);
            }
            // otherwise, set up a one-time watch until it is set
            else {
                var addressWatchUnbind = $scope.$watch(
                    function() { return scope.sngOptions.address;  },
                    function(newAddress) {
                        if (newAddress) {
                            getAndUpdateLatitudeForAddress(newAddress);

                            addressWatchUnbind();
                        }
                    });
            }
        }

        function getAndUpdateLatitudeForAddress(address) {
                var resource = $resource(
                    amlConstants.config.map.mapGeocoderProvider,

                    //  var resource = $resource('http://nominatim.openstreetmap.org/search
                    //  ?format=json&limit=5&street=100%20sas%20campus%20dr&city=cary&state=nc',

                    // can also use:
                    //http://maps.googleapis.com/maps/api/geocode/json?address=my address,my city, mystate
                    {
                        format: 'json',
                        limit: 1,
                        street: '@street',
                        city: '@city',
                        state: '@state',
                        country: '@country',
                        postalcode: '@postalcode'
                    },
                    {
                        get: {
                            method: 'GET', isArray: true
                        }
                    });

                resource.get({
                        street: address.street,
                        city: address.city,
                        state: address.state,
                        country: address.country,
                        postalcode: address.postalcode
                    }
                ).$promise.then(function(data) {
                        if (data.length && data.length >= 1) {
                            var mapOb = data[0];
                            var latLong = [mapOb.lat, mapOb.lon];
                            scope.sngOptions.center = latLong;
                        }
                        else {
                            // if zero results found, it's possible that the geoLocator data does not exist for
                            // the specific address.  In that case, we'll try broader query with just city, state;
                            // broaden search radius to just the city
                            if ( address.street ) {
                                var broadAddress = angular.extend( {}, address );
                                broadAddress.street = null;
                                broadAddress.postalcode = null;
                                // make a request without address
                                getAndUpdateLatitudeForAddress( broadAddress );
                            }
                            else {
                                // the broader query failed to return data.
                                if ( scope.status ) {
                                    scope.status.addressNotResolved = true;
                                }
                            }
                        }
                    });
        }
    }
})();
/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    AboutModalController.$inject = ["resources", "usersService", "amlConstants"];
    angular.module('aml.core').controller('AboutModalController', AboutModalController);

    function AboutModalController( resources, usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        vm.copyrightDates = amlConstants.copyrightDates;
        vm.versionNumber = amlConstants.versionNumber;
        vm.helpVersionNumber = amlConstants.helpVersionNumber;

        activate();

        /////////
        function activate() {
            vm.buildVersion = usersService.getBuildVersion();
            vm.buildDate = usersService.getBuildDate();
        }

    }
})();

(function() {
    'use strict';
    AMLNavController.$inject = ["$uibModal", "adminService", "usersService", "resources", "amlConstants", "resourceService"];
    angular.module('aml.core').controller('AMLNavController', AMLNavController);

    function AMLNavController($uibModal, adminService, usersService, resources,
            amlConstants, resourceService) {
        var vm = this;
        vm.openAboutDialog = openAboutDialog;
        vm.clearCache = clearCache;
        vm.resources = resources;
        vm.userId = undefined; // to allow to lazily show
        vm.businessUnit = null;
        vm.businessUnitMemberships = null;
        vm.configConstants = amlConstants.config;
        vm.businessUnitChanged = businessUnitChanged;

        vm.versionNumber = amlConstants.versionNumber;
        vm.helpVersionNumber = amlConstants.helpVersionNumber;

        activate();

        //////////

        function activate() {
            usersService.getCurrentUser().then( function( user) {
                vm.userId = user.userId;
                vm.businessUnit = user.businessUnit;
                vm.businessUnitMemberships = user.businessUnitMemberships;

                if ( vm.businessUnitMemberships ) {
                    vm.businessUnitMemberships = vm.businessUnitMemberships.sort(function (a, b) {
                        // sort by alphabetical
                        return a.toLowerCase().localeCompare(b.toLowerCase());
                    });
                }
            });

            // get locale for Help link
            resourceService.getLocale().then(function(locale) {
                vm.locale = locale;
            });


        }

        function businessUnitChanged(selectedBusinessUnit) {
            adminService.setBusinessUnit(selectedBusinessUnit);
        }

        function openAboutDialog() {
            $uibModal.open({
                templateUrl: 'core/layout/navbar/about.html',
                controller: 'AboutModalController as vm'
            });
        }

        function clearCache() {
            adminService.clearCache().then( function() {
               adminService.refreshPageWithMessage( resources.aml.navbar.cacheClearedSuccessMessage );
            });
        }
    }
})();

/**
 * Created by dabock on 1/7/2016.
 */
(function() {
    'use strict';
    AmlKendoSearchResultsController.$inject = ["resources"];
    angular.module('aml.core').controller('AmlKendoSearchResultsController', AmlKendoSearchResultsController);

    function AmlKendoSearchResultsController(resources) {
        var vm = this;
        vm.resources = resources;
    }
})();

(function() {
    'use strict';
    AMLScoreController.$inject = ["kendoGridRendererService"];
    angular.module('aml.core').controller('AMLScoreController', AMLScoreController);

    function AMLScoreController(kendoGridRendererService) {
        var vm = this;

        vm.updateScore = updateScore;

        activate();

        //////////
        function activate() {
            vm.updateScore();
        }

        function updateScore() {
            if ( vm.priority) {
                if (kendoGridRendererService.isHighPriority(vm.priority) ) {
                    vm.scoreLevel = 'high';
                    vm.priorityImg = 'images/StatusImportant32.svg';
                }
                else if (kendoGridRendererService.isMediumPriority(vm.priority ) ) {
                    vm.scoreLevel = 'medium';
                    vm.priorityImg = 'images/StatusMediumPriority32.svg';
                }
                else if ( kendoGridRendererService.isLowPriority(vm.priority ) ) {
                    vm.scoreLevel = 'low';
                    vm.priorityImg = 'images/StatusLowPriority32.svg';
                }
            }
            else {
                vm.scoreLevel = 'low';
                vm.priorityImg = 'images/StatusLowPriority32.svg';
            }
            return vm.scoreLevel;
        }

    }
})();

/**
 * This simply creates a list of states-with-named-views and all other states, so that the
 * <div ui-view="..."> elements can be created for each.
 *
 */
(function() {
    'use strict';
    StateViewController.$inject = ["data", "$scope"];
    angular.module('aml.core').controller('StateViewController', StateViewController);

    function StateViewController(data, $scope) {
        var vm = this;
        vm.stateName = data.stateName;
        $scope.state = { name: data.stateName };
    }

})();

/**
 * This controller simply creates a list tabs for states-with-named-views for a given parent state, so that the
 * <div ui-view="..."> elements can be created for each.
 *
 */
(function() {
    'use strict';
    AMLTabbedUIViewController.$inject = ["$state", "$scope"];
    angular.module('aml.core').controller('AMLTabbedUIViewController', AMLTabbedUIViewController);

    function AMLTabbedUIViewController($state, $scope) {
        var vm = this;
        vm.$state = $state;
        vm.states = [];
        vm.viewlessStates = [];
        vm.isViewlessState = isViewlessState;
        vm.isViewState = isViewState;

        activate();

        /////////

        function addStates() {
            // add all of the view states to a list, so that a <div ui-view="..."> can be created for each
            vm.states = [];
            vm.viewlessStates = [];
            _.each( $state.get(), function(state) {
               addState( state );
            });
        }

        function activate() {
            addStates();
        }

        function addState(state) {
            if ( !state.abstract && state.name ) {
                var name = state.name;
                var views = _.keys(state.views);

                var parentStateForGivenState = state.parent;
                if ( parentStateForGivenState && parentStateForGivenState === vm.parentState ) {
                    if (views && views.length > 0) {
                        _.each(views, function (view) {
                            vm.states.push({name: name, view: view});
                        });
                    }
                    else {
                        vm.viewlessStates.push(name);
                    }
                }
            }
        }

        /**
         * This returns true if this is a standard state without a named view defined; this is used to show all other
         * standard states in a single <div ui-view>
         *
         * @returns {boolean} true if the current state has no defined named view
         */
        function isViewlessState() {
            var stateName = $state.current.name;
            var viewlessState = _.contains( vm.viewlessStates, stateName );
            return viewlessState;
        }


        function isViewState(name) {
            var isState = vm.$state.includes(name);
            return isState;
        }
    }

})();

/**
 * handle AML nested tab area navigation
 */
(function () {
    'use strict';
    TabAreaNavigationController.$inject = ["$state", "resources", "tabAreaNavigationServiceFactory"];
    angular.module('aml.core').controller('TabAreaNavigationController', TabAreaNavigationController);

    function TabAreaNavigationController( $state, resources, tabAreaNavigationServiceFactory) {
        var vm = this;
        vm.resources = resources;
        vm.navigate = navigate;
        vm.$state = $state;

        var tabAreaNavService = tabAreaNavigationServiceFactory.getInstance( vm.parentState );

        vm.areas = tabAreaNavService.visibleAreas;

        activate();

        //////

        function activate() {
            tabAreaNavService.initializeVisibleAreas($state.$current);
        }

        function navigate(area) {
            tabAreaNavService.navigate(area);
        }
    }
})();

/**
 * handle AML Functional area tab navigation
 */
(function () {
    'use strict';
    AreaNavigationController.$inject = ["$state", "resources", "areaNavigationService"];
    angular.module('aml.core').controller('AreaNavigationController', AreaNavigationController);

    function AreaNavigationController( $state, resources, areaNavigationService) {
        var vm = this;
        vm.resources = resources;
        vm.navigate = navigate;
        vm.$state = $state;
        vm.areas = areaNavigationService.visibleAreas;

        activate();

        //////

        function activate() {
            areaNavigationService.initializeVisibleAreas();
        }

        function navigate(area) {
            areaNavigationService.navigate(area);
        }
    }
})();

(function() {
    'use strict';
    TabsListController.$inject = ["tabsListService", "resources", "$state"];
    angular.module('aml.core').controller('TabsListController', TabsListController);

    function TabsListController(tabsListService, resources, $state) {
        var vm = this;
        vm.tabs = tabsListService.tabs;
        vm.$state = $state;
        vm.navigate = navigate;
        vm.closeTab = closeTab;
        vm.closeAllTabs = closeAllTabs;
        vm.closeAllOtherTabs = closeAllOtherTabs;
        vm.canCloseAllOtherTabs = false;
        vm.menuToggled = menuToggled;
        vm.resources = resources;

        function navigate(tab) {
           tabsListService.navigate(tab);
        }

        function closeTab(tab) {
            tabsListService.closeTab(tab);
        }

        function closeAllTabs() {
            tabsListService.closeAllTabs();
        }

        function closeAllOtherTabs() {
            tabsListService.closeAllOtherTabs();
        }

        /**
         * On menu open, check to see if currently on an object tab.
         * Only enable 'Close All Other Tabs' if currently on a closeable object tab.
         * @param opening: boolean - true if the menu is opening; false if closing
         */
        function menuToggled(opening) {
            if ( opening ) {
                vm.canCloseAllOtherTabs = vm.tabs.length > 1 &&
                    angular.isDefined( $state.current.data ) && angular.isDefined( $state.current.data.tabInfo );
            }
        }

    }
})();

/**
 * handle the review triage actions
 */
(function (){
    'use strict';
    EddDetailsController.$inject = ["amlLov", "resources", "$stateParams", "$state", "$scope"];
    angular.module('cdd.reviews')
        .controller('EddDetailsController', EddDetailsController);

    function EddDetailsController(amlLov, resources, $stateParams, $state, $scope) {
        var vm = this;
        vm.state = $state.$current;
        vm.isNewReview = $stateParams.newEntityFlag;
        vm.resources = resources;
            
        vm.completedChanged = function () {
            //run validation to reset error
            vm.validator.validateReview();
        };
        
        var unbindEddStepsForm = $scope.$watch('vm.eddStepsForm', function () {
            vm.forms.eddStepsForm = vm.eddStepsForm;
            $scope.$watch('vm.forms.eddStepsForm.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    vm.state.data.dirty = true;  // to set the tab pill to show an asterisk (dirty)
                }
            });
            unbindEddStepsForm();
        });

        vm.checkAll = function () {
            if (vm.selectedAll) {
                vm.selectedAll = true;
            } else {
                vm.selectedAll = false;
            }
            angular.forEach(vm.eddDetails, function (item) {
                item.stepRequired = vm.selectedAll ? 'Y':'N';
            });
        };

        vm.toggle = function(source) {
            var checkboxes = document.getElementsByName('eddCheckBox');
            for(var i=0, n=checkboxes.length;i<n;i++) {
                checkboxes[i].checked = source.checked;
            }
        };

    }
})();

/**
 * Created by omkulk on 1/22/2015.
 */

(function() {
    'use strict';
    CddReviewGridScoresChartController.$inject = ["cddReviewDetailsService", "resources", "$stateParams", "resourceService", "dateFilter"];
    angular.module('cdd.reviews').controller('cddReviewGridScoresChartController', CddReviewGridScoresChartController);

    function CddReviewGridScoresChartController(cddReviewDetailsService, resources,
                                    $stateParams, resourceService, dateFilter) {
        // init
        var vm = this;
        
        var cddReviewKey = $stateParams.reviewKey;
        vm.scatterId = 'scatterPlot' + cddReviewKey;
        vm.domId = vm.scatterId;
        vm.resources = resources;


        var appLocale = 'i'; //to catch initialization errors

        function activate(cddReviewKey, domId){
            cddReviewDetailsService.getOverallScores(cddReviewKey).then(function(data){

                    var scores = data.items;
                    var xAxisLabel =  vm.resources.aml.admin.cddReview.details.scoring.scoringTrends.dateLabel;
                    var yAxisLabel =  vm.resources.aml.admin.cddReview.details.scoring.scoringTrends.scoreLabel;
                    var averageThreshold =  vm.resources.aml.admin.cddReview.details.scoring.scoringTrends.averageScoreLabel;

                    resourceService.getLocale().then(function (locale) {
                       appLocale = locale;
                        cddReviewDetailsService.scatterLinePlot(scores, domId, yAxisLabel, averageThreshold,yAxisLabel, xAxisLabel, appLocale, dateFilter);

                    });

                });
        }

        activate(cddReviewKey,  vm.domId);
    }

})();


(function() {
    'use strict';
    CddGrids.$inject = ["$stateParams", "kendoGridRendererService", "logger", "cddReviewDetailsService", "resources"];
    angular.module('cdd.reviews').controller('cddReviewGridScoresController', CddGrids);

    function CddGrids( $stateParams, kendoGridRendererService, logger, cddReviewDetailsService, resources ) {

        var vm = this;
        var cddReviewKey = $stateParams.reviewKey;
        // vm.params;
        vm.grid = {};
        vm.categoryGrid = {};
        vm.attributeGrid = {};
        vm.amlGridActions = [];
        var selectedOverallDate = null;
        var selectedCategory;
        var entityNumber;
        var entityLevelCode;
        var isNewReview = $stateParams.newEntityFlag;

        // vm.params.reload = reloadGrid;
        vm.resources = resources;
        vm.getScores = getScores;
        vm.getCategoryScores = getCategoryScores;
        vm.getAttributeScores = getAttributeScores;

        vm.handleOverallScoresRowSelect = function(scoreEvent) {

            if ( scoreEvent ) {
                selectedOverallDate = scoreEvent.eventDate;
                kendoGridRendererService.refreshGrid( vm.categoryGrid );
            }
        };

        vm.handleOverallCategoryRowSelect = function(data) {

            if(data){
                selectedCategory = data.categoryCode;
                kendoGridRendererService.refreshGrid( vm.attributeGrid );
            }
        };
        
        // vm.handleOverallAttributeTowSelect = function(data){
        //    
        // };

        vm.gridColumns = [
            {
                field: 'ruleScore', type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.scoringTrends.scoreLabel,
                width: '9%'
            },
            {
                field: 'scoreClassificationCode', type: 'string',
                title: resources.aml.reviews.initialRiskRating,
                width: '12%',
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification'),
                template: kendoGridRendererService.enum('scoreClassificationCode', 'scoreClassification')
            },
            {
                field: 'eventDate', type: 'date',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.eventDateLabel,
                template: kendoGridRendererService.longDateMediumTime('eventDate'),
                width: '20%'
            },
            {
                field: 'cddReviewKey', type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.reviewLink,
                attributes:  {class: 'number-display'},  //right alignment
                template: '#if (cddReviewKey>0) {# <a href="\\#/cddReviews/{{dataItem.cddReviewKey}}">{{dataItem.cddReviewKey}}</a> #}#',
                width: '14%'
            },
            {
                field: 'reviewFinalDispositionCode', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.reviewFinalDispositionCode,
                width: '15%',
                filterable: kendoGridRendererService.getCheckboxFilter('finalDisposition'),
                template: kendoGridRendererService.enum('reviewFinalDispositionCode', 'finalDisposition', true)
            },
            {
                field: 'reviewRatingOverride', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.riskOverride,
                width: '15%',
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification'),
                template: kendoGridRendererService.enum('reviewRatingOverride', 'scoreClassification', true)
            }
        ];

        vm.gridColumnsCategoryScores = [
            {
                field: 'categoryCode', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.categoryScores.nameLabel,
                filterable: kendoGridRendererService.getCheckboxFilter('ruleGroupCategory'),
                template: kendoGridRendererService.enum('categoryCode', 'ruleGroupCategory'),
                width: '70%'
            },
            {
                field: 'ruleScore',  type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.categoryScores.scoreLabel,
                width: '10%'
            },

            {
                field: 'autoHighIndicator', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.categoryScores.autohighLabel,
                template: kendoGridRendererService.enum('autoHighIndicator', 'yesOrNo'),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo'),
                width: '20%'
            }
        ];

        vm.gridColumnsAttributeScores = [
            {
                field: 'cddRuleName', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.attributeScores.ruleLabel,
                width: '30%'
            },
            {
                field: 'triggeringValue', type: 'object',
                title: resources.aml.admin.cddReview.details.scoring.attributeScores.valueLabel,
                template: cddReviewDetailsService.triggeringValueRenderer,
                width: '30%'
            },
            {
                field: 'ruleScore',  type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.attributeScores.scoreLabel,
                width: '10%'
            },
            {
                field: 'autoHighIndicator', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.attributeScores.autohighLabel,
                template: kendoGridRendererService.enum('autoHighIndicator', 'yesOrNo'),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo'),
                width: '30%'
            }
        ];


        function getScores( gridCallback ) {
            var overallScoresResult = null;
            if ( isNewReview ) {
                overallScoresResult = cddReviewDetailsService.getOverallScoresForNewReview(
                    $stateParams.partyLevel, $stateParams.partyNumber, false ); //do not include manual reviews
            }
            else {
                overallScoresResult = cddReviewDetailsService.getOverallScores( cddReviewKey );
            }

            overallScoresResult.then( function( data ) {

                    var scores = data.items;

                    gridCallback.success( scores );
                },

                function( data, status ) {
                    logger.error( 'Could not load overall scores' );
                } );

        }

        function getCategoryScores( gridCallback ) {
            if ( !selectedOverallDate ) {
                gridCallback.success( [] );
            }
            else {
                // pass entity info if it is available
                if ( vm.review ) {
                    entityNumber = vm.review.primaryEntityNumber;
                    entityLevelCode = vm.review.primaryEntityLevelCode;
                }

                var categoryScoresResult;
                if ( isNewReview ) {
                    categoryScoresResult = cddReviewDetailsService.getCategoryScoresForNewReview( $stateParams.partyNumber,
                        $stateParams.partyLevel, selectedOverallDate );
                }
                else {
                    categoryScoresResult = cddReviewDetailsService.getCategoryScores( cddReviewKey, entityNumber, entityLevelCode, selectedOverallDate );
                }

                categoryScoresResult.then( function( data ) {
                        var categoryScores = data.items;
                        gridCallback.success( categoryScores );
                    },
                    function( data, status ) {
                        logger.error( 'Could not load category scores' );
                    } );
            }
        }

        function getAttributeScores( gridCallback ) {
            // pass entity info if it is available
            if ( !selectedCategory ) {
                gridCallback.success( [] );
            }
            else {
                if ( vm.review ) {
                    entityNumber = vm.review.primaryEntityNumber;
                    entityLevelCode = vm.review.primaryEntityLevelCode;
                }

                var categoryScoresResult;
                if ( isNewReview ) {
                    categoryScoresResult = cddReviewDetailsService.getAttributeScoresForNewReview( $stateParams.partyNumber,
                        $stateParams.partyLevel, selectedOverallDate, selectedCategory );
                }
                else {
                    categoryScoresResult = cddReviewDetailsService.getAttributeScores( cddReviewKey, entityNumber, entityLevelCode, selectedOverallDate, selectedCategory );
                }

                categoryScoresResult.then( function( data ) {
                        var attributeScores = data.items;
                        gridCallback.success( attributeScores );
                    },
                    function( data, status ) {
                        logger.error( 'Could not load attribute scores' );
                    } );
            }

        }

        /**
         * set to select the first overall grid score once the request completes; this
         * will cause the dependent category score grid to load based off of this selection
         */
        vm.gridOptions= kendoGridRendererService.initGridOptionsWithDefaults(
            {
                selectFirstRowOnLoad:true
            });
        function activate() {
        }
        activate();


    }
})();



(function() {
    'use strict';
    CddScoringHistory.$inject = ["kendoGridRendererService", "logger", "cddReviewDetailsService", "resources"];
    angular.module('cdd.reviews').controller('cddScoringHistoryController', CddScoringHistory);

    function CddScoringHistory(kendoGridRendererService, logger, cddReviewDetailsService, resources) {

        var vm = this;
        // vm.params;
        vm.grid = {};
        vm.categoryGrid = {};
        vm.attributeGrid = {};
        vm.amlGridActions = [];

        // vm.params.reload = reloadGrid;
        vm.resources = resources;
        vm.getScores = getScores;

        // vm.handleOverallAttributeTowSelect = function(data){
        //    
        // };

        vm.gridColumns = [
            {
                field: 'ruleScore', type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.scoringTrends.scoreLabel,
                width: '9%'
            },
            {
                field: 'scoreClassificationCode', type: 'string',
                title: resources.aml.reviews.initialRiskRating,
                width: '12%',
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification'),
                template: kendoGridRendererService.enum('scoreClassificationCode', 'scoreClassification', true)
            },
            {
                field: 'eventDate', type: 'date',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.eventDateLabel,
                template: kendoGridRendererService.longDateMediumTime('eventDate'),
                width: '20%'
            },
            {
                field: 'cddReviewKey', type: 'number',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.reviewLink,
                attributes:  {class: 'number-display'},  //right alignment
                template: '#if (cddReviewKey>0) {# <a href="\\#/cddReviews/{{dataItem.cddReviewKey}}">{{dataItem.cddReviewKey}}</a> #}#',
                width: '14%'
            },
            {
                field: 'reviewStatusCode', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.reviewStatusCode,
                width: '15%',
                filterable: kendoGridRendererService.getCheckboxFilter('reviewStatus'),
                template: kendoGridRendererService.enum('reviewStatusCode', 'reviewStatus', true)
            },
            {
                field: 'reviewFinalDispositionCode', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.reviewFinalDispositionCode,
                width: '15%',
                filterable: kendoGridRendererService.getCheckboxFilter('finalDisposition'),
                template: kendoGridRendererService.enum('reviewFinalDispositionCode', 'finalDisposition', true)
            },
            {
                field: 'reviewRatingOverride', type: 'string',
                title: resources.aml.admin.cddReview.details.scoring.customerRiskRating.overallScore.riskOverride,
                width: '15%',
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification'),
                template: kendoGridRendererService.enum('reviewRatingOverride', 'scoreClassification', true)
            }
        ];



        function getScores( gridCallback ) {
            //var overallScoresResult = cddReviewDetailsService.getOverallScoresForNewReview('PTY', vm.partyNumber, true );
            var overallScoresResult = cddReviewDetailsService.getOverallScoresForNewReview('PTY', vm.partyNumber, '' );
            overallScoresResult.then( function( data ) {

                    var scores = data.items;
                    gridCallback.success( scores );
                },

                function( data, status ) {
                    logger.error( 'Could not load overall scores' );
                } );
        }


        /**
         * set to select the first overall grid score once the request completes; this
         * will cause the dependent category score grid to load based off of this selection
         */
        vm.gridOptions= kendoGridRendererService.initGridOptionsWithDefaults(
            {
                selectFirstRowOnLoad:true
            });
        function activate() {
        }
        activate();


    }
})();


/**
 * handle the review triage actions
 */
(function (){

    'use strict';

    ReviewTriageController.$inject = ["$uibModal", "$state", "resources", "reviewTriageService", "reviewsListDataMessagingService", "messageService", "reviewsService", "usersService", "linksProcessor", "amlConstants", "amlPreferencesService", "_"];
    angular
        .module('cdd.reviews')
        .controller('ReviewTriageController', ReviewTriageController);

    /* jshint maxparams: 12 */
    function ReviewTriageController($uibModal, $state, resources, reviewTriageService, reviewsListDataMessagingService,
                                  messageService, reviewsService, usersService, linksProcessor, amlConstants, amlPreferencesService, _) {
        var vm = this;
        vm.resources = resources;
        vm.openRouteReviewsDialog = openRouteReviewsDialog;
        vm.checkinReviews = checkinReviews;
        vm.checkoutReviews = checkoutReviews;
        vm.changeDisplayReviews = changeDisplayReviews;

        vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeCDDReview) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCDDReviews)) ? true : false;
        vm.userCanCheckin = usersService.currentUserHasCapability(amlConstants.capabilities.checkinCDDReview);
        vm.userCanCheckout = usersService.currentUserHasCapability(amlConstants.capabilities.checkoutCDDReview);
        vm.userCanCreateReview = usersService.currentUserHasCapability(amlConstants.capabilities.createCDDReview);

        vm.displayMyReviews = false;
        vm.displayAllReviews = false;
        vm.displayAvailableReviews = false;

        vm.userCanRouteSelected = userCanRouteSelected;
        vm.isCheckinOwner = isCheckinOwner;
        vm.isOwnerEmptyForCheckout = isOwnerEmptyForCheckout;
        var expectedStateName = $state.$current.name;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [];
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCDDReviewsMy)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reviewsListQueueDisplayType.MY,
                        value: vm.resources.aml.reviewsList.displayQueueMyReviews
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCDDReviewsAll)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reviewsListQueueDisplayType.ALL,
                        value: vm.resources.aml.reviewsList.displayQueueAllReviews
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessCDDReviewsAvailable)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reviewsListQueueDisplayType.AVAILABLE,
                        value: vm.resources.aml.reviewsList.displayQueueAvailableReviews
                    }
                );
            }

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultReviewsQueue = amlPreferencesService.getLocalPreference('defaultReviewsQueue');
            if (defaultReviewsQueue) {
                vm.displayOwnersType = defaultReviewsQueue;
            }
            else {
                // if no preference is found, default to Available Reviews
                vm.displayOwnersType = amlConstants.reviewsListQueueDisplayType.AVAILABLE;
            }
            //if default or saved option does not exists then use first available option
            if (!_.findWhere(vm.displayOwnersTypes, { key: vm.displayOwnersType })) {
                if (vm.displayOwnersTypes[0]) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.reviewsListQueueDisplayType.MY;
                }
            }

            updateDisplayReviews();
        }

        vm.reloadList = function () {
            reviewsListDataMessagingService.reloadGrid();
        };

        //For now, this is the same value review number and review name
        function getSelectedReviewId() {
            var key = null;
            var selectedReviewIds = reviewsListDataMessagingService.getSelectedReviewNumbers();
            if (selectedReviewIds && selectedReviewIds.length > 0) {
                key = selectedReviewIds[0];
            }
            return key;
        }

        function openRouteReviewsDialog() {
            var selectedReviewNumbers = reviewsListDataMessagingService.getSelectedReviewNumbers();
            var user = '';
            var queue = '';
            if(selectedReviewNumbers.length === 1) {
                // We are routing just one review, so pre-populate the form.
                user = reviewsListDataMessagingService.getSelectedReviewOwners()[0];
                queue = reviewsListDataMessagingService.getSelectedReviewQueues()[0];
            }
            reviewTriageService.openRouteReviewsDialog(
                selectedReviewNumbers,
                getSelectedReviewId(),
                user,
                queue,
                refreshReviewsOwner
            ).then(
                function () {
                }
            );
        }

        function checkinReviews() {
            reviewTriageService.checkinReviews(reviewsListDataMessagingService.getSelectedReviewNumbers(),
                getSelectedReviewId(), refreshReviewsOwner);
        }

        function checkoutReviews() {
            reviewTriageService.checkoutReviews(reviewsListDataMessagingService.getSelectedReviewNumbers(),
                getSelectedReviewId(), refreshReviewsOwner);
        }

        function changeDisplayReviews() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultReviewsQueue, vm.displayOwnersType);

            updateDisplayReviews();
        }

        function updateDisplayReviews() {
            reviewsListDataMessagingService.setDisplayOwnersType(vm.displayOwnersType);

            vm.displayMyReviews = vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.MY;
            vm.displayAvailableReviews = vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.AVAILABLE;
            vm.displayAllReviews = vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.ALL;

            vm.userCanRoute = ( vm.displayMyReviews || vm.displayAllReviews) && usersService.currentUserHasCapability(amlConstants.capabilities.routeCDDReview) ||
                                vm.displayAvailableReviews && usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCDDReviews);
            vm.userCanCheckin = usersService.currentUserHasCapability(amlConstants.capabilities.checkinCDDReview);
            vm.userCanCheckout = usersService.currentUserHasCapability(amlConstants.capabilities.checkoutCDDReview);
            vm.userCanCreateReview = usersService.currentUserHasCapability(amlConstants.capabilities.createCDDReview);
        }

        /* To use from the UI to enable/disable the route button
            * depending on the queue and whether selected CDD Reviews are assigned to current user
            * @returns {boolean}
        */
        function userCanRouteSelected() {
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                if (vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.MY) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeCDDReview);
                }
                if (vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.ALL) {
                    return (usersService.currentUserHasCapability(amlConstants.capabilities.routeCDDReview) && isCheckinOwner()) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCDDReviews);
                }
                if (vm.displayOwnersType === amlConstants.reviewsListQueueDisplayType.AVAILABLE) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCDDReviews);
                }
            }
            return false;
        }

        /**
         * To use from the UI to enable/disable the checkin/checkout and route buttons
         * depending on whether selected CDD review are assigned to current user
         * @returns {boolean}
         */
        function isCheckinOwner() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var currentUser = usersService.getCurrentUserId();
                var selectedEntities = reviewsListDataMessagingService.getSelectedReviews();
                if (!selectedEntities || selectedEntities.length === 0) {
                    allOwned = false;
                }
                else {
                    allOwned = _.every(selectedEntities, function (entity) {
                        return entity.ownerUserLongId === currentUser;
                    });
                }
            }
            return allOwned;
        }


        function isOwnerEmptyForCheckout() {
            var allOwned;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var selectedEntities = reviewsListDataMessagingService.getSelectedReviews();
                if ( !selectedEntities || selectedEntities.length === 0 ) {
                    allOwned = false;
                }
                else {
                    allOwned =_.every(selectedEntities, function(entity) {
                        return !entity.ownerUserLongId || entity.ownerUserLongId === null || entity.ownerUserLongId === '';
                    });
                }
            }
            return allOwned;
        }

        function refreshReviewsOwner(reviewNumbers, owner, queue) {
            reviewsListDataMessagingService.reviewsOwnerChanged(reviewNumbers, owner, queue);
        }
    }
})();

/**
 * Created by fikhas on 1/22/2015.
 */
(function() {
    'use strict';
    CustomerDetailsController.$inject = ["$scope", "resources"];
    angular.module('aml.customer.details').controller('CustomerDetailsController', CustomerDetailsController);

    function CustomerDetailsController($scope, resources) {
        var vm = this;
        vm.resources = resources;
        vm.isIndividual = true;
        $scope.$watch('vm.customer', function (newValue, oldValue) {
            if (newValue) {
                vm.isIndividual = newValue.partyTypeDesc === 'INDIVIDUAL';
            }
        });
    }
})();

(function () {
    'use strict';
    CustomerDetailsController.$inject = ["$stateParams", "customerService", "resources", "_", "dataMessagingServiceFactory", "amlConstants", "titleCaseFilter", "amlCoreUtils"];
    angular.module('aml.customer.details').controller('CustomerDetailsViewController', CustomerDetailsController);

    /**
     * This is the overall controller for the Customer Details view.
     * It sets things that all directives on the details page may need, such
     * as the current selected customerNumber taken from the current route/state,
     * and the current customer object itself
     *
     * @param $stateParams
     * @constructor
     */
    function CustomerDetailsController($stateParams, customerService, resources, _, dataMessagingServiceFactory, amlConstants,
               titleCaseFilter, amlCoreUtils  ) {
        var viewVm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        viewVm.customerNumber = $stateParams.customerid;

        viewVm.entityId = {
            entityNumber: $stateParams.customerid,
            entityLevelCode: amlConstants.entityType.customer,
            entityKey: null,
            queueCode: $stateParams.queueCode
        };
        dataMessagingService.setEntityId( viewVm.entityId );

        viewVm.customer = null;
        viewVm.resources = resources;
        viewVm.isCDDEnabled = amlConstants.config.fcf.riskScore.source === 'CDD';
        
        activate();

        /////////////////////////////////////////////////

        viewVm.customerFiledownload = function customerFiledownload () {
          //alert();
          location.href="/SASStoredProcess/do?_program=%2FKFI_NY%2FAML+Compliance%2F00.Environments%2FStoredProcess%2Fget_customers_account_list&party_number="+viewVm.customerNumber;
        };

        function activate() {
            customerService.getCustomer($stateParams.customerid).then(function (data) {
                viewVm.customer = data;

                // set the customer name
                viewVm.customerName = viewVm.customer.customerName;

                // set name and key on the datamessaging service
                dataMessagingService.setCustomerName(viewVm.customerName);
                dataMessagingService.setEntityKey( viewVm.customer.key );
                dataMessagingService.setEmployeeIndicator( viewVm.customer.employeeInd );

                processAddresses();

                ensureRequiredFieldsDefined();
                
            });
        }

        function ensureRequiredFieldsDefined() {
            // since these values are one-time bound and we want to use a filter to set them
            // to "n/a" if unset, we set them to null if they are undefined.
            // This will allow the nullNA filter to treat null values as defined and/or already set and set to 'n/a',
            // while ignoring undefined values until such time as they are bound.
            _.defaults(viewVm.customer, {
                employerName: null,
                customerSince: null,
                emailAddress: null,
                idType: null,
                idNumber: null,
                occupation: null,
                politicallyExposedPersonInd: null
            });
            
					//function customerFiledownload(){
						//alert('a');
						//(\'{{::vm.resources.aml.customersummary.companyNumber }}\')
						//location.href="/SASStoredProcess/do?_program=%2FKFI_NY%2FAML+Compliance%2F00.Environments%2FStoredProcess%2Fget_customers_account_list&party_number="+cusNo;
					//}
        }

        /**
         * Gather all of the various customer addresses and put them in an appropriate
         * object form for display by the address component
         */
        function processAddresses() {
            // create customer address encapsulation (used by address widget)
            viewVm.customerAddress = {
                street: viewVm.customer.address1,
                street2: viewVm.customer.address2,
                city: viewVm.customer.city,
                state: viewVm.customer.state || viewVm.customer.stateCode,
                country: viewVm.customer.country,
                postalcode: viewVm.customer.postal
            };

            // create customer mailing address encapsulation (used by address widget)
            viewVm.customerMailingAddress = {
                street: viewVm.customer.mailingAddress1,
                street2: viewVm.customer.mailingAddress2,
                city: viewVm.customer.mailingCity,
                state: viewVm.customer.mailingState || viewVm.customer.mailingStateCode,
                country: viewVm.customer.mailingCountry,
                postalcode: viewVm.customer.mailingPostal
            };

            // massage any related addresses as address directive expects to be in specific format
            viewVm.relatedAddresses = _.map( viewVm.customer.relatedAddresses, function (relatedAddress) {
                relatedAddress.state = relatedAddress.state || relatedAddress.stateCode;
                relatedAddress.postalCode = relatedAddress.postal;
                return relatedAddress;
            });
        }

        

    }

})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    EntityTriageController.$inject = ["resources", "entityTriageService", "entityListDataMessagingService", "usersService", "amlConstants", "amlPreferencesService", "titleCaseFilter", "$state", "_"];
    angular.module('aml.customer.details').controller('EntityTriageController', EntityTriageController);

    function EntityTriageController( resources, entityTriageService, entityListDataMessagingService,
                                       usersService, amlConstants, amlPreferencesService, titleCaseFilter, $state, _) {
        var vm = this;
        vm.resources = resources;
        vm.openRouteEntitiesDialog = openRouteEntitiesDialog;
        vm.checkinEntities = checkinEntities;
        vm.checkoutEntities = checkoutEntities;
        vm.changeDisplayEntities = changeDisplayEntities;
        vm.userCanRoute = usersService.currentUserHasCapability( amlConstants.capabilities.routeEntity ) ||
            usersService.currentUserHasCapability( amlConstants.capabilities.routeAllEntities );
        vm.userCanCheckin = usersService.currentUserHasCapability( amlConstants.capabilities.checkinEntity );
        vm.userCanCheckout = usersService.currentUserHasCapability( amlConstants.capabilities.checkoutEntity );

        vm.displayMyEntities = false;
        vm.displayAllEntities = false;
        vm.displayAvailableEntities = false;

        vm.isCheckinOwner = isCheckinOwner;
        vm.isOwnerEmptyForCheckout = isOwnerEmptyForCheckout;
        vm.userCanRouteSelected = userCanRouteSelected;

        var expectedStateName = $state.$current.name;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [];
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessEntitiesMy)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.entityListQueueDisplayType.MY,
                        value: vm.resources.aml.customerList.displayQueueMyCustomers
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessEntitiesAll)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.entityListQueueDisplayType.ALL,
                        value: vm.resources.aml.customerList.displayQueueAllCustomers
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessEntitiesAvailable)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.entityListQueueDisplayType.AVAILABLE,
                        value: vm.resources.aml.customerList.displayQueueAvailableCustomers
                    }
                );
            }

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultEntitiesQueue = amlPreferencesService.getLocalPreference( 'defaultEntitiesQueue' );
            if ( defaultEntitiesQueue ) {
                vm.displayOwnersType = defaultEntitiesQueue;
            }
            else {
                // if no preference if found, default to All Alerts
                vm.displayOwnersType = amlConstants.entityListQueueDisplayType.ALL;
            }
            //if default or saved option does not exists then use first available option
            if (!_.findWhere(vm.displayOwnersTypes, { key: vm.displayOwnersType })) {
                if (vm.displayOwnersTypes[0]) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.entityListQueueDisplayType.MY;
                }
            }

            updateDisplayEntities();
        }

        /**
         * To use from the UI to enable/disable the checkin/checkout button
         * depending on whether it is assigned to current user
         * @returns {boolean}
         */
        function isCheckinOwner() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var currentUser = usersService.getCurrentUserId();
                var selectedEntities = entityListDataMessagingService.getSelectedEntities();
                if (!selectedEntities || selectedEntities.length === 0) {
                    allOwned = false;
                }
                else {
                    allOwned = _.every(selectedEntities, function (entity) {
                        return entity.ownerUserId === currentUser;
                    });
                }
            }
            return allOwned;
        }


        function isOwnerEmptyForCheckout() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var selectedEntities = entityListDataMessagingService.getSelectedEntities();
                if ( !selectedEntities || selectedEntities.length === 0 ) {
                    allOwned = false;
                }
                else {
                    allOwned =_.every(selectedEntities, function(entity) {
                        return !entity.ownerUserId || entity.ownerUserId === null || entity.ownerUserId === '';
                    });
                }
            }
            return allOwned;
        }


        function getSelectedCustomerName() {
            var custName = null;
            var selectedCustomerNames = entityListDataMessagingService.getSelectedEntityNames();
            if ( selectedCustomerNames && selectedCustomerNames.length > 0 ) {
                custName = titleCaseFilter(selectedCustomerNames[0]);
            }
            return custName;
        }

        function openRouteEntitiesDialog() {
            var selectedEntityIds = entityListDataMessagingService.getSelectedEntityIds();
            var user = '';
            var queue = '';
            if(selectedEntityIds.length === 1) {
                // We are routing just one entity, so pre-populate the form
                user = entityListDataMessagingService.getSelectedEntityOwners()[0];
                queue = entityListDataMessagingService.getSelectedEntityQueues()[0];
            }
            var entityName = getSelectedCustomerName();
            entityTriageService.openRouteEntitiesDialog(
                selectedEntityIds,
                entityName,
                user,
                queue,
                refreshEntitiesOwner
            ).then( function( ) {
                    // put any logic needed for after sending off the REST request
            });
        }

        function checkinEntities() {
            var selectedEntityIds = entityListDataMessagingService.getSelectedEntityIds();
            var entityName = getSelectedCustomerName();
            entityTriageService.checkinEntities( selectedEntityIds, entityName, refreshEntitiesOwner );
        }

        function checkoutEntities() {
            var selectedEntityIds = entityListDataMessagingService.getSelectedEntityIds();
            var entityName = getSelectedCustomerName();
            entityTriageService.checkoutEntities( selectedEntityIds, entityName, refreshEntitiesOwner );
        }

        function changeDisplayEntities() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultEntitiesQueue,  vm.displayOwnersType );

            updateDisplayEntities();
        }

        function updateDisplayEntities() {
            entityListDataMessagingService.setDisplayOwnersType( vm.displayOwnersType );

            vm.displayMyEntities = vm.displayOwnersType === amlConstants.entityListQueueDisplayType.MY;
            vm.displayAvailableEntities  = vm.displayOwnersType === amlConstants.entityListQueueDisplayType.AVAILABLE;
            vm.displayAllEntities = vm.displayOwnersType === amlConstants.entityListQueueDisplayType.ALL;
        }

        function refreshEntitiesOwner( entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner ) {
            //owner has to be replaced if queue is replaced
            entityListDataMessagingService.entitiesOwnerChanged( entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner );
        }

        vm.reloadList = function () {
            entityListDataMessagingService.reloadGrid();
        };

        /**
         * To use from the UI to enable/disable the route button
         * depending on the queue and whether selected cases are assigned to current user
         * @returns {boolean}
         */
        function userCanRouteSelected() {
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                if (vm.displayOwnersType === amlConstants.entityListQueueDisplayType.MY) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeEntity);
                }
                if (vm.displayOwnersType === amlConstants.entityListQueueDisplayType.ALL) {
                    return (usersService.currentUserHasCapability(amlConstants.capabilities.routeEntity) && isCheckinOwner()) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllEntities);
                }
                if (vm.displayOwnersType === amlConstants.entityListQueueDisplayType.AVAILABLE) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeAllEntities);
                }
            }
            return false;
        }
    }
})();

/**
 * handle the report details window triage actions
 */
(function () {
    'use strict';
    ReportDetailsTriageController.$inject = ["$scope", "$state", "$stateParams", "$q", "$sce", "$rootScope", "$document", "resources", "reportsService", "usersService", "tabsListService", "dialogService", "amlConstants", "messageService", "reportTriageService", "reportsListDataMessagingService", "_"];
    angular.module('aml.reports.details').controller('ReportDetailsTriageController', ReportDetailsTriageController);

    /* jshint maxparams: 20*/
    function ReportDetailsTriageController($scope, $state, $stateParams, $q, $sce, $rootScope, $document, resources,
                                           reportsService, usersService, tabsListService, dialogService, amlConstants,
                                           messageService, reportTriageService, reportsListDataMessagingService, _) {
        var vm = this;
        vm.resources = resources;
        vm.commentsOptions = {};
        vm.navigateBackToReportsList = navigateBackToReportsList;
        vm.saveReport = saveReport;
        vm.validateReport = validateReport;
        vm.isCorrectionAllowed = false;
        vm.makeCorrectionReport = makeCorrectionReport;

        vm.aReport = null;

        vm.reportKey = $stateParams.reportkey;
        vm.state = $state.$current;

        vm.userCanRoute = false;
        vm.readonly = true;
        vm.openRouteReportsDialog = openRouteReportsDialog;

        activate();

        //////
        function activate() {
            //Set pill to clean initially
            $state.$current.data.dirty = false;

            //When the form is dirty then set the tab dirty
            $scope.$watch('formCtrl.$dirty', function (newValue, oldValue) {
                if (newValue) {
                    var queryResult = $document[0].getElementById('button-toggle-comment-sidebar');
                    if (!queryResult.classList.contains('ng-dirty-add')) {
                        setReportDirtyFlag();
                    } else {
                        $scope.formCtrl.$dirty = false;
                    }
                }
            });

            $scope.$on('reportLoaded', function (event, args) {
                vm.aReport = args.val;
                vm.isCorrectionAllowed = isCorrectionAllowed();
                vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeReport) &&
                    usersService.getCurrentUserId() === vm.aReport.ownerUserLongId ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.routeAllReports));
                vm.readonly = reportsService.isReportReadonly(vm.aReport);
            });

            // add a modal dialog to allow pill to be closed
            // return true to close...false to keep pill
            tabsListService.registerCloseCallback($state.$current, function dirtyCheckCallback() {
                var defer = $q.defer();
                if (vm.state.data.dirty === true) {
                    //Scope changes so store current form validity to check later
                    var formValidity = $scope.formCtrl.$valid;

                    dialogService.openDirtyFormDialog().then(function () {
                    }, function (buttonValue) {
                        if (buttonValue === 'discard') {
                            defer.resolve(true);
                        } else if (buttonValue === 'save') {
                            if (formValidity) {
                                reportsService.saveReport(vm.aReport).then(
                                    function (savedReport) {
                                        var msg = vm.resources.aml.getResource('regulatoryReportdetails.triage.saveReportActionSuccessMessage',
                                            {reportKey: vm.reportKey});
                                        messageService.success(msg, null, 10000);
                                        vm.state.data.dirty = false;  //Set the pill to be clean
                                        $scope.formCtrl.$setPristine(); //Set form to valid and clean
                                        $scope.formCtrl.reportGridsDirtyFlag = false;
                                        $rootScope.$broadcast('reportListRefresh');
                                    },
                                    function (error) {
                                        messageService.danger(
                                            vm.resources.aml.getResource('regulatoryReportdetails.triage.saveReportActionErrorMessage',
                                                {reportKey: vm.reportKey}), null, 4000);
                                    });

                                defer.resolve(true);
                            } else {
                                dialogService.openErrorFormDialog();
                                vm.state.data.dirty = true;  //Set the pill to be dirty
                                defer.resolve(false);
                            }
                        } else if (buttonValue === 'cancel') {
                            defer.resolve(false);
                        }
                    });
                } else {
                    defer.resolve(true);
                }
                return defer.promise;
            });
        }

        function noDollarSign(aName) {
            if (aName[0] !== '$') {
                return true;
            }
            return false;
        }

        function setReportDirtyFlag () {
            var excludedIds = _.pluck($('.no-dirty-check'), 'name');
            var isDirty = isFormDirty($scope.formCtrl, excludedIds);
            if (isDirty) {
                $state.$current.data.dirty = true;  // to set the tab pill to dirty
            } else {
                $scope.formCtrl.$dirty = false;
            }
        }

        //check if the form is dirty, exclude all controls that have names listed
        //in excludeIds
        function isFormDirty(formIn, excludedIds) {
            /*jshint maxcomplexity:12 */
            var names = Object.getOwnPropertyNames(formIn).filter(noDollarSign);
            var dirty = false;
            for (var i = 0; i < names.length; i++) {
                //check if control is a form
                if (names[i].toString().startsWith('amlform')) {
                    if (isFormDirty(formIn[names[i]], excludedIds)) {
                        dirty = true;
                    }
                } else {
                    var noCheck = _.indexOf(excludedIds, names[i]) >= 0;
                    if (formIn[names[i]].$dirty && !noCheck) {
                        dirty = true;
                    }
                }
            }

            // JavaScript evaluates false || undefined as undefined.
            if(typeof $scope.formCtrl.reportGridsDirtyFlag === 'undefined') {
                // Not SARX - either CTR, CTRX, or SAR.
                if(typeof $scope.formCtrl.$dirty === 'undefined') {
                    return dirty;
                }
                else {
                    return dirty || $scope.formCtrl.$dirty;
                }
            }
            else {
                // SARX
                return dirty || $scope.formCtrl.reportGridsDirtyFlag;
            }
        }

        function saveReport() {
            if ($scope.formCtrl.$valid && $scope.formCtrl.$dirty) {
                reportsService.saveReport(vm.aReport).then(
                    function (savedReport) {
                        var msg = vm.resources.aml.getResource('regulatoryReportdetails.triage.saveReportActionSuccessMessage',
                            {reportKey: vm.reportKey});
                        messageService.success(msg, null, 10000);
                        vm.state.data.dirty = false;  //Set the pill to be clean
                        $scope.formCtrl.$setPristine(); //Set form to valid and clean
                        $rootScope.$broadcast('reportListRefresh');

                        //DOEP Entity save hack...  DOEP entities/subjects are completely different than other report subjects,
                        //it needs a special notice to save them back to the entity table...
                        $rootScope.$broadcast('reportSaveCallback');
                    },
                    function (error) {
                        messageService.danger(
                            vm.resources.aml.getResource('regulatoryReportdetails.triage.saveReportActionErrorMessage',
                                {reportKey: vm.reportKey}), null, 4000);
                    });
            }
            else if ($scope.formCtrl.$invalid) {
                dialogService.openErrorFormDialog();
                vm.state.data.dirty = true;  //Set the pill to be dirty
            }
        }

        function openRouteReportsDialog() {
            reportTriageService.openRouteReportsDialog(
                [vm.reportKey],
                vm.reportKey,
                vm.aReport.ownerUserLongId,
                vm.aReport.queueCode,
                function () {
                    $rootScope.$broadcast('reportListRefresh');
                }
            ).then(function () {
                navigateBackToReportsList();
            });
        }

        function navigateBackToReportsList() {
            // close current tab for the current state
            tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);

            // change current (originating) window back to reports list
            $state.go('reports');
        }

        function validateReport() {
            //Call the stored process
            $scope.loading = true;
            var checkStr = "N";
//console.log("validateReport vm.aReport : " + JSON.stringify(vm.aReport));
            reportsService.runReportValidation(vm.aReport).then(
                //Handle the results
                function (data) {
//console.log("validateReport data : " + JSON.stringify(data));
                    $scope.loading = false;
                    dialogService.openInformationDialog(vm.resources.aml.getResource('regulatoryReportdetails.triage.reportValidationTitle',
                        {reportKey: vm.reportKey}), $sce.trustAsHtml(data.data));

										if(data.data.indexOf("No Data Validation errors found for report:") != -1){
											checkStr = "Y";
										}

//console.log("AAAAAA : " + $("#btnEfile").length);
                },
                function (error) {
                    $scope.loading = false;
                }
            );

//console.log("BBBBB : " + $("#btnEfile").length);

						for(var i=1; i<=10; i++){
							fnInterval(i*500);
						}
						
						function fnInterval(val){
							setTimeout(function(){
//console.log("ddddd : " + $("#btnEfile").length + " ||| " + val + "|||" + vm.reportKey + "||||" + $("#statusCode").val());
								if($("#btnEfile").length == 1 && checkStr == "Y"){
									$("#btnEfile").show();
									$("#reqKeyValue").val(vm.reportKey);
								}
								//console.log("EEEEE : " + i);
							},val);	
						}

        }

        function isCorrectionAllowed() {
            if ((vm.aReport.statusCode === 'A' || vm.aReport.statusCode === 'AW' || vm.aReport.statusCode === 'AE')) {
                return true;
            }
            else {
                return false;
            }
        }

        function makeCorrectionReport() {
            //Confirm that user really wants to make this correction report
            dialogService.openConfirmDialog(resources.aml.regulatoryReportdetails.triage.correctionConfirmationWindowTitle,
                resources.aml.regulatoryReportdetails.triage.correctionConfirmationText).then(
                //Handle the results
                function (data) { //Yes, they want to do it
                    reportsService.makeCorrectionReport(vm.aReport).then(
                        //Handle the results
                        function (createdReport) {
                            var msg = vm.resources.aml.getResource('regulatoryReportdetails.triage.createCorrectionReportActionSuccessMessage',
                                {reportKey: createdReport.reportKey});
                            messageService.success(msg, null, 10000);
                            $rootScope.$broadcast('reportListRefresh');
                        },
                        function (error) {
                            messageService.danger(
                                vm.resources.aml.getResource('regulatoryReportdetails.triage.createCorrectionReportActionErrorMessage'), null, 4000);
                        }
                    );
                }
            );
        }
    }
})();

/**
 * handle the report triage actions
 */
(function () {
    'use strict';
    ReportTriageController.$inject = ["resources", "reportTriageService", "reportsListDataMessagingService", "usersService", "amlConstants", "amlPreferencesService", "$state", "_"];
    angular.module('aml.reports.details').controller('ReportTriageController', ReportTriageController);

    /* jshint maxparams: 12*/
    function ReportTriageController(resources, reportTriageService, reportsListDataMessagingService,
                                    usersService, amlConstants, amlPreferencesService, $state, _) {
        var vm = this;
        vm.resources = resources;
        vm.openRouteReportsDialog = openRouteReportsDialog;
        vm.checkinReports = checkinReports;
        vm.checkoutReports = checkoutReports;
        vm.changeDisplayReports = changeDisplayReports;

        vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeReport) ||
                            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllReports)) ? true : false;
        vm.userCanCheckin = usersService.currentUserHasCapability(amlConstants.capabilities.checkinReport);
        vm.userCanCheckout = usersService.currentUserHasCapability(amlConstants.capabilities.checkoutReport);
        vm.userCanCreateInvestigation = usersService.currentUserHasCapability(amlConstants.capabilities.createReport);
        vm.userCanRoute = (usersService.currentUserHasCapability(amlConstants.capabilities.routeCase) ||
            usersService.currentUserHasCapability(amlConstants.capabilities.routeAllCases)) ? true : false;

        vm.displayMyReports = false;
        vm.displayAllReports = false;
        vm.displayAvailableReports = false;

        vm.userCanRouteSelected = userCanRouteSelected;
        vm.isCheckinOwner = isCheckinOwner;
        vm.isOwnerEmptyForCheckout = isOwnerEmptyForCheckout;
        var expectedStateName = $state.$current.name;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [];
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessReportsMy)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reportsListQueueDisplayType.MY,
                        value: vm.resources.aml.regulatoryReportsList.displayQueueMyReports
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessReportsAll)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reportsListQueueDisplayType.ALL,
                        value: vm.resources.aml.regulatoryReportsList.displayQueueAllReports
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessReportsAvailable)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.reportsListQueueDisplayType.AVAILABLE,
                        value: vm.resources.aml.regulatoryReportsList.displayQueueAvailableReports
                    }
                );
            }

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultReportsQueue = amlPreferencesService.getLocalPreference('defaultReportsQueue');
            if (defaultReportsQueue) {
                vm.displayOwnersType = defaultReportsQueue;
            }
            else {
                // if no preference is found, default to Available Reports
                vm.displayOwnersType = amlConstants.reportsListQueueDisplayType.AVAILABLE;
            }
            //if default or saved option does not exists then use first available option
            if (!_.findWhere(vm.displayOwnersTypes, { key: vm.displayOwnersType })) {
                if (vm.displayOwnersTypes[0]) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.reportsListQueueDisplayType.MY;
                }
            }

            updateDisplayReports();
        }

        vm.reloadList = function () {
            reportsListDataMessagingService.reloadGrid();
        };
        //For now, this is the same value report number and report name
        function getSelectedReportKey() {
            var reportKey = null;
            var selectedReportKeys = reportsListDataMessagingService.getSelectedReportNumbers();
            if (selectedReportKeys && selectedReportKeys.length > 0) {
                reportKey = selectedReportKeys[0];
            }
            return reportKey;
        }

        function openRouteReportsDialog() {
            var selectedReportNumbers = reportsListDataMessagingService.getSelectedReportNumbers();
            var user = '';
            var queue = '';
            if(selectedReportNumbers.length === 1) {
                // We are routing just one report
                user = reportsListDataMessagingService.getSelectedReportOwners()[0];
                queue = reportsListDataMessagingService.getSelectedReportQueues()[0];
            }
            reportTriageService.openRouteReportsDialog(
                selectedReportNumbers,
                getSelectedReportKey(),
                user,
                queue,
                refreshReportsOwner
            ).then(
                function () {
                }
            );
        }

        function checkinReports() {
            reportTriageService.checkinReports(reportsListDataMessagingService.getSelectedReportNumbers(),
                getSelectedReportKey(), refreshReportsOwner);
        }

        function checkoutReports() {
            reportTriageService.checkoutReports(reportsListDataMessagingService.getSelectedReportNumbers(),
                getSelectedReportKey(), refreshReportsOwner);
        }

        function changeDisplayReports() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultReportsQueue, vm.displayOwnersType);

            updateDisplayReports();
        }

        function updateDisplayReports() {
            reportsListDataMessagingService.setDisplayOwnersType(vm.displayOwnersType);

            vm.displayMyReports = vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.MY;
            vm.displayAvailableReports = vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.AVAILABLE;
            vm.displayAllReports = vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.ALL;
        }

        function refreshReportsOwner(reportNumbers, owner, queue) {
            reportsListDataMessagingService.reportsOwnerChanged(reportNumbers, owner, queue);
        }

        /**
         * To use from the UI to enable/disable the checkin/checkout button
         * depending on whether it is assigned to current user
         * @returns {boolean}
         */
        function isCheckinOwner() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var currentUser = usersService.getCurrentUserId();
                var selectedEntities = reportsListDataMessagingService.getSelectedReports();
                if (!selectedEntities || selectedEntities.length === 0) {
                    allOwned = false;
                }
                else {
                    allOwned = _.every(selectedEntities, function (entity) {
                        return entity.ownerUserLongId === currentUser;
                    });
                }
            }
            return allOwned;
        }


        function isOwnerEmptyForCheckout() {
            var allOwned;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var selectedEntities = reportsListDataMessagingService.getSelectedReports();
                if ( !selectedEntities || selectedEntities.length === 0 ) {
                    allOwned = false;
                }
                else {
                    allOwned =_.every(selectedEntities, function(entity) {
                        return !entity.ownerUserLongId || entity.ownerUserLongId === null || entity.ownerUserLongId === '';
                    });
                }
            }
            return allOwned;
        }

        function userCanRouteSelected() {
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                if (vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.MY) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeReport);
                }
                if (vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.ALL) {
                    return (usersService.currentUserHasCapability(amlConstants.capabilities.routeReport) && isCheckinOwner()) ||
                        usersService.currentUserHasCapability(amlConstants.capabilities.routeAllReports);
                }
                if (vm.displayOwnersType === amlConstants.reportsListQueueDisplayType.AVAILABLE) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeAllReports);
                }
            }
            return false;
        }
    }
})();

/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    RiskAssessmentTriageController.$inject = ["resources", "riskAssessmentTriageService", "$stateParams", "usersService", "amlConstants", "tabsListService", "$state", "riskAssessmentsListDataMessagingService"];
    angular.module('aml.riskAssessments').controller('RiskAssessmentTriageController', RiskAssessmentTriageController);

    function RiskAssessmentTriageController( resources, riskAssessmentTriageService,  $stateParams,
                                       usersService, amlConstants, tabsListService, $state, riskAssessmentsListDataMessagingService) {
        var vm = this;
        vm.state = $state.$current;
        vm.resources = resources;
        vm.openRouteRiskAssessmentDialog = openRouteRiskAssessmentDialog;
        vm.openAcceptRiskAssessmentDialog = openAcceptRiskAssessmentDialog;
        vm.openRejectRiskAssessmentDialog = openRejectRiskAssessmentDialog;
        vm.navigateBackToRiskAssessmentsList = navigateBackToRiskAssessmentsList;
        vm.updateButtonsVisibility = updateButtonsVisibility;
        vm.isNewRiskAssessment = $stateParams.newEntityFlag;

        vm.userCanRoute = usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments);

        vm.userCanAccept = usersService.currentUserHasCapability(amlConstants.capabilities.acceptRiskAssessment );
        vm.userCanReject = usersService.currentUserHasCapability(amlConstants.capabilities.rejectRiskAssessment );

        vm.isNewRiskAssessment = $stateParams.newEntityFlag;
        
        var assessmentId = $stateParams.assessmentId;
        vm.assessmentId = assessmentId;
        vm.commentsOptions = {};

        vm.riskAssessmentCount = assessmentId.length;
        activate();

        //////

        function activate() {

        }

        function updateButtonsVisibility () {

            if (vm.riskAssessment && vm.riskAssessment.owner) {
                // if assessment is loaded
                vm.userCanRoute = usersService.currentUserHasCapability(amlConstants.capabilities.routeRiskAssessment ) && vm.riskAssessment.owner === usersService.getCurrentUserId() ||
                    usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments );
            } else {
                vm.userCanRoute = usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments );
            }
        }

        function openRouteRiskAssessmentDialog() {
            riskAssessmentTriageService.openRouteRiskAssessmentDialog(assessmentId, refreshEntityOwner ).then(
                function  ( ) {
                    // after performing action, return back to risk assessment list
                    navigateBackToRiskAssessmentsList();
                });
        }

        function refreshEntityOwner( riskAssessmentIds, owner ) {
            riskAssessmentsListDataMessagingService.riskAssessmentsOwnerChanged( riskAssessmentIds, owner );
        }

        function openAcceptRiskAssessmentDialog() {
            riskAssessmentTriageService.openAcceptRiskAssessmentDialog(assessmentId).then(function() {
                // after performing action, return back to risk assessment list
                navigateBackToRiskAssessmentsList();
            });
        }

        function openRejectRiskAssessmentDialog() {

            riskAssessmentTriageService.openRejectRiskAssessmentDialog(assessmentId).then(
                function  ( ) {
                    // after performing action, return back to risk assessment list
                    navigateBackToRiskAssessmentsList();

                });
        }

        function navigateBackToRiskAssessmentsList() {
            // close current tab for the current state
            tabsListService.closeTab(tabsListService.getTabForCurrentState(), false);

            // go back riskAssessment list
            $state.go('riskAssessmentsList');
        }

    }
})();

/**
 * handle the case triage actions
 */
(function () {
    'use strict';
    RiskAssessmentsListTriageController.$inject = ["$state", "resources", "riskAssessmentsListTriageService", "riskAssessmentsListDataMessagingService", "usersService", "amlConstants", "amlPreferencesService", "_"];
    angular.module('aml.riskAssessments').controller('RiskAssessmentsListTriageController', RiskAssessmentsListTriageController);
    /* jshint maxparams: 12 */
    function RiskAssessmentsListTriageController( $state, resources, riskAssessmentsListTriageService, riskAssessmentsListDataMessagingService,
                                  usersService, amlConstants, amlPreferencesService, _) {
        var vm = this;
        vm.resources = resources;
        vm.openRouteRiskAssessmentsDialog = openRouteRiskAssessmentsDialog;
        vm.checkinRiskAssessments = checkinRiskAssessments;
        vm.checkoutRiskAssessments = checkoutRiskAssessments;
        vm.changeDisplayRiskAssessments = changeDisplayRiskAssessments;

        vm.userCanRoute = usersService.currentUserHasCapability(amlConstants.capabilities.routeRiskAssessment) ||
                          usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments);
        vm.userCanCheckin = usersService.currentUserHasCapability(amlConstants.capabilities.takeOwnershipRiskAssessment);
        vm.userCanCheckout = usersService.currentUserHasCapability(amlConstants.capabilities.takeOwnershipRiskAssessment);

        vm.displayMyRiskAssessments = false;
        vm.displayAllRiskAssessments = false;
        vm.displayAvailableRiskAssessments = false;

        vm.userCanRouteSelected = userCanRouteSelected;
        vm.isCheckinOwner = isCheckinOwner;
        vm.isOwnerEmptyForCheckout = isOwnerEmptyForCheckout;
        var expectedStateName = $state.$current.name;

        activate();

        //////
        function activate() {
            vm.displayOwnersTypes = [];
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessMyRiskAssessment)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.riskAssessmentsListQueueDisplayType.MY,
                        value: vm.resources.aml.riskAssessmentsList.displayQueueMyRiskAssessments
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessAllRiskAssessment)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.riskAssessmentsListQueueDisplayType.ALL,
                        value: vm.resources.aml.riskAssessmentsList.displayQueueAllRiskAssessments
                    }
                );
            }
            if (usersService.currentUserHasCapability(amlConstants.capabilities.accessAvailableRiskAssessment)) {
                vm.displayOwnersTypes.push(
                    {
                        key: amlConstants.riskAssessmentsListQueueDisplayType.AVAILABLE,
                        value: vm.resources.aml.riskAssessmentsList.displayQueueAvailableRiskAssessments
                    }
                );
            }

            // set initial queue in the dropdown to be the last value that the user selected (persisted as
            // a preference in localStorage)
            var defaultRiskAssessmentsQueue = amlPreferencesService.getLocalPreference('defaultRiskAssessmentsQueue');
            if (defaultRiskAssessmentsQueue) {
                vm.displayOwnersType = defaultRiskAssessmentsQueue;
            }
            else {
                // if no preference is found, default to first available queue
                if (vm.displayOwnersTypes[0].length > 0) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.riskAssessmentsListQueueDisplayType.AVAILABLE;
                }
            }
            //if default or saved option does not exists then use first available option
            if (!_.findWhere(vm.displayOwnersTypes, { key: vm.displayOwnersType })) {
                if (vm.displayOwnersTypes[0]) {
                    vm.displayOwnersType = vm.displayOwnersTypes[0].key;
                } else  {
                    vm.displayOwnersType = amlConstants.riskAssessmentsListQueueDisplayType.MY;
                }
            }

            updateDisplayRiskAssessments();
        }

        //For now, this is the same value case number and case name
        function getSelectedRiskAssessmentId() {
            var riskAssessmentId = null;
            var selectedRiskAssessmentIds = riskAssessmentsListDataMessagingService.getSelectedRiskAssessmentNumbers();
            if (selectedRiskAssessmentIds && selectedRiskAssessmentIds.length > 0) {
                riskAssessmentId = selectedRiskAssessmentIds[0];
            }
            return riskAssessmentId;
        }

        function openRouteRiskAssessmentsDialog() {
            riskAssessmentsListTriageService.openRouteRiskAssessmentsDialog(riskAssessmentsListDataMessagingService.getSelectedRiskAssessmentNumbers(),
                getSelectedRiskAssessmentId(), refreshRiskAssessmentsOwner).then(function () {
                });
        }

        function checkinRiskAssessments() {
            riskAssessmentsListTriageService.checkinRiskAssessments(riskAssessmentsListDataMessagingService.getSelectedRiskAssessmentNumbers(),
                getSelectedRiskAssessmentId(), refreshRiskAssessmentsOwner);
        }

        function checkoutRiskAssessments() {
            riskAssessmentsListTriageService.checkoutRiskAssessments(riskAssessmentsListDataMessagingService.getSelectedRiskAssessmentNumbers(),
                getSelectedRiskAssessmentId(), refreshRiskAssessmentsOwner);
        }

        function changeDisplayRiskAssessments() {
            // save current display type to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.defaultRiskAssessmentsQueue, vm.displayOwnersType);

            updateDisplayRiskAssessments();
        }

        function updateDisplayRiskAssessments() {
            riskAssessmentsListDataMessagingService.setDisplayOwnersType(vm.displayOwnersType);

            vm.displayMyRiskAssessments = vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.MY;
            vm.displayAvailableRiskAssessments = vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.AVAILABLE;
            vm.displayAllRiskAssessments = vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.ALL;
        }

        function refreshRiskAssessmentsOwner(riskAssessmentNumbers, owner) {
            riskAssessmentsListDataMessagingService.riskAssessmentsOwnerChanged(riskAssessmentNumbers, owner);
        }

        /**
         * To use from the UI to enable/disable the route button
         * depending on the queue and whether selected risk assessments are assigned to current user
         * @returns {boolean}
         */
        function userCanRouteSelected() {
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                if (vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.MY) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeRiskAssessment);
                }
                if (vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.ALL) {
                    return (usersService.currentUserHasCapability(amlConstants.capabilities.routeRiskAssessment)  && isCheckinOwner()) ||
                        usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments);
                }
                if (vm.displayOwnersType === amlConstants.riskAssessmentsListQueueDisplayType.AVAILABLE) {
                    return usersService.currentUserHasCapability(amlConstants.capabilities.routeAllRiskAssessments);
                }
            }
            return false;
        }
        /**
         * To use from the UI to enable/disable the checkin/checkout button
         * depending on whether it is assigned to current user
         * @returns {boolean}
         */
        function isCheckinOwner() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var currentUser = usersService.getCurrentUserId();
                var selectedEntities = riskAssessmentsListDataMessagingService.getSelectedRiskAssessments();
                if (!selectedEntities || selectedEntities.length === 0) {
                    allOwned = false;
                }
                else {
                    allOwned = _.every(selectedEntities, function (entity) {
                        return entity.owner === currentUser;
                    });
                }
            }
            return allOwned;
        }


        function isOwnerEmptyForCheckout() {
            var allOwned = false;
            if ( $state.$current.name === expectedStateName ) { // for performance; don't run check when tab not selected
                var selectedEntities = riskAssessmentsListDataMessagingService.getSelectedRiskAssessments();
                if ( !selectedEntities || selectedEntities.length === 0 ) {
                    allOwned = false;
                }
                else {
                    allOwned =_.every(selectedEntities, function(entity) {
                        return !entity.owner || entity.owner === null || entity.owner === '';
                    });
                }
            }
            return allOwned;
        }


    }
})();

/**
 * Created by dabock on 3/24/2016.
 */

(function () {
    'use strict';
    AmlGlobalSearchResultController.$inject = ["resources", "amlConstants", "entityService", "$state", "dateFilter", "messageMapFilter"];
    angular.module('aml.search').controller('AmlGlobalSearchResultController', AmlGlobalSearchResultController);

    /*
    Suppressing cyclomatic complexity checking because this really isn't
    all that complex.

    Suppressing dot notation checking (e.g. "['bank_name'] is better written in
    dot notation." because jshint complains about the underscore if it's in dot
    notation.
    */

    /*jshint maxcomplexity:16, sub:true */
    function AmlGlobalSearchResultController(resources, amlConstants, entityService, $state,
                                    dateFilter, messageMapFilter) {
        var vm = this;
        vm.resources = resources;

        var entity = {};
        var details = [];

        if(!vm.title) {
            vm.title = vm.subtitle;
        }

        vm.titleClick = function() {
            var entityState = entityService.getStateForEntity(entity);
            $state.go(entityState.stateName, entityState.stateParams);
        };

        activate();

        ////////////////////

        function activate() {
            switch(vm.doc['doc_type']) {
                case 'account':
                    handleAccount();
                    break;

                case 'alert':
                    handleAlert();
                    break;

                case 'associate':
                    handleAssociate();
                    break;

                case 'attachment':
                    handleAttachment();
                    break;

                case 'bank':
                    handleBank();
                    break;

                case 'branch':
                    handleBranch();
                    break;

                case 'case':
                    handleCase();
                    break;

                case 'comment':
                    handleComment();
                    break;

                case 'customer':
                    handleCustomer();
                    break;

                case 'ext':
                    handleExternalParty();
                    break;

                case 'hhd':
                    handleHousehold();
                    break;

                case 'report':
                    handleReport();
                    break;

                case 'risk':
                    handleRisk();
                    break;

                case 'watch list':
                    handleWatchList();
                    break;

                case 'cddreview':
                    handleCddReview();
                    break;

                default:
                    break;

            }

            // Remove details with empty value
            vm.details = details.filter(function(element) {
                return element.value;
            });


        }

        function makeEntityObj(numberName, nameName, codeName) {
            // Create object that will be used to create a state that will
            // be used if the link is clicked.

            // Make title link clickable.
            vm.clickable = true;

            // ID used in URL
            entity.entityNumber = vm.doc[numberName];
            entity.entityKey = vm.doc[numberName];

            // Name used on tab
            entity.entityName = vm.doc[nameName];

            // Code from app.constants.js
            entity.entityLevelCode = amlConstants.entityType[codeName];
        }


        function handleAccount() {
            vm.title = vm.doc['account_name'];
            vm.icon = 'sas-icon-customerFacingFacilityScenario';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.accountTxt;
            makeEntityObj('account_number', 'account_name', 'account');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.typeTxt,
                    value: messageMapFilter(vm.doc['account_type'], 'accountType')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.accountNumberTxt,
                    value: vm.doc['account_number']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.openedByTxt,
                    value: vm.doc['opened_by_party_name']
                }
            ];
        }

        function handleAlert() {
            vm.title = resources.aml.getResource(
                'search.alertWithIdTxt',
                {alertId: vm.doc.alertid}
            );
            vm.icon = 'sas-icon-alert';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.alertTxt;
            makeEntityObj('alertid', 'primary_entity_name', 'alert');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.nameTxt,
                    value: vm.doc['primary_entity_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.descriptionTxt,
                    value: vm.doc['alert_description']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.alertStatusTxt,
                    value: messageMapFilter(vm.doc['alert_status_code'], 'alertStatus')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.primaryEntityLevelTxt,
                    value: messageMapFilter(vm.doc['primary_entity_level_code'], 'entityLevel')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.runDateTxt,
                    value: dateFilter(vm.doc['run_date'])
                }
            ];
        }

        function handleAssociate() {
            vm.title = vm.doc['associate_full_name'];
            vm.icon = 'sas-icon-usergroup';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.associateTxt;
            makeEntityObj('associate_number', 'associate_full_name', 'associate');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.associateNumberTxt,
                    value: vm.doc['associate_number']
                }
            ];
        }

        function handleAttachment() {
            vm.title = vm.doc['attachment_name'];
            vm.icon = 'sas-icon-attach';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.attachmentTxt;
            makeEntityObj('entity_id', 'doc_type');
            entity.entityLevelCode = vm.doc['entity_type'];
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.entityTypeTxt,
                    value: messageMapFilter(vm.doc['entity_type'], 'entityLevel')
                }
            ];
        }

        function handleBank() {
            vm.title = vm.doc['bank_name'];
            vm.icon = 'sas-icon-scales';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.bankTxt;
            makeEntityObj('bank_number', 'bank_name', 'bank');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.addressTxt,
                    value: vm.doc['bank_address_1']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.cityTxt,
                    value: vm.doc['bank_city_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.countryTxt,
                    value: vm.doc['bank_country_name']
                }
            ];
        }

        function handleBranch() {
            vm.title = vm.doc['street_address_1'];
            vm.icon = 'sas-icon-internalFacilityScenario';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.branchTxt;
            makeEntityObj('branch_number', 'street_address_1', 'branch');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.cityTxt,
                    value: vm.doc['street_city_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.stateTxt,
                    value: vm.doc['street_state_code']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.countryTxt,
                    value: vm.doc['street_country_name']
                }
            ];
        }

        function handleCase() {
            vm.title = vm.doc['case_description'];
            vm.icon = 'sas-icon-accessControlTemplate';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.caseTxt;
            makeEntityObj('case_id', 'case_id', 'case');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.categoryTxt,
                    value: messageMapFilter(vm.doc['case_category_code'], 'caseCategory')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.subcategoryTxt,
                    value: messageMapFilter(vm.doc['case_sub_category_code'], 'caseSubcategory')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.statusTxt,
                    value: messageMapFilter(vm.doc['case_status_code'], 'caseStatus')
                }
            ];
        }

        function handleComment() {
            vm.title = vm.resources.aml.search.globalSearchResultSubtitles.commentTxt;
            vm.icon = 'sas-icon-comment';
            vm.subtitle = entityService.getReadableEntityIdentifier(
                vm.doc['object_type_cd'], vm.doc['object_id']);

            // makeEntityObj won't work here, so instead of that:
            if(vm.doc['object_id'] && vm.doc['object_type_cd']) {
                vm.clickable = true;
                entity.entityNumber = vm.doc['object_id'];
                entity.entityLevelCode = vm.doc['object_type_cd'];
            }

            var truncatedDesc;

            if(vm.doc['comment_text']) {
                var htmlRemoved = vm.doc['comment_text'].replace(/<[^>]+>/g, ' ');
                truncatedDesc = htmlRemoved.substr(0, 140) +
                    (htmlRemoved.length > 140 ? '...' : '');
            }

            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.textTxt,
                    value: truncatedDesc
                }
            ];
        }

        function handleCustomer() {
            vm.title = vm.doc['party_name'];
            vm.icon = 'sas-icon-user';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.customerTxt;
            makeEntityObj('party_number', 'party_name', 'customer');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.streetAddressTxt,
                    value: vm.doc['street_address_1']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.streetAddressTxt,
                    value: vm.doc['street_address_2']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.cityTxt,
                    value: vm.doc['street_city_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.stateTxt,
                    value: vm.doc['street_state_code']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.countryTxt,
                    value: vm.doc['street_country_name']
                }
            ];
        }

        function handleExternalParty() {
            vm.title = vm.doc['full_name'];
            vm.icon = 'sas-icon-usergroup';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.externalPartyTxt;
            makeEntityObj('ext_party_number', 'full_name', 'externalParty');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.accountNumberTxt,
                    value: vm.doc['ext_account_number']
                }
            ];
        }

        function handleHousehold() {
            vm.title = vm.doc['head_of_household_name'];
            vm.icon = 'sas-icon-CIBusinessContext_obj';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.householdTxt;
            makeEntityObj('household_number', 'head_of_household_name', 'household');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.streetAddressTxt,
                    value: vm.doc['street_address_1']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.streetAddressTxt,
                    value: vm.doc['street_address_2']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.cityTxt,
                    value: vm.doc['street_city_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.stateTxt,
                    value: vm.doc['street_state_code']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.countryTxt,
                    value: vm.doc['street_country_name']
                }
            ];
        }

        function handleReport() {
            vm.title = vm.doc['report_desc'];
            vm.icon = 'sas-icon-accessControlTemplate';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.reportTxt;
            makeEntityObj('report_key', 'report_desc', 'report');

            var truncatedDesc;

            if(vm.doc['narrative_long_desc']) {
                truncatedDesc = vm.doc['narrative_long_desc'].substr(0, 140) +
                    (vm.doc['narrative_long_desc'].length > 140 ? '...' : '');
            }

            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.reportReadyCodeTxt,
                    value: messageMapFilter(vm.doc['report_ready_code'], 'readyCode')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.descriptionTxt,
                    value: truncatedDesc
                }
            ];
        }

        function handleRisk() {
            vm.title = vm.doc['risk_party_name'];
            vm.icon = 'sas-icon-alert';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.riskAssessmentTxt;
            makeEntityObj('risk_assessment_id', 'risk_party_name', 'riskAssessment');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.riskClassificationTxt,
                    value: messageMapFilter(vm.doc['risk_classification'], 'riskClassification')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.proposedRiskClassificationTxt,
                    value: messageMapFilter(vm.doc['proposed_risk_classification'], 'riskClassification')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.statusTxt,
                    value: messageMapFilter(vm.doc['risk_assessment_status_code'], 'riskAssessmentStatus')
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.createDateTxt,
                    value: dateFilter(vm.doc['create_date'])
                }
            ];
        }

        function handleWatchList() {
            vm.title = vm.doc['entity_name'];
            vm.icon = 'sas-icon-bulletedList';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.watchListTxt;
            makeEntityObj('entity_watch_list_key', 'entity_name', 'watchList');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.typeTxt,
                    value: vm.doc['type_desc']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.watchListNameTxt,
                    value: vm.doc['watch_list_name']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.programsTxt,
                    value: vm.doc['programs']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.politicallyExposedPersonTxt,
                    value: vm.doc['politically_exposed_person_ind']
                }
            ];
        }


        function handleCddReview() {
            vm.title = vm.doc['party_name'];
            vm.icon = 'sas-icon-bulletedList';
            vm.subtitle = vm.resources.aml.search.globalSearchResultSubtitles.cddReviewTxt;
            makeEntityObj('review_key', 'party_name', 'cddReview');
            details = [
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.keyTxt,
                    value: vm.doc['review_key']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.taxIdTxt,
                    value: vm.doc['party_tax_id']
                },
                {
                    label: vm.resources.aml.search.globalSearchResultDetails.statusTxt,
                    value: vm.doc['status_code']
                }
            ];
        }
    }
})();


/**
 * handle the creation of a report actions
 */
(function () {
    'use strict';
    CreateReportModalController.$inject = ["$uibModalInstance", "resources", "reportsService", "parentCaseId", "caseDescription"];
    angular.module('aml.cases.details').controller('CreateReportModalController', CreateReportModalController);

    function CreateReportModalController($uibModalInstance, resources, reportsService, parentCaseId, caseDescription) {
        var vm = this;
        vm.description = caseDescription;
        vm.reportType = null;
        vm.parentCaseId = parentCaseId;
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        
//console.log("createreportmodalcontroller vm : " + JSON.stringify(vm));

        activate();

        function activate() {
            reportsService.getReportConfigurations().then(function (data) {
            	var tmpData = new Array;
            	data.items.forEach(function (item, index, array){
            		if(item.formConfigKey == 311){
            			tmpData.push(item);
            		}
            	});
              vm.reportTypeList = tmpData;
            });
        }

        function ok() {
//console.log("555555");
            var result = {
                description: vm.description,
                reportTypeKey: vm.reportType.formConfigKey,
                formTypeCode: vm.reportType.formTypeCode
            };
            
//console.log("2222222");

            $uibModalInstance.close(result);
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }
    }
})();

/**
 * handle the case routing modal dialog action
 */
(function () {
    'use strict';
    RouteCasesModalController.$inject = ["$uibModalInstance", "amlConstants", "resources", "usersService", "caseNumbers", "caseId", "user", "queue"];
    angular.module('aml.cases.details').controller('RouteCasesModalController', RouteCasesModalController);

    function RouteCasesModalController  ($uibModalInstance, amlConstants, resources, usersService,
                                         caseNumbers, caseId, user, queue) {
        var vm = this;
        vm.uibModalInstance = $uibModalInstance;
        vm.resources = resources;
        vm.user = user;
        vm.queue = queue;

        if(caseNumbers.length === 1) {
            vm.modalTitle = resources.aml.getResource(
                'cases.triage.routeOneCaseTitle',
                {caseId: caseId}
            );
        }
        else {
            vm.modalTitle = resources.aml.getResource(
                'cases.triage.routeOtherCasesTitle',
                {numberOfCases: caseNumbers.length}
            );
        }

        activate();

        /////////

        function activate() {
            // get all alerts count from Alerts directive
            vm.users = [];
            usersService.getUsersWithAnyCapability( [amlConstants.capabilities.accessCasesMy, amlConstants.capabilities.accessCasesAll,
                                                     amlConstants.capabilities.accessCasesAvailable] ).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                }
            });
        }
    }
})();

/**
 * handles the confirmation modal dialog
 */
(function () {
    'use strict';
    ConfirmationDialogController.$inject = ["$uibModalInstance", "resources", "title", "text"];
    angular.module('aml.core').controller('ConfirmationDialogController', ConfirmationDialogController);

    function ConfirmationDialogController($uibModalInstance, resources, title, text) {
        var vm = this;

        vm.resources = resources;
        vm.title = title;
        vm.text = text;

        vm.ok =  $uibModalInstance.close;
        vm.cancel =  $uibModalInstance.dismiss;
    }

})();

(function () {
    'use strict';
ErrorModalController.$inject = ["$uibModalInstance", "resources"];
    angular.module('aml.cases.details').controller('ErrorModalController', ErrorModalController);


    function ErrorModalController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;

         viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
         };
}
})();
(function () {
    'use strict';
    DirtyModalController.$inject = ["$uibModalInstance", "resources", "tabsListService"];
    angular.module('aml.cases.details').controller('DirtyModalController', DirtyModalController);

    function DirtyModalController($uibModalInstance, resources, tabsListService) {
        var viewVm = this;
        viewVm.resources = resources;

        var tab = tabsListService.getTabForCurrentState();
        viewVm.tabName = tab ? tab.title : '';

        viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
        };
        viewVm.save = function () {
            $uibModalInstance.dismiss('save');
        };
        viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();
(function () {
    'use strict';
    InformationModalController.$inject = ["$uibModalInstance", "resources", "title", "text"];
    angular.module('aml.core').controller('InformationModalController', InformationModalController);

    function InformationModalController($uibModalInstance, resources, title, text) {
        var vm = this;
        vm.resources = resources;
        vm.title = title;
        vm.text = text;
        
//console.log("texttexttext : " + text);

        vm.ok =  $uibModalInstance.close;
    }
})();
/**
 * Created by dabock on 10/28/2015.
 */
(function() {
    'use strict';
    AmlDateRangeController.$inject = ["resources"];
    angular.module('aml.core').controller('AmlDateRangeController', AmlDateRangeController);

    function AmlDateRangeController(resources) {
        var vm = this;
        vm.resources = resources;

        vm.minNameAndId = 'min' + vm.nameAndId;
        vm.maxNameAndId = 'max' + vm.nameAndId;

        vm.selectedFrom = function (selectedDate) {
            //this is called when From field was changed and range was validated
            //if range is valid then both From and To are valid, so need to reset validity of To
            if (vm.minObj.$valid) {
                vm.maxObj.$setValidity('dateRange', true);
            }
        };

        vm.selectedTo = function (selectedDate) {
            //this is called when To field was changed and range was validated
            //if range is valid then both From and To are valid, so need to reset validity of From
            if (vm.maxObj.$valid) {
                vm.minObj.$setValidity('dateRange', true);
            }
        };
    }
})();

(function() {
    'use strict';
    AmlDatePickerController.$inject = ["amlConstants", "resources", "amlCoreUtils", "$locale"];
    angular.module('aml.core').controller('AmlDatePickerController', AmlDatePickerController);

    function AmlDatePickerController(amlConstants, resources, amlCoreUtils, $locale) {
        var vm = this;

        vm.resources = resources;
        // global datepicker settings
        vm.dateFormat = 'mediumDate';

        vm.dateOptions = {
            startingDay: amlCoreUtils.getLocaleStartingDayOfWeek(),
            showWeeks: amlConstants.config.datePicker ? amlConstants.config.datePicker.showWeeks : 0
        };

        //S1265895 - The mediumDate format doesn't work for 'ar' locale.  If the locale is 'ar' then force the format
        // to be the desired format.
        /* tslint:disable */ /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        if ($locale.id.indexOf('ar') != -1) {
            vm.dateFormat = 'dd/MM/yyyy';
        }
        /* tslint:enable */ /* jshint ignore:end */

        if($locale.DATETIME_FORMATS.shortDate.charAt(0).toLowerCase() === 'y') {
            // S1199214
            // By default, the format of the title when selecting a day is MMM yyyy.
            // uib-datepicker does not change this for different locales. Angular
            // doesn't have a local date format for month and year without day. The
            // closest it has is shortDate, which is e.g. M/d/yy for US English and
            // y/M/d for traditional Chinese. If the local shortDate format starts
            // with year, then the calendar title should start with year.
            vm.dateOptions.formatDayTitle = 'yyyy MMM';
        }

        if($locale.DATETIME_FORMATS.mediumDate === 'y\u5e74M\u6708d\u65e5') {
            // S1199214
            // Overriding the above for Chinese locales only.
            vm.dateOptions.formatDayTitle = 'y\u5e74M\u6708';
        }

        vm.openDatePicker = openDatePicker;

        function openDatePicker($event) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.dateOpened = true;
        }
    }
})();

(function() {
    'use strict';
    AmlDatePicker2Controller.$inject = ["$locale", "amlConstants", "resources", "amlCoreUtils", "$scope"];
    angular.module('aml.core').controller('AmlDatePicker2Controller', AmlDatePicker2Controller);

    function AmlDatePicker2Controller($locale, amlConstants, resources, amlCoreUtils, $scope) {
        var vm = this;

        vm.resources = resources;
        // global datepicker settings
        vm.dateFormat = 'mediumDate';

        vm.dateOptions = {
            startingDay: amlCoreUtils.getLocaleStartingDayOfWeek(),
            showWeeks:  amlConstants.config.datePicker ? amlConstants.config.datePicker.showWeeks : 0,
            rtl: true
        };

        vm.required = $scope.required;

        //S1265895 - The mediumDate format doesn't work for 'ar' locale.  If the locale is 'ar' then force the format
        // to be the desired format.
        /* tslint:disable */ /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        if ($locale.id.indexOf('ar') != -1) {
            vm.dateFormat = 'dd/MM/yyyy';
        }
        /* tslint:enable */ /* jshint ignore:end */

        if($locale.DATETIME_FORMATS.shortDate.charAt(0).toLowerCase() === 'y') {
            // S1199214
            // By default, the format of the title when selecting a day is MMM yyyy.
            // uib-datepicker does not change this for different locales. Angular
            // doesn't have a local date format for month and year without day. The
            // closest it has is shortDate, which is e.g. M/d/yy for US English and
            // y/M/d for traditional Chinese. If the local shortDate format starts
            // with year, then the calendar title should start with year.
            vm.dateOptions.formatDayTitle = 'yyyy MMM';
        }

        if($locale.DATETIME_FORMATS.mediumDate === 'y\u5e74M\u6708d\u65e5') {
            // S1199214
            // Overriding the above for Chinese locales only.
            vm.dateOptions.formatDayTitle = 'y\u5e74M\u6708';
        }

        vm.openDatePicker = openDatePicker;

        function openDatePicker($event) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.dateOpened = true;
        }
    }
})();

/**
 * handle the review routing modal dialog action
 */
(function () {
    'use strict';
    RouteReviewsModalController.$inject = ["$uibModalInstance", "amlConstants", "resources", "usersService", "reviewNumbers", "key", "user", "queue"];
    angular.module('cdd.reviews').controller('RouteReviewsModalController', RouteReviewsModalController);

    function RouteReviewsModalController($uibModalInstance, amlConstants, resources, usersService,
                                         reviewNumbers, key, user, queue) {

        var vm = this;
        vm.uibModalInstance = $uibModalInstance;
        vm.resources = resources;
        vm.user = user;
        vm.queue = queue;

        if(reviewNumbers.length === 1) {
            vm.modalTitle = resources.aml.getResource(
                'reviews.triage.routeOneReviewTitle',
                {key: key}
            );
        }
        else {
            vm.modalTitle = resources.aml.getResource(
                'reviews.triage.routeOtherReviewsTitle',
                {numberOfReports: reviewNumbers.length}
            );
        }

        activate();

        /////////

        function activate() {
            // get all alerts count from Alerts directive
            vm.users = [];
            usersService.getUsersWithCapability( amlConstants.capabilities.accessCDDReviewsMy ).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                }
            });
        }
    }
})();

/**
 * handle the alert routing modal dialog action
 */
(function () {
    'use strict';
    RouteEntitiesModalController.$inject = ["$uibModalInstance", "amlConstants", "resources", "usersService", "entityIds", "entityName", "user", "queue"];
    angular.module('aml.customer.details').controller('RouteEntitiesModalController', RouteEntitiesModalController);

    function RouteEntitiesModalController($uibModalInstance, amlConstants, resources, usersService,
        entityIds, entityName, user, queue) {

        var vm = this;
        vm.uibModalInstance = $uibModalInstance;
        vm.resources = resources;
        vm.user = user;
        vm.queue = queue;

        if(entityIds.length === 1) {
            vm.modalTitle = resources.aml.getResource(
                'customer.triage.routeOneCustomerTitle',
                {entityName: entityName}
            );
        }
        else {
            vm.modalTitle = resources.aml.getResource(
                'customer.triage.routeOtherCustomersTitle',
                {numberOfEntities: entityIds.length}
            );
        }

        activate();

        /////////

        function activate() {
            vm.users = [];
            usersService.getUsersWithAnyCapability( [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll,
                                                     amlConstants.capabilities.accessEntitiesAvailable] ).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                }
            });
        }
    }
})();

/**
 * handle the report routing modal dialog action
 */
(function () {
    'use strict';
    RouteReportsModalController.$inject = ["$uibModalInstance", "amlConstants", "resources", "usersService", "reportNumbers", "reportKey", "user", "queue"];
    angular.module('aml.reports.details').controller('RouteReportsModalController', RouteReportsModalController);

    function RouteReportsModalController ($uibModalInstance, amlConstants, resources, usersService,
        reportNumbers, reportKey, user, queue) {

        var vm = this;
        vm.uibModalInstance = $uibModalInstance;
        vm.resources = resources;
        vm.user = user;
        vm.queue = queue;

        if(reportNumbers.length === 1) {
            vm.modalTitle = resources.aml.getResource(
                'regulatoryReports.triage.routeOneReportTitle',
                {reportKey: reportKey}
            );
        }
        else {
            vm.modalTitle = resources.aml.getResource(
                'regulatoryReports.triage.routeOtherReportsTitle',
                {numberOfReports: reportNumbers.length}
            );
        }

        activate();

        /////////

        function activate() {
            // get all alerts count from Alerts directive
            vm.users = [];
            usersService.getUsersWithAnyCapability([amlConstants.capabilities.accessReportsMy, amlConstants.capabilities.accessReportsAvailable,
                                                    amlConstants.capabilities.accessReportsAll]).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                }
            });
        }
    }
})();

/**
 * handle the accept risk asessement modal dialog action
 */
(function () {
    'use strict';
    AcceptRiskAssessmentsModalController.$inject = ["$uibModalInstance", "resources", "assessmentId"];
    angular.module('aml.riskAssessments').controller('AcceptRiskAssessmentsModalController', AcceptRiskAssessmentsModalController);

    function AcceptRiskAssessmentsModalController($uibModalInstance,  resources,  assessmentId  ) {

        var vm = this;
//console.log('Inside AcceptRiskAssessments.conroller.js - post this');

        vm.assesmentId  = null;
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        vm.assesmentId = assessmentId;


        /////////

        function ok() {
            var result = {
            };
//console.log("666666");
            $uibModalInstance.close(result);
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

    }
})();

/**
 * handle the reject risk asessement modal dialog action
 */
(function () {
    'use strict';
    RejectRiskAssessmentsModalController.$inject = ["$uibModalInstance", "resources", "assessmentId"];
    angular.module('aml.riskAssessments').controller('RejectRiskAssessmentsModalController', RejectRiskAssessmentsModalController);

    function RejectRiskAssessmentsModalController($uibModalInstance, resources, assessmentId  ) {

        var vm = this;
        vm.assesmentId  = null;
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        vm.assesmentId = assessmentId;


        /////////

        function ok() {
//console.log("7777777");
            var result = {
            };

            $uibModalInstance.close(result);
        }

        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }

    }

})();

/**
 * handle the alert routing modal dialog action
 */
(function () {
    'use strict';
    RouteRiskAssessmentsModalController.$inject = ["$uibModalInstance", "amlConstants", "resources", "usersService", "riskAssessmentNumbers", "assessmentId"];
    angular.module('aml.riskAssessments').controller('RouteRiskAssessmentsModalController', RouteRiskAssessmentsModalController);

    function RouteRiskAssessmentsModalController($uibModalInstance, amlConstants, resources,
                                                 usersService, riskAssessmentNumbers, assessmentId) {

        var vm = this;
        vm.uibModalInstance = $uibModalInstance;
        vm.resources = resources;

        if(riskAssessmentNumbers.length === 1) {
            vm.modalTitle = resources.aml.getResource(
                'riskAssessment.triage.routeOneRiskTitle',
                {assessmentId: assessmentId}
            );
        }
        else {
            vm.modalTitle = resources.aml.getResource(
                'riskAssessment.triage.routeOtherRiskTitle',
                {numberOfAssessments: riskAssessmentNumbers.length}
            );
        }

        activate();

        /////////

        function activate() {
            vm.users = [];
            usersService.getUsersWithCapability( amlConstants.capabilities.accessMyRiskAssessment ).then( function(users) {
                if ( users && users.items ) {
                    vm.users = users.items;
                }
            });
        }
    }
})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlAlertsList', amlAlertsList);

    function amlAlertsList() {
        var directive = {
            restrict: 'E',
            scope: {
                caseId: '=',
                entityNumber: '=',
                entityLevelCode: '=',
                entityKey: '=',
                entityId: '=',
                idPrefix: '@', // prefix to use for grid id so it's unique (if used multiple times in the application)
                updateOnEntityChanges: '=',
                listType: '=',
                pageSize: '@'
            },
            templateUrl: 'alerts/alertsListDirective.html',

            controller: 'AlertsListController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by tommut on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlRiskFactorsList', amlRiskFactorsList);

    function amlRiskFactorsList() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'riskFactors/riskFactorsListDirective.html',
            controller: 'RiskFactorsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * Created by tommut on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlTransactionsList', amlTransactionsList);

    function amlTransactionsList() {
        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                alertId: '=',
                exttype: '=',
                hostPage: '@',
                entityNumber: '=',
                entityLevelCode: '=',
                entityKey: '=',
                entityId: '=',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'transactions/transactionsListDirective.html',
            controller: 'TransactionsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlTransactionMetrics', amlTransactionMetrics);

    /* @ngInject */
    function amlTransactionMetrics() {
        // Usage:
        //
        // Creates:
        //
        var directive = {
            restrict: 'E',
            scope: {
                entityNumber: '=',
                entityLevelCode: '=',
                entityId: '=',
                grpBy: '=',
                gClass: '=',
                aggTitle: '='
            },
            templateUrl: 'transactions/txMetricsDirective.html',

            controller: 'TxMetricsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml')
        .directive('amlFundsTracker', amlFundsTracker);

    function amlFundsTracker() {

        var directive = {
            restrict: 'E',
            scope: {},
            templateUrl: 'networks/fundstrackerDirective.html',

            controller: 'FundsTrackerController',
            controllerAs: 'vm',
            bindToController: { accountNumber: '=',
                entityLevelCode: '=',
                entityId: '=',
                grpBy: '=',
                gClass: '=',
                aggTitle: '=',
                params: '='} // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlAuditEventList
 *
 * @restrict E
 *
 * @description
 * This directive is used to display a list of audit events for a given AML object (such as alert, case, entity).
 *
 * @element ANY
 * @required
 *
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAuditEventList', amlAuditEventList);

    /* @ngInject */
    function amlAuditEventList() {

        var directive = {
            restrict: 'E',
            templateUrl: 'admin/audit/amlAuditEventListDirective.html',
            controller: 'AuditEventListController',
            controllerAs: 'vm',
            scope:  {
                 //  the scope is isolated
                 objectId: '=',
                 objectTypeCode: '='
             },
             bindToController: true
        };
        return directive;
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlAuditLink
 *
 * @restrict E
 *
 * @description
 * This directive is used to display a link that will navigate to an audit events page for a given entity (such as
 * alert, case, entity). The link will only be displayed if the user has the capability to view audit events.
 *
 * @element ANY
 * @required
 *
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAuditLink', amlAuditEventList);

    /* @ngInject */
    function amlAuditEventList() {

        var directive = {
            restrict: 'E',
            templateUrl: 'admin/audit/amlAuditLinkDirective.html',
            controller: 'AuditLinkController',
            controllerAs: 'vm',
            scope:  {
                 //  the scope is isolated
                 objectId: '=',
                 objectTypeCode: '=',
                 objectName: '='  // can pass the objectName if available, for use in the object tab label
             },
             bindToController: true
        };
        return directive;
    }
})();
/**
 * Created by dabock on 4/24/2017.
 */
(function() {
    'use strict';

    angular.module('aml.customer.details').directive('amlAlertInfo', amlAlertInfo);

    /*@ngInject*/
    function amlAlertInfo() {
        return {
            restrict: 'E',
            scope: {
                alertObj: '=',
                alertId: '='
            },
            templateUrl: 'alerts/alertInfo/alertInfoDirective.html',
            /*@ngInject*/
            controller: ["resources", "alertLevelFilter", "amlConstants", function(resources, alertLevelFilter, amlConstants) {
                var vm = this;
                vm.resources = resources;
                vm.displayMLS = true;
                if (amlConstants.config.aml && amlConstants.config.aml.MLS && angular.isDefined(amlConstants.config.aml.MLS.display)) {
                    vm.displayMLS = amlConstants.config.aml.MLS.display;
                }
                if (amlConstants.config.aml && amlConstants.config.aml.terrorFinancing && angular.isDefined(amlConstants.config.aml.terrorFinancing.display)) {
                    vm.displayTerrorFinancingScore = amlConstants.config.aml.terrorFinancing.display;
                }

                vm.getEntityType = function( entityType ) {
                    return alertLevelFilter( entityType );
                };

                var closedCaseStatuses;
                if(amlConstants.config.caseStatusClosed) {
                    closedCaseStatuses = amlConstants.config.caseStatusClosed.replace(/\s/g, '').split(',');
                }

                vm.isCaseClosed = function() {
                    if(!vm.alertObj || !vm.alertObj.caseStatus) {
                        return false;
                    }
                    else if(closedCaseStatuses.indexOf(vm.alertObj.caseStatus) > -1) {
                        return true;
                    }
                    else {
                        return false;
                    }
                };

            }],
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAlertTriage', amlAlertTriage);

    function amlAlertTriage() {
        var directive = {
            restrict: 'E',

            templateUrl: 'alerts/triage/alertTriageDirective.html',
            controller: 'AlertTriageController',
            controllerAs: 'vm',
           /* bindToController: true, // because the scope is isolated
            scope: {
                //  the scope is isolated
                objectId: '=',
                objectTypeCode: '='
            },*/

             bindToController:  {
                //  the scope is isolated
                objectId: '=',
                objectTypeCode: '=',
                alertable: '='
            },
             scope: true
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAlertTriageCaseList', alertTriageCaseList);

    function alertTriageCaseList() {
        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                selectedCaseId: '=',
                editable: '='
            },
            templateUrl: 'alerts/triage/alertTriageCaseListDirective.html',
            controller: 'AlertTriageCaseListController',
            controllerAs: 'vm',
            bindToController: true

        };
        return directive;
    }
})();

/**
 * Created by dabock on 4/28/2017.
 */
(function() {
    'use strict';

    angular.module('aml.customer.details').directive('amlWatchList', amlWatchList);

    function amlWatchList() {
        return {
            restrict: 'E',
            scope: {
                alertId: '='
            },
            templateUrl: 'alerts/watchList/watchListDirective.html',
            controller: 'WatchListDirectiveController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * Created by dabock on 5/23/2017.
 */
(function() {
    'use strict';
    angular.module('aml.customer.details').directive(
        'amlWatchListExtendedDetails', amlWatchListExtendedDetails);

    function amlWatchListExtendedDetails() {
        return {
            restrict: 'E',
            scope: {
                watchListData: '='
            },
            templateUrl: 'alerts/watchList/watchListExtendedDetailsDirective.html',
            controller: ["resources", function(resources) {
                var vm = this;
                vm.resources = resources;
            }],
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.cases.details')
        .directive('amlCaseDetails', amlCaseDetails);

    /* @ngInject */
    function amlCaseDetails() {
        var directive = {
            restrict: 'E',
            scope: {
                case: '=',
                entity: '=',
                readonly: '='
            },
            templateUrl: 'cases/caseDetails/caseDetailsDirective.html',
            controller: 'CaseDetailsController',
            controllerAs: 'vm',
            require: ['^form'],
            link: function($scope, $element, $attrs, $ctrls) {
                $scope.formCtrl = $ctrls[0];
            },
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.cases.details')
        .directive('amlCaseEntityList', amlCaseEntities);

    /* @ngInject */
    function amlCaseEntities() {
        var directive = {
            restrict: 'E',
            templateUrl: 'cases/caseDetails/caseEntitiesDirective.html',
            controller: 'CaseEntitiesController',
            controllerAs: 'vm',
            bindToController:  {
                readonly: '='
            },
            scope : true

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.cases:casesList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'casesList' directive is used to generate a list of cases
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-cases-list page-size="20"></aml-cases-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('aml.cases')
        .directive('amlCasesList', casesList);

    /* @ngInject */
    function casesList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'cases/casesList/casesListDirective.html',

            controller: 'CasesListDirectiveController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();
/**
 * Created by sasrns on 8/19/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.cases.details')
        .directive('amlCasesOverview', amlCasesOverview);

    /* @ngInject */
    function amlCasesOverview() {
        var directive = {
            restrict: 'E',
            scope: {
                case: '=',
                overviewReadOnly: '=',
                readonly: '='
            },
            /*@ngInject*/
            controller: ["$scope", "resources", "amlLov", function($scope, resources, amlLov){
                var vm = this;
                vm.resources = resources;
                vm.amlLov = amlLov;
            }],
            controllerAs: 'vm',
            templateUrl: 'cases/overview/caseOverviewDirective.html',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('cdd.rule')
        .directive('amlRuleGroupList', ruleGroupList);

    function ruleGroupList() {
        var directive = {
            scope: {
            },
            restrict: 'E',
            templateUrl: 'cddAdmin/ruleGroupList/ruleGroupListDirective.html',
            controller: 'RuleGroupListDirectiveController',
            controllerAs: 'vm',
            bindToController: {
                //ruleGroups: '=*',
                loading: '@loading',
                showDeleted : '=',
                callback: '='
            }
        };
        return directive;
    }
})();
(function(){
    'use strict';

    angular
        .module('cdd.rule')
        .directive('amlRuleList', ruleList);

    function ruleList() {
        var directive = {
            scope: {
            },
            restrict: 'E',
            templateUrl: 'cddAdmin/ruleList/ruleListDirective.html',
            controller: 'RuleListDirectiveController',
            controllerAs: 'vm',
            bindToController: {
                rules: '=*',
                loading: '@loading',
                showDeleted : '=',
                callback: '='
            }
        };
        return directive;
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlAlertMessages
 *
 * @restrict E
 *
 * @description
 * The 'amlAlertMessages' directive is used to display a floating notification area that will
 * display any alerts sent to the message-service
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAlertMessages', amlAlertMessages);

    /* @ngInject */
    function amlAlertMessages() {
        var directive = {
            restrict: 'E',
            scope: {},
            templateUrl: 'core/alertMessages/alertMessages.html',
            controller: 'AlertMessagesController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlAutoLogout
 *
 * @restrict E
 *
 * @description
 * The 'amlAutoLogout' directive is used to set an inactivity timer that will automatically
 * log out the user after a period of inactivity.  If the inactivity timeout is reached, a
 * dialog is displayed asking whether the user wishes to remain logged in; otherwise the user
 * is logged out automatically.
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAutoLogout', amlAutoLogout);

    function amlAutoLogout() {
        var directive = {
            controller: 'AutoLogoutController',
            controllerAs: 'vm',
            bindToController: true, // because the scope is isolated
            scope: {
                keepAliveMinutes: '='
            }
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlConfirmOnDirtyPageExit
 *
 * @restrict EA
 *
 * @description
 * The 'amlConfirmOnDirtyPageExit' directive is used to check if there are any unsaved (dirty) pages whenever the
 * browser tab/window attempts to be closed or refreshed. If there are, the browser's standard unload confirmation
 * dialog will be presented to the user asking whether they wish to navigate away from the page or not.
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlConfirmOnDirtyPageExit', amlConfirmOnDirtyPageExit);

    function amlConfirmOnDirtyPageExit() {
        return {
            controller: ["tabsListService", "resources", "$window", function AutoLogoutController(tabsListService, resources, $window ) {

                $window.addEventListener('beforeunload', function (e) {
                    var confirmationMessage = null;

                    // if there's any dirty tabs, return confirmation message
                    if ( tabsListService.isAnyTabDirty() ) {
                        confirmationMessage =  resources.aml.logout.unsavedChangesPromptText;
                        (e || window.event).returnValue = confirmationMessage;
                        return confirmationMessage;
                    }
                });
            }]
        };
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlUiView
 *
 * @restrict E
 *
 * @description
 * The 'amlUiView' directive adds a separate ui-view div for each named-view state, and sets a ng-show to display it
 * only if the corresponding state is active. To make use of the 'sticky' states, state views must be used, which is
 * why we use views for most of our states.
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlUiView', amlUiView);

    function amlUiView() {
        var directive = {
            templateUrl: 'core/state/amlUiViewDirective.html',
            controller: 'AMLUIViewController',
            controllerAs: 'vm',
            bindToController: true, // because the scope is isolated
            scope: {
               parentState: '=',  // the parent state to load children ui-views for
               includeStatesWithNoParent: '@' // set to true to include all states that do not define a parent
            }
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlTabNavigation
 *
 * @restrict E
 *
 * @description
 * The 'amlTabNavigation' directive displays a separated list of functional area tabs and corresponding object tabs for
 * each state that defines itself as a tab. It essentially combines the amlAreaNavigation and amlTabsList directives
 * into a single navbar.
 *
 * @element ANY
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTabNavigation', amlTabNavigation);

    function amlTabNavigation() {
        var directive = {
            restrict: 'E',
            templateUrl: 'core/tabs/amlTabNavigationDirective.html'
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlReview', review);

    /* @ngInject */
    function review() {
        var directive = {
            restrict: 'E',
            scope: {
                reviewDetail: '=',
                currentCustomer: '=',
                overviewReadOnly: '=',
                readOnly: '=',
                forms: '=',
                validator: '='
            },
            controller: 'CddReviewDetailsController',
            controllerAs: 'vm',
            templateUrl: 'cddReviews/cddReviewDetails/cddReviewDetailsDirective.html',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();



/**
 * Created by sasrns on 8/19/2015.
 */
(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlReviewsOverview', amlReviewsOverview);

    /* @ngInject */
    function amlReviewsOverview() {
        var directive = {
            restrict: 'E',
            scope: {
                review: '='
            },
            /*@ngInject*/
            controller: ["$scope", "resources", "amlLov", function($scope, resources, amlLov){
                var vm = this;
                vm.resources = resources;
                vm.amlLov = amlLov;
                vm.isIndividual = true;
                $scope.$watch('vm.review.currentCustomer', function (newValue, oldValue) {
                    if (newValue) {
                      vm.isIndividual = newValue.partyTypeDesc === 'INDIVIDUAL';
                    }
                });
            }],
            controllerAs: 'vm',
            templateUrl: 'cddReviews/overview/reviewOverviewDirective.html',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.reviews:reviewsList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'reviewsList' directive is used to generate a list of reviews
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-reviews-list page-size="20"></aml-reviews-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlReviewsList', reviewsList);

    /* @ngInject */
    function reviewsList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'cddReviews/reviewsList/reviewsListDirective.html',

            controller: 'ReviewsListDirectiveController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();
/**
 * Associated parties list
 * Created by segalk on 02/26/2018
 */
(function() {
    'use strict';

    angular.module('aml.customer.details').directive('amlCustomerList', amlCustomerList);

    function amlCustomerList() {
        return {
            restrict: 'E',
            scope: {
                customerList: '='
            },
            templateUrl: 'customers/customersList/customerListDirective.html',
            controller: 'CustomerListDirectiveController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.customer:customerList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'customerList' directive is used to generate a list of customers
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-entity-list page-size="20"></aml-entity-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('aml.customer')
        .directive('amlEntityList', amlEntityList);

    /* @ngInject */
    function amlEntityList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'entities/entitiesList/entitiesListDirective.html',
            controller: 'EntityListDirectiveController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();
(function(){
    'use strict';

    angular
        .module('aml.entities')
        .directive('amlEntityCaseList', caseList);

    function caseList() {
        var directive = {
            restrict: 'E',
            scope: {
                entityNumber: '=',
                entityLevelCode: '=',
                entityKey: '=',
                entityId: '=',
                ownerUserLongId: '=',
                caseId: '=',
                pageSize: '@'
            },
            templateUrl: 'entities/entityCases/entityCaseListDirective.html',
            controller: 'EntityCaseListController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.efiles.details')
        .directive('amlEfileDetails', amlEfileDetails);

    /* @ngInject */
    function amlEfileDetails() {
        var directive = {
            restrict: 'E',
            scope: {
                efile: '='
            },
            templateUrl: 'efiles/efileDetails/efileDetailsDirective.html',

            controller: 'EfileDetailsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.efiles:efilesList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'efilesList' directive is used to generate a list of efiles
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-efiles-list page-size="20"></aml-efiles-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('aml.efiles')
        .directive('amlEfilesList', efilesList);

    /* @ngInject */
    function efilesList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'efiles/efilesList/efilesListDirective.html',

            controller: 'EfilesListDirectiveController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();
/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.reports.details')
        .directive('amlReportDetails', amlReportDetails);

    /* @ngInject */
    function amlReportDetails() {
        var directive = {
            restrict: 'E',
            scope: {
                report: '=',
                entity: '='
            },
            templateUrl: 'regulatoryReports/reportDetails/reportDetailsDirective.html',

            controller: 'ReportDetailsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.reports:reportsList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'reportsList' directive is used to generate a list of reports
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-reports-list page-size="20"></aml-reports-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('aml.reports')
        .directive('amlReportsList', reportsList);

    /* @ngInject */
    function reportsList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'regulatoryReports/reportsList/reportsListDirective.html',

            controller: 'ReportsListDirectiveController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.riskAssessments')
        .directive('amlRiskClassifierList', amlRiskClassifierList);

    function amlRiskClassifierList() {
        var directive = {
            restrict: 'E',
            scope: {
                assessmentId: '='
            },
            templateUrl: 'riskAssessments/riskAssessmentDetails/riskClassifiersListDirective.html',

            controller: 'RiskClassifiersController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.scenario')
        .directive('amlHeaderList', headerList);

    function headerList() {
        var directive = {
            scope: {
            },
            restrict: 'E',
            templateUrl: 'scenarios/headerList/headerListDirective.html',
            controller: 'HeaderListDirectiveController',
            controllerAs: 'vm',
            bindToController: {
                //headers: '=*',
                loading: '@loading',
                showDeleted : '=',
                callback: '='
            }
        };
        return directive;
    }
})();
(function(){
    'use strict';

    headerName.$inject = ["_"];
    angular
        .module('aml.scenario')
        .directive('headerName', headerName);

    function headerName(_) {
        var directive = {
            restrict: 'A',
            require: 'ngModel',
            scope: {
                originalName: '=',
                headerNames: '=',
                newHeader: '=',
                errorVar: '='
            },
            link: function(scope, elem, attrs, ctrl) {
                ctrl.$validators.headerName = function(modelValue, viewValue) {

                    scope.errorVar = false;
                    if (ctrl.$isEmpty(modelValue)) {
                        return true;
                    }
                    //if the name has not changed still need to verify other headers
                    //because table does not have unique constraint
                    var match = _.where(scope.headerNames, {code: modelValue});
                    // new header name must be unique
                    if (scope.newHeader && match.length > 0) {
                        scope.errorVar = true;
                        return false;
                    }
                    // existing header name must be unique
                    if (!scope.newHeader) {
                        if (modelValue === scope.originalName) {
                            //if name has not changed then there must be only one match
                            scope.errorVar = (match.length !== 1);
                            return (match.length === 1);
                        }
                        //if name has changed then it cannot match any existing header
                        if (match.length > 0) {
                            scope.errorVar = true;
                            return false;
                        }
                    }
                    return true;
                };
            }
        };
        return directive;
    }
})();
/**
 * @ngdoc directive
 * @name    aml.riskAssessments:riskAssessmentsList
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'riskAssessmentsList' directive is used to generate a list of riskAssessments
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-risk-assessments-list page-size="20"></aml-risk-assessments-list>
 </pre>
 */
(function() {
    'use strict';

    angular
        .module('aml.riskAssessments')
        .directive('amlRiskAssessmentsList', amlRiskAssessmentsList);

    /* @ngInject */
    function amlRiskAssessmentsList() {

        var directive = {
            restrict: 'E',
            scope: {
                pageSize: '@',
                defaultSortColumn: '@',
                defaultSortDirection: '@'
            },
            templateUrl: 'riskAssessments/riskAssessmentsList/riskAssessmentsListDirective.html',

            controller: 'RiskAssessmentsListController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();
(function () {
    'use strict';

    scenarioName.$inject = ["_"];
    angular
        .module('aml.scenario')
        .directive('scenarioName', scenarioName);

    function scenarioName(_) {
        var directive = {
            restrict: 'A',
            require: 'ngModel',
            scope: {
                originalName: '=',
                scenarioNames: '=',
                newScenario: '=',
                errorVar: '='
            },
            link: function (scope, elem, attrs, ctrl) {
                ctrl.$validators.scenarioName = function (modelValue, viewValue) {

                    scope.errorVar = false;
                    if (ctrl.$isEmpty(modelValue)) {
                        return true;
                    }
                    //if the name has not changed still need to verify other scenarios
                    //because table does not have unique constraint
                    var match = _.where(scope.scenarioNames, {code: modelValue});
                    // new scenario name must be unique
                    if (scope.newScenario && match.length > 0) {
                        scope.errorVar = true;
                        return false;
                    }
                    // existing scenario name must be unique or match the original name
                    if (!scope.newScenario) {
                        if (modelValue === scope.originalName) {
                            // it is invalid situation if scenario names list is empty,
                            // but allow user to save scenario
                            if (!scope.scenarioNames || scope.scenarioNames.length === 0) {
                                return true;
                            }
                            //if name has not changed then there must be only one match
                            scope.errorVar = (match.length !== 1);
                            return (match.length === 1);
                        }
                        //if name has changed then it cannot match existing scenario
                        if (match.length > 0) {
                            scope.errorVar = true;
                            return false;
                        }
                    }
                    return true;
                };
            }
        };
        return directive;
    }
})();
(function(){
    'use strict';

    angular
        .module('aml.scenario')
        .directive('amlScenarioList', scenarioList);

    function scenarioList() {
        var directive = {
            scope: {
            },
            restrict: 'E',
            templateUrl: 'scenarios/scenarioList/scenarioListDirective.html',
            controller: 'ScenarioListDirectiveController',
            controllerAs: 'vm',
            bindToController: {
                scenarios: '=*',
                loading: '@loading',
                showDeleted : '=',
                callback: '='
            }
        };
        return directive;
    }
})();
/**
 * Created by dabock on 2/9/2016.
 */
(function(){
    'use strict';

    angular
        .module('aml.search')
        .directive('amlGlobalSearchButton', amlGlobalSearchButton);

    function amlGlobalSearchButton() {
        return {
            restrict: 'E',
            templateUrl: 'search/global/amlGlobalSearchButtonDirective.html',
            controller: 'AmlGlobalSearchButtonController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * Created by dabock on 2/9/2016.
 */
(function(){
    'use strict';

    angular
        .module('aml.search')
        .directive('amlGlobalSearchForm', amlGlobalSearchForm);

    function amlGlobalSearchForm() {
        return {
            restrict: 'E',
            templateUrl: 'search/global/amlGlobalSearchFormDirective.html',
            controller: 'AmlGlobalSearchFormController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * Created by shasho on 7/11/2017.
 */
(function() {
    'use strict';

    angular.module('aml.customer.details').directive('amlScenarioInfo', amlScenarioInfo);

    /*@ngInject*/
    function amlScenarioInfo() {
        return {
            restrict: 'E',
            scope: {
                scenarioObj: '='
            },
            templateUrl: 'scenarios/scenarioInfo/scenarioInfoDirective.html',
            /*@ngInject*/
            controller: ["resources", "usersService", "amlConstants", function(resources, usersService, amlConstants) {
                var vm = this;
                vm.resources = resources;
                vm.userScenarioAdmin = usersService.currentUserHasCapability( amlConstants.capabilities.accessScenarioAdmin );
            }],
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
///**
// * Created by omkulk on 3/30/2016.
// */
//
//(function(){
//    'use strict';
//
//    angular
//        .module('aml')
//        .directive('amlFundsTrackerForceNetwork', amlFundsTrackerForceNetwork);
//
//    function amlFundsTrackerForceNetwork() {
//
//        var directive = {
//            restrict: 'E',
//            scope: {},
//            templateUrl: 'networks/fundsTrackerForceNetwork/fundstrackerForceNetworkDirective.html',
//
//            controller: 'FundsTrackerForceNetworkController',
//            controllerAs: 'vm',
//            bindToController: { accountNumber: '=',
//                entityLevelCode: '=',
//                entityId: '=',
//                grpBy: '=',
//                gClass: '=',
//                aggTitle: '=',
//                params: '='} // because the scope is isolated
//
//        };
//        return directive;
//    }
//})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlFundsTrackerTransactionList', amlAlertsList);

    function amlAlertsList() {
        var directive = {
            restrict: 'E',
            scope:{},
            templateUrl: 'networks/transactionTable/fundsTrackerTransactionListDirective.html',

            controller: 'fundsTrackerTransactionListController',
            controllerAs: 'vmg',
            bindToController:{
                accountNumber:'=',

                idPrefix: '@', // prefix to use for grid id so it's unique (if used multiple times in the application)
                updateOnEntityChanges: '=',
                listType: '=',
                params: '=',
                pageSize: '@'
            }
        };
        return directive;
    }
})();


(function(){
    'use strict';

    angular
        .module('aml.cases.details')
        .directive('amlCaseReportList', caseReportList);

    function caseReportList() {
        var directive = {
            restrict: 'E',
            scope: {
                caseid: '=',
                pageSize: '@'
            },
            templateUrl: 'cases/caseDetails/caseReports/caseReportListDirective.html',
            controller: 'CaseReportListController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.cases.details')
        .directive('amlCaseDetailsTriage', amlCaseDetailsTriage);

    function amlCaseDetailsTriage() {
        var directive = {
            restrict: 'E',
            require: ['^form'],
            scope: {
            },
            templateUrl: 'cases/caseDetails/triage/caseDetailsTriageDirective.html',
            controller: 'CaseDetailsTriageController',
            controllerAs: 'vm',
            link: function($scope, $element, $attrs, $ctrls) {
                $scope.formCtrl = $ctrls[0];
            },
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlCaseTriage', amlCaseTriage);

    function amlCaseTriage() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'cases/casesList/triage/caseTriageDirective.html',
            controller: 'CaseTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:editComment
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'customerList' directive is used to generate a list of customers
 *
 * @element ANY
 * @required on-click
 *
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .directive('amlEditComment', amlEditComment);

    /* @ngInject */
    function amlEditComment() {

        var directive = {
            restrict: 'E',
            templateUrl: 'core/comments/editComment/amlEditCommentDirective.html',
            controller: 'EditCommentDirectiveController',
            controllerAs: 'vm',
            scope:  {
                 //  the scope is isolated
                 objectId: '=',
                 objectTypeCode: '=',
                 commentsOptions: '=',
                 comment: '=',
                 addMode: '@',
                 onCommentAdd: '&'
             },
             bindToController: true
        };
        return directive;
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlAddress
 *
 * @restrict E
 *
 * @description
 * The 'amlAddress' directive is used to display an address.
 * It will displays a Map of the address in addition to the address details
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAddress', amlAddress);

    /* @ngInject */
    function amlAddress() {
        var directive = {
            restrict: 'E',
            scope: {
                address: '='
            },
            templateUrl: 'core/layout/address/addressDirective.html',

            controller: 'AddressController',
            controllerAs: 'vm',
            bindToController: true

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlAddressDisplay
 *
 * @restrict EA
 *
 * @description
 * The 'amlAddressDisplay' directive is used to display an address in a nicely-formatted multi-row standard
 * address display
 *   Address1
 *   Address2 (if available)
 *   City, State, Zip
 *   Country Code
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAddressDisplay', amlAddressDisplay);

    /* @ngInject */
    function amlAddressDisplay() {
        var directive = {
            restrict: 'EA',
            scope: {
                address: '='
            },
            templateUrl: 'core/layout/address/addressDisplayDirective.html',

            controller: 'AddressDisplayController',
            controllerAs: 'vm',
            bindToController: true

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlGridActions
 *
 * @description
 * The amlGridActions will add a menu button with a list of user-selectable grid-related actions, such as
 * 'Clear sort and filters'.  Additional customActions can be supplied for actions pertaining only to a
 * specific grid.
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlGridActions', amlGridActions);

    function amlGridActions() {
        var directive = {
            restrict: 'E',

            /*@ngInject*/
            controller: ["$scope", "resources", function($scope, resources){
                $scope.resources = resources;

                // if there's any hideActions, just remove them
                _.each( $scope.hideActions, function( actionId ) {
                    _.each( $scope.gridActions, function( gridAction ) {
                        if ( gridAction.id === actionId ) {
                            // hide it
                            gridAction.hidden = true;
                            //// remove it
                            //let index = _.indexOf( $scope.gridActions,  gridAction);
                            //$scope.gridActions.splice( index,  1);
                        }
                    });
                });
            }],
            scope: {
                gridActions: '=',
                hideActions: '=',
                customActions: '='
            },
            templateUrl: 'core/layout/grid/gridActionsDirective.html'

            // the custom actions are added directly in the template itself
/*            link : function(scope, element, attrs, model){
                var actions = scope.customActions;
                if ( actions ) {
                    var ul = $('ul', $(element));
                    _.each(scope.customActions, function (customAction, index) {
                        //ul.append( '<li><a href ng-click="' + customAction.action.name + '()">' + customAction.label + '</a></li>');
                        //ul.append( '<li><a href ng-click="{{ scope.customActions[0].action}}">' + customAction.label + '_TEST_' + '</a></li>');

                        // add this as a function on the controller scope
                        var customActionFunctionName = 'customAction' + index;
                        scope[customActionFunctionName] = customAction.action;

                        // add menu item for this action pointing to the custom function that we added
                        ul.append( '<li><a href ng-click="' + customActionFunctionName + '()">' + customAction.label + '</a></li>');
                    });
                }
            }*/

        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlGridFilterLabel
 *
 * @description
 * The amlGridFilterLabel will add a stylized display label showing the current selected filter(s) for a Grid.
 *
 * @example
 *  For a filter of scenarioType column with 'contains' operator and value 'Status', this directive will display
 *  an italicized value:
 *    Filtered by: Scenario Type contains 'Status'
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlGridFilterLabel', amlGridFilterLabel);

    function amlGridFilterLabel() {
        var directive = {
            restrict: 'E',

            /*@ngInject*/
            controller: ["$scope", "resources", function($scope, resources){
                $scope.resources = resources;
            }],
            scope: {
                filterString: '='
            },
            templateUrl: 'core/layout/grid/gridFilterLabelDirective.html'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlGridHeader
 *
 * @description
 * The amlGridHeader adds a header bar with a textual label and a grid actions menu with a list of user-selectable
 * grid-related actions, such as 'Clear sort and filters'.
 * Additional customActions can be supplied for actions pertaining only to a specific grid.
 *
 * The label text is retrieved from the body of the directive, so that custom ng-messages can be supplied.
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlGridHeader', amlGridHeader);

    function amlGridHeader() {
        var directive = {
            restrict: 'EA',

            /*@ngInject*/
            controller: function(){},
            controllerAs: 'vm',
            bindToController: true,
            transclude: true,
            scope: {
                gridActions: '=',
                hideActions: '=',
                customActions: '=',
                filterString: '='
            },
            templateUrl: 'core/layout/grid/gridHeaderDirective.html'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlCountdown
 *
 * @restrict E
 *
 * @description
 * The 'amlCountdown' directive displays a countdown component comprised of a color-coded circle
 * with the countdown text displayed within, along with an associated priority icon (High/Medium/Low).
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlCountdown', amlCountdown);

    function amlCountdown() {
        var directive = {
            restrict: 'E',
            scope: {
                'startdate': '=',
                'enddate': '=',
                'type': '='
            },
            templateUrl: 'core/layout/countdown/countdownDirective.html',
            controller: 'AMLCountdownController',
            controllerAs: 'vm',
            bindToController: true
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlMap
 *
 * @restrict E
 *
 * @description
 * The 'amlMap' directive is used to display a map widget for a given address.
 *
 * @element ANY
 * @required
 *
 */
(function() {
    'use strict';

    amlMapDirective.$inject = ["$timeout", "amlConstants", "resources"];
    angular
        .module('aml.core')
        .directive('amlMap', amlMapDirective);

    /* @ngInject */
    function amlMapDirective( $timeout, amlConstants, resources) {
        // References:  See:
        //http://nominatim.openstreetmap.org/search?format=json&limit=5&street=100%20sas%20campus%20dr%20
        //http://nominatim.openstreetmap.org/search?format=json&limit=5&street=100%20sas%20campus%20dr&city=cary&state=nc
        //http://wiki.openstreetmap.org/wiki/Nominatim#Parameters

        return {
            restrict: 'E',
            replace: false,
            controller: 'MapController',
            scope: {
                sngDisabled: '=',
                sngHeight: '=',
                sngWidth: '=',
                sngFeatures: '=',
                sngOptions: '=',
                sngTileProviderUrl: '=',
                onFeatureClicked: '&',
                status: '='
            },
            link: function (scope, iElement, attrs) {

                var defaultCentrePoint,
                    defaultZoom,
                    mapContainer,
                    leafletMap,
                    createMap = function (element) {

                        mapContainer = $('<div/>');
                        element.append(mapContainer);

                        if (scope.sngOptions) {
                            defaultCentrePoint = scope.sngOptions.center;
                            defaultZoom = scope.sngOptions.zoom;

                            // we'll add our own zoomControl for localization
                            scope.sngOptions.zoomControl = false;

                            leafletMap = L.map(mapContainer[0], scope.sngOptions);

                        } else {
                            var defaultOptions = {
                                zoomControl: false // we'll add our own zoomControl for localization
                            };
                            leafletMap = L.map(mapContainer[0], defaultOptions);
                        }
                        // add zoom control with localized tooltips
                        leafletMap.addControl(L.control.zoom({
                            zoomInTitle : resources.aml.map.zoomInTitle,
                            zoomOutTitle: resources.aml.map.zoomOutTitle})
                        );

                        if (scope.sngTileProviderUrl) {
                            L.tileLayer(scope.sngTileProviderUrl, {
                                attribution: amlConstants.config.map.mapTileProviderAttribution,
                                maxZoom: amlConstants.config.map.mapTileProviderMaxZoom
                            }).addTo(leafletMap);
                        }

                        if (defaultCentrePoint && defaultZoom) {
                            leafletMap.setView(defaultCentrePoint, defaultZoom);
                        }

                        scope.leafletMap = leafletMap;
                        return leafletMap;

                    },
                    disableInteraction = function (map, isDisabled) {
                        if (isDisabled) {
                            map.dragging.disable();
                            map.touchZoom.disable();
                            map.doubleClickZoom.disable();
                            map.scrollWheelZoom.disable();
                            map.boxZoom.disable();
                            map.keyboard.disable();
                        } else {
                            map.dragging.enable();
                            map.touchZoom.enable();
                            map.doubleClickZoom.enable();
                            map.scrollWheelZoom.enable();
                            map.boxZoom.enable();
                            map.keyboard.enable();
                        }
                        map.setZoom();
                    };

                // setup map
                leafletMap = createMap(iElement);

                $timeout(function() {
                    leafletMap.invalidateSize();
                });

                scope.$watch('sngHeight', function (height) {
                    mapContainer.css('height', height);
                    leafletMap.invalidateSize();
                });
                scope.$watch('sngWidth', function (width) {
                    mapContainer.css('width', width);
                    leafletMap.invalidateSize();
                });
                scope.$watch('sngOptions.center', function (newCenter) {
                    if ( newCenter ) {
                        leafletMap.setView(newCenter, defaultZoom);
                        var markerIcon = L.icon({
                            iconUrl: 'images/marker-icon.png',
                            iconSize: [14, 25]
                            //,
                            // iconAnchor: [14, 36]
                        });
                        var marker = L.marker(newCenter, {icon: markerIcon});
                        if ( scope.sngOptions.address ) {
                            var address = '';
                            if ( scope.sngOptions.address.street ) {
                                address = scope.sngOptions.address.street + '<br/>';
                            }
                            if ( scope.sngOptions.address.city ) {
                                address += scope.sngOptions.address.city + '<br/>';
                            }
                            if ( scope.sngOptions.address.state ) {
                                address += scope.sngOptions.address.state;
                            }
                            marker.bindPopup(address).openPopup();
                        }

                        marker.addTo(leafletMap);
                    }
                });

                // bind the popup content
                var bindPopup = function (feature, layer) {
                    if (attrs.onFeatureClicked) {
                        layer.bindPopup(scope.onFeatureClicked());
                    }
                };

                var setMarkerIcon = function(feature, latlng) {
                    var markerIcon = L.icon({
                        iconUrl: feature.properties.iconUrl,
                        iconSize: [29, 38],
                        iconAnchor: [14, 36]
                    });

                    return L.marker(latlng, {icon: markerIcon});
                };

                var featuresLayer;

                scope.$watchCollection('sngOptions', function (features) {
                    if (features && features.length > 0) {
                        //if (scope.sngOptions) {
                        //    defaultCentrePoint = scope.sngOptions.center;
                        //    defaultZoom = scope.sngOptions.zoom;
                        //    leafletMap = L.map(mapContainer[0], scope.sngOptions);
                        //} else {
                        //    leafletMap = L.map(mapContainer[0]);
                        //}
                        //
                        //if (scope.sngTileProviderUrl) {
                        //    L.tileLayer(scope.sngTileProviderUrl).addTo(leafletMap);
                        //}

                        if (defaultCentrePoint && defaultZoom) {
                            leafletMap.setView(defaultCentrePoint, defaultZoom);
                        }
                    }
                });

                scope.$watchCollection('sngFeatures', function (features) {
                    if (features && features.length > 0) {

                        if(featuresLayer) {
                            leafletMap.removeLayer(featuresLayer);
                        }

                        featuresLayer = L.geoJson(null, { pointToLayer: setMarkerIcon, onEachFeature: bindPopup });

                        angular.forEach(features, function (feature) {
                            featuresLayer.addData(feature);
                        });

                        leafletMap.addLayer(featuresLayer);

                        leafletMap.fitBounds(featuresLayer.getBounds());

                        $timeout(function() {
                            leafletMap.invalidateSize();
                        });
                    }
                });

                scope.$watch('sngDisabled', function (isDisabled) {
                    disableInteraction(leafletMap, isDisabled);
                });
            }
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlNav
 *
 * @restrict E
 *
 * @description
 * The 'amlNav' directive adds a general top-level AML navbar at the top of the page.
 * This navbar contains the AML title and page sub-title, as well as provides the general
 * application button bar for Help and User actions.
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlNav', amlNav);

    function amlNav() {
        var directive = {
            restrict: 'E',
            scope: {
                navSubTitle: '='
            },
            templateUrl: 'core/layout/navbar/amlNavDirective.html',
            controller: 'AMLNavController',
            controllerAs: 'vm',
            bindToController: true
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlSection
 *
 * @restrict E
 *
 * @description
 * The 'amlSection' directive creates a collapsible section using the specified title in the collapsible
 * header
 * Set 'deferredLoad' to true to allow a collapsed section to not load until the section is opened (can be used as
 * a performance optimization)
 *
 * @element ANY
 * @required att: title - the title to use for the section which will appear in the collapsible section header
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlSection', amlSection);

    /* @ngInject */
    function amlSection() {
        var directive = {
            restrict: 'E',
            scope: {
                'updateableTitle': '=',
                'defaultCollapsed': '=collapsed',
                'deferredLoad': '@',
                'sectionTitle': '=',
                'hideErrors': '@'
            },
            /*@ngInject*/
            controller: ["$timeout", "$scope", function( $timeout, $scope){
                // convert string attribute to boolean for use in directive's html
                if ( $scope.deferredLoad === 'true') {
                    $scope.isDeferredLoad = true;
                }
                else {
                    $scope.isDeferredLoad = false;
                }

                $scope.$on('amlErrorBubble', function(evt, args) {
                    //Start with no error
                    $scope.sectionError = false;
                    if (!args.isValid) {
                        //Turn on error
                        if (!$scope.hideErrors) {
                            $scope.sectionError = true;
                        }
                        evt.stopPropagation();
                    }
                });

                // if section is initially collapsed, we hide the section content initially to avoid render flicker;
                // in this case, we set a timeout to remove the initialCollapsed flag which is used by
                // ng-hide.  Otherwise the first time you uncollapse and show at the same time, the uncollapse animation
                // is jittery. So we unhide briefly after the page is rendered.
                if ( $scope.defaultCollapsed ) {
                    $timeout(function () {
                        $scope.initialCollapsed = false;
                    }, 1);
                }
            }],
            transclude: true,
            templateUrl: 'core/layout/section/amlSectionDirective.html',

            link: function( scope, elem, attrs, $timeout ){
                scope.title = scope.sectionTitle || attrs.title;

                if ( scope.defaultCollapsed ) {
                    scope.collapsed = scope.defaultCollapsed;
                    // need ng-hide initially if the component defaults to closed;
                    // otherwise the content renders briefly before it's collapsed
                    scope.initialCollapsed = scope.defaultCollapsed;
                }

                // Toggle the open/closed state and save it away
                scope.toggleCollapsed = function() {
                    scope.collapsed = !scope.collapsed;
                    scope.initialCollapsed = false;
                    scope.isDeferredLoad = false;
                };
            }
        };
        return directive;
    }
})();

/**
 * Created by dabock on 1/7/2016.
 */

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlKendoSearchResults', amlKendoSearchResults);

    function amlKendoSearchResults() {
        return {
            restrict: 'E',
            scope: {
                pluralizeCount: '=',
                pluralizeWhen: '=',
                gridActions: '=',
                customActions: '=',
                scopeField: '=',
                options: '=',
                columns: '='
            },
            templateUrl: 'core/layout/searchResults/amlKendoSearchResultsDirective.html',
            controller: 'AmlKendoSearchResultsController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlScore
 *
 * @restrict E
 *
 * @description
 * The 'amlScore' directive displays a score component comprised of a color-coded circle
 * with the score text displayed within, along with an associated priority icon (High/Medium/Low).
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlScore', amlScore);

    function amlScore() {
        var directive = {
            restrict: 'E',
            scope: {
                'priority': '=',
                'score': '='
            },
            templateUrl: 'core/layout/score/scoreDirective.html',
            controller: 'AMLScoreController',
            controllerAs: 'vm',
            bindToController: true,
            link: function (scope) {

                // when score attribute changes, update the other attributes dependent on
                // the score
                scope.$watchGroup(['vm.score', 'vm.priority'] ,
                    function (score) {
                        if (score) {
                            scope.vm.updateScore();
                        }
                    });
            }
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlTabbedUiView
 *
 * @restrict E
 *
 * @description
 * The 'amlTabbedUiView' directive adds a separate ui-view div for each named-view state defined as a tabObject,
 * and sets a ng-show to display it only if the corresponding state is active. To make use of the 'sticky' states,
 * state views must be used, which is why we use views for most of our states.
 *
 * @element ANY
 * @required
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTabbedUiView', amlTabbedUiView);

    function amlTabbedUiView() {
        var directive = {
            templateUrl: 'core/state/tabbedState/amlTabbedUiViewDirective.html',
            controller: 'AMLTabbedUIViewController',
            controllerAs: 'vm',
            bindToController: true, // because the scope is isolated
            scope: {
               parentState: '='  // the parent state to load children ui-views for
            }
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlTabAreaNavigation
 *
 * @restrict E
 *
 * @description
 *  The amlTabAreaNavigation directive is used to display selectable nested tabbed areas, based on the
 * current user's capabilities
 *
 * @element ANY
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTabAreaNavigation', amlTabAreaNavigation);

    function amlTabAreaNavigation() {
        var directive = {
            restrict: 'E',
            scope: {
                parentState: '='  // the parent state to load children ui-views for
            },
            templateUrl: 'core/tabs/areaSubTabs/amlTabAreaNavigationDirective.html',
            controller: 'TabAreaNavigationController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlAreaNavigation
 *
 * @restrict E
 *
 * @description
 *  The amlAreaNavigation directive is used to display selectable tabbed functional areas, based on the
 * current user's capabilities
 *
 * @element ANY
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlAreaNavigation', amlAreaNavigation);

    function amlAreaNavigation() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'core/tabs/areas/amlAreaNavigationDirective.html',
            controller: 'AreaNavigationController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlTabsList
 *
 * @restrict E
 *
 * @description
 * The 'amlTabsList' directive displays a list of object tabs for each state that defines itself as a tab
 *
 * @element ANY
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTabsList', amlTabsList);

    function amlTabsList() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'core/tabs/objectTabs/tabsListDirective.html',
            controller: 'TabsListController',
            controllerAs: 'vm',
            bindToController: true
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlTabsListOverview
 *
 * @restrict E
 *
 * @description
 * The 'amlTabsListOverview' directive displays an overview button showing a list of object tabs for each state
 * that defines itself as a tab
 *
 * @element ANY
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTabsListOverview', amlTabsList);

    function amlTabsList() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'core/tabs/objectTabs/tabsListOverviewDirective.html',
            controller: 'TabsListController',
            controllerAs: 'vm',
            bindToController: true
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlEddDetails', eddDetails);

    function eddDetails() {

        var directive = {
            restrict: 'E',
            scope:{},
            templateUrl: 'cddReviews/cddReviewDetails/eddDetails/eddDetailsDirective.html',

            controller: 'EddDetailsController',
            controllerAs: 'vm',
            bindToController:{
                reviewDetail: '=',
                currentCustomer: '=',
                overviewReadOnly: '=',
                readOnly: '=',
                forms: '=',
                validator: '=',
                eddDetails: '='
            }
        };
        return directive;
    }
})();


(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('kendocddGridChart', kendocddGridChart);

    function kendocddGridChart() {
        
        var directive = {
            restrict: 'E',
            scope:{},
            templateUrl: 'cddReviews/cddReviewDetails/gridChart/cddReviewsGridScoresChartDirective.html',
            
            controller: 'cddReviewGridScoresChartController',
            controllerAs: 'vm',
            bindToController:{
                accountNumber:'=',
                
                idPrefix: '@', // prefix to use for grid id so it's unique (if used multiple times in the application)
                updateOnEntityChanges: '=',
                listType: '=',
                params: '=',
                pageSize: '@'
            }
        };
        return directive;
    }
})();


(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlScores', cddReviewGridScores);

    function cddReviewGridScores() {
        var directive = {
            restrict: 'E',
            scope:{
                // review: '='
            },
            templateUrl: 'cddReviews/cddReviewDetails/gridScores/cddReviewGridScoresDirective.html',

            controller: 'cddReviewGridScoresController',
            controllerAs: 'vm',
            bindToController:{
                accountNumber:'=',
                review: '=',
                idPrefix: '@', // prefix to use for grid id so it's unique (if used multiple times in the application)
                updateOnEntityChanges: '=',
                listType: '=',
                params: '=',
                pageSize: '@'
            }
        };
        return directive;
    }
})();


(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('cddScoringHistory', cddScoringHistory);

    function cddScoringHistory() {
        var directive = {
            restrict: 'E',
            scope:{
            },
            templateUrl: 'cddReviews/cddReviewDetails/scoringHistory/cddScoringHistoryDirective.html',

            controller: 'cddScoringHistoryController',
            controllerAs: 'vm',
            bindToController:{
                partyNumber:'=',
                idPrefix: '@', // prefix to use for grid id so it's unique (if used multiple times in the application)
                listType: '=',
                params: '=',
                pageSize: '@'
            }
        };
        return directive;
    }
})();


(function(){
    'use strict';

    angular
        .module('cdd.reviews')
        .directive('amlReviewTriage', amlReviewTriage);

    function amlReviewTriage() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'cddReviews/reviewsList/triage/reviewTriageDirective.html',
            controller: 'ReviewTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlCustomerDetails', amlCustomerDetails);

    /* @ngInject */
    function amlCustomerDetails() {
        var directive = {
            restrict: 'E',
            scope: {
                customer: '='
            },
            templateUrl: 'entities/customers/customerDetails/customerDetailsDirective.html',

            controller: 'CustomerDetailsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by fikhas on 1/23/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.customer.details')
        .directive('amlEntitySummary', amlEntitySummary);


    /* @ngInject */
    function amlEntitySummary() {
        var directive = {
            restrict: 'E',
            scope: {
                entity: '='
            },
            /*@ngInject*/
            controller: ["$scope", "resources", function($scope, resources){
                var vm = this;
                vm.resources = resources;
            }],
            controllerAs: 'vm',
            templateUrl: 'entities/entitiesList/summary/entitySummaryDirective.html',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlEntityTriage', amlEntityTriage);

    function amlEntityTriage() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'entities/entitiesList/triage/entitiesTriageDirective.html',
            controller: 'EntityTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.reports.details')
        .directive('amlSarFormBranches', amlSARFormBranches);

    /* @ngInject */
    function amlSARFormBranches() {
        var directive = {
            restrict: 'E',
            scope: {
                branchList : '=',
                institution :  '=', //SARX only
                report : '=',
                formTypeKey : '='
            },
            templateUrl: 'regulatoryReports/reportDetails/forms/SARFormGenericTableDirective.html',

            controller: 'SARFormBranchesController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.reports.details')
        .directive('amlSarFormSubjects', amlSARFormSubjects);

    /* @ngInject */
    function amlSARFormSubjects() {
        var directive = {
            restrict: 'E',
            scope: {
                report: '=',
                formTypeKey: '='
            },
            templateUrl: 'regulatoryReports/reportDetails/forms/SARFormGenericTableDirective.html',

            controller: 'SARFormSubjectsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

/**
 * Created by sasrns on 9/2/2015.
 */
(function(){
    'use strict';

    angular
        .module('aml.reports.details')
        .directive('amlSarxFormSubjects', amlSARXFormSubjects);

    /* @ngInject */
    function amlSARXFormSubjects() {
        var directive = {
            restrict: 'E',
            scope: {
                report: '=',
                formTypeKey: '=',
                reportInstitutions: '='
            },
            templateUrl: 'regulatoryReports/reportDetails/forms/SARXFormSubjectsDirective.html',

            controller: 'SARXFormSubjectsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.reports.details')
        .directive('amlReportDetailsTriage', amlReportDetailsTriage);

    function amlReportDetailsTriage() {
        var directive = {
            restrict: 'E',
            require: ['^form'],
            scope: {
            },
            templateUrl: 'regulatoryReports/reportDetails/triage/reportDetailsTriageDirective.html',
            controller: 'ReportDetailsTriageController',
            controllerAs: 'vm',
            bindToController: true, // because the scope is isolated
            link: function($scope, $element, $attrs, $ctrls) {
                $scope.formCtrl = $ctrls[0];
            }
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlReportTriage', amlReportTriage);

    function amlReportTriage() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'regulatoryReports/reportsList/triage/reportTriageDirective.html',
            controller: 'ReportTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.riskAssessments')
        .directive('amlRiskAssessmentTriage', amlRiskAssessmentTriage);

    function amlRiskAssessmentTriage() {
        var directive = {
            restrict: 'E',
            scope: {
                riskAssessmentStatus : '=',
                riskAssessment: '='
            },
            link: function(scope, elem, attrs, ctrl){
                scope.$watch('vm.riskAssessment' , function(n,o){
                    ctrl.updateButtonsVisibility();
                });
            },
            templateUrl: 'riskAssessments/riskAssessmentDetails/triage/riskAssessmentTriageDirective.html',
            controller: 'RiskAssessmentTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlRiskAssessmentsListTriage', amlRiskAssessmentsListTriage);

    function amlRiskAssessmentsListTriage() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'riskAssessments/riskAssessmentsList/triage/riskAssessmentsListTriageDirective.html',
            controller: 'RiskAssessmentsListTriageController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();

/**
 * Created by dabock on 3/24/2016.
 */
(function(){
    'use strict';

    angular
        .module('aml.search')
        .directive('amlGlobalSearchResult', amlGlobalSearchResult);

    function amlGlobalSearchResult() {
        return {
            restrict: 'E',
            scope: {
                doc: '='
            },
            templateUrl: 'search/global/results/amlGlobalSearchResultDirective.html',
            controller: 'AmlGlobalSearchResultController',
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core.layout:amlCheckboxInput
 *
 * @description
 *
 */

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlCheckboxInput', amlCheckboxInput);

    /* @ngInject */
    function amlCheckboxInput() {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                required: '=',
                readonly: '=',
                trueValue: '@',
                falseValue: '@',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/checkbox/amlCheckboxInputDirective.html'
            ///* @ngInject */
            //controller: function ($scope, resources) {
            //    var vm = this;
            //    vm.resources = resources;
            //},
            //controllerAs: 'vm'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlCurrencyInput
 *
 * @description
 *
 */

(function() {
    'use strict';

    amlCurrencyInput.$inject = ["$compile"];
    angular
        .module('aml.core')
        .directive('amlCurrencyInput', amlCurrencyInput);

    /* @ngInject */
    function amlCurrencyInput($compile) {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                required: '=',
                maxLength: '=',
                minimum: '=',
                readonly: '=',
                autoFocus: '@',
                integerPlaces: '@',
                decimalPlaces: '@',
                regex: '=',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/currencyInput/amlCurrencyInputDirective.html',
            /* @ngInject */
            controller: ["$scope", "resources", function($scope, resources) {
                var vm = this;
                vm.resources = resources;
                vm.maxLengthMessage = vm.resources.aml.getResource('component.errorMaxLength');
                $scope.currencyRegex = generateCurrencyPattern($scope.integerPlaces, $scope.decimalPlaces);
            }],
            link: function(scop, elem, attrs) {
                if(angular.isDefined(attrs.setAutoFocus)) {
                    var inputElement = $(elem.find('input')[0]);
                    $(inputElement).attr('autofocus', '');
                }
            },
            controllerAs: 'vm'
        };

        return directive;
    }

    /**
     * @description Generates a regular expression to validate the input.
     * @param {number} nInteger Max number of integer places accepted.
     * @param {number} nDecimal Max number of decimal places accepted.
     * @return {RegExp} Regular Expression to match numeric input.
     */
    function generateCurrencyPattern(nInteger, nDecimal) {
        /*   /^(\d{0,x}(?:[\.,]\d{0,y})?)$/   */
        if(nInteger >= 0 && nDecimal >= 0) {
            var separatorPattern = '[\\.,]';
            var integerPattern = '\\d{0,' + nInteger + '}';
            var decimalPattern = '\\d{0,' + nDecimal + '}';

            var _re = '^(' + integerPattern + '(?:' + separatorPattern + decimalPattern + ')?)$';
            return new RegExp(_re);
        } else {
            // need inputs of at least 0
            return null;
        }
    }
})();
/**
 * Created by dabock on 10/19/2015.
 */

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlDateRange', amlDateRange);

    function amlDateRange() {
        return {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'core/layout/forms/dateRange/amlDateRangeDirective.html',
            controller: 'AmlDateRangeController',
            controllerAs: 'vm',
            bindToController: {
                label: '@',
                minModel: '=',
                maxModel: '=',
                minObj: '=',
                maxObj: '=',
                nameAndId: '@',
                noDirtyFlag: '@'
            }
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core.layout:amlDatePicker
 *
 * @description
 * The amlDatePicker directive encapsulates the Angular UI Bootstrap datepicker in order to
 * combine an input field and datepicker button (along with all the associated logic) into
 * a single encapsulated component.
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlDatePicker', amlDatePicker)
        .directive('dateRangeValidator', dateRangeValidator);

    /* @ngInject */
    function amlDatePicker() {
        var directive = {
            restrict: 'E',
            scope: {
            },
            templateUrl: 'core/layout/forms/datepicker/amlDatePickerDirective.html',
            controller: 'AmlDatePickerController',
            controllerAs: 'vm',
            bindToController: {
                calModel: '=',
                calModelType: '=',
                calModelRange: '=',
                calPlaceholder: '@',
                calNameAndId: '@',
                callback: '&',
                noDirtyFlag: '@'
            }
        };
        return directive;
    }

    //validating data range if date picker is used in aml-data-range directive
    //calModelType indicates what end of range current value represents,
    //if 'min' then it is From value, if 'max' then it is To value
    //calModelRange contains the value for the other range end if it was selected
    function dateRangeValidator () {
        return {
            restrict: 'A',
            require: ['^amlDatePicker', 'ngModel'],
            link: function(scope, element, attr, controllers) {
                var datePickerCtrl = controllers[0],
                    modelCtrl = controllers[1];
                modelCtrl.$validators.dateRange = function dateRangeValidator (value) {
                    if (datePickerCtrl.calModelType === 'min') {
                        if (value && datePickerCtrl.calModelRange) {
                            return value <= datePickerCtrl.calModelRange;
                        }
                    }
                    if (datePickerCtrl.calModelType === 'max') {
                        if (value && datePickerCtrl.calModelRange) {
                            return value >= datePickerCtrl.calModelRange;
                        }
                    }
                    return true;
                };
            }
        };
    }

})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlDatePicker2
 *
 * @description
 * The amlDatePicker2 directive encapsulates the Angular UI Bootstrap datepicker in order to
 * combine an input field and datepicker button (along with all the associated logic) into
 * a single encapsulated component.
 *
 * This version adds a label and some other attributes to make it more useful.
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlDatePicker2', amlDatePicker);

    /* @ngInject */
    function amlDatePicker() {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                placeholder: '@',
                nameAndId: '@',
                label: '@',
                required: '=',
                readonly: '=',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/datepicker/amlDatePicker2Directive.html',
            controller: 'AmlDatePicker2Controller',
            controllerAs: 'vm'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlNumber
 * Input
 *
 * @description
 *
 */

//TODO: need to add more error checking

(function(){
    'use strict';

    amlNumberInput.$inject = ["$compile"];
    angular
        .module('aml.core')
        .directive('amlNumberInput', amlNumberInput);

    /* @ngInject */
    function amlNumberInput($compile) {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                onChange: '=',
                required: '=',
                maxLength: '=',
                minimum: '=',
                readonly: '=',
                autoFocus: '@',
                errorOnTouch: '=',  // only add error styling once field is touched
                integerOnly: '=',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/numberInput/amlNumberInputDirective.html',
            /* @ngInject */
            controller: ["$scope", "resources", function ($scope, resources) {
                var vm = this;
                vm.resources = resources;
                if(vm.integerOnly) {
                    vm.pattern = /^\d*$/;
                }
            }],
            link: function( scope, elem, attrs ){
                // if auto-focus attribute is set, add autofocus to the input element.
                // Note: we use a separate attribute name on the directive ('set-autofocus', as if we use 'autofocus' it
                // seems to conflict and to not allow the actual input element to consistently retrieve autofocus.
                if ( angular.isDefined(attrs.setAutofocus) ) {
                    var inputElement = $(elem.find('input')[0]);
                    $(inputElement).attr('autofocus', '');
                }
            },

            controllerAs: 'vm',
            bindToController: true
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlDisplayOnly
 *
 * @description A way to display a label and field values with same consistent look & feel as other aml components
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlDisplayOnly', amlDisplayOnly);

    /* @ngInject */
    function amlDisplayOnly() {
        var directive = {
            restrict: 'E',
            scope: {
                label: '@',
                value: '@'
            },
            templateUrl: 'core/layout/forms/displayOnly/amlDisplayOnlyDirective.html'
        };
        return directive;
    }
})();

/**
 * Created by dabock on 10/28/2015.
 */

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlSubmitButton', amlSubmitButton);

    function amlSubmitButton() {
        return {
            restrict: 'E',
            scope: {
                formObj: '=',
                model: '='
            },
            templateUrl: 'core/layout/forms/submitButton/amlSubmitButtonDirective.html',

            /* @ngInject */
            controller: ["resources", function(resources) {
                var vm = this;
                vm.resources = resources;
                vm.resetButton = resetButton;

                function resetButton() {
                    for(var key in vm.model) {
                        if(Array.isArray(vm.model[key].value)) {
                            vm.model[key].value = [null, null];
                        }
                        else if(key !== 'docType') {
                            vm.model[key].value = '';
                        }
                    }
                }
            }],
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();
/**
 * Created by dabock on 10/12/2015.
 */
/**
 * @ngdoc directive
 * @name    aml.core.layout:amlTextInput
 *
 * @description
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlSelect', amlSelect);

    function amlSelect() {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                optionsArray: '='
            },
            templateUrl: 'core/layout/forms/select/amlSelectDirective.html'
        };
        return directive;
    }
})();

/**
 * Created by sasrns on 2/11/2016.
 */
/**
 * @ngdoc directive
 * @name    aml.core.layout:select
 *
 * @description
 *
 */

//TODO: Need to figure out how to pass in the select's options with the angular filter options
//TODO: e.g. item.key as item.value for item in vm.closeReasons | orderBy: 'value'

(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlSelect2', amlSelect);

    function amlSelect() {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                onChange: '=',
                required: '=',
                optionsArray: '=',
                readonly: '=',
                filter: '=',
                disableoptions: '=',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/select/amlSelect2Directive.html',

            /* @ngInject */
            controller: ["$scope", "resources", function ($scope, resources) {
                var vm = this;
                vm.resources = resources;
                vm.defaultOptionText = resources.aml.component.selectOptionDefault;
            }],
            controllerAs: 'vm'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlTextAreaInput
 *
 * @description
 *
 */

(function() {
    'use strict';

    amlTextAreaInput.$inject = ["$compile"];
    angular
        .module('aml.core')
        .directive('amlTextAreaInput', amlTextAreaInput);

    /* @ngInject */
    function amlTextAreaInput($compile) {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                required: '=',
                maxLength: '=',
                overviewReadOnly: '=',
                autoFocus: '@',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/textAreaInput/amlTextAreaInputDirective.html',
            /* @ngInject */
            controller: ["$scope", "resources", function($scope, resources) {
                var vm = this;
                vm.resources = resources;
                vm.maxLengthMessage = vm.resources.aml.getResource('component.errorMaxLength');
            }],
            link: function(scop, elem, attrs) {
                if(angular.isDefined(attrs.setAutoFocus)) {
                    var inputElement = $(elem.find('textarea')[0]);
                    $(inputElement).attr('autofocus', '');
                }
            },
            controllerAs: 'vm'
        };

        return directive;
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core.layout:amlTextInput
 *
 * @description
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlTextInput', amlTextInput);

    /* @ngInject */
    function amlTextInput() {
        var directive = {
            restrict: 'E',
            scope: {
                fieldModel: '=',
                fieldLabel: '@',
                fieldNameAndId: '@',
                noDirtyFlag: '@'
            },
            templateUrl: 'core/layout/forms/textInput/amlTextInputDirective.html'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core.layout:amlTextInput
 *
 * @description
 *
 */

//TODO: need to add more error checking for field length, min length, etc.

(function(){
    'use strict';

    amlTextInput.$inject = ["$compile"];
    angular
        .module('aml.core')
        .directive('amlTextInput2', amlTextInput);

    /* @ngInject */
    function amlTextInput($compile) {
        var directive = {
            restrict: 'E',
            scope: {
                model: '=',
                label: '@',
                nameAndId: '@',
                required: '=',
                maxLength: '=',
                readonly: '=',
                autoFocus: '@',
                errorOnTouch: '=',  // only add error styling once field is touched
                noDirtyFlag: '@',
                pattern: '@',
                patternMessage: '@',
                customValidations: '@',
                parseMessage: '@'
            },
            templateUrl: 'core/layout/forms/textInput/amlTextInput2Directive.html',
            /* @ngInject */
            controller: ["$scope", "resources", function ($scope, resources) {
                var vm = this;
                vm.resources = resources;
                vm.maxLengthMessage = vm.resources.aml.getResource('component.errorMaxLength');
            }],
            link: function( scope, elem, attrs ){
                // if auto-focus attribute is set, add autofocus to the input element.
                // Note: we use a separate attribute name on the directive ('set-autofocus', as if we use 'autofocus' it
                // seems to conflict and to not allow the actual input element to consistently retrieve autofocus.
                if ( angular.isDefined(attrs.setAutofocus) ) {
                    var inputElement = $(elem.find('input')[0]);
                    $(inputElement).attr('autofocus', '');
                }
            },

            controllerAs: 'vm'
        };
        return directive;
    }
})();

/**
 * @ngdoc directive
 * @name    aml.core:amlGrid

 * @description
 * The amlGrid handles adding a grid to a page; it is a wrapper over the kendo grid directive and handles common
 * handling and setup. It includes both the kendo grid and a grid header with default grid actions.
 * This directive also adds additional event handlers like the onDoubleClick function.
 *
 * @param {string} id an id for this grid
 * @param {any} grid specify this if you need a handle on the grid object
 * @param {Function} onDataLoad function called to retrieve data for the grid
 * @param {any} data existing data to use in the grid (instead of fetching via onDataLoad)
 * @param {Function} onDoubleClick double-click handler function
 * @param {Function} onChange row-select handler function
 * @param {Function} onDataSourceChange callback function called when a grid datasource event occurs, such as the
 *  grid's filters, sorts, or page size have changed.
 * @param {Function} onGridInitialized handler function called when the grid is finished initializing
 *  (but before any data is loaded)
 * @param {any[]} customGridActions list of custom grid actions to add to the grid actions menu
 * @param {string[]} hideGridActions list of grid action ids to exclude from the grid actions menu
 * @param {any[]} columns - list of grid columns for this grid
 * @param {any} options the grid options object for controlling behavior and appearance of the grid.
 *  Additional AML Grid options:
 *      remotePaging {boolean} - set true if using remote grid paging
 *      selectFirstRowOnLoad {boolean} - set true to pre-select the first row once the grid is loaded
 * @param {any} defaultPageSize the default page size selected on the grid pager initially
 * @param {boolean} useFullWidth boolean value; if set to true will style the grid to take up full width of screen
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlGrid', amlGrid);

    function amlGrid() {
        var directive = {
            restrict: 'E',
            transclude: true,
            scope: {
                id: '@',
                grid: '=',
                onDataLoad: '=',
                data: '=',
                onDoubleClick: '=',
                onChange: '=',
                onDataSourceChange: '=',
                onGridInitialized: '=',
                customGridActions: '=',
                hideGridActions: '=',
                columns: '=',
                options: '=',
                defaultPageSize: '=',
                useFullWidth: '@'
            },
            templateUrl: 'core/layout/grid/amlGrid/amlGridDirective.html',

            controller: 'AmlGridController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated

        };
        return directive;
    }
})();

(function() {
    'use strict';

    angular
        .module('aml.core')
        .filter('classifierFactColumn', function() {

            return function(columns, existingColumns, ownColumn) {
                var filteredColumns = [];

                var checkColumnExists = function(col) {
                    /* this === c */
                    /* I know. I'm a monster. */
                    /* jshint camelcase: false */
                    return this === col.rc_fact_column;
                };

                if(columns.length && existingColumns) {
                    /* filter out columns that are already used in the Risk Classifiers table */
                    columns.forEach(function(c) {
                        var exists = existingColumns.some(checkColumnExists, c); //add c to scope
                        if(!exists || c === ownColumn) {
                            filteredColumns.push(c);
                        }
                    });
                }

                return filteredColumns;
            };
        });
})();
/**
 * @ngdoc filter
 * @name    aml.core:baseCurrency
 *
 * @description
 * The 'baseCurrency' filter filters the value using the standard Angular 'currency' filter, but uses
 * the base currency symbol as stored in the AML preferences
 *
 * @example
 *  Input: 10003 --> $10,003
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .filter('baseCurrency', ["currencyFilter", "amlCoreUtils", function( currencyFilter, amlCoreUtils) {
            var baseCurrencySymbol = amlCoreUtils.getBaseCurrencySymbol();

            return function(input) {
                if ( input ) {
                    input = input || '';
                    return currencyFilter( input, baseCurrencySymbol, 2 );
                }
                else {
                    // if input is undefined, return that and not empty string, as that can break
                    // one-time binding
                    return input;
                }
            };
        }]);
})();
/**
 * @ngdoc filter
 * @name    aml.core:blankNA
 *
 * @description
 * The 'blankNA' filter will take an input and if it is empty (undefined, null, '') it will
 * default it to "n/a"
 *
 * @example
 *  Input: ''|null|undefined --> 'n/a'
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .filter('blankNA', ["resources", function(resources) {
            return function(input) {
                if ( !input ) {
                    return resources.aml.notApplicable;
                }
                else {
                    return input;
                }
            };
        }]);
})();
(function () {
    'use strict';
    //jshint latedef: false
    /**
     *   generic filter for message mappings - the message map name must be provided.
     * Called like:
     *   <div> {{vm.customerDetails.riskClassification | messageMap: 'riskClassification'}}</div>
     */
    angular
        .module('aml.core')
        .filter('messageMap', ["amlLov", function (amlLov) {
            //jshint latedef: false
            return function (input, messageMapName) {
                var map = amlLov[messageMapName];
                return filterMessageVal(input, map);
            };
        }])
        .filter('allCountriesStates', ["amlLov", function (amlLov) {
            return function (input, countryCode) {
                /*jshint maxcomplexity:15 */
                if (!countryCode) {
                    return filterMessageVal(input, amlLov.stateUSCode);
                } else {
                    if (countryCode === 'US') {
                        return filterMessageVal(input, amlLov.stateUSCode);
                    }
                    if (countryCode === 'MX') {
                        return filterMessageVal(input, amlLov.stateMXCode);
                    }
                    if (countryCode === 'CA') {
                        return filterMessageVal(input, amlLov.stateCACode);
                    }
                    if (countryCode === 'VI') {
                        return filterMessageVal(input, amlLov.stateVICode);
                    }
                    if (countryCode === 'AS') {
                        return filterMessageVal(input, amlLov.stateASCode);
                    }
                    if (countryCode === 'FM') {
                        return filterMessageVal(input, amlLov.stateFMCode);
                    }
                    if (countryCode === 'GU') {
                        return filterMessageVal(input, amlLov.stateGUCode);
                    }
                    if (countryCode === 'MH') {
                        return filterMessageVal(input, amlLov.stateMHCode);
                    }
                    if (countryCode === 'MP') {
                        return filterMessageVal(input, amlLov.stateMPCode);
                    }
                    if (countryCode === 'PR' || input === 'PR') {
                        return filterMessageVal(input, amlLov.statePRCode);
                    }
                    if (countryCode === 'PW') {
                        return filterMessageVal(input, amlLov.statePWCode);
                    }
                    return '';
                }
            };
        }])

    /**
     * specific filters - convenience over the generic messageMap filter where the message map
     * is already known and need not be specified.
     * Called like:
     * <div> {{vm.customerDetails.riskClassification | riskClassification}}</div>
     */
        .filter('alertStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.alertStatus);
        }])
        .filter('riskClassification', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.riskClassification);
        }])
        .filter('caseStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.caseStatus);
        }])
        // .filter('caseDisposition', function (amlLov) {
        //     return getFilterForMessageMap(amlLov.caseDisposition);
        // })
        .filter('reportStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.reportStatus);
        }])
        .filter('efileStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.efileStatus);
        }])
        .filter('manualAlertReason', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.manualAlertReason);
        }])
        .filter('alertCategory', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.alertCategory);
        }])
        .filter('commentCategory', ["amlLov", function (amlLov) {
        	return getFilterForMessageMap(amlLov.commentCategory);
        }])

        .filter('commentCategoryAll', ["amlLov", function (amlLov) {
        	var tempData = $.extend({}
        												,amlLov.commentCategory
        												, amlLov.commentCategoryCases
        												, amlLov.commentCategoryTriage
        												, amlLov.commentCategoryReport
        												, amlLov.commentCategoryCddreviews
        												, amlLov.commentCategoryCasesDel
        												);
        	return getFilterForMessageMap(tempData);
        }])
        
        .filter('commentCategoryCases', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.commentCategoryCases);
        }])
        .filter('commentCategoryTriage', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.commentCategoryTriage);
        }])
        .filter('commentCategoryReport', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.commentCategoryReport);
        }])
        .filter('commentCategoryCddreviews', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.commentCategoryCddreviews);
        }])
        
				.filter('commentCategoryCasesDel', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.commentCategoryCasesDel);
        }])
        
        .filter('priority', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.priority);
        }])
        .filter('yesOrNo', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.yesOrNo);
        }])
        .filter('caseCategory', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.caseCategory);
        }])
        .filter('caseSubcategory', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.caseSubcategory);
        }])
        .filter('alertLevel', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.alertLevel);
        }])
        .filter('scenarioStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.scenarioStatus);
        }])
        .filter('scenarioType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.scenarioType);
        }])
        .filter('scenarioParameterType', ["amlLov", function(amlLov) {
            return getFilterForMessageMap( amlLov.scenarioParameterType);
        }])
        .filter('productType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap( amlLov.productType);
        }])
        .filter('alertColumnUsageCode', ["amlLov", function(amlLov) {
            return getFilterForMessageMap( amlLov.alertColumnUsageCode);
        }])
        .filter('scenarioParameterType', ["amlLov", function(amlLov) {
            return getFilterForMessageMap( amlLov.scenarioParameterType);
        }])
        .filter('scenarioCategory', ["amlLov", function(amlLov) {
            return getFilterForMessageMap( amlLov.scenarioCategory);
        }])
        .filter('scenarioFrequency', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.scenarioFrequency);
        }])
        .filter('entityLevel', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.entityLevel);
        }])
        .filter('headerTypeCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.headerTypeCode);
        }])
        .filter('currencyCode', ["amlLov", "amlCoreUtils", function (amlLov, amlCoreUtils) {
            return amlCoreUtils.getBaseCurrencySymbol();
        }])
        .filter('riskAssessmentStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.riskAssessmentStatus);
        }])
        .filter('accountType', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.accountType);
        }])
        .filter('closeReason', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.closeReason);
        }])
        .filter('alertCloseReason', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.alertCloseReason);
        }])
        .filter('partyType', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.partyType);
        }])
        .filter('associationAttrCode', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.associationAttrCode);
        }])
        .filter('associationType', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.associationType);
        }])
        .filter('queueName', ["amlLov", "resources", function(amlLov, resources) {
            var messageMap = amlLov.queueName;
            return function (input, includeQueueCode) {
                if (input) {
                    var display = filterMessageVal(input, messageMap);
                    if (display !== input) {
                        if (includeQueueCode) {
                            return resources.aml.getResource('queue.queueNameTemplate', {queueCode: input, queueName:display});
                        } else {
                            return display;
                        }
                    } else {
                        return input;
                    }
                } else {
                        return '';
                }
            };
        }])
        .filter('auditEvent', ["amlLov", function(amlLov) {
            return getFilterForMessageMap(amlLov.auditEvent);
        }])

        //CDD
        .filter('scoreClassification', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.scoreClassification);
        }])
        .filter('reviewStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.reviewStatus);
        }])
        .filter('ruleStatus', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.ruleStatus);
        }])
        .filter('ruleType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.ruleType);
        }])
        .filter('ruleGroupCategory', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.ruleGroupCategory);
        }])
        .filter('ruleGroupType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.ruleGroupType);
        }])
        .filter('ruleParameterType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.ruleParameterType);
        }])
        .filter('cddCountry', ["amlLov", function (amlLov) {
            //country name lookup - uses three letter code
            return getFilterForMessageMap(amlLov.cddCountry);
        }])
        .filter('finalDisposition', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.finalDisposition);
        }])
        .filter('cddLegalEntityType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.cddLegalEntityType);
        }])
        .filter('cddIndustry', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.cddIndustry);
        }])
        .filter('cddOccupation', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.cddOccupation);
        }])
        .filter('cddProduct', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.cddProduct);
        }])

        //EDD
        .filter('eddStep', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.eddStep);
        }])

        //These are Regulatory Report related filters
        .filter('reportType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.reportType);
        }])
        .filter('reportTypeLong', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.reportTypeLong);
        }])
        .filter('taxIDType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.taxIDType);
        }])
        .filter('phoneTypeCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.phoneTypeCode);
        }])
        .filter('IDType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.IDType);
        }])
        .filter('federalRegulator', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.federalRegulator);
        }])
        .filter('federalRegulator2', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.federalRegulator2);
        }])
        .filter('institutionGamingType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.institutionGamingType);
        }])
        .filter('financialInstitutionIDType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.financialInstitutionIDType);
        }])
        .filter('financialInstitutionTINType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.financialInstitutionTINType);
        }])
        .filter('financialInstitutionType', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.financialInstitutionType);
        }])
        .filter('branchRoleCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.branchRoleCode);
        }])
        .filter('branchTypeCtrCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.branchTypeCtrCode);
        }])
        .filter('branchGamingTypeCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.branchGamingTypeCode);
        }])
        .filter('stateUSCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.stateUSCode);
        }])
        .filter('stateMXCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.stateMXCode);
        }])
        .filter('stateCACode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.stateCACode);
        }])
        .filter('countryCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.countryCode);
        }])
        .filter('caseEntityLevel', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.caseEntityLevel);
        }])
        .filter('metric', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.metric);
        }])
        .filter('cyberEventTypeCode', ["amlLov", function (amlLov) {
            return getFilterForMessageMap(amlLov.cyberEventTypeCode);
        }])
        .filter('localizedSegmentName', ["amlLov", function(amlLov) {
            /*
            This filter accepts an alphabetic code and returns a localized segment name. For the filter that accepts a
            numeric segment ID and returns a localized segment name, see: segmentName.
             */
            return getFilterForMessageMap(amlLov.segmentName);
        }])
    ;


    /**
     * given a message map and a key, return the corresponding localized string value
     * @param key
     * @param messageMap
     * @returns {*}
     */
    var filterMessageVal = function (key, messageMap) {
        var filteredVal = messageMap[key];
        if (!filteredVal || !filteredVal.description) {
                return key;
        }
        return filteredVal.description;
    };

    /**
     * return a filter for a given specific message map
     * @param messageMap
     * @returns {Function}
     */
    var getFilterForMessageMap = function (messageMap) {
        return function (input) {
            return filterMessageVal(input, messageMap);
        };
    };

})();

/**
 * @ngdoc filter
 * @name    aml.core:blankNA
 *
 * @description
 * The 'nullNA' filter will take a string and if it is null set it to "n/a";
 * if it is undefined it will leave the value undefined; thus, this filter can
 * be used for one-time bindings where the value is set in a deferred manner,
 * provided the value is set to null once it resolves.
 *
 * @example
 *  Input: null --> 'n/a'
 */
(function() {
    'use strict';

    angular
        .module('aml.core')
        .filter('nullNA', ["resources", function(resources) {
            return function(input) {
                if ( input === null ) {
                    return resources.aml.notApplicable;
                }
                else {
                    return input;
                }
            };
        }]);
})();
/**
 * Created by dabock on 5/11/2016.
 */
/**
 * @ngdoc filter
 * @name    aml.core:sentenceCase
 *
 * @description
 * The 'sentenceCase' filter will capitalize the first letter of a string
 * and make the remaining letters lowercase.
 *
 * @example
 *  Input: THIS IS THE EXAMPLE. --> This is the example.
 */
(function() {
    'use strict';

    angular
        .module('aml')
        .filter('sentenceCase', ["amlConstants", function(amlConstants) {
            return function(input) {
                // if option set to ignore nice casing, then just return default value
                if ( input && !amlConstants.config.ignoreNiceCasing ) {
                    return input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
                }
                else {
                    return input;
                }
            };
        }]);
})();
/**
 * @ngdoc filter
 * @name    aml.core:titleCase
 *
 * @description
 * The 'titleCase' filter will take a string and capitalize the first letter of each separate word (a word is
 * considered separated by whitespace)
 *
 * @example
 *  Input: MICHAEL J. FOX --> Michael J. Fox
 */
(function() {
    'use strict';

    angular
        .module('aml')
        .filter('titleCase', ["amlConstants", function(amlConstants) {
            return function(input) {
                // if option set to ignore nice caseing, then just return default value
                if ( input && !amlConstants.config.ignoreNiceCasing ) {
                    input = input || '';
                    if ( !input.replace ) { // if this isn't a string type, just return value
                        return input;
                    }
                    return input.replace(/\w\S*/g, function(txt) {
                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                    });
                }
                else {
                    // if input is undefined, return that and not empty string, as that can break
                    // one-time binding
                    return input;
                }
            };
        }]);
})();
/**
 * Created by dabock on 3/20/2018.
 */
/*

Take a user ID and turns it into a user name.
install -> SAS Install User

 */
(function() {
    'use strict';

    angular
        .module('aml')
        .filter('userName', ["usersService", "resources", function(usersService, resources) {
            var userNames = usersService.getUserNames();

            return function(input, includeUserId) {
                var user = userNames.find(function(item) {
                    return item.userId === input;
                });

                if(!user) {
                    // User was not found in list - display userid only
                    return input;
                }
                else if(includeUserId) {
                    // Display as userid space username - probably for a grid

                    var display = user.userName;
                    return resources.aml.getResource('userNameTemplate', {userId: input, userName:display});
                }
                else {
                    // Display just the name - probably for a detail page
                    return user.userName;
                }
            };
        }]);
})();
/**
 * @ngdoc filter
 * @name    aml.core:phoneNumber
 *
 * @description takes a 10, 11, or 12-digit phone number and returns it in standard
 * phone number notation
 *
 * @example 11234567890 -> 1 (123) 456-7890
 */
(function() {
    'use strict';

    angular.module('aml.core').filter('phoneNumber', function () {
        return function (telephoneNumber) {
            if (!telephoneNumber) { return telephoneNumber; }

            var value = telephoneNumber.toString().trim().replace(/^\+/, '');

            if (value.match(/[^0-9]/)) {
                return telephoneNumber;
            }

            var country, city, number;

            switch (value.length) {
                case 10: // +1PPP####### -> C (PPP) ###-####
                    country = 1;
                    city = value.slice(0, 3);
                    number = value.slice(3);
                    break;

                case 11: // +CPPP####### -> CCC (PP) ###-####
                    country = value[0];
                    city = value.slice(1, 4);
                    number = value.slice(4);
                    break;

                case 12: // +CCCPP####### -> CCC (PP) ###-####
                    country = value.slice(0, 3);
                    city = value.slice(3, 5);
                    number = value.slice(5);
                    break;

                default:
                    return telephoneNumber;
            }

            if (country === 1) {
                country = '';
            }

            number = number.slice(0, 3) + '-' + number.slice(3);

            return (country + ' (' + city + ') ' + number).trim();
        };
    });
})();
/**
 * @ngdoc service
 * @name     aml.admin:adminService
 *
 * @restrict E
 *
 * @description
 * The admin service is used to perform administrative functions, such as retrieving logs and clearing caches
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    adminService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "amlConstants", "$window", "$timeout", "messageService", "resources", "amlPreferencesService", "tabsListService"];
    angular
        .module('aml.admin')
        .factory('adminService', adminService);

    /* @ngInject */
    /* jshint maxparams: 11 */
    function adminService($resource, amlConfig, _, exceptionResourceHandler, amlConstants, $window,
        $timeout, messageService, resources, amlPreferencesService, tabsListService) {

        /**
         * Resources
         */
        var logsResource = $resource(amlConfig.baseUrl + '/admin/logs',
            {}, { get: {
                method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var clearCacheResource = $resource(amlConfig.baseUrl + '/admin/clearCache',
            {}, { doAction: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });


        var service = {
            clearLocalClientCache: clearLocalClientCache,
            clearCache: clearCache,
            getLogs: getLogs,
            refreshPageWithMessage: refreshPageWithMessage,
            setBusinessUnit: setBusinessUnit

        };

        return service;

        /////////////////////

        function setBusinessUnit( businessUnit ) {
            // if we're on an entity tab, we'll close all of the object tabs as these entities/states likely would not
            // exist on another business unit and we don't want to refresh the page
            tabsListService.closeAllTabs();

            // save business unit to local storage
            amlPreferencesService.setLocalPreference(
                amlConstants.preferences.selectedBusinessUnit,  businessUnit );

            // clear sessionstorage to remove any old business-unit specific caches, like lov/preferences
            clearLocalClientCache();

            // reload the page
            refreshPageWithMessage( resources.aml.getResource('navbar.businessUnitSetMessage',
                {businessUnit: businessUnit} ) );
        }

        function refreshPageWithMessage( msg ) {
            messageService.success( msg +
                    '<br>' +
                    resources.aml.navbar.reloadingPageMessage +
                    // add spinner
                    '<br><span class="sas-icon sas-icon-refresh sas-icon-spin-backwards"></span>',
                null, 4000);

            // after clearing cache need to reload the entire page/application in order for the app to reload
            // resources that were cached.
            // Use dealay to give a chance to display the message
            reloadApplicationPageWithDelay();
        }


        /**
         * Clear browser session storage for any aml objects
         *
         * @returns {$promise|*}
         */
        function clearLocalStorage() {
            // clear sessionstorage
            if ( sessionStorage ) {
                angular.forEach(sessionStorage, function (val, key) {
                    if ( key.indexOf( amlConstants.resourceComponent + '/' ) === 0 ) {
                        sessionStorage.removeItem( key );
                    }
                });
            }
        }

        /**
         * Get a list of all server logs
         *
         * @returns {$promise|*}
         */
        function getLogs() {
            return logsResource.get().$promise;
        }
        /**
         * Reload/refresh the page with a delay
         */
        function reloadApplicationPageWithDelay() {
            // Use timeout to give a chance to display the message
            $timeout( function() {
                $window.location.reload();
            }, 3000 );
        }


        /**
         * Clear local caches and server caches
         *
         * @returns {$promise|*}
         */
        function clearCache() {
            // clear sessionstorage
            clearLocalClientCache();

            // call server-side clearCache
            return clearCacheResource.doAction({}).$promise;
        }

        function clearLocalClientCache() {
            // clear sessionstorage
            clearLocalStorage();
        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.customer:alertsService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve customers
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    alertsService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "$state", "amlConstants"];
    angular
        .module('aml.customer.details')
        .factory('alertsService', alertsService);

    /* @ngInject */
    function alertsService($resource, amlConfig, _, exceptionResourceHandler, $state, amlConstants) {

        /**
         * Resources
         */
        // alert should include scenario data, use relationships=scenario to get it
        var alertResource = $resource(amlConfig.baseUrl + '/alerts/:id?relationships=scenario',
            {
                id: '@id'
            }, { get: {
                method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });
            
        var alertResourceTemp = $resource(amlConfig.baseUrl + '/alerts/:id?relationships=scenario',
            {
                id: '@id',
                exttype:'@exttype'
            }, { get: {
                method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var triageAlertResource = $resource(amlConfig.baseUrl + '/alerts/:id/triageRequests/:action',
            {id: '@id'},
            {
                activate: {
                    params : {action: 'activate'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var triageAlertsResource = $resource(amlConfig.baseUrl + '/alerts/triageRequests/:action',
            {},
            {
                syncCaseAlerts: {
                    params : {action: 'caseAlerts'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }

            });
        var manualAlertResource = $resource(amlConfig.baseUrl + '/alerts',
            {
            },
            { create: {
                method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            }
        );

        var triageSupressAlertsResource = $resource(amlConfig.baseUrl + '/alerts/triageRequests/suppress',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });
        var triageCloseAlertsResource = $resource(amlConfig.baseUrl + '/alerts/triageRequests/close',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });
        var triageRouteAlertsResource = $resource(amlConfig.baseUrl + '/alerts/triageRequests/route',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });
        var currentSegmentResource = $resource(
            amlConfig.baseUrl + '/alerts/currentSegment/:code/:number',
            {
                code: '@code',
                number: '@number'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            }
        );

        var service = {
            getAlert: getAlert,
            getAlertTemp: getAlertTemp,
            suppressAlerts: suppressAlerts,
            closeAlerts: closeAlerts,
            routeAlerts: routeAlerts,
            navigateToAlert: navigateToAlert,
            createManualAlert: createManualAlert,
            activateAlert : activateAlert,
            removeFromCase : removeFromCase,
            getCurrentSegment: getCurrentSegment
        };

        return service;

        /////////////////////

        function getAlert(alertid) {
            return alertResource.get({
                id: alertid
            }).$promise;
        }
        
        function getAlertTemp(alertid, exttype) {
            return alertResourceTemp.get({
                id: alertid,
                exttype: exttype
            }).$promise;
        }

        function activateAlert(alertId, status) {
            var alertTriageParams = {
                alertIds: null,
                status: status
            };
            return triageAlertResource.activate({id: alertId}, alertTriageParams).$promise;
        }

        function removeFromCase(alertId) {
            var caseAlertTriageParameters = {
                removedAlertIds: [alertId]
            };
            return triageAlertsResource.syncCaseAlerts(caseAlertTriageParameters).$promise;
        }

        /**
         * Navigate to alert details screens for specified alertId
         * @param alertId
         */
        function navigateToAlert( alertId, alertLevel ) {
//console.log("&&&&&&&&&&&&&&&&&&& " + alertId);
            $state.go( 'alertDetails', { alertid: alertId, exttype: alertLevel });
        }

        /**
         * Suppress an array of alerts
         * @param alerts
         * @param suppressionEndDate
         * @param suppressionReason
         * @returns {$promise|*}
         */
        function suppressAlerts(alerts, suppressionEndDate, suppressionReason) {
            var alertIds = getAlertIds( alerts );

            var alertTriageParams = {
                alertIds: alertIds,
                suppressionEndDate: suppressionEndDate,
                closeReason: suppressionReason
            };

            return triageSupressAlertsResource.create({}, alertTriageParams).$promise;
        }


        /**
         * close an array of alerts
         * @param alerts
         * @param closeReason
         * @returns {$promise|*}
         */
        function closeAlerts(alerts, closeReason) {
            var alertIds = getAlertIds( alerts );
            var alertTriageParams = {
                alertIds: alertIds,
                closeReason: closeReason
            };

            return triageCloseAlertsResource.create({}, alertTriageParams).$promise;
        }

        /**
         * route an array of alerts
         * @param alerts
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeAlerts(alerts, routeToUser) {
            var alertIds = getAlertIds( alerts );
            var alertTriageParams = {
                alertIds: alertIds,
                ownerUserLongId: routeToUser
            };

            return triageRouteAlertsResource.create({}, alertTriageParams).$promise;
        }

        /**
         * Get array of alertIds from an array of alerts
         * @param alerts
         * @returns {Array}
         */
        function getAlertIds( alerts ) {
            var alertIds = _.pluck( alerts, 'alertId' );
            return alertIds;
        }


        function createManualAlert(manualAlert) {
            // update associated primaryKey/Number for the different alerted entities
            if ( manualAlert.alertLevel === amlConstants.entityType.externalParty ) {
                // for EXT, primary number/key is the EXT key
                manualAlert.alertedEntityLevelCode = manualAlert.alertLevel;
                manualAlert.alertedEntityNumber = manualAlert.primaryEntityNumber;
                manualAlert.alertedEntityKey = manualAlert.primaryEntityKey;
            }

            // four HHD/ACC alerts, the server will look up the associated "rolled-up" alerted
            // Party entity
            else if ( manualAlert.alertLevel === amlConstants.entityType.household ) {
                // server will look up primary rolled-up customer
                manualAlert.alertedEntityLevelCode = amlConstants.entityType.customer;
            }
            else if ( manualAlert.alertLevel === amlConstants.entityType.account ) {
                // server will look up primary rolled-up customer
                manualAlert.alertedEntityLevelCode = amlConstants.entityType.customer;
            }
            else {
                // for all other entities, they alerted number/key will match the primary number/key
                manualAlert.alertedEntityLevelCode = manualAlert.alertLevel;
                manualAlert.alertedEntityNumber = manualAlert.primaryEntityNumber;
                manualAlert.alertedEntityKey = manualAlert.primaryEntityKey;
            }
            return manualAlertResource.create({}, manualAlert).$promise;
        }

        function getCurrentSegment(alertLevel, primaryEntityNumber) {
            return currentSegmentResource.get({
                code: alertLevel,
                number: primaryEntityNumber
            }).$promise;
        }

    }
})();

/**
 * @ngdoc service
 * @name     cdd.rule:ruleService
 *
 * @restrict E
 *
 * @description
 * The rule service is used to retrieve rules from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    ruleService.$inject = ["$http", "$resource", "amlConfig", "amlConstants", "_", "exceptionResourceHandler"];
    angular
        .module('cdd.rule')
        .factory('ruleService', ruleService);

    /* @ngInject */
    function ruleService($http, $resource, amlConfig, amlConstants, _, exceptionResourceHandler) {
        var idSeq = 1;

        /**
         * Resources
         */
        var rulesResource = $resource(amlConfig.baseUrl + '/rules',
            {}, {
                get: {
                    url: amlConfig.baseUrl + '/rules/:id',
                    params: {id: '@id'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getAll: {
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getNondeleted: {
                    params: {'type' : 'NONDELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getDeleted: {
                    params: {'type' : 'DELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                changeId: {
                    url: amlConfig.baseUrl + '/rules?oldId=:oldId',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                //update handles 409 status code, so we do not want to display http error message
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });

        var rulesActionResource = $resource(amlConfig.baseUrl + '/rules/:id/actions/:action',
            {id: '@id'}, {
                delete: {
                    params : {action: 'delete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undelete: {
                    params : {action: 'undelete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                activate: {
                    params : {action: 'activate'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deactivate: {
                    params : {action: 'deactivate'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deleteMultiple: {
                    url: amlConfig.baseUrl + '/rules/actions/delete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undeleteMultiple: {
                    url: amlConfig.baseUrl + '/rules/actions/undelete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                activateMultiple: {
                    url: amlConfig.baseUrl + '/rules/actions/activate',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deactivateMultiple: {
                    url: amlConfig.baseUrl + '/rules/actions/deactivate',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                export: {
                    url: amlConfig.baseUrl + '/rules/actions/export',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                import: {
                    url: amlConfig.baseUrl + '/rules/actions/import',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                copy: {
                    url: amlConfig.baseUrl + '/rules/actions/copy',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                run: {
                    url: amlConfig.baseUrl + '/rules/actions/test',
                    method: 'POST',
                    cache : false,
                    headers: { 'Accept': 'text/html'},
                    transformResponse: parseHtml,
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });
        /**
         * We have a parseHtml function that just returns the data in a JSON object; otherwise ngResource
         * seems to want to parse it as JSON and returns ArrayBuffer.
         */
        function parseHtml(data, headersGetter) {
            return { data: data };
        }

        function getRules(showDeleted) {
            var rulesPromise;
            if (showDeleted) {
                rulesPromise = rulesResource.getDeleted({}).$promise;
            } else {
                rulesPromise = rulesResource.getNondeleted({}).$promise;
            }
            return rulesPromise.then(function (data) {
                if (data.items && idSeq < data.items.length) { idSeq = data.items.length; }
                return data;
            });
        }

        function getRule(ruleId) {
            return rulesResource.get({id: ruleId}).$promise;
        }

        function createNewRule(ruleIn) {
            return rulesResource.create(ruleIn).$promise;
        }

        function changeRuleId(rule, oldId) {
            return rulesResource.changeId({oldId: oldId}, rule).$promise;
        }

        function newRule(ruleName, ruleId) {
            var dateNow = new Date();
            var rule = {
                'ruleId': (ruleId && ruleId !== '' ? ruleId : 'CDDR_new_' + getNextId().toString()),
                'ruleTypeCode': 'ATTR',
                'currentInd': 'Y',
                'updateDate': dateNow,
                'createUserId': '',
                'createDate': dateNow,
                'ruleName': ruleName,
                'ruleDescription': '',
                'ruleStatusCode': 'ACT',
                'ruleSaveIdFlg': 'Y',
                'ruleOrderInGroup': 1,
                'version': 1,
                'ruleGroupId': 'none',
                'ruleGroupName': '',
                'source' : '',
                'logicalDeleteInd': 'N',
                'ruleGroupInputDsName' : 'none',
                'parms' : []
            };
            return rule;
        }

        function updateRule(ruleIn) {
            return rulesResource.update({}, ruleIn).$promise;
        }

        function getRuleNames(includeDeleted) {
            var rulesPromise;
            if (includeDeleted) {
                rulesPromise = rulesResource.getAll({}).$promise;
            } else {
                rulesPromise = rulesResource.getNondeleted({}).$promise;
            }
            return rulesPromise.then(function (data) {
                var rules = data.items;
                if (idSeq < rules.length) { idSeq = rules.length; }
                var ruleNames = [];
                for (var i = 0; i < rules.length; i++) {
                    ruleNames.push({code: rules[i].ruleName, value: rules[i].ruleName});
                }

                ruleNames = _.sortBy(ruleNames, function (rule) {
                    return rule.value.toLowerCase();
                });
                return ruleNames;
            });
        }

        function markRuleAsDeleted(ruleId) {
            return rulesActionResource.delete({id: ruleId}).$promise;
        }

        function markRuleAsUndeleted(ruleId) {
            return rulesActionResource.undelete({id: ruleId}).$promise;
        }

        function deleteRules(ids) {
            var actionParameters = {
                ids : ids
            };
            return rulesActionResource.deleteMultiple({}, actionParameters).$promise;
        }

        function undeleteRules(ids) {
            var actionParameters = {
                ids : ids
            };
            return rulesActionResource.undeleteMultiple({}, actionParameters).$promise;
        }

        function activateRules(ids) {
            var actionParameters = {
                ids : ids
            };
            return rulesActionResource.activateMultiple({}, actionParameters).$promise;
        }

        function deactivateRules(ids) {
            var actionParameters = {
                ids : ids
            };
            return rulesActionResource.deactivateMultiple({}, actionParameters).$promise;
        }

        function activateRule(rule) {
            rule.ruleStatusCode = 'ACT';
            return rulesActionResource.activate({id: rule.ruleId}).$promise;
        }

        function deactivateRule(rule) {
            rule.ruleStatusCode = 'INA';
            return rulesActionResource.deactivate({id: rule.ruleId}).$promise;
        }

        function getRuleIdCount (rule) {
            return $http.get(amlConfig.baseUrl + '/rules/' + rule.ruleId + '/count');
        }
        function exportRules(ids) {
            var actionParameters = {
                ids : ids
            };
            return rulesActionResource.export({}, actionParameters).$promise;
        }

        function importRules(json) {
            return rulesActionResource.import({}, json).$promise;
        }

        function runRules(params) {
            return rulesActionResource.run({}, params).$promise;
        }

        function copyRules(ids, groupAction) {
            var actionParameters = {
                ids : ids,
                ruleGroupAction : groupAction
            };
            return rulesActionResource.copy({}, actionParameters).$promise;
        }

        function getNextId () {
            return ++idSeq;
        }

        // parameters for rule test button
        var runParameters = {
            'ids': [],
            'ruleGroupAction': 'NONE',
            'sampleSize' : 0,
            'displayAllScores' : 'Y'
        };

        var service = {
            getRules: getRules,
            getRule: getRule,
            newRule: newRule,
            updateRule: updateRule,
            createNewRule: createNewRule,
            changeRuleId : changeRuleId,
            getRuleNames : getRuleNames,
            markRuleAsDeleted : markRuleAsDeleted,
            markRuleAsUndeleted : markRuleAsUndeleted,
            deleteRules : deleteRules,
            undeleteRules : undeleteRules,
            activateRule : activateRule,
            deactivateRule : deactivateRule,
            getRuleIdCount : getRuleIdCount,
            activateRules : activateRules,
            deactivateRules : deactivateRules,
            exportRules : exportRules,
            importRules : importRules,
            runRules: runRules,
            copyRules : copyRules,
            getNextId : getNextId,
            runParameters : runParameters
        };
        return service;
    }
})();
/**
 * @ngdoc service
 * @name     cdd.rule:ruleGroupService
 *
 * @restrict E
 *
 * @description
 * The ruleGroup rule service is used to retrieve ruleGroups from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    ruleGroupService.$inject = ["$http", "$resource", "amlConfig", "amlConstants", "moment", "_", "exceptionResourceHandler"];
    angular
        .module('cdd.rule')
        .factory('ruleGroupService', ruleGroupService);

    /* @ngInject */
    function ruleGroupService($http, $resource, amlConfig, amlConstants, moment, _, exceptionResourceHandler) {
        var idSeq = 1;

        /**
         * Resources
         */
        var ruleGroupsResource = $resource(amlConfig.baseUrl + '/ruleGroups',
            {}, {
                get: {
                    url: amlConfig.baseUrl + '/ruleGroups/:id',
                    params: {id: '@id'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getAll: {
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getNondeleted: {
                    params: {'type': 'NONDELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getDeleted: {
                    params: {'type': 'DELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                changeId: {
                    url: amlConfig.baseUrl + '/ruleGroups?oldId=:oldId',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                //update handles 409 status code, so we do not want to display http error message
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });

        var ruleGroupsActionResource = $resource(amlConfig.baseUrl + '/ruleGroups/:id/actions/:action',
            {id: '@id'}, {
                delete: {
                    params: {action: 'delete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undelete: {
                    params: {action: 'undelete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deleteMultiple: {
                    url: amlConfig.baseUrl + '/ruleGroups/actions/delete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undeleteMultiple: {
                    url: amlConfig.baseUrl + '/ruleGroups/actions/undelete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        function newRuleGroup(ruleGroupName, ruleGroupId) {
            var dateNow = new Date();
            var ruleGroup = {
                'ruleGroupId': ruleGroupId,
                'ruleGroupFileName': '',
                'ruleGroupName': ruleGroupName,
                'ruleGroupDescription': '',
                'ruleGroupCategoryCode': '',
                'ruleGroupType' : 'ATTR',
                'ruleGroupByVar1Name':'',
                'ruleGroupByVar2Name':'',
                'ruleGroupInputDsName':'',
                'ruleGroupLevel': 1,
                'ruleGroupOrderInLevel': 1,
                'ruleGroupSaveToKcFlg': 'Y',
                'ruleGroupSaveTrigVFlg': 'Y',
                'currentInd': 'Y',
                'headerSource': '',
                'footerSource': '',
                'lastUpdateUserId': '',
                'createUserId': '',
                'createDate': dateNow,
                'updateDate': dateNow,
                'logicalDeleteInd': 'N',
                'version': 0
            };
            return ruleGroup;
        }

        var ruleGroupNames;

        function getRuleGroupNames(includeDeleted) {
            var ruleGroupsPromise;
            if (includeDeleted) {
                ruleGroupsPromise = ruleGroupsResource.getAll({}).$promise;
            } else {
                ruleGroupsPromise = ruleGroupsResource.getNondeleted({}).$promise;
            }
            return ruleGroupsPromise.then(function (data) {
                if (idSeq < data.items.length) { idSeq = data.items.length; }
                var ruleGroups = data.items;
                var names = [];
                for (var i = 0; i < ruleGroups.length; i++) {
                    names.push({code: ruleGroups[i].ruleGroupName, value: ruleGroups[i].ruleGroupName});
                }
                ruleGroupNames = names.sort(
                    function (a, b) {
                        if (a.code < b.code) {
                            return -1;
                        } else if (a.code === b.code) {
                            return 0;
                        } else {
                            return 1;
                        }
                    });
                return ruleGroupNames;
            });
        }

        function processRuleGroups (ruleGroupsPromise) {
            return ruleGroupsPromise.then(function (data) {
                if (data.items && idSeq < data.items.length) { idSeq = data.items.length; }
                return data;
            });
        }

        function getRuleGroups(showDeleted) {
            var ruleGroupsPromise;
            if (showDeleted) {
                ruleGroupsPromise = ruleGroupsResource.getDeleted({}).$promise;
            } else {
                ruleGroupsPromise = ruleGroupsResource.getNondeleted({}).$promise;
            }
            return processRuleGroups(ruleGroupsPromise);
        }

        function getAllRuleGroups() {
            var ruleGroupsPromise = ruleGroupsResource.getAll({}).$promise;
            return processRuleGroups(ruleGroupsPromise);
        }

        function getRuleGroup(ruleGroupId) {
            return ruleGroupsResource.get({id: ruleGroupId}).$promise;
        }

        function updateRuleGroup(ruleGroupIn) {
            return ruleGroupsResource.update({}, ruleGroupIn).$promise;
        }

        function createNewRuleGroup(ruleGroupIn) {
            return ruleGroupsResource.create({}, ruleGroupIn).$promise;
        }

        function markRuleGroupAsDeleted(ruleGroupId) {
            return ruleGroupsActionResource.delete({id: ruleGroupId}).$promise;
        }

        function markRuleGroupAsUndeleted(ruleGroupId) {
            return ruleGroupsActionResource.undelete({id: ruleGroupId}).$promise;
        }

        function markRuleGroupsAsDeleted(ids) {
            var actionParameters = {
                ids: ids
            };
            return ruleGroupsActionResource.deleteMultiple({}, actionParameters).$promise;
        }

        function markRuleGroupsAsUndeleted(ids) {
            var actionParameters = {
                ids: ids
            };
            return ruleGroupsActionResource.undeleteMultiple({}, actionParameters).$promise;
        }

        //one and only one By Variable has to be selected for the prep data se
        function isByVariableValid(ruleGroup) {
            //function isByVariableValid (ruleGroup, varName, modelValue, viewValue) {
            //var byCounter = 0;
            //if (angular.isUndefined(ruleGroup.datasetColumns)) {
            //    return true;
            //}
            //for (var i = 0; i < ruleGroup.datasetColumns.length; i++) {
            //    if (ruleGroup.datasetColumns[i].usageCode === 'By variable') {
            //        byCounter++;
            //    }
            //}
            ////console.log(varName + ":" +byCounter);
            //return (byCounter === 1);
            return true;
        }

        function hasSource(ruleGroup) {
            return true;
        }


        function getNextId() {
            return ++idSeq;
        }

        function getRuleGroupIdCount (ruleGroup) {
            return $http.get(amlConfig.baseUrl + '/ruleGroups/' + ruleGroup.ruleGroupId + '/count');
        }

        function changeRuleGroupId(ruleGroup, oldId) {
            return ruleGroupsResource.changeId({oldId: oldId}, ruleGroup).$promise;
        }

        var service = {
            getRuleGroups: getRuleGroups,
            getAllRuleGroups : getAllRuleGroups,
            getRuleGroup: getRuleGroup,
            newRuleGroup: newRuleGroup,
            updateRuleGroup: updateRuleGroup,
            createNewRuleGroup: createNewRuleGroup,
            changeRuleGroupId: changeRuleGroupId,
            isByVariableValid: isByVariableValid,
            getRuleGroupNames: getRuleGroupNames,
            getRuleGroupIdCount: getRuleGroupIdCount,
            markRuleGroupAsDeleted: markRuleGroupAsDeleted,
            markRuleGroupsAsDeleted: markRuleGroupsAsDeleted,
            markRuleGroupAsUndeleted: markRuleGroupAsUndeleted,
            markRuleGroupsAsUndeleted: markRuleGroupsAsUndeleted,
            hasSource: hasSource,
            getNextId: getNextId
        };
        return service;
    }
})();
/*
var pubsub = {};
(function (myObject) {
    var topics = {}; // Storage for topics that can be broadcast
     var subUid = -1; // An topic identifier
// Subscribe to events of interest with a specific topic name and a
// callback function.
    myObject.subscribe = function (topic, func) {
        if (!topics[topic]) {
            topics[topic] = [];
        }
        var token = ( ++subUid ).toString();
        topics[topic].push({token: token, func: func});
        return token;
    };

// Publish or broadcast events of interest with a specific topic name
// and arguments such as the data to pass along
    myObject.publish = function (topic, args) {
        if (!topics[topic]) {
            return false;
        }
        var subscribers = topics[topic], len = subscribers ? subscribers.length : 0;
        while (len--) {
            subscribers[len].func(topic, args);
        }
        return this;
    };
}(pubsub));
*/

/**
 * @ngdoc service
 * @name     aml:resourceService
 *
 * @description
 * The resourceService handles retrieving the localized resources for the current user
 * locale, and populating the 'resource' constant object with those results.
 *
 * It is also responsible for retrieving the LOV Table values for the current user
 * locale and populating the 'amlMappedContants" object with those results.
 */
(function() {
    'use strict';
    resourceService.$inject = ["$resource", "$interpolate", "$location", "$q", "resources", "amlConfig", "amlLov", "logger", "amlConstants", "exceptionResourceHandler", "$locale", "messageService"];
    angular.module('aml').service('resourceService', resourceService );

    /*jshint maxparams: 13 */
    /*jshint latedef: false */
    function resourceService( $resource, $interpolate, $location, $q, resources,
                              amlConfig, amlLov, logger, amlConstants, exceptionResourceHandler,
                              $locale, messageService ) {
        // the index of the requests in the allPromises
        var DEFAULT_RESOURCES_INDEX = 0;
        var LOCALE_RESOURCES_INDEX = 1;
        var LOV_RESOURCES_INDEX = 2;
        var AML_PREFERENCES_INDEX = 3;

        var rootPath = amlConstants.resourcesRootPath;
        var rootPathI18n = rootPath + '/nls';
        var resourcesFileName = 'resources.json';
        var overrideFileName = 'resources-override.json';
        var configPropertiesPath = amlConfig.baseUrl + '/preferences';
        var DEFAULT_LOCALE = 'en';
        var LOV_TABLES = '/lov';

        // if we've set a different config properties path in the app config, use that instead
        if ( amlConfig.configPropertiesPath ) {
            configPropertiesPath = amlConfig.configPropertiesPath;
        }

        var userClientLocaleResource = $resource(amlConfig.baseUrl + '/users/current/locale',
            { get: { method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var locale;
        var initializeResourcesPromise;

        var addToScope = function (scope, component, data) {
            if (!scope.resources) {
                scope.resources = {};
            }

            var modularData = {};
            modularData[component] = data;

            // add 'resources' to the rootscope, as well as to the 'resources' constant object
            $.extend(true, scope.resources, modularData);
            angular.extend( resources, scope.resources );
        };

        var storeResources = function (scope, component, data, ssid) {
            addToScope(scope, component, data);
            if (amlConfig.cacheStartupResources && sessionStorage) {
                sessionStorage.setItem(ssid, JSON.stringify(data));
            }
            createInterpolationFunction(scope, component);
        };

        var initializeLovMappings = function(lovData ) {
            amlLov.initialize( lovData, resources );
        };

        var setLovMappings = function ( data, ssid) {
            initializeLovMappings( data );
            if (amlConfig.cacheStartupResources && sessionStorage) {
                sessionStorage.setItem(ssid, JSON.stringify(data));
            }
        };

        var initializeConfigConstantValues = function( configValues ) {
            amlConstants.initializeConfigValues( configValues );
        };

        var setConfigConstantValues = function ( configValues, ssid) {
            initializeConfigConstantValues( configValues );
            if (amlConfig.cacheStartupResources && sessionStorage) {
                sessionStorage.setItem(ssid, JSON.stringify(configValues));
            }
        };

        var setInitializeResourcesPromise = function(promise){
            initializeResourcesPromise = promise;
        };

        /**
         * Retrieve all resources remotely.
         * This includes the localized resources which are stored locally within the application
         * (accessed via a network request) and the LOV Table mappings which are retrieved
         * via a REST API request
         * @param scope
         * @param component
         * @param localeResourcesPath
         * @param ssid
         * @param defaultPath
         * @param lovTablesSsid
         * @param locale
         * @returns {Promise}
         */
        var retrieveResources = function (scope, component, localeResourcesPath, ssid, defaultPath,
                                          lovTablesSsid, locale, amlConfigPropertiesPath, configPropertiesSSID,
                                          overridePath) {

            // it will look like:
            //http://d78245.na.sas.com:8780/SASComplianceSolutionsMid/localeResources/resources/nls/_LOCALE_/resources.json

            // localized resource files are retrieved via a network request to a local file
            var defaultResources = $resource(defaultPath).get();
            var overrideResources = $resource(overridePath).get();
            var localeResources = $resource(localeResourcesPath).get();
            // reference tables are retrieved via REST service
            var lovResource = $resource(amlConfig.baseUrl + LOV_TABLES).get();

            // customizable aml configuration properties
            var amlPreferencesResource = $resource(amlConfigPropertiesPath).get();

            // $q.all() resolves immediately when any promise fails, so we have to wrap the http promises
            var defaultResourcesCompleted = $q.defer();
            var overrideResourcesCompleted = $q.defer();
            var localeResourcesCompleted = $q.defer();
            var lovResourcesCompleted = $q.defer();
            var amlPreferencesResourceCompleted = $q.defer();

            defaultResources.$promise.then(function() {
                    defaultResourcesCompleted.resolve({success: true});
                }, function(data) {
                    defaultResourcesCompleted.resolve({success:false, data: data});
                }
            );
            overrideResources.$promise.then(function() {
                    overrideResourcesCompleted.resolve({success: true});
                }, function(data) {
                    overrideResourcesCompleted.resolve({success:false, data: data});
                }
            );
            localeResources.$promise.then(function(){
                    localeResourcesCompleted.resolve({success:true});
                }, function(data) {
                    localeResourcesCompleted.resolve({success:false, data: data});
                }
            );
            lovResource.$promise.then(function(){
                    lovResourcesCompleted.resolve({success:true});
                }, function(data) {
                    lovResourcesCompleted.resolve({success:false, data: data});
                }
            );

            amlPreferencesResource.$promise.then(function(){
                    amlPreferencesResourceCompleted.resolve({success:true});
                }, function(data) {
                    amlPreferencesResourceCompleted.resolve({success:false, data: data});
                }
            );
            //TODO: do these non-locale values need to be part of the group of promises?
            // can't they run separately?  maybe resources is needed to update the LOV Tables?
            // but config props could probably be separate promise

            var allPromises = $q.all([
                defaultResourcesCompleted.promise,
                localeResourcesCompleted.promise,
                lovResourcesCompleted.promise,
                amlPreferencesResourceCompleted.promise,
                overrideResourcesCompleted.promise
            ]);


            // check all promises at once
            allPromises.then(function(results){
                updateResources( results,
                    amlConfigPropertiesPath, amlPreferencesResource, configPropertiesSSID, ssid, defaultResources,
                    localeResources, scope, component, lovTablesSsid, lovResource, overrideResources);
            });

            return allPromises;
        };


        /**
         * Once all of the necessary startup resources are fetched (resources --strings, lov, preferences), this
         * handler handlers setting all of the appropriate values in the system
         */
        function updateResources(results, amlConfigPropertiesPath, amlPreferencesResource,
                                 configPropertiesSSID, ssid, defaultResources, localeResources,
                                 scope, component, lovTablesSsid, lovResource, overrideResources) {

            // set resource strings
            if (results[DEFAULT_RESOURCES_INDEX].success === false && results[LOCALE_RESOURCES_INDEX].success === false) {
                messageService.danger('Unable to load any resource strings for ' + ssid);
                exceptionResourceHandler.resourceErrorHandler(results[DEFAULT_RESOURCES_INDEX].data);
            }
            else {
                var resourcesVal;
                if (results[LOCALE_RESOURCES_INDEX].success === false) {
                    messageService.danger('No localised resource strings for ' + ssid + '; using defaults');
                    exceptionResourceHandler.resourceErrorHandler(results[LOCALE_RESOURCES_INDEX].data);
                    resourcesVal = $.extend(true, defaultResources, overrideResources);
                } else {
                    resourcesVal = $.extend(true, defaultResources, localeResources, overrideResources);
                }

                storeResources(scope, component, resourcesVal, ssid);
            }

            // set preference values
            if (results[AML_PREFERENCES_INDEX].success === false) {
                messageService.danger('Unable to load AML preferences: ' + amlConfigPropertiesPath);
                exceptionResourceHandler.resourceErrorHandler(results[AML_PREFERENCES_INDEX].data);
            }
            else {
                setConfigConstantValues(amlPreferencesResource, configPropertiesSSID);
                // setConfigValues on amlConstants
            }

            // set lov values
            if (results[LOV_RESOURCES_INDEX].success === false) {
                messageService.danger('Unable to load any AML LOV table values for ' + lovTablesSsid);
                exceptionResourceHandler.resourceErrorHandler(results[LOV_RESOURCES_INDEX].data);

                // if the lov tables cannot be loaded, initialize with blank mappings; the application will
                // still work, but only lov table keys will be displayed since there's no mappings available
                initializeLovMappings({});
            }
            else {
                setLovMappings(lovResource, lovTablesSsid);
            }
        }


        var createInterpolationFunction = function (scope, component) {
            scope.resources[component].getResource = function (resourceKey, params, returnUndefinedIfUnbound) {
                if ( !resourceKey ) {
                    return undefined;
                }

                // in some cases such as utilizing one-time binding, if the object parameters are not yet bound,
                // we don't want this value to be bound yet in that case. We will return 'undefined' until all of
                // the parameters have been bound (are non-null).
                if ( returnUndefinedIfUnbound && params ) {
                    var paramsContainsNullValues = _.any(params, function (val) { return !val; });
                    if ( paramsContainsNullValues ) {
                        return undefined;
                    }
                }

                //var resourceValue = scope.resources[component][resourceKey];
                // Note: it's possible the values are nested objects (resources.aml.navbar.logoff), so we need to
                // iterate over each nested object
                var resourceValue = scope.resources[component];
                var keys = resourceKey.split('.');
                for(var i=0;i<keys.length;i++){
                    resourceValue = resourceValue[keys[i]];
                }

                if (resourceValue) {
                    return $interpolate(resourceValue)(params);
                } else {
                    return '';
                }
            };

            scope.paramResources = {};
            angular.forEach(scope.resources[component], function (resource, key) {
                if (typeof resource === 'string' && resource.indexOf('{{') > -1 && resource.indexOf('}}') > -1) {
                    scope.paramResources[key] = function (params) {
                        return scope.resources[component].getResource(key, params);
                    };
                }
            });

            /**
             * pluralized-aware version of getResource.  The count is passed in, along with the resource key to use in
             * the case of one (singular) as well as the key to use in the case of Other (plural)
             *
             * @param count
             * @param resourceKeyOne
             * @param resourceKeyOther
             * @param params
             * @returns {*}
             */
            scope.resources[component].getPluralizedResource = function (count, resourceKeyOne, resourceKeyOther, params) {
                if ( count === 1 ) {
                    return scope.resources[component].getResource( resourceKeyOne, params);
                }
                else {
                    return scope.resources[component].getResource( resourceKeyOther, params);
                }
            };
        };

        /**
         * Get the locale from the server (using the Accept-Language header that the browser sends).
         * This is the most reliable way to determine the locale that is set in the client browser.
         *
         * @returns {*}
         */
        var getLocaleFromServer = function() {
            // IE client-side check is not reliable, so must get value from server
            var localePromise = userClientLocaleResource.get().$promise.then( function(data) {
                locale = data.clientLocale;
                // use the first locale specified
                if ( locale ) {
                    var locales = locale.split(',');
                    if ( locales) {
                        locale = locales[0];

                        var index = locale.indexOf( ';');
                        if ( index > -1 ) {
                            locale = locale.substring( 0, index );
                        }
                    }
                }
                if ( !locale ) {
                    // if no server locale specified, get it from the client
                    locale = getClientSpecifiedLocale();
                }
                if ( locale ) {
                    locale = locale.toLowerCase();
                }
                return locale;
            });
            return localePromise;
        };

        /**
         * Return the locale as identified by the client; note that this is not reliable for IE
         * @returns {string}
         */
        var getClientSpecifiedLocale = function() {
            // Use any locale specified in the client side URL (i.e. after any #/), then attempt to get it from the
            // browser using one of the many ways that it can be stored, and finally default to en.  Ideally we'd get
            // it from the HTTP Accept-Language header but this requires server side support.
            // see http://stackoverflow.com/questions/1043339/javascript-for-detecting-browser-language-preference
            var clientLocale = ($location.search().locale ||
                navigator.userLanguage ||
                (navigator.languages && navigator.languages[0]) ||
                navigator.language ||
                navigator.browserLanguage ||
                navigator.systemLanguage || DEFAULT_LOCALE).toLowerCase();
            return clientLocale;
        };


        /**
         * Return a promise that returns the locale using the most appropriate method
         * (via client javascript for Chrome/FF, and via a server request for IE).
         *
         * @returns {promise}
         */
        var getLocale = function() {
            /*jshint maxcomplexity:10 */
            var localePromise;
            var loadLocaleDefer;
            var useLocaleOverride;
            // return locale if we've already retrieved and cached it
            if ( !locale ) {
                //  Use any locale specified in the client side URL (i.e. after any #/),
                if ($location.search().locale && $location.search().locale === '_' ) {
                    useLocaleOverride = true;
                }
                else if ($location.search().locale) {
                    locale = $location.search().locale;
                }
                else {
                    // use angular locale unless override is specified
                    if ( !useLocaleOverride ) {
                        // get from $locale.id; this is retrieved from the angular-locale_{country} files that are
                        // loaded
                        locale = $locale.id;

                        // the default angular locale uses en-us; we just store 'en' for resources so default to the
                        // the short 'en' form in that case. This would only come back if the initial request to
                        // /localeResources failed
                        if ( locale === 'en-us') {
                            locale = DEFAULT_LOCALE;
                        }
                    }
                }
            }
            if ( locale ) {
                loadLocaleDefer = $q.defer();
                localePromise = loadLocaleDefer.promise;
                loadLocaleDefer.resolve( locale );
            }
            else {
                var checkServerLocaleOverride = false;
                var isIE =  !!document.documentMode; // At least IE6
                if ( isIE || checkServerLocaleOverride ) {
                    // IE client-side check is not reliable, so must get value from server
                    localePromise = getLocaleFromServer();
                }
                else {
                    loadLocaleDefer = $q.defer();
                    localePromise = loadLocaleDefer.promise;
                    locale = getClientSpecifiedLocale();
                    loadLocaleDefer.resolve( locale );
                }
            }

            return localePromise;
        };

        /**
         * Return a promise that returns the 2-character short form of the locale.
         * Example: for the 'en-en' locale, returns 'en'
         * @returns {*}
         */
        var getLocaleShortCode = function() {
            return getLocale().then(function(locale) {
                var localeShortCode = locale;
                if ( localeShortCode && localeShortCode.length > 2 ) {
                    localeShortCode = localeShortCode.substring(0, 2);
                }
                return localeShortCode;
                });
        };


        function setVendorLanguage(lang) {
            // set kendo grid culture
            var kendoLang = lang;

            // kendo locales are upper case for specific segment of 4-letter locale zh-TW
            if (kendoLang && kendoLang.length > 2) {
                kendoLang = kendoLang.substring(0, 2) + kendoLang.substring(2).toUpperCase();
            }
            kendo.culture(kendoLang); // change the culture
        }

        var init = function($rootScope, component) {
            // wrap the initialize in a single promise, so if multiple routes/run configurations call this init, only
            // a single promise will actually execute
            if ( !initializeResourcesPromise ) {
                var initializeResourcesDeferred = $q.defer();
                initializeResourcesPromise = initializeResourcesDeferred.promise;

                // if resources were somehow already initialized, then do nothing
                if ( $rootScope.resources && $rootScope.resources.aml ) {
                    initializeResourcesDeferred.resolve();
                    return null;
                }

                var promise = getResourcesForLocale($rootScope, component);

                var configurePage = function() {
                    getLocaleShortCode().then(function(lang) {
                        // set direction (dir=ltr/rtl) based on which locale is being used
                        $('html').attr('dir', $rootScope.resources.aml.metadata.textDirection).attr('lang', lang);

                        // add rtl class for kendo grids
                        if (  $rootScope.resources.aml.metadata.textDirection === 'rtl' ) {
                            $('body').addClass('k-rtl');
                        }
                    });

                    getLocale().then(function(lang) {
                        setVendorLanguage(lang);
                    });
                };

                if (promise) {
                    promise.then(function() {
                        configurePage();

                        initializeResourcesDeferred.resolve();
                    });
                } else {
                    configurePage();
                    initializeResourcesDeferred.resolve();
                }
            }
            return initializeResourcesPromise;
        };


        var getCachedLocale = function() {
            return locale;
        };
        var setCachedLocale = function(loc) {
            locale = loc;
        };

        var getResourcesForLocale = function(scope, component) {
            // if locale is already cached, use it to check for resources of that locale
            if (getCachedLocale()) {
               return getResources( scope, component, getCachedLocale() );
            }
            else {
                // determine locale (method is browser-dependent) and then check/retrieve
                // resources for that locale
                return getLocale().then(function(locale) {
                    return getResources( scope, component, locale );
                });
            }
        };


        function retrieveFromCache( ssid, lovTablesSSID, preferencesSSID, scope, component, promise, path, defaultPath, locale, overridePath ) {
            var resourceFromStorage = sessionStorage.getItem( ssid );
            var storageLov = sessionStorage.getItem( lovTablesSSID );
            var amlConfigs = sessionStorage.getItem( preferencesSSID );
            // if we have ALL of the needed initial resources cached, use them.
            if ( resourceFromStorage && storageLov && amlConfigs ) {
                addToScope( scope, component, JSON.parse( resourceFromStorage ) );
                createInterpolationFunction( scope, component );

                initializeLovMappings( JSON.parse( storageLov ) );

                initializeConfigConstantValues( JSON.parse( amlConfigs ) );
                // No promise returned from here as no async tasks
            } else {
                // we do not have one or more of the needed initial resources cached; retrieve them all
                promise = retrieveResources( scope, component, path, ssid, defaultPath, lovTablesSSID,
                    locale, configPropertiesPath, preferencesSSID, overridePath );
            }
            return promise;
        }

        /**
         * This gets the resources; if both the localized resource and LOV Tables
         * resource are stored in session storage *for the current locale*, then
         * those are retrieved from the session storage.
         *
         * Otherwise, all resources are retrieved via asynchronouse network requests.
         *
         * @param scope
         * @param component
         * @returns {*}
         */
        var getResources = function(scope, component, locale) {
            // session storage id
            var ssid = component + '/resources_' + locale;
            var lovTablesSSID = component + '/lov_' + locale;
            var path = rootPathI18n + '/' + locale + '/' + resourcesFileName;
            var defaultPath = rootPathI18n + '/' + resourcesFileName;
            var overridePath = rootPathI18n + '/' + locale + '/' + overrideFileName;
            var preferencesSSID = component + '/configValues';
            var promise;

            /**
             * By default, we do not retrieve cached resources at startup as this requires users to perform Clear Cache
             * locally when LOV or preferences change.
             */
            if ( sessionStorage && amlConfig.cacheStartupResources) {
                promise = retrieveFromCache( ssid, lovTablesSSID, preferencesSSID, scope, component, promise, path, defaultPath, locale, overridePath );
            } else {
                promise = retrieveResources(scope, component, path, ssid, defaultPath, lovTablesSSID,
                    locale, configPropertiesPath, preferencesSSID, overridePath);
            }

            return promise;
        };

/*        /!**
         * Load a deferred script from the server
         * @param scriptName
         * @returns {*}
         *!/
        function loadScript( scriptName ) {
            var deferred = $q.defer();
            $.getScript(scriptName, function( data, textStatus, jqxhr ) {
                //console.log( textStatus ); // Success
                //console.log( jqxhr.status ); // 200
                //console.log( "Load was performed."  + data );
                deferred.resolve();
            });

            //$window.initialize = function () {
            //    deferred.resolve();
            //};
            //if ($window.attachEvent) {
            //    $window.attachEvent('onload', load_script);
            //} else {
            //    $window.addEventListener('load', load_script, false);
            //}
            return deferred.promise;
        }*/


        var service = {
            getLocale: getLocale,
            getLocaleShortCode: getLocaleShortCode,
            init: init,
            setCachedLocale: setCachedLocale,
            updateResources: updateResources,
            setInitializeResourcesPromise: setInitializeResourcesPromise,
            retrieveResources: retrieveResources
        };
        return service;

    }

}());

(function () {
    'use strict';

    queueListService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.admin')
        .factory('queueListService', queueListService);


    function queueListService($resource, amlConfig, exceptionResourceHandler) {


        //the url here is: http://d10c667.na.sas.com:8780/SASComplianceSolutionsMid/rest so add the /queues
        var queueResource = $resource(amlConfig.baseUrl + '/queues',
            {},     //empty, we just send the queue object -- Spring serializes/de-serializes to java object of type Queue when requested
            {
                create: {
                    method: 'POST',
                    interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
                },
                get: {
                    method: 'GET',
                    interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
                },
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                    //this is idempotent, resource change is independent of number of times requested
                }
            }
        );

        function createQueue(queue) {
            return queueResource.create( queue ).$promise;
        }

        function getQueues() {
            return queueResource.get({ }).$promise;
        }

        function updateQueue(queue) {       //used for updating a logically deleting a queue
            return queueResource.update( queue ).$promise;
        }


        var service = {

            getQueues: getQueues,
            createQueue: createQueue,
            updateQueue: updateQueue

        };


        return service;

    }
})();

/**
 * @ngdoc service
 * @name     aml.reports:reportsService
 *
 * @restrict E
 *
 * @description
 * The reports service is used to retrieve reports from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    reportsService.$inject = ["$resource", "amlConfig", "amlConstants", "_", "exceptionResourceHandler", "usersService", "kendoGridRendererService"];
    angular
        .module('aml.reports')
        .factory('reportsService', reportsService);

    /* @ngInject */
    /* jshint maxstatements: 52 */
    function reportsService($resource, amlConfig, amlConstants, _, exceptionResourceHandler, usersService,
                            kendoGridRendererService) {

        var formConfigList = [];

        //This is here only to create a proper filter for attachments
        var dataSourceOptions = {
            transport: {
                read: getSARAttachments
            },
            schema: {
                model: {
                    fields: {
                        objectId: {type: 'string'},
                        objectTypeCode: {type: 'string'},
                        size: {type: 'number'},
                        mimeType: {type: 'string'}
                    }
                },

                data: 'items', // records are returned in the 'items' field of the response
                total: 'count' // total number of results
            },
            pageSize: 10,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };

        var gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions
        });

        /**
         * Resources
         */

        var reportsResource = $resource(amlConfig.baseUrl + '/regulatoryReports',
            {
                id: '@id',

                // list parameters
                start: '@start',
                limit: '@limit',
                relationships: '@relationships',
                sortBy: '@sortBy',
                previousCount: '@previousCount',
                filter: '@filter',
                ownerUserLongId: '@ownerUserLongId'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportsForCaseResource = $resource(amlConfig.baseUrl + '/regulatoryReports/case',
            {
                // list parameters
                start: '@start',
                limit: '@limit',
                sortBy: '@sortBy',
                previousCount: '@previousCount',
                caseid: '@caseid'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportConfigResource = $resource(amlConfig.baseUrl + '/regulatoryReports/config',
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportSARAttachmentsResource = $resource(amlConfig.baseUrl + '/attachments',
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportEntitiesResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/entities',
            {
                id: '@id',
                entityKey: '@entityKey',
                entityType: '@entityType'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                update: {
                    method: 'PUT',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                remove: {
                    method: 'DELETE',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportEntityBridgeResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/relationships',
            {
                id: '@id',
                entityKey:  '@parentKey',
                entityType: '@parentLevelCode'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                update: {
                    method: 'PUT',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                remove: {
                    method: 'DELETE',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getBridges: {
                    url: amlConfig.baseUrl + '/regulatoryReports/:id/bridges',
                    params: {id: '@id',
                        entityKey:  '@parentKey',
                        entityType: '@parentLevelCode',
                        entityLevelCode: '@entityLevelCode'
                    },
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deleteBridge: {
                    url: amlConfig.baseUrl + '/regulatoryReports/:id/bridges',
                    params: {id: '@id',
                        parentKey:  '@parentKey',
                        parentLevelCode: '@parentLevelCode',
                        entityLevelCode: '@entityLevelCode',
                        entityKey:  '@entityKey'
                    },
                    method: 'DELETE',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportEntityInfoResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/reportEntityInfo',
            {
                id: '@id',
                start: '@start',
                limit: '@limit',
                sortBy: '@sortBy',
                entityKey: '@entityKey',
                entityTypeName: '@entityTypeName',
                entityNumber: '@entityTypeNumber',
                parentEntityNumber: '@parentEntityNumber'

            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var financialInstitutionResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/reportEntityInfo',
            {
                id: '@id',
                entityTypeName: '@entityTypeName'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id',
            {
                id: '@id'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound}
                },
                save: {
                    method: 'PUT',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var reportCallSTPResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/callStp',
            {
                id: '@id',
                stpName: '@stpName'
            },
            {
                get: {
                    method: 'GET',
                    headers: {'Accept': 'text/html'},
                    transformResponse: parseHtml,
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var triageRouteReportsResource = $resource(amlConfig.baseUrl + '/regulatoryReports/triageRequests/route',
            {}, {
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });
        var triageCheckinReportsResource = $resource(amlConfig.baseUrl + '/regulatoryReports/triageRequests/checkin',
            {}, {
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });
        var triageCheckoutReportsResource = $resource(amlConfig.baseUrl + '/regulatoryReports/triageRequests/checkout',
            {}, {
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });

        var triageCreateCorrectionReportResource = $resource(amlConfig.baseUrl + '/regulatoryReports',
            {}, {
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var service = {
            saveReport: saveReport,
            getReport: getReport,
            getReports: getReports,
            getReportsForCase: getReportsForCase,
            getSubjects: getSubjects,
            getBranches: getBranches,
            getReportConfigurations: getReportConfigurations,
            getImplementationTypeCode: getImplementationTypeCode,
            getSARAttachments: getSARAttachments,
            getReportBranches: getReportBranches,
            getReportBranchesByParent: getReportBranchesByParent,
            getReportInstitutions: getReportInstitutions,
            getReportEntityInfo: getReportEntityInfo,
            updateReportEntity: updateReportEntity,
            createReportEntity: createReportEntity,
            removeReportEntity: removeReportEntity,
            createReportEntityBridge: createReportEntityBridge,
            updateReportEntityBridge: updateReportEntityBridge,
            removeReportEntityBridge: removeReportEntityBridge,
            getReportBridges: getReportBridges,
            deleteReportBridge : deleteReportBridge,
            getReportsInArrayByNumber: getReportsInArrayByNumber,
            getFinancialInstitutionData : getFinancialInstitutionData,
            routeReports: routeReports,
            checkinReports: checkinReports,
            checkoutReports: checkoutReports,
            isReportReadonly: isReportReadonly,
            runReportValidation: runReportValidation,
            makeCorrectionReport: makeCorrectionReport
        };

        activate();

        return service;


        function activate() {

            getReportConfigurations().then(function (data) {
                formConfigList = data.items;
            });
        }

        /**
         * We have a parseHtml function that just returns the data in a JSON object; otherwise ngResource
         * seems to want to parse it as JSON and returns ArrayBuffer.
         */
        function parseHtml(data, headersGetter) {
            return {data: data};
        }


        /**
         * Get list of reports
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all reports matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getReports(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = null;
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length > 0) {
                filter = filterStr;
            }

            return reportsResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }


        /**
         * Get list of reports for a particular case
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param caseid the id of the case to get reports for
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getReportsForCase(start, pageSize, sortBys, caseid, previousCount) {
            var sortByList = null;
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }

            return reportsForCaseResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                caseid: caseid
            }).$promise;
        }


        /**
         * Get list of report subjects
         * @returns {$promise|*}
         */
        function getSubjects(start, pageSize, sortBys, reportKey) {
            return reportEntitiesResource.get({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                entityType: 'PTY'
            }).$promise;
        }

        /**
         * Get list of report branches
         * @returns {$promise|*}
         */
        function getReportBranches(start, pageSize, sortBys, reportKey) {
            return reportEntitiesResource.get({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                entityType: 'BRANCH'
            }).$promise;
        }

        /**
         * Get list of report branches
         * @returns {$promise|*}
         */
        function getReportBranchesByParent (start, pageSize, sortBys, reportKey, parentKey, parentLevelCode) {
            return reportEntityBridgeResource.get({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                entityType: 'BRANCH',
                parentLevelCode: parentLevelCode,
                parentKey : parentKey
            }).$promise;
        }

        /**
         * Get report bridges
         * @returns {$promise|*}
         */
        function getReportBridges (start, pageSize, sortBys, reportKey, parentKey, parentLevelCode, entityLevelCode) {
            return reportEntityBridgeResource.getBridges({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                parentLevelCode: parentLevelCode,
                parentKey : parentKey,
                entityLevelCode: entityLevelCode
            }).$promise;
        }

        /**
         * Get report bridges
         * @returns {$promise|*}
         */
        function deleteReportBridge (reportKey, parentEntityKey, parentEntityLevelCode, entityKey, entityLevelCode) {
            return reportEntityBridgeResource.deleteBridge({
                    parentKey:  parentEntityKey,
                    parentLevelCode: parentEntityLevelCode,
                    entityLevelCode: entityLevelCode,
                    entityKey:  entityKey,
                    id: reportKey
            }).$promise;
        }

        function getReportInstitutions(start, pageSize, sortBys, reportKey) {
            return reportEntitiesResource.get({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                entityType: 'INSTITUTION'
            }).$promise;
        }

        /**
         * Get list of report branches
         * @returns {$promise|*}
         */
        function getBranches(start, pageSize, sortBys, reportKey, parentEntityNumber) {
            return reportEntityInfoResource.get({
                id: reportKey,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                entityTypeName: 'FINCEN_BRANCH',
                entityNumber: null,
                parentEntityNumber: parentEntityNumber
            }).$promise;
        }


        /**
         * Get list entity info for one entity
         * @returns {$promise|*}
         */
        function getReportEntityInfo(reportKey, entityKey, entityType, entityNumber) {
            return reportEntityInfoResource.get({
                id: reportKey,
                entityKey: entityKey,
                entityTypeName: entityType,
                entityNumber: entityNumber
            }).$promise;
        }

        /**
         * Create a report entity bridge record
         * @returns {$promise|*}
         */
        function createReportEntityBridge(reportKey, entity) {
            return reportEntityBridgeResource.create({
                id: reportKey
            }, entity).$promise;
        }
        /**
         * Update a report entity bridge record
         * @returns {$promise|*}
         */
        function updateReportEntityBridge(reportKey, entity) {
            return reportEntityBridgeResource.update({
                id: reportKey
            }, entity).$promise;
        }
        /**
         * Remove a report entity
         * @returns {$promise|*}
         */
        function removeReportEntityBridge(reportKey, entity) {
            return reportEntitiesResource.remove({
                    id: reportKey
                }, entity).$promise;
        }

        /**
         * Create a report entity
         * @returns {$promise|*}
         */
        function createReportEntity(reportKey, entity) {
            return reportEntitiesResource.create({
                id: reportKey
            }, entity).$promise;
        }

        /**
         * Update a report entity
         * @returns {$promise|*}
         */
        function updateReportEntity(reportKey, entity) {
            return reportEntitiesResource.update({
                    id: reportKey,
                    entityKey: entity.entityKey
                }, entity).$promise;
        }

        /**
         * Remove a report entity
         * @returns {$promise|*}
         */
        function removeReportEntity(reportKey, entityKey, entityType, deleteRelationships) {
            return reportEntitiesResource.remove({
                    id: reportKey,
                    entityKey: entityKey,
                    entityType: entityType,
                    deleteRelationships: deleteRelationships
                }
            ).$promise;
        }


        /**
         * Get a report by report ID
         * @param reportkey
         * @returns {$promise|*}
         */
        function getReport(reportkey) {
            return reportResource.get({id: reportkey}).$promise;
        }

        /**
         * Save a report by report ID
         * @param aReport
         * @returns {$promise|*}
         */
        function saveReport(aReport) {
            return reportResource.save({id: aReport.reportKey}, aReport).$promise;
        }

        function getReportsInArrayByNumber(reportsNumber, array) {
            var reports = _.find(array, function (item) {
                return item && item.reportKey && item.reportKey === reportsNumber;
            });
            return reports;
        }

        /**
         * route an array of reports
         * @param reportNumbers
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeReports(reportNumbers, routeToUser, routeToQueue) {
            var reportsTriageParams = {
                reportNumbers: reportNumbers,
                ownerUserLongId: routeToUser,
                queueCode: routeToQueue
            };

            return triageRouteReportsResource.create({}, reportsTriageParams).$promise;
        }

        /**
         * checkin an array of reports
         * @param reportNumbers
         * @returns {$promise|*}
         */
        function checkinReports(reportNumbers) {
            var reportsTriageParams = {
                reportNumbers: reportNumbers
            };

            return triageCheckinReportsResource.create({}, reportsTriageParams).$promise;
        }

        /**
         * checkout an array of reports
         * @param reportNumbers
         * @returns {$promise|*}
         */
        function checkoutReports(reportNumbers) {
            var reportsTriageParams = {
                reportNumbers: reportNumbers
            };

            return triageCheckoutReportsResource.create({}, reportsTriageParams).$promise;
        }

        /**
         * Checks user permissions and report status to see if the report should be editable or just view mode
         * @returns {boolean}
         */
        function isReportReadonly(aReport) {
            var readOnlyStatusSet = ['C', 'E', 'R'];
            var efileReadOnlyStatusSet = ['A', 'AE', 'AW', 'G', 'RJ'];

            //Default is that case is editable
            var readOnly = false;

            //Check user permission
            if (!usersService.currentUserHasCapability(amlConstants.capabilities.editReport) && !usersService.currentUserHasCapability(amlConstants.capabilities.editAllReports)) {
                readOnly = true;
            }

            //Does the user own the case (i.e. in their work queue)?
            if (aReport.ownerUserLongId !== usersService.getCurrentUserId() && !usersService.currentUserHasCapability(amlConstants.capabilities.editAllReports)) {
                readOnly = true;
            }

            //Report is not open (i.e. closed) then not editable (no e-filed either)
            if (readOnlyStatusSet.indexOf(aReport.statusCode) !== -1 &&
                (!usersService.currentUserHasCapability(amlConstants.capabilities.resetReportStatus) &&
                !usersService.currentUserHasCapability(amlConstants.capabilities.reportReadyToSubmit))) {
                readOnly = true;
            }

            //If report in e-file+, then only resetReportStatus can edit.
            if (efileReadOnlyStatusSet.indexOf(aReport.statusCode) !== -1 && !usersService.currentUserHasCapability(amlConstants.capabilities.resetReportStatus)) {
                readOnly = true;
            }

            return readOnly;
        }

        /**
         * Returns a list of the report configurations defined in FSK_RC_FORM_CONFIG
         * @returns {$promise|*}
         */
        function getReportConfigurations() {
            return reportConfigResource.get().$promise;
        }

        /**
         * Returns the implementation type of the report.  This is used to determine if we are viewing a CUSTOM report
         * or a regular one.
         * @param aReport
         * @returns {*}
         */
        function getImplementationTypeCode(aReport) {
            var typeCode = null;

            var reportFormKey = aReport.reportFormTypeKey;

            formConfigList.forEach(
                function (item) {
                    //Convert both to strings as there is sometimes a type mismatch
                    if (item.formConfigKey.toString() === reportFormKey.toString()) {
                        typeCode = item.implementationTypeCode;
                    }
                }
            );

            return typeCode;
        }

        function runReportValidation(aReport) {
            return reportCallSTPResource.get({id: aReport.reportKey, stpName: 'rc_validate'}).$promise;
        }

        /**
         * Get financial institution data for this report
         * @returns {$promise|*}
         */
        function getFinancialInstitutionData(report) {
            return financialInstitutionResource.get({
                id: report.reportKey,
                entityTypeName: 'FINCEN_INSTITUTION_' + report.reportFormTypeKey
            }).$promise;
        }
        /**
         * Returns a list of the report attachments that can be attached to a SAR report
         * @returns {$promise|*}
         */
        function getSARAttachments(reportKey) {
            var filter = {
                logic: 'and',
                filters: [
                    {
                        field: 'objectTypeCode',
                        operator: 'eq',
                        value: 'RPT'
                    },
                    {
                        field: 'objectId',
                        operator: 'eq',
                        value: '' + reportKey
                    },
                    {
                        field: 'size',
                        operator: 'lte',
                        value: 1000000
                    },
                    {
                        field: 'mimeType',
                        operator: 'eq',
                        value: 'application/vnd.ms-excel'
                    }
                ]
            };

            var filterStr = kendoGridRendererService.getCustomFilterString(filter, gridOptions, null);

            return reportSARAttachmentsResource.get({
                filter: filterStr
            }).$promise;
        }

        /**
         * create a correction of an existing report
         * @param aReport the report to be corrected
         * @returns {angular.IPromise<T>|angular.IPromise<IResourceArray<T>>|angular.IPromise<Array<T>>|*|Function|promise}
         */
        function makeCorrectionReport(aReport) {

            var reportCreateParameters = {
                previousReportKey: aReport.reportKey
            };

            return triageCreateCorrectionReportResource.create({}, reportCreateParameters).$promise;
        }
    }
})();
/**
 * Created by sasjrf on 10/15/2015.
 */
/**
 * @ngdoc service
 * @name     aml.customer:riskAssessmentService
 *
 * @restrict E
 *
 * @description
 * The riskAssessment service is used to retrieve riskAssessment details  from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    riskAssessmentService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler", "amlCoreUtils"];
    angular
        .module('aml.riskAssessments')
        .factory('riskAssessmentService', riskAssessmentService);

    /* @ngInject */
    function riskAssessmentService($resource, amlConfig, exceptionResourceHandler,  amlCoreUtils) {

        /**
         * Resources
         */
        var riskAssessmentsResource = $resource(amlConfig.baseUrl + '/riskAssessments',
            {
                // list parameters

                start: '@start',
                limit: '@limit',
                sortBy: '@sortBy',
                previousCount: '@previousCount',
                filter: '@filter',
                ownerUserLongId: '@ownerUserLongId'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var riskAssessmentResource = $resource(amlConfig.baseUrl + '/riskAssessments/:id', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
                }
            },
            getClassifiers: {
                method: 'GET',
                params: { relationships: 'riskClassifiers'},
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            },
            create: {
                method: 'POST'
            }
        });

        var triageRouteRiskAssessmentsResource = $resource(amlConfig.baseUrl + '/riskAssessments/triageRequests/route',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });


        var triageRouteRiskAssessmentResource = $resource(amlConfig.baseUrl + '/riskAssessments/:assessmentIds/triageRequests/route',
            {assessmentIds: '@assessmentIds'}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });


        var triageAcceptRiskAssessmentResource = $resource(amlConfig.baseUrl + '/riskAssessments/:assessmentIds/triageRequests/accept',
            {assessmentIds: '@assessmentIds'}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var triageRejectRiskAssessmentResource = $resource(amlConfig.baseUrl + '/riskAssessments/:assessmentIds/triageRequests/reject',
            {assessmentIds: '@assessmentIds'}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var triageCheckoutRiskAssessmentsResource = $resource(amlConfig.baseUrl + '/riskAssessments/triageRequests/checkout',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}}
            });


        var triageCheckinRiskAssessmentaResource = $resource(amlConfig.baseUrl + '/riskAssessments/triageRequests/checkin',
            {}, { create: {
                method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}}
            });


        var service = {
            NEW_RISK_ASSESSMENT_ID: 'new_',
            constructNewRiskAssessment: constructNewRiskAssessment,
            createManualRiskAssessment: createManualRiskAssessment,
            getRiskAssessments: getRiskAssessments,
            getRiskAssessment: getRiskAssessment,
            getRiskAssessmentRiskClassifiers: getRiskAssessmentRiskClassifiers,
            routeRiskAssessments: routeRiskAssessments,
            routeRiskAssessment: routeRiskAssessment,
            acceptRiskAssessment: acceptRiskAssessment,
            rejectRiskAssessment: rejectRiskAssessment,
            checkoutRiskAssessments: checkoutRiskAssessments,
            checkinRiskAssessments: checkinRiskAssessments

        };

        return service;

        function getRiskAssessments(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = amlCoreUtils.getSortByString( sortBys );

            if ( !pageSize ) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if ( filterStr && filterStr.length >= 0 ) {
                filter = filterStr;

            }

            return riskAssessmentsResource.get( {
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }


        function getRiskAssessment(assessmentId) {
            return riskAssessmentResource.get({
                id: assessmentId
            }).$promise;
        }

        function getRiskAssessmentRiskClassifiers(assessmentId) {
            return riskAssessmentResource.getClassifiers({
                id: assessmentId
            }).$promise;
        }

        /**
         * route an individual risk assessment
         * @param assessmentId
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeRiskAssessment(assessmentId, routeToUser) {

            var routeRiskAssessmentTriageParams = {
                assessmentIds: [assessmentId],
                ownerUserLongId: routeToUser
            };
            return triageRouteRiskAssessmentResource.create({}, routeRiskAssessmentTriageParams).$promise;
        }

        /**
         * route an individual risk assessment
         * @param riskAssessmentNumbers
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeRiskAssessments(riskAssessmentNumbers, routeToUser) {

            var routeRiskAssessmentsTriageParams = {
                assessmentIds: riskAssessmentNumbers,
                ownerUserLongId: routeToUser
            };

            return triageRouteRiskAssessmentsResource.create({}, routeRiskAssessmentsTriageParams).$promise;
        }
        /**
         * accept an individual risk assessment
         * @param assessmentId
         * @returns {$promise|*}
         */

        function acceptRiskAssessment(assessmentId) {

            var acceptRiskAssessmentTriageParams = {
                assessmentIds: [assessmentId]
            };

            return triageAcceptRiskAssessmentResource.create({}, acceptRiskAssessmentTriageParams).$promise;
        }

        /**
         * reject an individual risk assessment
         * @param assessmentId
         * @returns {$promise|*}
         */

        function rejectRiskAssessment(assessmentId) {

            var rejectRiskAssessmentTriageParams = {
                assessmentIds: [assessmentId]
            };

            return triageRejectRiskAssessmentResource.create({}, rejectRiskAssessmentTriageParams).$promise;
        }


        /**
         * checkout (aka claim) an array of riskAssessments
         * @param riskAssessmentNumbers
         * @returns {$promise|*}
         */
        function checkoutRiskAssessments(riskAssessmentNumbers) {
            var checkoutRiskAssessmentsTriageParams = {
                assessmentIds: riskAssessmentNumbers
            };
            return triageCheckoutRiskAssessmentsResource.create({}, checkoutRiskAssessmentsTriageParams).$promise;
        }

        /**
         * checkin (aka return to queue) an array of riskAssessments
         * @param riskAssessmentNumbers
         * @returns {$promise|*}
         */
        function checkinRiskAssessments(riskAssessmentNumbers) {
            var checkinRiskAssessmentsTriageParams = {
                //  riskAssessmentNumbers: riskAssessmentNumbers
                assessmentIds: riskAssessmentNumbers
            };
            return triageCheckinRiskAssessmentaResource.create({}, checkinRiskAssessmentsTriageParams).$promise;
        }

        /**
         * Create a new manual risk assessment
         * @param riskAssessment
         * @returns {angular.IPromise<T>|angular.IPromise<Array<T>>|angular.IPromise<IResourceArray<T>>|*|Function}
         */
        function createManualRiskAssessment( riskAssessment ) {
            return riskAssessmentResource.create( {}, riskAssessment).$promise;
        }

        /**
         * Create a new risk assessment object for use in populating by the user
         * @param customerNumber
         * @param customerName
         * @returns {{assessmentId: null, customerNumber: *, assessmentDate: Date, status: string, partyName: *}}
         */
        function constructNewRiskAssessment( customerNumber, customerName) {
            return {
                assessmentId: null,
                customerNumber: customerNumber,
                assessmentDate: new Date(),
                status: 'ACT',
                partyName: customerName
            };
        }

    }
})();

/**
 * @ngdoc service
 * @name     aml.customer:alertsService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve customers
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    riskFactorsService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "$state"];
    angular
        .module('aml.customer.details')
        .factory('riskFactorsService', riskFactorsService);

    /* @ngInject */
    function riskFactorsService($resource, amlConfig, _, exceptionResourceHandler, $state) {

        /**
         * Resources
         */
        var riskFactorResource = $resource(amlConfig.baseUrl + '/alerts/:id/riskFactors',
            {
                id: '@id'
            }, { get: {
                method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var service = {
            getRiskFactors: getRiskFactors
        };

        return service;

        /////////////////////

        function getRiskFactors(alertid) {
            return riskFactorResource.get({
                id: alertid
            }).$promise;
        }



    }
})();

/**
 * @ngdoc service
 * @name     aml.scenario.data-service
 *
 * @restrict E
 *
 * @description
 * The dataset service is used to retrieve datasets for prep data set variables from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

datasetService.$inject = ["$resource", "amlConfig", "amlConstants", "moment", "_", "exceptionResourceHandler"];
    angular
        .module('aml.scenario')
        .factory('datasetService', datasetService);

    /* @ngInject */
    function datasetService($resource, amlConfig, amlConstants, moment, _, exceptionResourceHandler) {

        /**
         * Resources
         */
        var datasetsResource = $resource(amlConfig.baseUrl + '/datasets',
            {}, {
                get: {
                   params: {type: '@type'},
                   method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });
        var datasetResource = $resource(amlConfig.baseUrl + '/datasets/:dsName',
            {dsName: '@dsName'}, {
                get: {
                    params: {type: '@type'},
                    method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        var service = {
            getDatasets: getDatasets,
            getDataset: getDataset
        };

        return service;

    function getDatasets(product){
        if (product && product==='CDD') {
            return datasetsResource.get({type: product}).$promise;
        }
        return datasetsResource.get({type:'AML'}).$promise;
    }

    function getDataset(name, product){
        if (product && product==='CDD') {
            return datasetResource.get({dsName: name, type: product}).$promise;
        }
        return datasetResource.get({dsName: name, type:'AML'}).$promise;
    }
}
})();
/**
 * @ngdoc service
 * @name     aml.scenario:headerService
 *
 * @restrict E
 *
 * @description
 * The header scenario service is used to retrieve headers from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    headerService.$inject = ["$resource", "amlConfig", "amlConstants", "moment", "_", "exceptionResourceHandler"];
    angular
        .module('aml.scenario')
        .factory('headerService', headerService);

    /* @ngInject */
    function headerService($resource, amlConfig, amlConstants, moment, _, exceptionResourceHandler) {
        var idSeq = 1;

        /**
         * Resources
         */
        var headersResource = $resource(amlConfig.baseUrl + '/headers',
            {}, {
                get: {
                    url: amlConfig.baseUrl + '/headers/:id',
                    params: {id: '@id'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getAll: {
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getNondeleted: {
                    params: {'type': 'NONDELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getDeleted: {
                    params: {'type': 'DELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                //update handles 409 status code, so we do not want to display http error message
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });

        var headersActionResource = $resource(amlConfig.baseUrl + '/headers/:id/actions/:action',
            {id: '@id'}, {
                delete: {
                    params: {action: 'delete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undelete: {
                    params: {action: 'undelete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deleteMultiple: {
                    url: amlConfig.baseUrl + '/headers/actions/delete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undeleteMultiple: {
                    url: amlConfig.baseUrl + '/headers/actions/undelete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });

        function newHeader(headerName) {
            var dateNow = new Date();
            var header = {
                'headerID': -1,
                'name': headerName,
                'description': '',
                'entityLevelCode': '',
                'datasetName': '',
                'alertTableName': '',
                'typeCode': 'SAS Datastep',
                'autogenInd': 'Y',
                'source': '',
                'sourceLocation': '',
                'createUserID': '',
                'createDate': dateNow,
                'lastUpdateUserID': '',
                'lastUpdatedDate': dateNow,
                'hostName': '',
                'logicalDeleteInd': 'N',
                'versionNumber': 0,
                'datasetColumns': []
            };
            return header;
        }

        var headerNames;

        function getHeaderNames(includeDeleted) {
            var headersPromise;
            if (includeDeleted) {
                headersPromise = headersResource.getAll({}).$promise;
            } else {
                headersPromise = headersResource.getNondeleted({}).$promise;
            }
            return headersPromise.then(function (data) {
                var hdrMaxId = _.max(data.items, function (header) {
                    return header.headerID;
                });
                if (idSeq < hdrMaxId.headerID) {
                    idSeq = hdrMaxId.headerID;
                }
                var headers = data.items;
                var names = [];
                for (var i = 0; i < headers.length; i++) {
                    names.push({code: headers[i].name, value: headers[i].name});
                }
                headerNames = names.sort(
                    function (a, b) {
                        if (a.code < b.code) {
                            return -1;
                        } else if (a.code === b.code) {
                            return 0;
                        } else {
                            return 1;
                        }
                    });
                return headerNames;
            });
        }

        function processHeaders (headersPromise) {
            return headersPromise.then(function (data) {
                var hdrMaxId = _.max(data.items, function (header) {
                    return header.headerID;
                });
                if (idSeq < hdrMaxId.headerID) {
                    idSeq = hdrMaxId.headerID;
                }
                return data;
            });
        }

        function getHeaders(showDeleted) {
            var headersPromise;
            if (showDeleted) {
                headersPromise = headersResource.getDeleted({}).$promise;
            } else {
                headersPromise = headersResource.getNondeleted({}).$promise;
            }
            return processHeaders(headersPromise);
        }

        function getAllHeaders() {
            var headersPromise = headersResource.getAll({}).$promise;
            return processHeaders(headersPromise);
        }

        function getHeader(headerId) {
            return headersResource.get({id: headerId}).$promise;
        }

        function updateHeader(headerIn) {
            return headersResource.update({}, headerIn).$promise;
        }

        function createNewHeader(headerIn) {
            return headersResource.create({}, headerIn).$promise;
        }

        function markHeaderAsDeleted(headerId) {
            return headersActionResource.delete({id: headerId}).$promise;
        }

        function markHeaderAsUndeleted(headerId) {
            return headersActionResource.undelete({id: headerId}).$promise;
        }

        function markHeadersAsDeleted(ids) {
            var actionParameters = {
                ids: ids
            };
            return headersActionResource.deleteMultiple({}, actionParameters).$promise;
        }

        function markHeadersAsUndeleted(ids) {
            var actionParameters = {
                ids: ids
            };
            return headersActionResource.undeleteMultiple({}, actionParameters).$promise;
        }

        //one and only one By Variable has to be selected for the prep data se
        function isByVariableValid(header) {
            //function isByVariableValid (header, varName, modelValue, viewValue) {
            var byCounter = 0;
            if (angular.isUndefined(header.datasetColumns)) {
                return true;
            }
            for (var i = 0; i < header.datasetColumns.length; i++) {
                if (header.datasetColumns[i].usageCode === 'By variable') {
                    byCounter++;
                }
            }
            //console.log(varName + ":" +byCounter);
            return (byCounter === 1);
        }

        function typeCodeSelected(header, typeCode) {
            if (typeCode === 'Custom') {
                header.autogenInd = 'N';
                header.datasetName = '';
                header.datasetColumns = [];
            }
        }

        function autogenSelected(header, autogen) {
            if (header.typeCode === 'Custom' || autogen === 'N') {
                header.datasetName = '';
                header.datasetColumns = [];
            }
        }

        function hasSource(header) {
            return header.typeCode === 'SAS Datastep' && header.autogenInd === 'N' || header.typeCode === 'Custom';
        }


        function getNextId() {
            return ++idSeq;
        }

        var service = {
            getHeaders: getHeaders,
            getAllHeaders : getAllHeaders,
            getHeader: getHeader,
            newHeader: newHeader,
            updateHeader: updateHeader,
            createNewHeader: createNewHeader,
            isByVariableValid: isByVariableValid,
            typeCodeSelected: typeCodeSelected,
            autogenSelected: autogenSelected,
            getHeaderNames: getHeaderNames,
            markHeaderAsDeleted: markHeaderAsDeleted,
            markHeadersAsDeleted: markHeadersAsDeleted,
            markHeaderAsUndeleted: markHeaderAsUndeleted,
            markHeadersAsUndeleted: markHeadersAsUndeleted,
            hasSource: hasSource,
            getNextId: getNextId
        };
        return service;
    }
})();
/**
 * @ngdoc service
 * @name     aml.scenario:scenarioService
 *
 * @restrict E
 *
 * @description
 * The scenario service is used to retrieve scenarios from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    scenarioService.$inject = ["$resource", "amlConfig", "amlConstants", "moment", "_", "exceptionResourceHandler"];
    angular
        .module('aml.scenario')
        .factory('scenarioService', scenarioService);

    /* @ngInject */
    function scenarioService($resource, amlConfig, amlConstants, moment, _, exceptionResourceHandler) {
        var idSeq = 1;
        var segmentListPromise = null;
        var segmentList;

        /**
         * Resources
         */
        var segmentsResource = $resource(amlConfig.baseUrl + '/scenarios/segments',
            {}, {
                getAll: {
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });
        var scenariosResource = $resource(amlConfig.baseUrl + '/scenarios',
            {}, {
                get: {
                    url: amlConfig.baseUrl + '/scenarios/:id',
                    params: {id: '@id', includeSource:'@includeSource'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getAll: {
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getNondeleted: {
                    params: {'type' : 'NONDELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getDeleted: {
                    params: {'type' : 'DELETED'},
                    method: 'GET', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                create: {
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                //update handles 409 status code, so we do not want to display http error message
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler}
                }
            });

        var scenariosActionResource = $resource(amlConfig.baseUrl + '/scenarios/:id/actions/:action',
            {id: '@id'}, {
                delete: {
                    params : {action: 'delete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undelete: {
                    params : {action: 'undelete'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                activate: {
                    params : {action: 'activate'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deactivate: {
                    params : {action: 'deactivate'},
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deleteMultiple: {
                    url: amlConfig.baseUrl + '/scenarios/actions/delete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                undeleteMultiple: {
                    url: amlConfig.baseUrl + '/scenarios/actions/undelete',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                activateMultiple: {
                    url: amlConfig.baseUrl + '/scenarios/actions/activate',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                deactivateMultiple: {
                    url: amlConfig.baseUrl + '/scenarios/actions/deactivate',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                export: {
                    url: amlConfig.baseUrl + '/scenarios/actions/export',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                import: {
                    url: amlConfig.baseUrl + '/scenarios/actions/import',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                copy: {
                    url: amlConfig.baseUrl + '/scenarios/actions/copy',
                    method: 'POST', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                run: {
                    url: amlConfig.baseUrl + '/scenarios/actions/test',
                    method: 'POST',
                    cache : false,
                    headers: { 'Accept': 'text/html'},
                    transformResponse: parseHtml,
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            });
        /**
         * We have a parseHtml function that just returns the data in a JSON object; otherwise ngResource
         * seems to want to parse it as JSON and returns ArrayBuffer.
         */
        function parseHtml(data, headersGetter) {
            return { data: data };
        }

        function getScenarios(showDeleted) {
            var scenariosPromise;
            if (showDeleted) {
                scenariosPromise = scenariosResource.getDeleted({}).$promise;
            } else {
                scenariosPromise = scenariosResource.getNondeleted({}).$promise;
            }
            return scenariosPromise.then(function (data) {
                var scrMaxId = _.max(data.items, function(scr){return scr.scenarioID;});
                if (idSeq < scrMaxId.scenarioID) { idSeq = scrMaxId.scenarioID; }
                return data;
            });
        }

        function downloadSegmentList() {
            // This is only called from app.routes.js, root state.
            if(!segmentListPromise) {
                segmentListPromise = segmentsResource.getAll({}).$promise.then(function(data) {
                    segmentList = data;
                    return data;
                });
            }
            return segmentListPromise;
        }

        function getSegments(type) {
            var filterFunction;
            if(type === 'deleted') {
                filterFunction = function(item) {
                    return item.logicalDeleteInd === 'Y';
                };
            }
            else if(type === 'nondeleted') {
                filterFunction = function(item) {
                    return item.logicalDeleteInd === 'N';
                };
            }
            else {
                filterFunction = function (item) {
                    return true;
                };
            }

            return segmentList.items.filter(filterFunction);
        }

        function getScenario(scenarioId) {
            return scenariosResource.get({id: scenarioId}).$promise;
        }

        function getScenarioNoSource(scenarioId) {
            return scenariosResource.get({id: scenarioId, includeSource: false}).$promise;
        }
        function createNewScenario(scenarioIn) {
            return scenariosResource.create(scenarioIn).$promise;
        }

        function newScenario(scenarioName) {
            var dateNow = new Date();
            var scenario = {
                'scenarioID': -1,
                'headerID': -1,
                'orderInHeader': 1,
                'name': scenarioName,
                'description': '',
                'shortDescription': '',
                'productTypeCode': 'AML',
                'scenarioTypeCode': 'CUS',
                'status': 'ACT',
                'categoryCode': '',
                'codeLocation': '',
                'defaultSuppressDurationDaysCount': 0,
                'replicationDaysCount': 1,
                'moneyLaunderingBayesWeight': 5,
                'terrorFinancingBayesWeight': 5,
                'executionProbabilityRate': 0.005,
                'runFrequencyCode': 'D',
                'riskFactorInd': 'N',
                'primaryEntityNumberVariableName' : '',
                'entityLevelCode' : '',
                'routingGroupID': 0,
                'createUserID': '',
                'creationDate': dateNow,
                'endDate': '5999-01-01T05:00:00.000+0000',
                'versionNumber': 1,
                'currentInd': 'Y',
                'logicalDeleteInd': 'N',
                'segmentsEnabledInd': 'N',
                'btlEnabledInd' : 'N',
                'lastUpdate': dateNow,
                'lastUpdateUserID': '',
                'source': '',
                'parms': [],
                'alertColumns': []
            };
            return scenario;
        }

        function updateScenario(scenarioIn) {
            return scenariosResource.update({}, scenarioIn).$promise;
        }

        var scenarioNames;

        function getScenarioNames(includeDeleted) {
            var scenariosPromise;
            if (includeDeleted) {
                scenariosPromise = scenariosResource.getAll({}).$promise;
            } else {
                scenariosPromise = scenariosResource.getNondeleted({}).$promise;
            }
            return scenariosPromise.then(function (data) {
                var scrMaxId = _.max(data.items, function(scr){return scr.scenarioID;});
                if (idSeq < scrMaxId.scenarioID) { idSeq = scrMaxId.scenarioID; }
                var scenarios = data.items;
                var names = [];
                for (var i = 0; i < scenarios.length; i++) {
                    names.push({code: scenarios[i].name, value: scenarios[i].name});
                }

                scenarioNames = _.sortBy(names, function (scr) {
                    return scr.value.toLowerCase();
                });
                return scenarioNames;
            });
        }

        function markScenarioAsDeleted(scenarioId) {
            return scenariosActionResource.delete({id: scenarioId}).$promise;
        }

        function markScenarioAsUndeleted(scenarioId) {
            return scenariosActionResource.undelete({id: scenarioId}).$promise;
        }

        function deleteScenarios(ids) {
            var actionParameters = {
                ids : ids
            };
            return scenariosActionResource.deleteMultiple({}, actionParameters).$promise;
        }

        function undeleteScenarios(ids) {
            var actionParameters = {
                ids : ids
            };
            return scenariosActionResource.undeleteMultiple({}, actionParameters).$promise;
        }

        function activateScenarios(ids) {
            var actionParameters = {
                ids : ids
            };
            return scenariosActionResource.activateMultiple({}, actionParameters).$promise;
        }

        function deactivateScenarios(ids) {
            var actionParameters = {
                ids : ids
            };
            return scenariosActionResource.deactivateMultiple({}, actionParameters).$promise;
        }

        function activateScenario(scenario) {
            scenario.status = 'ACT';
            return scenariosActionResource.activate({id: scenario.scenarioID}).$promise;
        }

        function deactivateScenario(scenario) {
            scenario.status = 'INA';
            return scenariosActionResource.deactivate({id: scenario.scenarioID}).$promise;
        }

        function exportScenarios(ids) {
            var actionParameters = {
                ids : ids
            };
            return scenariosActionResource.export({}, actionParameters).$promise;
        }

        function importScenarios(json) {
            return scenariosActionResource.import({}, json).$promise;
        }

        function runScenarios(params) {
            return scenariosActionResource.run({}, {ids: params.ids, runAsOfDate: params.runAsOfDate,
                                                    displayAlerts: params.displayAlerts, displayTransactions: params.displayTransactions,
                                                    sampleSize: params.sampleSize, headerAction: params.headerAction, msgEncoding: params.messageEncoding}).$promise;
        }

        function copyScenarios(ids, hdrAction) {
            var actionParameters = {
                ids : ids,
                headerAction : hdrAction
            };
            return scenariosActionResource.copy({}, actionParameters).$promise;
        }

        function getNextId () {
            return ++idSeq;
        }

        // parameters for scenario test button
        var runParameters = {
            'ids': [],
            'runDate': null, //do not send this property to rest service - it is not supported
            'runAsOfDate': '',
            'displayAlerts': 'Y',
            'displayTransactions': 'Y',
            'sampleSize': 0,
            'headerAction': 'NONE',
            'messageEncoding': 'utf8'
        };

        var service = {
            getScenarios: getScenarios,
            getScenario: getScenario,
            getScenarioNoSource : getScenarioNoSource,
            getSegments : getSegments,
            newScenario: newScenario,
            updateScenario: updateScenario,
            createNewScenario: createNewScenario,
            getScenarioNames : getScenarioNames,
            markScenarioAsDeleted : markScenarioAsDeleted,
            markScenarioAsUndeleted : markScenarioAsUndeleted,
            deleteScenarios : deleteScenarios,
            undeleteScenarios : undeleteScenarios,
            activateScenario : activateScenario,
            deactivateScenario : deactivateScenario,
            activateScenarios : activateScenarios,
            deactivateScenarios : deactivateScenarios,
            exportScenarios : exportScenarios,
            importScenarios : importScenarios,
            runScenarios: runScenarios,
            copyScenarios : copyScenarios,
            getNextId : getNextId,
            runParameters : runParameters,
            downloadSegmentList : downloadSegmentList
        };
        return service;
    }
})();
/**
 * @ngdoc service
 * @name     aml.scenario:sourceCodeService
 *
 * @restrict E
 *
 * @description
 * The source code service is used to retrieve the scenario source code from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

  sourceCodeService.$inject = ["$resource", "amlConfig", "amlConstants", "moment", "_", "exceptionResourceHandler"];
    angular
        .module('aml.scenario')
        .factory('sourceCodeService', sourceCodeService);

    /* @ngInject */
    function sourceCodeService($resource, amlConfig, amlConstants, moment, _, exceptionResourceHandler) {

        var service = {
            getSourceCode: getSourceCode
        };

        return service;

        function getSourceCode()
            {
              var sc = [
            '/*==============================================================================',
            '|                               SAS SCENARIO FILE',
            '|',
            '| PRODUCT: SAS Anti-Money Laundering',
            '| SYSTEM:  UNIX/WINDOWS',
            '================================================================================',
            '| NAME:            | SAS10002',
            '|                  |',
            '| CATEGORY:        | ATM/Phone Activity',
            '|                  |',
            '| SEVERITY:        | Scenario',
            '|                  |',
            '| FREQUENCY:       | Daily',
            '|                  |',
            '| DURATION:        | 10 days',
            '|                  |',
            '| SUBJECT:         | Account',
            '|                  |',
            '| PREP FILE:       | ACCOUNT_TRANSACTIONS',
            '|                  |',
            '| HEADER FILE:     | account_header',
            '|                  |',
            '| TRIGGER:         | Yes',
            '|                  |',
            '| DAYS CONSIDERED: | Business',
            '================================================================================',
            '',
            'SHORT DESCRIPTION',
            '-----------------',
            'High Velocity ATM Withdrawals',
            '',
            'DESCRIPTION',
            '-----------',
            'An account has a total amount of ATM withdrawals greater than a large',
            'percentage of deposits made in the same time period.',
            '',
            'BUSINESS NOTES',
            '--------------',
            'This scenario calculates the sum of ATM withdrawals and deposits during the',
            'specified time period. If an account exceeds the ATM withdrawal and deposit',
            'thresholds, the scenario calculates that account\'s sum of ATM withdrawals',
            'occurring since the earliest deposit date. If that sum meets or exceeds the',
            'specified percentage of deposits, a match is found. If the number of ATM',
            'withdrawals for an account does not exceed the minimum number for the current',
            'run date, the scenario will exit to prevent the generation of multiple alerts.',
            'This scenario considers business days.',
            '',
            'TECHNICAL NOTES',
            '---------------',
            'Not Applicable',
            '',
            'MESSAGE',
            '-------',
            'r10002_threshold_message = %str(\'Total Deposits = #$ #1;',
            'Total ATM Withdrawals = #$ #2\');',
            '',
            'SAMPLE MESSAGE',
            '--------------',
            'Total Deposits = USD 1,400; Total ATM Withdrawals = USD 2,600',
            '',
            '================================================================================',
            'PARAMETERS',
            '',
            'Name                              Type                Default Value',
            '---------------------------------|-------------------|--------------------------',
            ' p10002_account_type_desc        | Character List    | \'P\'',
            ' p10002_atm_today                | Numeric Constant  | 300',
            ' p10002_credit_indicator         | Character List    | \'C\'',
            ' p10002_debit_indicator          | Character List    | \'D\'',
            ' p10002_deposit_trigger          | Numeric Constant  | 1000',
            ' p10002_mechanism_desc           | Character List    | \'ATM\'',
            ' p10002_num_days                 | Numeric Constant  | 10',
            ' p10002_pct_atm_deposit          | Numeric Constant  | 90',
            ' p10002_status_desc              | Character List    | \'SUCCESS\'',
            '',
            'Descriptions',
            '------------',
            '- p10002_account_type_desc',
            'List denoting valid types of accounts',
            '',
            '- p10002_atm_today',
            'Minimum aggregate amount of valid debits on the current day',
            '',
            '- p10002_credit_indicator',
            'List denoting credit activities',
            '',
            '- p10002_debit_indicator',
            'List denoting debit activities',
            '',
            '- p10002_deposit_trigger',
            'Minimum aggregate credit amount',
            '',
            '- p10002_mechanism_desc',
            'List denoting ATM activities',
            '',
            '- p10002_num_days',
            'Number of business days in interval',
            '',
            '- p10002_pct_atm_deposit',
            'Percentage of aggregate credits withdrawn via ATM',
            '',
            '- p10002_status_desc',
            'List denoting completed transactions',
            '',
            '================================================================================',
            '',
            '================================================================================',
            'Copyright (c) 2012-2013 by SAS Institute Inc., Cary, NC 27513 USA',
            '- All rights reserved',
            '==============================================================================*/',
            '',
            '/*----------------------------------------------------------------------------',
            '    NOTE:> The statement below required for triggering transaction processing',
            '------------------------------------------------------------------------------*/',
            '%let this_macro_name = &sysmacroname;  /* save this macro name */',
            '/*----------------------------------------------------------------------------*/',
            '',
            'retain p10002_begin_date;',
            '',
            '/* This init section should be placed before any goto statements.  This section of',
            '   code will only be run when processing the first BY group of the prep data set.',
            '   Any goto statements placed before it may prevent the init code from being run. */',
            'if run_scenario_init eq 1 then do;',
            '  p10002_begin_date = input(put(rundate_number-&p10002_num_days+1,num_to_date.),8.);',
            'end;',
            '',
            '/* Skip accounts that do not have transactions on the current day */',
            'if date_key{n} < rundate then goto &sysmacroname.;',
            '',
            '/* Exclude accounts based on site-specific requirements */',
            'if upcase(account_type_desc{n}) ^in (&p10002_account_type_desc) then goto &sysmacroname.;',
            '',
            'p10002_total_deposits = 0;',
            'p10002_total_today = 0;',
            'p10002_total_ATM_withdrawals = 0;',
            'p10002_first_dep_date = 99999;',
            '',
            '/* Pass one - total today\'s ATM withdrawals and earliest date of deposits and total of deposits */',
            'do i = n to 1 by -1 while (date_key{i} >= p10002_begin_date);',
            '    /* Current day ATM withdrawals */',
            '    if date_key{i} = rundate and',
            '       upcase(transaction_cdi_code{i}) in (&p10002_debit_indicator) and',
            '       upcase(mechanism_desc{i}) in (&p10002_mechanism_desc) and',
            '       upcase(status_desc{i}) in (&p10002_status_desc)',
            '    then do;',
            '        p10002_total_today = sum(p10002_total_today,currency_amount{i});',
            '    end;',
            '    /* All deposits in interval, tracking earliest date */',
            '    if p10002_begin_date <= date_key{i} <= rundate and',
            '       upcase(transaction_cdi_code{i}) in (&p10002_credit_indicator) and',
            '       upcase(status_desc{i}) in (&p10002_status_desc)',
            '    then do;',
            '        p10002_total_deposits = sum(p10002_total_deposits,currency_amount{i});',
            '        %fcf_save_transaction_key (calling_macro=&this_macro_name);',
            '        if date_key{i} < p10002_first_dep_date then p10002_first_dep_date = date_key{i};',
            '    end;',
            'end;',
            '',
            '/* Pass two if necessary - if today\'s ATM withdrawals and total deposits exceed parameters   */',
            'if p10002_total_today >= &p10002_ATM_today and',
            '   p10002_total_deposits >= &p10002_deposit_trigger',
            'then do;',
            '    do i = n to 1 by -1 while (date_key{i} >= p10002_first_dep_date);',
            '        if p10002_first_dep_date <= date_key{i} <= rundate and',
            '           upcase(transaction_cdi_code{i}) in (&p10002_debit_indicator) and',
            '           upcase(mechanism_desc{i}) in (&p10002_mechanism_desc) and',
            '           upcase(status_desc{i}) in (&p10002_status_desc)',
            '        then do;',
            '            p10002_total_ATM_withdrawals = sum(p10002_total_ATM_withdrawals,currency_amount{i});',
            '            %fcf_save_transaction_key (calling_macro=&this_macro_name);',
            '        end;',
            '    end;',
            'end;',
            '',
            '/* Skip final calculations if possible */',
            'else goto &sysmacroname.;',
            '',
            '/* Compare account values to parameters for a match */',
            'p10002_pct_withdrawn = (p10002_total_ATM_withdrawals/p10002_total_deposits) * 100;',
            '',
            'if p10002_pct_withdrawn > &p10002_pct_ATM_deposit then do;',
            '    actual_values_text  =  tranwrd(&r10002_threshold_message,\'#1\',kstrip(put(p10002_total_deposits,nlnum32.)) );',
            '    actual_values_text  =  tranwrd(actual_values_text,\'#2\',kstrip(put(p10002_total_ATM_withdrawals,nlnum32.)) );',
            '    actual_values_text  =  tranwrd(actual_values_text,\'#$\', \'&currency_code\' );',
            '    output &alert_fname;',
            'end;',
            '',
            '/* EXIT */',
            '&sysmacroname.:;',
            '',
            '',
            '/* ========================================================================== */',
            '/* END SCENARIO - SAS10002                                                    */',
            '/* ========================================================================== */',
            ''];
            return sc;
          }
  }
})();
(function() {
    'use strict';

    searchService.$inject = ["$resource", "exceptionResourceHandler", "kendoGridRendererService", "entityService", "$state", "messageService", "resources", "amlConfig", "amlConstants", "moment"];
    angular.module('aml.search').factory('searchService', searchService);

    function searchService($resource, exceptionResourceHandler, kendoGridRendererService,
                           entityService, $state, messageService, resources, amlConfig,
                           amlConstants, moment) {
        var noLimitChar = '*';
        var solrUri = amlConfig.baseUrl + '/solr/aml/select';

        var solrResource = $resource(solrUri,
            {
                q: '@q',
                fl: '@fl',
                start: '@start',
                rows: '@rows',
                sort: '@sort'
            },
            {
                getJson: {
                    method: 'GET',
                    params: {
                        wt: 'json'
                    },
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                },
                getCsv: {
                    method: 'GET',
                    params: {
                        wt: 'csv'
                    },
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler},
                    transformResponse: function(data) {
                        return {data: data};
                    }
                }
            }
        );

        function globalSearch(searchTerm, start, rows) {
            return solrResource.getJson({
                q: searchTerm,
                start: start,
                rows: rows
            }).$promise;
        }

        function SearchField(name, value, type) {
            // If neither name nor value is an array, search name for value.
            // If name is an array and value is not, search all names for value.
            // If value is an array of 2 and name is a string, value is a range.
            this.name = name;
            this.value = value;

            // type must be 'date' or 'number' if value is an array
            // otherwise, it's undefined
            this.type = type;
        }
        SearchField.prototype.nameColonValue = function() {
            /*jshint maxcomplexity:11 */
            if(Array.isArray(this.name) && !Array.isArray(this.value)) {
                // return something like '(account_name:*mike* OR customer_name:*mike*)'
                var orParam = [];
                var that = this;

                this.name.forEach(function(solrColName) {
                    orParam.push(solrColName + ':*' + escape(that.value) + '*');
                });
                return '(' + orParam.join(' OR ') + ')';
            }
            else if(Array.isArray(this.value) && this.value.length === 2) {
                if(this.type === 'date') {
                    // return something like 'create_date:[2000-11-01T00:00:00Z TO 2014-12-01T23:59:59Z]'
                    return this.name +
                        ':[' +
                        solrDate(this.value[0], true) +
                        ' TO ' +
                        solrDate(this.value[1], false) +
                        ']';
                }
                else if(this.type === 'number') {
                    // return something like 'risk_score:[47 TO 83]'
                    return this.name +
                        ':[' +
                        (this.value[0] ? this.value[0] : noLimitChar) +
                        ' TO ' +
                        (this.value[1] ? this.value[1] : noLimitChar) +
                        ']';
                }
            }
            else {
                // return something like 'account_name:*mike*' or 'account_type:C'
                // S1362055: If there's a space in the search term, don't wrap it in asterisks.
                if(
                    this.noWildcard ||
                    this.value.includes(' ') ||
                    this.value.includes('"') ||
                    this.name === 'doc_type')
                {
                    return this.name + ':' + escape(this.value);
                }
                else {
                    return this.name + ':*' + escape(this.value) + '*';
                }
            }

            function escape(str) {
                // Escape each special character with backslash
                ['\\', ' ', '+', '-', '&&', '||', '!', '(', ')', '{', '}', '[', ']',
                    '^', '"', '~', '*', '?', ':'].forEach(function(element) {
                        str = str.split(element).join('\\' + element);
                });

                return str;
            }

            function solrDate(date, startOfDay) {
                if(date) {
                    var m = moment(date).utc();

                    if(!startOfDay) {
                        // The user can only enter dates, not times. For the
                        // start of a date range, the moment object has a
                        // time of 00:00:00. For the end of a date range, the
                        // moment object is given a time of 11:59:59.999.
                        m.add(1, 'day').subtract(1, 'milliseconds');
                    }

                    return m.format('YYYY[-]MM[-]DD[T]HH[:]mm[:]ss[Z]');
                }
                else {
                    return noLimitChar;
                }
            }
        };
        SearchField.prototype.isSet = function() {
            // function returns truthy value if user has entered something in this field
            if(Array.isArray(this.value)) {
                return this.value[0] || this.value[1];
            }
            else {
                return this.value;
            }
        };

        function solrParams(fields) {
            var flParam = [];
            var qParam = [];

            for(var key in fields) {
                if(fields.hasOwnProperty(key)){
                    var element = fields[key];
                    if(Array.isArray(element.name)) {
                        flParam = flParam.concat(element.name);
                    }
                    else {
                        flParam.push(element.name);
                    }
                    if (element.isSet()) {
                        qParam.push(element.nameColonValue());
                    }
                }
            }

            return {
                flParam: flParam.join(','),
                qParam: qParam.join(' AND ')
            };
        }

        function processQuery(fields, start, rows, sortByString, wt) {
            var sp = solrParams(fields);
            var params = {
                q: sp.qParam,
                fl: sp.flParam,
                start: start,
                rows: rows,
                sort: sortByString
            };

            if(wt === 'json') {
                return solrResource.getJson(params).$promise;
            }
            else if(wt === 'csv') {
                return solrResource.getCsv(params).$promise;
            }
        }

        function getSolrSortString(data) {
            return kendoGridRendererService.getSortByString(
                kendoGridRendererService.getSortColumns(
                    data,
                    'score',
                    'desc',
                    'asc',
                    'desc'
                ),
                ' '
            );
        }

        function searchGridOptions(dataSourceOptions) {
            return kendoGridRendererService.initGridOptionsWithDefaults({
                autoBind: true,
                filterable: false,
                dataSource: new kendo.data.DataSource(dataSourceOptions),
                height: 400,
                pageable: false,
                scrollable: {
                    virtual: true
                }
            });
        }

        function commonSearch(vm, fields, $scope, entityNumberName, entityNameName, entityLevelCode) {
            var dataSourceOptions = {
                transport: {read: getSearchResults},
                schema: {
                    model: {fields: fields},
                    data: 'docs',
                    total: 'numFound'
                },
                pageSize: vm.pageSize || 50,
                serverPaging: true,
                serverSorting: true
            };

            vm.submitButton = function() {
                if(!vm.searchSubmitted) {
                    activate();
                    vm.searchSubmitted = true;
                }
                else {
                    vm.gridOptions.dataSource.read();
                }
            };

            vm.exportToCSV = function() {
                processQuery(
                    vm.model,
                    0,
                    1000000,
                    null,
                    'csv'
                ).then(function (result) {
                    if (result && result.data) {
                        var blob = new Blob([result.data]);

                        if(window.navigator.msSaveOrOpenBlob) {
                            // Internet Explorer
                            window.navigator.msSaveOrOpenBlob(blob,
                                resources.aml.search.csvFileName + amlConstants.csvFileExtension);
                        }
                        else {
                            // Normal browsers
                            var hiddenLinkElement = document.createElement('a');
                            hiddenLinkElement.href = window.URL.createObjectURL(
                                blob,
                                {type: 'text/csv'}
                            );

                            hiddenLinkElement.download = resources.aml.search.csvFileName +
                                amlConstants.csvFileExtension;
                            document.body.appendChild(hiddenLinkElement);
                            hiddenLinkElement.click();
                            document.body.removeChild(hiddenLinkElement);
                        }
                    }
                    else {
                        messageService.info(resources.aml.search.noResultsToExport);
                    }
                });
            };

            function activate() {
                vm.gridOptions = searchGridOptions(dataSourceOptions);
                kendoGridRendererService.initialize(
                    vm,
                    vm.grid,
                    vm.gridOptions,
                    $scope,
                    handleDoubleClick,
                    'targetedSearchResults' + entityLevelCode
                );
                vm.customActions = [
                    {id: 'exportCsv', label: resources.aml.grid.actions.exportTitle, action:vm.exportToCSV}
                ];
            }

            function handleDoubleClick(evt) {
                var selectedEntity = vm.grid.dataItem(evt.currentTarget);

                selectedEntity.entityNumber = selectedEntity[entityNumberName];
                selectedEntity.entityName = selectedEntity[entityNameName];
                selectedEntity.entityLevelCode = entityLevelCode;

                // For external parties only.
                selectedEntity.entityKey = selectedEntity.entityNumber;

                var entityState = entityService.getStateForEntity(selectedEntity);
                if(entityState.stateName) {
                    // Everything except watch list: new state
                    $state.go(entityState.stateName, entityState.stateParams);
                }
            }

            function getSearchResults(gridCallback) {
                var pageInfo = kendoGridRendererService.getPageInfo(
                    gridCallback.data,
                    vm.gridOptions.dataSource.pageSize
                );

                processQuery(
                    vm.model,
                    pageInfo.start,
                    pageInfo.limit,
                    getSolrSortString(gridCallback.data),
                    'json'
                ).then(function(data) {
                    vm.resultsCount = data.response.numFound;
                    gridCallback.success(data.response);
                });
            }
        }

        return {
            SearchField: SearchField,
            searchGridOptions: searchGridOptions,
            commonSearch: commonSearch,
            processQuery: processQuery,
            globalSearch: globalSearch
        };
    }
})();
(function () {
    'use strict';

    segmentListService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.admin')
        .factory('segmentListService', segmentListService);


    function segmentListService($resource, amlConfig, exceptionResourceHandler) {


        //the url here is: http://dxxxxxx.na.sas.com:8780/SASComplianceSolutionsMid/rest so add the /segments
        var segmentResource = $resource(amlConfig.baseUrl + '/segments',
            {},     //empty, we just send the segment object -- Spring serializes/de-serializes to java object of type Segment when requested
            {
                create: {
                    method: 'POST',
                    interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
                },
                get: {
                    params: {type: '@type'},
                    method: 'GET',
                    interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
                },
                update: {
                    method: 'PUT', interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                    //this is idempotent, resource change is independent of number of times requested
                }
            }
        );


        function createSegment(segment) {
            return segmentResource.create( segment ).$promise;
        }

        function getSegments(type) {
            return segmentResource.get({ type: type }).$promise;
        }

        function updateSegment(segment) {       //used for updating a logically deleting a segment
            return segmentResource.update( segment ).$promise;
        }


        var service = {

            getSegments: getSegments,
            createSegment: createSegment,
            updateSegment: updateSegment

        };


        return service;

    }
})();

(function () {
    'use strict';

    transactionDetailsService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.customer')
        .factory('transactionDetailsService', transactionDetailsService);

    /* @ngInject */
    function transactionDetailsService($resource, amlConfig, exceptionResourceHandler) {

        /**
         * Resources
         */

        var transactionResource = $resource(amlConfig.baseUrl + '/transactions/:id', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });


        var service = {

            getTransaction: getTransaction

        };

        return service;

        function getTransaction(transactionid) {
//console.log("transactionDetailsServicegetTransaction Call 00003");
            return transactionResource.get({
                id: transactionid
            }).$promise;
        }
    }
})();

/**
 * Created by Omkar on 1/22/2015.
 */
(function () {
    'use strict';

    fundsTrackerService.$inject = ["$resource", "resources", "amlConfig", "exceptionResourceHandler", "$state", "baseCurrencyFilter", "_"];
    angular.module('aml').factory('fundsTrackerService', fundsTrackerService);

    //Global links and nodes for the fundstracker
    var links = {}, nodes = {};
    var linksAll = {};

    /* jshint maxstatements: 20000 */
    function fundsTrackerService($resource, resources, amlConfig,
                                 exceptionResourceHandler, $state, baseCurrencyFilter, _) {

        // define resources
        var networkResource = $resource(amlConfig.baseUrl + '/accounts/:accountNumber/fundsTracker', {
            accountNumber: '@accountNumber'
        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        var transactionResource = $resource(amlConfig.baseUrl + '/accounts/:accountNumber/fundsTracker/transactionsDetails', {}, {
            get: {
                params: {accountNumber: '@accountNumber', fromNode: 'fromNode', toNode: 'toNode'},
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        function getNetwork(accountNumber) {
            return networkResource.get({
                accountNumber: accountNumber
            }).$promise;
        }

        function getTransactionResource(accountNumber, fromNode, toNode) {
            return transactionResource.get({
                accountNumber: accountNumber,
                fromNode: fromNode,
                toNode: toNode
            }).$promise;
        }

        var onLinkSelect;
        function setonLinkSelect(onLinkSelectControllerFunction){
            onLinkSelect = onLinkSelectControllerFunction;
        }

        function clearLinks(fundsTrackerId){
            linksAll[fundsTrackerId] = [];
        }

        //to get the max amount of transaction in the list of aggregated transactions
        function maxCurrencyAmount(linksNew){
            return _.max(linksNew, function(obj) {
                return obj.currencyAmount;
            }).currencyAmount ;
        }
        //to get the min amount of transaction in the list of aggregated transactions
        function minCurrencyAmount(linksNew){
            return _.min(linksNew, function(obj) {
                return obj.currencyAmount;
            }).currencyAmount ;
        }

        function step(linksNew){
            var max = _.max(linksNew, function(obj) {
                    return obj.currencyAmount;
                }).currencyAmount ;
            var min =  _.min(linksNew, function(obj) {
                    return obj.currencyAmount;
                }).currencyAmount ;
            var stepVal = (min + max) / 2;
            return stepVal;
        }

        function sankey(linksNew, accountNumber, activate, minThreshold, maxThreshold, fundsTrackerId) {
            /*jshint maxcomplexity:18*/
            //linksNew has the following propertiez:
            // currencyAmount: 1616362
            // date: "2015-12-01T05:00:00.000+0000"
            // degree: 1
            // edgeTypeCode: "R"
            // fromCustomer: "BETH WRAY"
            // fromNode: "01-0000033659"
            // toCustomer: "FRANK YOUNG"
            // toNode: "03-0000280969"

            //this is really cool
           linksAll[fundsTrackerId]=linksAll[fundsTrackerId] ? linksAll[fundsTrackerId].concat(linksNew) : linksNew;
           var svgUniqueId = [];
           svgUniqueId.push('svg' + fundsTrackerId);
            //calculate the height and width of the sankey depending on the width of the actual data

            var tooltip, biHiSankey, path, defs, colorScale, highlightColorScale, isTransitioning, i, j,
                targetLinks, //a list of links from account to account
                targetNodes;


            //create a list of links from account to account
            targetLinks = _.map(linksAll[fundsTrackerId], function(obj){ return {
                                    source: obj.fromNode, target: obj.toNode, degree: obj.degree, value: obj.currencyAmount };});

            //create a nodes array with distinct values from the links array
            var nodesArray = []; // a list of all accounts and all customers
            var len = linksAll[fundsTrackerId].length;

            //create a list of all accounts and all customers
            for(i = 0; i < len; i++){
                for(var key in linksAll[fundsTrackerId][i]){
                    if(key === 'fromNode' || key ==='toNode' || key === 'fromCustomer' || key === 'toCustomer'){
                        nodesArray.push(linksAll[fundsTrackerId][i][key]);
                    }
                }
            }

            //create an object array with parent

            var count = 0;
            var newArray = []; // list of {id: account, parent:owner} pairs

            if(nodesArray.length !== 0){
                do{
                    newArray.push({
                        id: nodesArray[count],
                        parent: nodesArray[count+1]
                    });
                    count += 2;
                }while(count < nodesArray.length);
            }


            //final array.
            //we will add and append this array with the parents
            var nodesDistinctArray = []; //list of unique nodes for pairs: {account, owner}
            nodesDistinctArray = _.uniq(newArray, false, function(obj){return obj.id + obj.parent;});

            //this array will be used only to map the indices of the elements of nodes to links
            var nodesArrayForIndexing = _.map(nodesDistinctArray, function(obj){return obj.id;});

            //need to add a parent(owner) property to each object in this array {parent: owner, name: account}
            var nodesIndexed = _.map(nodesDistinctArray, function(obj, index){return { id: index,
                parent: obj.parent,  //owner
                name: obj.id};});    //account


            //creating an array with only parents
                var nodeswithParentsandID = _.map(nodesDistinctArray,function(obj){return {
                    type: obj.parent.concat('P'), //owner+'P'
                    id: obj.id.concat(obj.parent).replace(/\s/g, ''), //account+owner
                    parent: null,
                    name: obj.parent};});  //name:owner


            //this section will give us the final nodesArray:
            for(i = 0; i < nodesIndexed.length; i++){
                for(j = 0; j < nodeswithParentsandID.length; j++){
                    if(nodesIndexed[i].parent === nodeswithParentsandID[j].name){
                        nodesIndexed[i].displayName = nodeswithParentsandID[j].name;
                        nodesIndexed[i].parent = nodeswithParentsandID[j].id;
                        nodesIndexed[i].type = nodeswithParentsandID[j].type;
                    }
                }
            }

                //-------------------------------final datasets------------------------------------->>
                //append the array which contains parent elements and rest of the array:
            targetNodes = nodeswithParentsandID.concat(nodesIndexed);


            var TYPES = _.uniq(_.map(targetNodes, function(obj){return obj.type;}), false, function(obj){return obj;});
            //substituting the source and target nodes of targetLinks with the respective index:
            for(i = 0; i < targetLinks.length; i++){
                targetLinks[i].source = nodesArrayForIndexing.indexOf(targetLinks[i].source);
                targetLinks[i].target = nodesArrayForIndexing.indexOf(targetLinks[i].target);
            }

            /**
             * each time the funds tracker will be populated, it will get a random contrasting color
             * to the parent nodes. The same color will be replicated by the children.
             * The getRandomColor function will be called each time new dataset is being populated.
             * Consider this function to be a blackbox
             * @param brightness
             * @returns {string}
             */

            function getRandColor(brightness){
                //6 levels of brightness from 0 to 5, 0 being the darkest
                var rgb = [Math.random() * 256, Math.random() * 256, Math.random() * 256];
                var mix = [brightness*51, brightness*51, brightness*51]; //51 => 255/5
                var mixedrgb = [rgb[0] + mix[0], rgb[1] + mix[1], rgb[2] + mix[2]].map(function(x){ return Math.round(x/2.0);});
                return 'rgb(' + mixedrgb.join(',') + ')';
            }

            var TYPE_COLORS = [];
            for(j = 0; j < TYPES.length; j++){TYPE_COLORS[j] = getRandColor(4);}
            var TYPE_HIGHLIGHT_COLORS = TYPE_COLORS;

            /**
             * using the minThreshold and maxThreshold to filter the dataset.
             * Simply get the value of the transaction and filter based on the values.
             * This is the final links dataset which will be used to populate the graph
             */
            if(minThreshold && maxThreshold){
                links[fundsTrackerId]= _.filter(targetLinks, function(e){
                    return (e.value >= minThreshold && e.value <= maxThreshold);
                });
            }else if(minThreshold){
                links[fundsTrackerId]= _.filter(targetLinks, function(e){
                    return (e.value >= minThreshold);
                });
            }else if(maxThreshold){
                links[fundsTrackerId]= _.filter(targetLinks, function(e){
                    return (e.value <= maxThreshold);
                });
            }else{
                links[fundsTrackerId] = targetLinks;
            }

            /**
             * This is a final nodes dataset.
             * links and nodes are two arrays of arrays. At each fundstrackerID, respective links
             * and nodes will be saved.
             * @type {Array.<*>|T[]|Array[]|*}
             */
            nodes[fundsTrackerId] = targetNodes;

            /*--------------------------------------------------------------------------------------------------------*/

            /**
             * Some basic initial hardcoded values to determine the animation
             * @type {{NODE_DEFAULT: number, NODE_FADED: number, NODE_HIGHLIGHT: number, LINK_DEFAULT: number, LINK_FADED: number, LINK_HIGHLIGHT: number}}
             */
            var OPACITY = {
                    NODE_DEFAULT: 0.9,
                    NODE_FADED: 0.1,
                    NODE_HIGHLIGHT: 0.8,
                    LINK_DEFAULT: 0.6,
                    LINK_FADED: 0.05,
                    LINK_HIGHLIGHT: 0.9
                },

                LINK_COLOR = '#b3b3b3',
                INFLOW_COLOR = '#2E86D1',
                OUTFLOW_COLOR = '#D63028',
                NODE_WIDTH = 100,
                COLLAPSER = {

                    RADIUS: NODE_WIDTH / 3,
                    SPACING: 10
                },
                OUTER_MARGIN = 10,
                MARGIN = {
                    TOP: 2 * (COLLAPSER.RADIUS + OUTER_MARGIN),
                    RIGHT: OUTER_MARGIN,
                    BOTTOM: OUTER_MARGIN,
                    LEFT: OUTER_MARGIN
                },
                TRANSITION_DURATION = 400,
                HEIGHT = 800 - MARGIN.TOP - MARGIN.BOTTOM,
                WIDTH = 1500 - MARGIN.LEFT - MARGIN.RIGHT,
                LAYOUT_INTERATIONS = 32;

                // Used when temporarily disabling user interractions to allow animations to complete
                var disableUserInterractions = function (time) {
                    isTransitioning = true;
                    setTimeout(function(){
                        isTransitioning = false;
                    }, time);
                },

                hideTooltip = function () {
                    return tooltip.transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', 0);
                },

                showTooltip = function () {
                    return tooltip
                        .style('left', d3.event.pageX + 'px')
                        .style('top', d3.event.pageY + 30 + 'px')
                        .transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', 1);
                };

            /**
             * domId and domIdLog are two unique div id's which will be used to attach svg's to.
             * This will help to create new divs each time a new fundstracker will be created.
             * domIdLog will be unique div id for the 'Network Logger' which is at the bottom of the graph.
             * @type {string}
             */
            var domId = '#fundstracker-' + accountNumber;
            var domIdLog = '#fundstracker-' + accountNumber + 'Log';
            colorScale = d3.scale.ordinal().domain(TYPES).range(TYPE_COLORS);
            highlightColorScale = d3.scale.ordinal().domain(TYPES).range(TYPE_HIGHLIGHT_COLORS);


            /**
             * The actual drawing starts. svg1 is the first svg which is created.
             * It will be created with the domID. DomID is 'fundstracker' + accountNumber.
             * So no two fundstrackers will have the same svgs.
             */
            var svg1 = d3.select(domId).append('svg')
                    .attr('width', WIDTH + MARGIN.LEFT + MARGIN.RIGHT)
                    .attr('height', HEIGHT + MARGIN.TOP + MARGIN.BOTTOM)
                    .append('g')
                    .attr('transform', 'translate(' + MARGIN.LEFT + ',' + MARGIN.TOP + ')');

            /**
             * create a grouping element g.
             * Append links, nodes and collapsers to it.
             * They are main elements of the fundstracker.
             */
           svg1.append('g').attr('id', 'links');
           svg1.append('g').attr('id', 'nodes');
           svg1.append('g').attr('id', 'collapsers');

            /**
             * tooltip styling and attaching it to the same domId.
             */
            tooltip = d3.select(domId).append('div').attr('id', 'tooltip');

            tooltip.style('opacity', 0)
                .append('p')
                .attr('class', 'tooltip')
                .attr('class', 'value');

            /**
             * This is the most important function of all. You can consider this as a black box as well.
             * This function will essential to compute new x and y coordinates of the svgs when double clicked.
             * Also, the function computes new height, width, new positions while the parent node is broken
             * into child nodes.
             * Unless and until you want to change the position, alignment and orientation of the expanded nodes
             * and links, there is no need to get into this function. you can keep this function steady.
             * @returns {{}}
             */
            var computeNewPositions = function () {

                var biHiSankey = {},
                    nodeWidth = 35,
                    nodeSpacing = 25,
                    linkSpacing = 4,
                    arrowheadScaleFactor = 0, // Specifies the proportion of a link's stroke width to be allowed for the marker at the end of the link.
                    size = [1, 1], // default to one pixel by one pixel
                    nodes = [],
                    nodeMap = {},
                    parentNodes = [],
                    leafNodes = [],
                    links = [],
                    xScaleFactor = 1,
                    yScaleFactor = 1,
                    defaultLinkCurvature = 1;

                function center(node) {
                    return node.y + node.height / 2;
                }

                function value(link) {
                    return link.value;
                }

                function initializeNodeArrayProperties(node) {
                    node.sourceLinks = [];
                    node.rightLinks = [];
                    node.targetLinks = [];
                    node.leftLinks = [];
                    node.connectedNodes = [];
                    node.children = [];
                    node.ancestors = [];
                }

                // generates the nodeMap {'1': <node1>, '2': <node2>}
                // and initializes the array properties of each node
                function initializeNodeMap() {
                    nodes.forEach(function (node) {
                        nodeMap[node.id] = node;
                        initializeNodeArrayProperties(node);
                    });
                }

                function computeLeafNodes() {
                    leafNodes = nodes.filter(function (node) {
                        return !node.children.length;
                    });
                }

                function computeParentNodes() {
                    parentNodes = nodes.filter(function (node) {
                        return node.children.length;
                    });
                }

                function addAncestorsToChildren(node) {
                    node.children.forEach(function (child) {
                        child.ancestors = child.ancestors.concat(this.ancestors.concat([this]));
                        addAncestorsToChildren(child);
                    }, node);
                }

                // generate hierarchical connections between parent and child nodes
                function computeNodeHierarchy() {
                    var parent,
                        rootNodes = [];

                    nodes.forEach(function (node) {
                        parent = nodeMap[node.parent];
                        if (parent) {
                            node.parent = parent;
                            parent.children.push(node);
                        } else {
                            node.parent = null;
                            rootNodes.push(node);
                        }
                    });

                    computeLeafNodes();
                    computeParentNodes();

                    rootNodes.forEach(function (rNode) {
                        addAncestorsToChildren(rNode);
                    });
                }

                // Populate the sourceLinks and targetLinks for each node.
                function computeNodeLinks() {
                    var sourceNode, targetNode;
                    links.forEach(function (link) {
                        sourceNode = nodeMap[link.source] || link.source;
                        targetNode = nodeMap[link.target] || link.target;
                        link.id = link.source + '-' + link.target;
                        link.source = sourceNode;
                        link.target = targetNode;
                        sourceNode.sourceLinks.push(link);
                        targetNode.targetLinks.push(link);
                    });
                }

                function visible(linkCollection) {
                    return linkCollection.filter(function (link) {
                        return link.source.state === 'collapsed' && link.target.state === 'collapsed';
                    });
                }

                // When child nodes are collapsed into their parents (or higher ancestors)
                // the links between the child nodes should be represented by links
                // between the containing ancestors. This function adds those extra links.
                function computeAncestorLinks() {
                    // Leaf nodes are never parents of other nodes
                    // Duplicate source and target links between a leaf node and another leaf node
                    // and add to the leaf nodes' parents
                    leafNodes.forEach(function (leafNode) {
                        leafNode.sourceLinks.forEach(function (sourceLink) {
                            var ancestorTargets,
                                target = sourceLink.target;
                            if (leafNodes.indexOf(target) >= 0) {
                                ancestorTargets = target.ancestors.filter(function (tAncestor) {
                                    return leafNode.ancestors.indexOf(tAncestor) < 0;
                                });
                                ancestorTargets.forEach(function (ancestorTarget) {
                                    var ancestorLink = {
                                        source: leafNode,
                                        target: ancestorTarget,
                                        value: sourceLink.value,
                                        id: leafNode.id + '-' + ancestorTarget.id
                                    };

                                    leafNode.sourceLinks.push(ancestorLink);
                                    ancestorTarget.targetLinks.push(ancestorLink);
                                    links.push(ancestorLink);
                                });
                            }
                        });

                        leafNode.targetLinks.forEach(function (targetLink) {
                            var ancestorSources, source = targetLink.source;
                            if (leafNodes.indexOf(source) >= 0) {
                                ancestorSources = source.ancestors.filter(function (sAncestor) {
                                    return leafNode.ancestors.indexOf(sAncestor) < 0;
                                });
                                ancestorSources.forEach(function (ancestorSource) {
                                    var ancestorLink = {
                                        source: ancestorSource,
                                        target: leafNode,
                                        value: targetLink.value,
                                        id: ancestorSource.id + '-' + leafNode.id
                                    };
                                    ancestorSource.sourceLinks.push(ancestorLink);
                                    leafNode.targetLinks.push(ancestorLink);
                                    links.push(ancestorLink);
                                });
                            }
                        });
                    });

                    // Add links between parents (for when both parents are in collapsed state)
                    parentNodes.forEach(function (parentNode) {
                        parentNode.sourceLinks.forEach(function (sourceLink) {
                            var ancestorTargets, target = sourceLink.target;
                            if (leafNodes.indexOf(target) >= 0) {
                                ancestorTargets = target.ancestors.filter(function (tAncestor) {
                                    return parentNode.ancestors.indexOf(tAncestor) < 0;
                                });
                                ancestorTargets.forEach(function (ancestorTarget) {
                                    var ancestorLink = {
                                        source: parentNode,
                                        target: ancestorTarget,
                                        value: sourceLink.value,
                                        id: parentNode.id + '-' + ancestorTarget.id
                                    };

                                    parentNode.sourceLinks.push(ancestorLink);
                                    ancestorTarget.targetLinks.push(ancestorLink);
                                    links.push(ancestorLink);
                                });
                            }
                        });
                    });
                }

                // To reduce clutter in the diagram merge links that are from the
                // same source to the same target by creating a new link
                // with a value equal to the sum of the values of the merged links
                function mergeLinks() {
                    var linkGroups = d3.nest()
                        .key(function (link) {
                            return link.source.id + '->' + link.target.id;
                        })
                        .entries(links)
                        .map(function (object) {
                            return object.values;
                        });

                    links = linkGroups.map(function (linkGroup) {
                        return linkGroup.reduce(function (previousLink, currentLink) {
                            return {
                                'source': previousLink.source,
                                'target': previousLink.target,
                                'id': d3.min([previousLink.id, currentLink.id]),
                                'value': previousLink.value + currentLink.value
                            };
                        });
                    });
                }

                function nodeHeight(sideLinks) {
                    var spacing = Math.max(sideLinks.length - 1, 0) * linkSpacing,
                        scaledValueSum = d3.sum(sideLinks, value) * yScaleFactor;
                    return scaledValueSum + spacing;
                }

                // Compute the value of each node by summing the associated links.
                // Compute the number of spaces between the links
                // Compute the number of source links for later decrementing
                function computeNodeValues() {
                    nodes.forEach(function (node) {
                        node.value = Math.max(
                            d3.sum(node.leftLinks, value),
                            d3.sum(node.rightLinks, value)
                        );
                        node.netFlow = d3.sum(visible(node.targetLinks), value) - d3.sum(visible(node.sourceLinks), value);
                        node.height = Math.max(nodeHeight(visible(node.leftLinks)), nodeHeight(visible(node.rightLinks)));
                        node.linkSpaceCount = Math.max(Math.max(node.leftLinks.length, node.rightLinks.length) - 1, 0);
                    });
                }

                function computeConnectedNodes() {
                    var sourceNode, targetNode;
                    links.forEach(function (link) {
                        sourceNode = link.source;
                        targetNode = link.target;
                        if (sourceNode.connectedNodes.indexOf(targetNode) < 0) {
                            sourceNode.connectedNodes.push(targetNode);
                        }
                        if (targetNode.connectedNodes.indexOf(sourceNode) < 0) {
                            targetNode.connectedNodes.push(sourceNode);
                        }
                    });
                }

                /**
                 * the following functions viz. sourceAndTargetNodesWithSameX() and compressinXDirection()
                 * will define the x-coordinate for the nodes and their positions
                 * @returns {Array}
                 */
                function sourceAndTargetNodesWithSameX() {
                    var nodeArray = [];
                    links.filter(function (link) {
                        return link.target.x === link.source.x;
                    }).forEach(function (link) {
                        if (nodeArray.indexOf(link.target) < 0) {
                            nodeArray.push(link.target);
                        }
                    });
                    return nodeArray;
                }

                function compressInXDirection() {
                    var connectedNodesXPositions,
                        nodesByXPosition = d3.nest()
                            .key(function (node) {
                                return node.x;
                            })
                            .sortKeys(d3.ascending)
                            .entries(nodes)
                            .map(function (object) {
                                return object.values;
                            });

                    nodesByXPosition.forEach(function (xnodes) {
                        xnodes.forEach(function (node) {
                            connectedNodesXPositions = node.connectedNodes.map(function (connectedNode) {
                                return connectedNode.x;
                            });
                            // keep decrementing the x value of the node
                            // unless it would have the same x value as one of its source or target nodes
                            // or node.x is already 0
                            while (node.x > 0 && connectedNodesXPositions.indexOf(node.x - 1) < 0) {
                                node.x -= 1;
                            }
                        });
                    });
                }

                /**
                 * As and how the data will come in, the nodes will be positioned in a linear fashion.
                 */
                function scaleNodeXPositions() {
                    var minX = d3.min(nodes, function (node) {
                            return node.x;
                        }),
                        maxX = d3.max(nodes, function (node) {
                                return node.x;
                            }) - minX;
                    xScaleFactor = (size[0] - nodeWidth) / maxX;

                    nodes.forEach(function (node) {
                        node.x *= xScaleFactor;
                    });
                }

                function computeNodeXPositions() {
                    var remainingNodes = nodes,
                        nextNodes,
                        x = 0,
                        addToNextNodes = function (link) {
                            if (nextNodes.indexOf(link.target) < 0 && link.target.x === this.x) {
                                nextNodes.push(link.target);
                            }
                        },
                        setValues = function (node) {
                            node.x = x;
                            node.width = nodeWidth;
                            node.sourceLinks.forEach(addToNextNodes, node);
                        };

                    while (remainingNodes.length) {
                        nextNodes = [];
                        remainingNodes.forEach(setValues);
                        if (nextNodes.length) {
                            remainingNodes = nextNodes;
                        } else {
                            remainingNodes = sourceAndTargetNodesWithSameX();
                        }
                        x += 1;
                    }

                    compressInXDirection();
                    scaleNodeXPositions();
                }

                function computeLeftAndRightLinks() {
                    var source, target;
                    nodes.forEach(function (node) {
                        node.rightLinks = [];
                        node.leftLinks = [];
                    });
                    links.forEach(function (link) {
                        source = link.source;
                        target = link.target;
                        if (source.x < target.x) {
                            source.rightLinks.push(link);
                            target.leftLinks.push(link);
                            link.direction = 1;
                        } else {
                            source.leftLinks.push(link);
                            target.rightLinks.push(link);
                            link.direction = -1;
                        }
                    });
                }

                function adjustTop(adjustment) {
                    nodes.forEach(function (node) {
                        node.y -= adjustment;
                    });
                }

                function computeNodeYPositions(iterations) {
                    var minY,
                        alpha,
                        nodesByXPosition = d3.nest()
                            .key(function (node) {
                                return node.x;
                            })
                            .sortKeys(d3.ascending)
                            .entries(nodes)
                            .map(function (object) {
                                return object.values;
                            });

                    function calculateYScaleFactor() {
                        var linkSpacesCount, nodeValueSum, discretionaryY;
                        yScaleFactor = d3.min(nodesByXPosition, function (nodes) {
                            linkSpacesCount = d3.sum(nodes, function (node) {
                                return node.linkSpaceCount;
                            });
                            nodeValueSum = d3.sum(nodes, function (node) {
                                return node.value;
                            });
                            discretionaryY = (size[1] - (nodes.length - 1) * nodeSpacing - linkSpacesCount * linkSpacing);

                            return discretionaryY / nodeValueSum;
                        });

                        // Fat links are those with lengths less than about 4 times their heights
                        // Fat links don't bend well
                        // Test that yScaleFactor is not so big that it causes 'fat' links; adjust yScaleFactor accordingly
                        links.forEach(function (link) {
                            var linkLength = Math.abs(link.source.x - link.target.x),
                                linkHeight = link.value * yScaleFactor;
                            if (linkLength / linkHeight < 4) {
                                yScaleFactor = 0.25 * linkLength / link.value;
                            }
                        });
                    }

                    function initializeNodeYPosition() {
                        nodesByXPosition.forEach(function (nodes) {
                            nodes.forEach(function (node, i) {
                                node.y = i;
                                node.heightAllowance = node.value * yScaleFactor + linkSpacing * node.linkSpaceCount;
                            });
                        });
                    }

                    function calculateLinkThickness() {
                        links.forEach(function (link) {
                            link.thickness = link.value * yScaleFactor;
                        });
                    }

                    function relaxLeftToRight(alpha) {
                        function weightedSource(link) {
                            return center(link.source) * link.value;
                        }

                        nodesByXPosition.forEach(function (nodes) {
                            nodes.forEach(function (node) {
                                if (node.rightLinks.length) {
                                    var y = d3.sum(node.rightLinks, weightedSource) / d3.sum(node.rightLinks, value);
                                    node.y += (y - center(node)) * alpha;
                                }
                            });
                        });
                    }

                    function relaxRightToLeft(alpha) {
                        function weightedTarget(link) {
                            return center(link.target) * link.value;
                        }

                        nodesByXPosition.slice().reverse().forEach(function (nodes) {
                            nodes.forEach(function (node) {
                                if (node.leftLinks.length) {
                                    var y = d3.sum(node.leftLinks, weightedTarget) / d3.sum(node.leftLinks, value);
                                    node.y += (y - center(node)) * alpha;
                                }
                            });
                        });
                    }

                    function resolveCollisions() {
                        function ascendingYPosition(a, b) {
                            return a.y - b.y;
                        }

                        nodesByXPosition.forEach(function (nodes) {
                            var node,
                                dy,
                                y0 = 0,
                                n = nodes.length,
                                i;

                            nodes.sort(ascendingYPosition);

                            // Push any overlapping nodes down.
                            for (i = 0; i < n; ++i) {
                                node = nodes[i];
                                dy = y0 - node.y;
                                if (dy > 0) {
                                    node.y += dy;
                                }
                                y0 = node.y + node.heightAllowance + nodeSpacing;
                            }

                            // If the bottommost node goes outside the bounds, push it back up.
                            dy = y0 - nodeSpacing - size[1];
                            if (dy > 0) {
                                node.y -= dy;
                                y0 = node.y;

                                // Push any overlapping nodes back up.
                                for (i = n - 2; i >= 0; --i) {
                                    node = nodes[i];
                                    dy = node.y + node.heightAllowance + nodeSpacing - y0;
                                    if (dy > 0) {
                                        node.y -= dy;
                                    }
                                    y0 = node.y;
                                }
                            }
                        });
                    }

                    calculateYScaleFactor();
                    initializeNodeYPosition();
                    calculateLinkThickness();
                    resolveCollisions();

                    for (alpha = 1; iterations > 0; --iterations) {
                        alpha *= 0.99;
                        relaxRightToLeft(alpha);
                        resolveCollisions();
                        relaxLeftToRight(alpha);
                        resolveCollisions();
                    }

                    minY = d3.min(nodes, function (node) {
                        return node.y;
                    });
                    adjustTop(minY);
                }

                function computeLinkYPositions() {

                    function ascendingLeftNodeYPosition(a, b) {
                        var aLeftNode = (a.direction > 0) ? a.source : a.target,
                            bLeftNode = (b.direction > 0) ? b.source : b.target;
                        return aLeftNode.y - bLeftNode.y;
                    }

                    function ascendingRightNodeYPosition(a, b) {
                        var aRightNode = (a.direction > 0) ? a.target : a.source,
                            bRightNode = (b.direction > 0) ? b.target : b.source;
                        return aRightNode.y - bRightNode.y;
                    }

                    nodes.forEach(function (node) {
                        node.rightLinks.sort(ascendingRightNodeYPosition);
                        node.leftLinks.sort(ascendingLeftNodeYPosition);
                    });

                    nodes.forEach(function (node) {
                        var rightY = 0, leftY = 0;

                        node.rightLinks.forEach(function (link) {
                            if (link.direction > 0) {
                                link.sourceY = rightY;
                                if (link.target.state === 'collapsed') {
                                    rightY += link.thickness + linkSpacing;
                                }
                            }
                            else {
                                link.targetY = rightY;
                                if (link.source.state === 'collapsed') {
                                    rightY += link.thickness + linkSpacing;
                                }
                            }
                        });

                        node.leftLinks.forEach(function (link) {
                            if (link.direction < 0) {
                                link.sourceY = leftY;
                                if (link.target.state === 'collapsed') {
                                    leftY += link.thickness + linkSpacing;
                                }
                            }
                            else {
                                link.targetY = leftY;
                                if (link.source.state === 'collapsed') {
                                    leftY += link.thickness + linkSpacing;
                                }
                            }
                        });

                    });
                }

                biHiSankey.arrowheadScaleFactor = function (_) {
                    if (!arguments.length) {
                        return arrowheadScaleFactor;
                    }
                    arrowheadScaleFactor = +_;
                    return biHiSankey;
                };

                biHiSankey.collapsedNodes = function () {
                    return nodes.filter(function (node) {
                        return node.state === 'collapsed';
                    });
                };

                biHiSankey.connected = function (nodeA, nodeB) {
                    return nodeA.connectedNodes.indexOf(nodeB) >= 0;
                };

                biHiSankey.expandedNodes = function () {
                    return nodes.filter(function (node) {
                        return node.state === 'expanded';
                    });
                };

                biHiSankey.layout = function (iterations) {
                    computeNodeXPositions();
                    computeLeftAndRightLinks();
                    computeNodeValues();
                    computeNodeYPositions(iterations);
                    computeNodeValues();
                    computeLinkYPositions();
                    return biHiSankey;
                };

                /**
                 * Currently we are using D3 version 3. In Version 3, the markers or the arrowheads
                 * are computed using url's.
                 * Following function creates the links. The links will include the coordinates
                 * through which the path/line will pass which connects two nodes. We dont need to look into this
                 * as its simply going to compute values based off on the nodes position.
                 * @returns {link}
                 */
                biHiSankey.link = function () {
                    var curvature = defaultLinkCurvature;

                    function leftToRightLink(link) {
                        var arrowHeadLength = link.thickness * arrowheadScaleFactor,
                            straightSectionLength = (3 * link.thickness / 4) - arrowHeadLength,
                            x0 = link.source.x + link.source.width,
                            x1 = x0 + arrowHeadLength / 2,
                            x4 = link.target.x - straightSectionLength - arrowHeadLength,
                            xi = d3.interpolateNumber(x0, x4),
                            x2 = xi(curvature),
                            x3 = xi(1 - curvature),
                            y0 = link.source.y + link.sourceY + link.thickness / 2,
                            y1 = link.target.y + link.targetY + link.thickness / 2;
                        return 'M'+x0+','+y0+'L'+x1+','+y0+'C'+x2+','+y0+' '+x3+','+y1+' '+x4+','+y1+'L'+(x4+straightSectionLength)+','+y1;
                    }

                    function rightToLeftLink(link) {
                        var arrowHeadLength = link.thickness * arrowheadScaleFactor,
                            straightSectionLength = link.thickness / 4,
                            x0 = link.source.x,
                            x1 = x0 - arrowHeadLength / 2,
                            x4 = link.target.x + link.target.width + straightSectionLength + arrowHeadLength,
                            xi = d3.interpolateNumber(x0, x4),
                            x2 = xi(curvature),
                            x3 = xi(1 - curvature),
                            y0 = link.source.y + link.sourceY + link.thickness / 2,
                            y1 = link.target.y + link.targetY + link.thickness / 2;
                        return 'M'+x0+','+y0+'L'+x1+','+y0+'C'+x2+','+y0+' '+x3+','+y1+' '+x4+','+y1+'L'+(x4-straightSectionLength)+','+y1;
                    }

                    function link(d) {
                        if (d.source.x < d.target.x) {
                            return leftToRightLink(d);
                        }
                        return rightToLeftLink(d);
                    }

                    link.curvature = function (_) {
                        if (!arguments.length) {
                            return curvature;
                        }
                        curvature = +_;
                        return link;
                    };

                    return link;
                };

                /**
                 * Most of these functions can be considered to be black box.
                 * They are mostly used to calculate the link spacing, positioning
                 * and orientation of the svg's. Depending on the data, they will orient themselves.
                 * This doesnt need to be touched.
                 *
                 * It is extremely vital that before any changes are done to any of these functions,
                 * pring the data before the function in the console using console.log() to see
                 * exactly what are the fields and variables.
                 * Then according to the fields which need to be altered, change the functions which
                 * manipulate the fields.
                 *
                 * For example, you can print the links dataset and check the length of arguments
                 * in the links dataset. Depending on the behavior, the functions can then be changed.
                 * @param _
                 * @returns {*}
                 */

                biHiSankey.links = function (_) {
                    if (!arguments.length) {
                        return links;
                    }
                    links = _.filter(function (link) {
                        return link.source !== link.target; // filter out links that go nowhere
                    });
                    return biHiSankey;
                };

                biHiSankey.linkSpacing = function (_) {
                    if (!arguments.length) {
                        return linkSpacing;
                    }
                    linkSpacing = +_;
                    return biHiSankey;
                };

                biHiSankey.nodes = function (_) {
                    if (!arguments.length) {
                        return nodes;
                    }
                    nodes = _;
                    return biHiSankey;
                };

                biHiSankey.nodeWidth = function (_) {
                    if (!arguments.length) {
                        return nodeWidth;
                    }
                    nodeWidth = +_;
                    return biHiSankey;
                };

                biHiSankey.nodeSpacing = function (_) {
                    if (!arguments.length) {
                        return nodeSpacing;
                    }
                    nodeSpacing = +_;
                    return biHiSankey;
                };

                biHiSankey.relayout = function () {
                    computeLeftAndRightLinks();
                    computeNodeValues();
                    computeLinkYPositions();
                    return biHiSankey;
                };

                biHiSankey.size = function (_) {
                    if (!arguments.length) {
                        return size;
                    }
                    size = _;
                    return biHiSankey;
                };

                biHiSankey.visibleLinks = function () {
                    return visible(links);
                };

                /**
                 * final function variable which will compute the new positions.
                 * This variable can be used to understand the computeNewPositions() function
                 * better, as the order in which all the functions below are called exemplify the
                 * necessary steps and math to calculate new positions.
                 */

                biHiSankey.initializeNodes = function (callback) {
                    initializeNodeMap();
                    computeNodeHierarchy();
                    computeNodeLinks();
                    computeAncestorLinks();
                    mergeLinks();
                    computeConnectedNodes();
                    nodes.forEach(callback);
                    return biHiSankey;
                };

                return biHiSankey;
            };

            //creating the function variable
            biHiSankey = computeNewPositions();

            /**
             * These are some hard coded values. For experimentation basis, values can be changed
             * This is the final variable where the variables are passed to generate the svg
             */
            biHiSankey
                .nodeWidth(NODE_WIDTH)
                .nodeSpacing(20)
                .linkSpacing(5)
                .arrowheadScaleFactor(0.5) // Specifies that 0.5 of the link's stroke WIDTH should be allowed for the marker at the end of the link.
                .size([1500, 1200]);

            path = biHiSankey.link().curvature(0.45);
            defs =d3.select(domId).select('svg').append('defs');

            /**
             * creating the arrowheads. Uisng marker, this will create markers.
             * The following attributes connected to the marker are required for it to be built correctly.
             * They ar econnected to the links.
             * This can be considered as a black box as well.
             */
            defs.append('marker')
                .style('fill', LINK_COLOR)
                .attr('id', 'arrowHead')
                .attr('viewBox', '0 0 6 10')
                .attr('refX', '1')
                .attr('refY', '5')
                .attr('markerUnits', 'strokeWidth')
                .attr('markerWidth', '1')
                .attr('markerHeight', '1')
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z');

            defs.append('marker')
                .style('fill', OUTFLOW_COLOR)
                .attr('id', 'arrowHeadInflow')
                .attr('viewBox', '0 0 6 10')
                .attr('refX', '1')
                .attr('refY', '5')
                .attr('markerUnits', 'strokeWidth')
                .attr('markerWidth', '1')
                .attr('markerHeight', '1')
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z');

            defs.append('marker')
                .style('fill', INFLOW_COLOR)
                .attr('id', 'arrowHeadOutlow')
                .attr('viewBox', '0 0 6 10')
                .attr('refX', '1')
                .attr('refY', '5')
                .attr('markerUnits', 'strokeWidth')
                .attr('markerWidth', '1')
                .attr('markerHeight', '1')
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z');

            var filter = defs.append('filter')
                .attr('id', 'drop-shadow')
                .attr('height', '150%');

            filter.append('feGaussianBlur')
                .attr('in', 'SourceAlpha')
                .attr('stdDeviation', 5)
                .attr('result', 'blur');

            filter.append('feOffset')
                .attr('in', 'blur')
                .attr('dx', 0.5)
                .attr('dy', 0.5)
                .attr('result', 'offsetBlur');

            var feMerge = filter.append('feMerge');

            feMerge.append('feMergeNode')
                .attr('in', 'offsetBlur');
            feMerge.append('feMergeNode')
                .attr('in', 'SourceGraphic');

            /**
             * This function includes the major svg's which will be used to create the nodes
             * and collapsers. Collapsers are the nodes which will be created once double-clicked on the
             * parent node to see the child nodes.
             */
            function update () {
                var link, linkEnter, node, nodeEnter, collapser, collapserEnter;

                function containChildren(node) {
                    node.children.forEach(function (child) {
                        child.state = 'contained';
                        child.parent = this;
                        child.parentOfChild = null;
                        containChildren(child);
                    }, node);
                }

                function expand(node) {
                    node.state = 'expanded';
                    node.children.forEach(function (child) {
                        child.state = 'collapsed';
                        child.parentOfChild = this;
                        child.parent = null;
                        containChildren(child);
                    }, node);
                }

                function collapse(node) {
                    node.state = 'collapsed';
                    containChildren(node);
                    HEIGHT = HEIGHT - node.children.length * 50;
                    WIDTH = WIDTH - node.children.length * 50;
                    d3.select(domId).select('svg').attr('height', HEIGHT);
                    d3.select(domId).select('svg').attr('width', WIDTH);
                }

                function restoreLinksAndNodes() {
                    link
                        .style('stroke', LINK_COLOR)
                        .style('marker-end', function () { return 'url(#arrowHead)'; })
                        .transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', OPACITY.LINK_DEFAULT);

                    node
                        .selectAll('rect')
                        .style('fill', function (d) {
                            d.color = colorScale(d.type.replace(/ .*/, ''));
                            return d.color;
                        })
                        .style('stroke', function (d) {
                            return d3.rgb(colorScale(d.type.replace(/ .*/, ''))).darker(0.1);
                        })
                        .style('fill-opacity', OPACITY.NODE_DEFAULT);

                    node.filter(function (n) { return n.state === 'collapsed'; })
                        .transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', OPACITY.NODE_DEFAULT);
                }

                function showHideChildren(node) {
                    disableUserInterractions(2 * TRANSITION_DURATION);
                    hideTooltip();
                    if (node.state === 'collapsed') { expand(node); }
                    else { collapse(node); }

                    biHiSankey.relayout();

                    update();
                    link.attr('d', path);
                    restoreLinksAndNodes();
                }

                function highlightConnected(g) {
                    link.filter(function (d) { return d.source === g; })
                        .style('marker-end', function () { return 'url(#arrowHeadInflow)'; })
                        .style('stroke', OUTFLOW_COLOR)
                        .style('opacity', OPACITY.LINK_DEFAULT);

                    link.filter(function (d) { return d.target === g; })
                        .style('marker-end', function () { return 'url(#arrowHeadOutlow)'; })
                        .style('stroke', INFLOW_COLOR)
                        .style('opacity', OPACITY.LINK_DEFAULT);
                }

                function fadeUnconnected(g) {
                    link.filter(function (d) { return d.source !== g && d.target !== g; })
                        .style('marker-end', function () { return 'url(#arrowHead)'; })
                        .transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', OPACITY.LINK_FADED);

                    node.filter(function (d) {
                        return (d.name === g.name) ? false : !biHiSankey.connected(d, g);
                    }).transition()
                        .duration(TRANSITION_DURATION)
                        .style('opacity', OPACITY.NODE_FADED);
                }

                link =svg1.select('#links').selectAll('path.link')
                    .data(biHiSankey.visibleLinks(), function (d) { return d.id; });

                link.transition()
                    .duration(TRANSITION_DURATION)
                    .style('stroke-WIDTH', function (d) { return Math.max(1, d.thickness); })
                    .attr('d', path)
                    .style('opacity', OPACITY.LINK_DEFAULT);


                link.exit().remove();


                linkEnter = link.enter().append('path')
                    .attr('class', 'link')
                    .style('fill', 'none');

                /**
                 * when you enter the link using the cursor, the account names and the target names
                 * will be shown. It is simply showing a tooltip when 'mouseenter'
                 */
                linkEnter.on('mouseenter', function(d){
                    if (!isTransitioning) {
                        showTooltip().select('.value').text(function () {
                            if (d.direction > 0) {
                                return d.source.name.replace(/\w\S*/g, function (txt) {
                                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                                    }) + ' ??' + d.target.name.replace(/\w\S*/g, function (txt) {
                                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                                    }) + '\n' + baseCurrencyFilter(d.value );
                            }
                            return d.target.name.replace(/\w\S*/g, function (txt) {
                                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                                }) + ' ??' + d.source.name.replace(/\w\S*/g, function (txt) {
                                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                                }) + '\n' + baseCurrencyFilter(d.value );
                        });
                    }
                });
                linkEnter.on('mouseleave', function(d){
                      hideTooltip();
                });

                linkEnter.on('click', function (d) {
                    if (!isTransitioning) {
                        d3.select(this)
                            .style('stroke', LINK_COLOR)
                            .transition()
                            .duration(TRANSITION_DURATION / 2)
                            .style('opacity', OPACITY.LINK_HIGHLIGHT);
                    }
                });

                linkEnter.on('click',onLinkSelect);


                linkEnter.on('dblclick', function () {
                    if (!isTransitioning) {
                        hideTooltip();

                        d3.select(this)
                            .style('stroke', LINK_COLOR)
                            .transition()
                            .duration(TRANSITION_DURATION / 2)
                            .style('opacity', OPACITY.LINK_DEFAULT);
                    }
                });

                /**
                 * This function on linkEnter is to sort them as left or right links
                 * Depending on their orientation, the marker-end will be attached to the
                 * end of the links. This can be considered a black box.
                 */
                linkEnter.sort(function (a, b) { return b.thickness - a.thickness; })
                    .classed('leftToRight', function (d) {
                        return d.direction > 0;
                    })
                    .classed('rightToLeft', function (d) {
                        return d.direction < 0;
                    })
                    .style('marker-end', function () {
                        return 'url(#arrowHead)';
                    })
                    .style('stroke', LINK_COLOR)
                    .style('opacity', 0)
                    .transition()
                    .delay(TRANSITION_DURATION)
                    .duration(TRANSITION_DURATION)
                    .attr('d', path)
                    .style('stroke-WIDTH', function (d) { return Math.max(1, d.thickness); })
                    .style('opacity', OPACITY.LINK_DEFAULT);


                /**
                 * According to d3 documentation, you can pass a function to each node with .data()
                 */
                node =svg1.select('#nodes').selectAll('.node')
                    .data(biHiSankey.collapsedNodes(), function (d) { return d.id; });

                node.transition()
                    .duration(TRANSITION_DURATION)
                    .attr('transform', function (d) { return 'translate(' + d.x + ',' + d.y + ')'; })
                    .style('opacity', OPACITY.NODE_DEFAULT)
                    .select('rect')
                    .style('fill', function (d) {
                        d.color = colorScale(d.type.replace(/ .*/, ''));
                        return d.color;
                    })
                    .style('stroke', function (d) { return d3.rgb(colorScale(d.type.replace(/ .*/, ''))).darker(0.1); })
                    .style('stroke-WIDTH', '1px')
                    .attr('height', function (d) { return d.height; })
                    .attr('width', biHiSankey.nodeWidth());


                node.exit()
                    .transition()
                    .duration(TRANSITION_DURATION)
                    .attr('transform', function (d) {
                        var collapsedAncestor, endX, endY;
                        collapsedAncestor = d.ancestors.filter(function (a) {
                            return a.state === 'collapsed';
                        })[0];
                        endX = collapsedAncestor ? collapsedAncestor.x : d.x;
                        endY = collapsedAncestor ? collapsedAncestor.y : d.y;
                        return 'translate(' + endX + ',' + endY + ')';
                    })
                    .remove();


                /**
                 * @nodeEnter
                 * this svg element is going to appear again below in the code somewhere.
                 * Currently, this is appended to the node svg and given class node.
                 * In d3, when you submit a class attribute to the element, it will inherit
                 * all the features of that class. This can be considered very similar to css
                 * where you give a class id to a div element and then in styles.css write the attributes
                 * of that class for styling purposes.
                 */

                nodeEnter = node.enter().append('g').attr('class', 'node');

                nodeEnter
                    .attr('transform', function (d) {
                        var startX = d.parentOfChild ? d.parentOfChild.x : d.x,
                            startY = d.parentOfChild ? d.parentOfChild.y : d.y;
                        return 'translate(' + startX + ',' + startY + ')';
                    })
                    .style('opacity', 1e-6)
                    .transition()
                    .duration(TRANSITION_DURATION)
                    .style('opacity', OPACITY.NODE_DEFAULT)
                    .attr('transform', function (d) { return 'translate(' + d.x + ',' + d.y + ')'; });

                nodeEnter.append('text');
                nodeEnter.append('rect')
                    .style('fill', function (d) {
                        d.color = colorScale(d.type.replace(/ .*/, ''));
                        return d.color;
                    })
                    .style('stroke', function (d) {
                        return d3.rgb(colorScale(d.type.replace(/ .*/, ''))).darker(0.1);
                    })
                    .style('stroke-WIDTH', '1px')
                    .attr('height', function (d) { return d.height; })
                    .attr('width', biHiSankey.nodeWidth());

                /**
                 * node will change the color as: if the inflow of transactions is higher,
                 * it will turn blue, if low it will turn red.
                 */
                node.on('click', function (g) {
                    if (!isTransitioning) {
                        restoreLinksAndNodes();
                        highlightConnected(g);
                        fadeUnconnected(g);

                        d3.select(this).select('rect')
                            .style('fill', function (d) {
                                d.color = d.netFlow > 0 ? INFLOW_COLOR : OUTFLOW_COLOR;
                                return d.color;
                            })
                            .style('stroke', function (d) {
                                return d3.rgb(d.color).darker(0.1);
                            })
                            .style('fill-opacity', OPACITY.LINK_DEFAULT);

                        if(d3.event.shiftKey && g.children.length === 0){
                           $state.go('accountDetails', {accountid: g.name});
                        }
                        else if(d3.event.shiftKey && g.children.length !== 0) {
                            $state.go('customerDetails', {customerid: g.name});
                        }

                        /**
                         * This is the network logger function. When you do alt+click on a node,
                         * it will log the title/name of the node in the Network Logger section
                         */
                        if (d3.event.altKey) {
                            var msg = g.name.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                            document.getElementById(domIdLog).innerHTML += ' ??' + msg;
                        }
                    }
                });

                /**
                 * using escape key, restore links and nodes if one particular node/collapser
                 * is highlighted and rest are faded. This will restore the diagram.
                 */
                
                $(document).keyup(function(e) {
                    // escape and restore the links and the nodes
                    if (e.keyCode === 27){
                        if (!isTransitioning) {
                            hideTooltip();
                            restoreLinksAndNodes();
                        }
                    }
                });


                //-----------------------------start zoom-------------------------------------------
                var zoom = d3.behavior.zoom()
                    .scaleExtent([0.4, 5])
                    .on('zoom', zoomed);

                function zoomed() {
                   svg1.attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')');
                }

                d3.select(domId).select('svg').call(zoom);

                d3.select(domId).select('svg').on('dblclick.zoom', null);
                //-----------------------------end zoom---------------------------------------------

                node.filter(function (d) { return d.children.length; })
                    .on('dblclick', showHideChildren);

                /**
                 * @nodeEnter
                 * this is the basic svg node which will be rendered.
                 * text is appended to the node as labels.
                 * If at all in the future, any modifications are done to the calculations
                 * of x,y coordinates of nodes or sizes or the way they are oriented,
                 * this section might be altered acoordingly. Till then this doesnt need to be touched.
                 */
                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .append('text')
                    .attr('id', 'nodeEnter')
                    .attr('x', function(d) { return NODE_WIDTH + 10;})
                    .attr('y', function (d) { return d.height/2; })
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'start')
                    .attr('transform', null)
                    .style('font-size', function(d){
                        var size = d.height/2;
                        if(size < 5){
                            return 5 + 'px';
                        }else if(size > 30){
                            return 28 + 'px';
                        }
                        return size.toString() + 'px'; })
                    .attr('font-weight', function(d) { if(d.name === targetNodes[0].name) { return 'bold';} else { return 'normal';}})
                    .text(function(d)
                            {
                                return d.name.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                            });

                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .append('text')
                    .attr('id', 'nodeEnter')
                    .attr('x', function(d) { return NODE_WIDTH + 10;})
                    .attr('y', function (d) {
                        if(d.height/2 < 5){

                            return d.height/2 + 2.5 + 5;
                        }
                        else{
                            return d.height/2 + d.height/4 + d.height/5;
                        }
                         })
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'start')
                    .attr('transform', null)
                    .style('font-size', function(d){
                        var size = d.height/3;
                        if(size < 5){
                            return 5 + 'px';
                        }else if(size > 20){
                            return 20 + 'px';
                        }
                        return size.toString() + 'px'; })
                    .attr('font-weight', function(d) { if(d.name === targetNodes[0].name) { return 'bold';} else { return 'normal';}})
                    .text(function(d)
                    {
                        if(d.netFlow > 0){ return resources.aml.getResource('fundsTracker.netFlowLabel', {netFlowAmount: baseCurrencyFilter(d.netFlow.toFixed(2))}); }
                        else { return resources.aml.getResource('fundsTracker.netFlowLabelNeg', {netFlowAmount: baseCurrencyFilter(d.netFlow.toFixed(2))});}
                    });

                //doesnt seem to work
                d3.select(domId).select('svg').selectAll('node').select('text').attr('font-weight', function(d){ if(d.name === nodesArray[1]){ return 'bold';} else{ return 'normal';} });


                /**
                 * nodeEnter is the node svg element you see on the fundstracker. All the below
                 * functions applied to nodeEnter are going to basically add extra:
                 * a. Circle for showing how many accounts the entity has(child nodes of parent nodes)
                 * b. Another circle as border with no fill
                 * c. Text by calculating the length of childnode array of the node object
                 */

                /**
                 * @Formulations:
                 * Here on, there is a generic concept used to formulate the positions of the circle, its border
                 * and the text.
                 * The radius of the circle is calculated based on whichever is small; the height or width,
                 * it is divided by 2. that will be the radius.
                 */

                //adding a couple of few more svg to node to add details of child and netflow
                //adding a circle
                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .append('circle')
                    .attr('cx', function(d){ return 0;})
                    .attr('cy', function (d) { return d.height; })
                    .attr('r', function (d) {
                        if(d.height > d.width){
                            return d.width / 2;
                        }else{
                            return d.height / 3;
                        }
                    })
                    .style('fill', function(d) { return d.color; });

                //border to the above circle
                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .append('circle')
                    .attr('cx', function(d){ return 0;})
                    .attr('cy', function (d) { return d.height; })
                    .attr('r', function (d) {
                        if(d.height > d.width){
                            return d.width / 2;
                        }else{
                            return d.height / 3;
                        }
                    })
                    .style('fill', 'none')
                    .style('stroke', 'black')
                    .style('stroke-width', function(d){ return d.height/30;});

                /**
                 * @Formulations:
                 * Here on, there is a generic concept used to formulate the positions of the circle, its border
                 * and the text.
                 * The position of the text inside the circle is relative 
                 */

                //text
                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .append('text')
                    .attr('x', function(d){
                        var radius;
                        if(d.height > d.width){
                           radius = d.width / 2;
                        }else{
                            radius = d.height / 3;
                        }
                        return radius/2;
                    })
                    .attr('y', function (d) {  return d.height;  })
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'end')
                    .attr('transform', null)
                    .text(function(d)
                    {
                        return '+' + d.children.length;
                    })
                    .style('font-weight','bold')
                    .style('font-size', function(d){
                        if(d.height > d.width){
                            var size = d.width/3;
                            return size;
                        }else{

                            return d.height/3;
                        }
                    });

                //adding initials to the childnode
                nodeEnter.filter(function (d) { return d.value !== 0; })
                    .filter(function (d) { return d.children.length === 0; })
                    .append('text')
                    .attr('id', 'nodeEnter')
                    .attr('x', function(d) { return 0;})
                    .attr('y', function (d) { return -d.height/3; })
                    .attr('dy', '0.35em')
                    .attr('text-anchor', 'start')
                    .attr('transform', null)
                    .style('font-size', function(d){
                        var size = d.height/3;
                        return size.toString() + 'px'; })
                    .attr('font-weight', function(d) { if(d.name === targetNodes[0].name) { return 'bold';} else { return 'normal';}})
                    .text(function(d)
                    {
                        if (d.displayName) {
                            return d.displayName.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                        } else {
                            return d.type.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                        }
                    })
                    .attr('font-size', '20px')
                    .style('font-weight','bold');

                /**
                 * @Collapsers
                 * Another important component of the graph. When you double click on an entity node
                 * to expand to its account nodes(children), a collapser node will appear on the top left
                 * corner of the funds tracker. This will have the initials of the entity which
                 * is currently expanded. After investigation, you can double click on the collapser to
                 * reset the children back to its parent node.
                 */

                //selecting svg's with collapsers and adding it to the data we have for the expanded
                collapser =svg1.select('#collapsers').selectAll('.collapser')
                    .data(biHiSankey.expandedNodes(), function (d) { return d.id; });


                collapserEnter = collapser.enter().append('g').attr('class', 'collapser');

                /**
                 * @TODO
                 * the 'r' attribute of the collapser can be changed to be calculated dynamically
                 * depending on the node's width/height.
                 * Nodes will have maximum width as specified, height will be variable.
                 * Hence, the collapsers can be proportional to the height of the nodes rather than width.
                 * 
                 */
                collapserEnter.append('circle')
                    .attr('r', COLLAPSER.RADIUS)
                    .style('fill', function (d) {
                        d.color = colorScale(d.type.replace(/ .*/, ''));
                        return d.color;
                    });

                collapserEnter.append('text')
                    .text(function(d) { return d.name.split(' ')[0].split('')[0] + d.name.split(' ')[1].split('')[0] ; })
                    .attr('dx', function(d){return -20;})
                    .attr('class', 'collapseEnterText')
                    .attr('y', 5)
                    .attr('font-size',function(){ return COLLAPSER.RADIUS*2;})
                    .attr('text-anchor', 'start')
                    .attr('font-weight', '900');

                collapserEnter
                    .style('opacity', OPACITY.NODE_DEFAULT)
                    .attr('transform', function (d) {
                        return 'translate(' + (d.x + d.width / 2 ) + ',' + (d.y + COLLAPSER.RADIUS) + ')';
                    });

                collapserEnter.on('dblclick', showHideChildren);

                //showing the massive dense network
                var printChild = function(g){
                    g.forEach(function(g){ restoreLinksAndNodes(g); highlightConnected(g);  fadeUnconnected(g); });
                };

                /**
                 * @debug
                 * the following line can be uncommented during debugging or dev mode
                 * to see the objects being populated
                 */
                //console.log(printChild);

                collapser.on('click', function(g){
                    printChild(g.children);
                });

                collapser.select('circle')
                    .attr('r', COLLAPSER.RADIUS);

                collapser.transition()
                    .delay(TRANSITION_DURATION)
                    .duration(TRANSITION_DURATION)
                    .attr('transform', function (d, i) {
                        return 'translate('+ (COLLAPSER.RADIUS + i * 2 * (COLLAPSER.RADIUS + COLLAPSER.SPACING)) + ',' + (-COLLAPSER.RADIUS - OUTER_MARGIN)+ ')';
                    });

                /**
                 * when cursor enters the collapser, the specific child nodes
                 * are highlighted.
                 * So basically when you want to analyze accounts of one particular entity,
                 * enter the collapser to highlight only the respective children and
                 * fade all other nodes in the diagram.
                 */
                collapser.on('mouseenter', function (g) {
                    if (!isTransitioning) {
                        showTooltip().select('.value')
                            .text(function () {
                                return g.name.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                            });

                        var highlightColor = highlightColorScale(g.type.replace(/ .*/, ''));

                        d3.select(this)
                            .style('opacity', OPACITY.NODE_HIGHLIGHT)
                            .select('circle')
                            .style('fill', highlightColor);

                        node.filter(function (d) {
                            return d.ancestors.indexOf(g) >= 0;
                        }).style('opacity', OPACITY.NODE_HIGHLIGHT)
                            .select('rect')
                            .style('fill', highlightColor);
                    }
                });

                /**
                 * when mouse leaves, the diagram will be restored
                 */
                collapser.on('mouseleave', function (g) {
                    if (!isTransitioning) {
                        hideTooltip();
                        d3.select(this)
                            .style('opacity', OPACITY.NODE_DEFAULT)
                            .select('circle')
                            .style('fill', function (d) { return d.color; });

                        node.filter(function (d) {
                            return d.ancestors.indexOf(g) >= 0;
                        }).style('opacity', OPACITY.NODE_DEFAULT)
                            .select('rect')
                            .style('fill', function (d) { return d.color; });
                    }
                });

                collapser.exit().remove();

            }

            /**
             * the final function call where you pass all the data
             * to the nodes and links function and respective svg's are generated
             */
            biHiSankey
                .nodes(nodes[fundsTrackerId])
                .links(links[fundsTrackerId])
                .initializeNodes(function (node) {
                    node.state = node.parent ? 'contained' : 'collapsed';
                })
                .layout(LAYOUT_INTERATIONS);

            disableUserInterractions(2 * TRANSITION_DURATION);

            //call to the update function which will generate the sankey chart
            update();

        }

        /*--------------------------------------------------------------------------------*/

        //passing the functions to service object which will be consumed by the fundstracker controller
        var service = {
            getNetwork: getNetwork,
            sankey: sankey,
            getTransactionsDetails: getTransactionResource,
            setonLinkSelect: setonLinkSelect,
            clearLinks: clearLinks,
            maxCurrencyAmount : maxCurrencyAmount,
            minCurrencyAmount : minCurrencyAmount,
            step: step
        };
        return service;
    }
})();


/**
 * Created by dabock on 4/10/2017.
 */
(function() {
    'use strict';
    watchListService.$inject = ["amlConfig", "exceptionResourceHandler", "$resource"];
    angular.module('aml.customer.details').factory('watchListService', watchListService);

    function watchListService(amlConfig, exceptionResourceHandler, $resource) {
        var watchListAlertResource = $resource(
            amlConfig.baseUrl + '/alerts/:alertId/watchList',
            {
                alertId: '@alertId'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            }
        );

        var watchListRecordResource = $resource(
            amlConfig.baseUrl + '/watchLists/:watchListKey',
            {
                watchListKey: '@watchListKey'
            },
            {
                get: {
                    method: 'GET',
                    interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}
                }
            }
        );

        function getWatchListAlertDetails(alertId) {
            return watchListAlertResource.get({alertId: alertId}).$promise;
        }

        function getWatchListRecordDetails(watchListKey) {
            return watchListRecordResource.get({watchListKey : watchListKey}).$promise;
        }

        return {
            getWatchListAlertDetails: getWatchListAlertDetails,
            getWatchListRecordDetails: getWatchListRecordDetails
        };
    }
})();
/**
 * Created by sasrns on 8/18/2015.
 *
 * Handle message passing between associated cases list components
 */

(function() {
    'use strict';

    casesListDataMessagingService.$inject = ["$rootScope"];
    angular.module('aml.cases.details').factory('casesListDataMessagingService', casesListDataMessagingService);
    function casesListDataMessagingService( $rootScope ) {
        var displayOwnersType = false;
        var getSelectedCasesFn = null;
        var gridRefershFn = null;

        function initializeDataRetrievalCallbacks( getSelectedCasesFnCallback, gridRefershFnCallback ) {
            getSelectedCasesFn = getSelectedCasesFnCallback;
            gridRefershFn = gridRefershFnCallback;
        }

        function reloadGrid() {
            if ( !gridRefershFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No gridRefershFn has been supplied.'
                });
            }
            gridRefershFn();
        }

        function getSelectedCaseNumbers() {
            return _.pluck( getSelectedCases(), 'caseId' );
        }

        function getSelectedCaseOwners() {
            return _.pluck( getSelectedCases(), 'ownerUserLongId');
        }

        function getSelectedCaseQueues() {
            return _.pluck( getSelectedCases(), 'queueCode');
        }

        function getSelectedCases() {
            if ( !getSelectedCasesFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedCasesFn has been supplied.'
                });
            }
            return getSelectedCasesFn();
        }


        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function casesOwnerChanged( caseNumbers, owner, queue ) {
            $rootScope.$broadcast( 'casesOwnerChanged', { caseNumbers: caseNumbers, owner: owner, queue: queue });
        }


        var service = {
            casesOwnerChanged: casesOwnerChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedCaseNumbers: getSelectedCaseNumbers,
            getSelectedCaseOwners: getSelectedCaseOwners,
            getSelectedCaseQueues: getSelectedCaseQueues,
            getSelectedCases: getSelectedCases,
            setDisplayOwnersType: setDisplayOwnersType,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks,
            reloadGrid : reloadGrid
        };
        return service;

    }
})();


/**
 * @ngdoc service
 * @name commons.service:messageService
 *
 * @description
 * Message service provides a way to present common notifications and prompts to the user.
 *
 * Complete list of shortcut methods:
 *
 * - {@link commons.service:messageService#info messageService.info}
 * - {@link commons.service:messageService#danger messageService.danger}
 * - {@link commons.service:messageService#success messageService.success}
 * - {@link commons.service:messageService#warning messageService.warning}
 * - {@link commons.service:messageService#show messageService.show}
 * - {@link commons.service:messageService#alert messageService.alert}
 * - {@link commons.service:messageService#confirm messageService.confirm}
 *
 * @example
 <pre>
 // Notifications
 messageService.info('Informational Notification');
 messageService.success('Successful Notification', 'bottom-right');

 </pre>
 */

(function() {
    'use strict';

    angular.module('aml.core').service('messageService',["$injector", "$timeout", "amlConstants", "resources", "_", function ($injector, $timeout, amlConstants,
                                                                resources, _  ) {

        // default close interval (in ms) if none is provided

        // default orientation if none is provided
        var defaultOrientation = 'top-right';

        var alerts = [ ];

        function getDefaultAutomaticCloseTime() {
            var autoCloseDefaultTime = 7000;

            // it's possible that if there is a failure at boostrap time, the configurable constants are not yet
            // loaded, in which case we will use a backup hardcoded value instead
            if ( amlConstants.config.alertMessage ) {
                return amlConstants.config.alertMessage.autoCloseDefaultTime;
            }
            else {
                return autoCloseDefaultTime;
            }
        }

        function addAlert(alert, closeAutomaticallyTime) {
            // add alert only if the same message does not already exist
            var existingMessageWithSameText = _.findWhere(alerts, {msg: alert.msg });
            if ( !existingMessageWithSameText ) {
                alerts.push(alert);

                // If specified, close the notification after the given time interval
                if ( closeAutomaticallyTime && closeAutomaticallyTime >= 0 ) {
                    $timeout(function () {
                        alerts.splice(alerts.indexOf(alert), 1);
                    }, closeAutomaticallyTime);
                }
            }

        }

        function getDetailsFromError(error) {
            var errorMsg = null;
            if ( error.data && error.data.message && error.data.message.length > 0 ) {
                errorMsg =
                    resources.aml.getResource( 'error.details', {errorMessageDetails: error.data.message });
            }
            return errorMsg;
        }

        return {
            duration: false,

            alerts: alerts,

            /**
             * close the alert at the given index
             * @param index
             */
            closeAlert: function(index) {
                alerts.splice(index, 1);
            },

            /**
             * Close all open alerts
             */
            closeAllAlerts: function() {
                alerts.length = 0;
            },

            /**
             * @ngdoc method
             * @name commons.service:messageService#info
             *
             * @description
             * Present an info notification message to the user.
             *
             * @param text - Message of the notification
             * @param orientation - Can be one of the following ['top-right, 'top, 'top-left', 'center', 'bottom-right',
             * @param closeAfter an optional time interval to close the notification after if the user hasn't already
             * 'bottom', 'bottom-left']. Defaults to 'center'
             */
            info: function(text, orientation, closeAfter) {
                this.show(text, 'info',
                    orientation || defaultOrientation,
                    closeAfter || getDefaultAutomaticCloseTime());
            },

            /**
             * @ngdoc method
             * @name commons.service:messageService#danger
             *
             * @description
             * Present a danger notification message to the user.
             *
             * @param text - Message of the notification
             * @param orientation - Can be one of the following ['top-right, 'top, 'top-left', 'center', 'bottom-right',
             * @param closeAfter an optional time interval to close the notification after if the user hasn't already
             * 'bottom', 'bottom-left']. Defaults to 'center'
             * @param error optional error object returned from ngResource rest promise
             */
            danger: function(text, orientation, closeAfter, error) {

                // if there's an associated error response, check it to see if there's associated details
                if ( error ) {
                    var errorDetails = getDetailsFromError(error);
                    if ( errorDetails ) {
                        text = text + '<br/>' + errorDetails;
                    }
                }

                this.show(text, 'danger',
                    orientation || defaultOrientation,
                    closeAfter || getDefaultAutomaticCloseTime());
            },

            /**
             * @ngdoc method
             * @name commons.service:messageService#success
             *
             * @description
             * Present a success notification message to the user.
             *
             * @param text - Message of the notification
             * @param orientation - Can be one of the following ['top-right, 'top, 'top-left', 'center', 'bottom-right',
             * @param closeAfter an optional time interval to close the notification after if the user hasn't already
             * 'bottom', 'bottom-left']. Defaults to 'center'
             */
            success: function(text, orientation, closeAfter) {
                this.show(text, 'success',
                    orientation || defaultOrientation,
                    closeAfter || getDefaultAutomaticCloseTime());
            },

            /**
             * @ngdoc method
             * @name commons.service:messageService#warning
             *
             * @description
             * Present a warning notification message to the user.
             *
             * @param text - Message of the notification
             * @param orientation - Can be one of the following ['top-right, 'top, 'top-left', 'center', 'bottom-right',
             * @param closeAfter an optional time interval to close the notification after if the user hasn't already
             * 'bottom', 'bottom-left']. Defaults to 'center'
             */
            warning: function(text, orientation, closeAfter) {
                this.show(text, 'warning',
                    orientation || defaultOrientation,
                    closeAfter || getDefaultAutomaticCloseTime());
            },

            /**
             * @ngdoc method
             * @name commons.service:messageService#show
             *
             * @description
             * Present a notification message to the user.
             *
             * @param text - Message of the notification
             * @param type - Type of message.  Correlates with bootstrap alerts. ['info', 'success', 'warning',
             *     'danger'].
             * @param orientation - Can be one of the following ['top-right, 'top, 'top-left', 'center',
             *     'bottom-right',
             * 'bottom', 'bottom-left']. Defaults to 'center'
             */
            show: function(text, type, orientation, closeAfter) {
                if ( orientation === 'top' ) {
                    type = type + '-centered'; // use centered version of .alert-type class
                }

               var alert = { type: type, msg: text };
               addAlert( alert, closeAfter );
            }


        };
    }]);

}());
/**
 * This service provides exception handlers to use for REST resource requests;
 * by default the exceptionHandlerProvider should catch all exceptions, but if you are
 * running in code that is outside of the scope of angular (such as JQWidgets grid)
 * then that exception will not be handled automatically.
 *
 */
(function() {
    'use strict';

    exceptionResourceHandler.$inject = ["logger", "$q", "$log", "resources", "messageService", "amlConstants", "amlConfig", "$state", "$injector"];
    angular
        .module('aml.core.logger')
        .factory('exceptionResourceHandler', exceptionResourceHandler);

    /* @ngInject */
    function exceptionResourceHandler(logger, $q, $log, resources, messageService, amlConstants, amlConfig, $state, $injector) {
        var service = {
            /**
             * This error handler logs messages to the console and additionally displays them with a UI message
             */
            resourceErrorHandler : createResourceErrorHandler(false),

            /**
             * This error handler logs messages to the console and additionally displays them with a UI message
             */
            resourceErrorHandlerRedirectOnNotFound : createResourceErrorHandler(true),

            /**
             * This error handler simply logs messages to the console, and never displays them with a UI message
             */
            resourceErrorLogOnlyHandler : resourceErrorLogOnlyHandler,

            /**
             * Calls the default resourceErrorHandler, but allows for specifying custom handler overrides for specific
             * responses
             */
            handleResourceError: handleResourceError,

            /**
             * Parse and return a details message from an Error object
             */
            getDetailsFromError: getDetailsFromError
        };

        return service;
        /////////////////////

        function redirectToLogonPage() {
            // TODO: if using wrong credentials, can possibly come here
            //window.location.href = 'http://pass0403.na.sas.com:7980/SASLogon/login?service=
            // http%3A%2F%2Fpass0403.na.sas.com%3A7980%2FSASComplianceSolutionsMid%2Fj_spring_cas_security_check#/customers';
            //window.location.reload();
        }

        /**
         * This error handler simply logs messages to the console, and never displays them with a UI message
         */
        function resourceErrorLogOnlyHandler(error) {
            if ( error.status === 401 ) {
                redirectToLogonPage();
            }

            if ( error.data && error.data.message && error.data.message.length > 0 ) {
                $log.error(
                    resources.aml.getResource( 'error.generalError', {errorMessage: error.data.message }) +
                    '<br/>' +
                    error.config.url + ': ' + error.status + ': ' + error.statusText  );
            }
            else if ( error.config ) {
                $log.error(
                    resources.aml.getResource( 'error.restAPIerror',
                        { url: error.config.url, errorStatusCode: error.status, errorMessage: error.statusText }),
                    error.data);
            }
            else {
                $log.error( error );
            }
            return  $q.reject(error);
        }


        function handleNotFoundError(error, errorMsg, errorObject) {
            var notFoundMsg = errorMsg;
            if ( resources && resources.aml ) { // if resource strings available, use localized client message
                if (error.config.method === 'PUT') {
                    notFoundMsg = resources.aml.error.requestedObjectNotFoundUpdateErrorTxt;
                }
                else if (error.config.method === 'DELETE') {
                    notFoundMsg = resources.aml.error.requestedObjectNotFoundDeleteErrorTxt;
                }
                else {
                    notFoundMsg = resources.aml.error.requestedObjectNotFoundErrorTxt;
                }
            }
            messageService.danger(notFoundMsg, null, -1);
            logger.log(errorMsg, errorObject);
        }

        function handleSystemUnavailable(errorMsg, errorObject) {

            // clear any open alerts, as the invalid access state page provides
            // the details already
            messageService.closeAllAlerts();

            var systemUnavailableMsg = errorMsg;
            if ( resources && resources.aml ) { // if resource strings available, use localized client message
                systemUnavailableMsg = resources.aml.error.systemNotAvailableDueToAlertGenerationErrorTxt;
            }
            // redirect back to invalidAccess page
            $state.go('invalidAccess', {message: systemUnavailableMsg});
        }

        function handleConflictError(error, errorMsg, errorObject) {
            var conflictMsg = errorMsg;
            if ( resources && resources.aml ) {
                if (error.config.method === 'PUT') {
                    conflictMsg = resources.aml.error.requestedObjectCannotBeUpdatedErrorTxt;
                }
                else if (error.config.method === 'POST') {
                    conflictMsg = resources.aml.error.requestedObjectCannotBeCreatedErrorTxt;
                }
                else {
                    conflictMsg = resources.aml.error.requestedObjectConflictErrorTxt;
                }
            }
            messageService.danger(conflictMsg, null, -1);
            logger.log(errorMsg, errorObject);
        }

        function handleForbiddenAccess(errorMsgTxt, errorObject) {
            if ( errorObject && errorObject.errorCode === 1 ) {
                // if this failed due to unauthorized business unit (identified by errorCode=1 from the server),
                // then clear local pref of the selected business unit in order to let the next request use the default
                // that the server determines
                var amlPreferencesService = $injector.get('amlPreferencesService');
                amlPreferencesService.deleteLocalPreference( amlConstants.preferences.selectedBusinessUnit );

                // clear stored session cache for good measure
                var adminService = $injector.get('adminService');
                adminService.clearLocalClientCache();
            }

            // redirect back to invalidAccess page
            $state.go('invalidAccess', {message: errorMsgTxt});
        }


        function handleResourceError(error, customHandlers) {
            var handlerFn = null;
            if ( customHandlers ) {
                handlerFn = customHandlers[error.status];
            }

            if ( handlerFn ) {
                handlerFn( error );
            }
            else {
                resourceErrorHandler( error );
            }
        }



        function createResourceErrorHandler( redirectOn404 ) {
            return function(error) {
                return resourceErrorHandler( error, redirectOn404 );
            };
        }

        function redirectToNotFoundPage(error) {
            // close current tab
            var tabsListService = $injector.get('tabsListService');
            var tabForCurrentState = tabsListService.getTabForCurrentState();
            var title = tabForCurrentState.tooltip;
            tabsListService.closeTab(tabForCurrentState, false);

            // use the tab's tooltip (ex: 'Customer 1234') if available; otherwise use the relative URL
            if (!title) {
                var relativeUrl = error.config.url;
                if (relativeUrl.indexOf(amlConfig.baseUrl === 0)) {
                    relativeUrl = relativeUrl.substring(amlConfig.baseUrl.length);
                }
                title = relativeUrl;
            }
            var notFoundMsg = resources.aml.getResource('core.notFoundDetailsMessage', {objectId: title});

            $state.go('notFound', {message: notFoundMsg});
        }

        function resourceErrorHandler(error, redirectOn404) {
            /*jshint maxcomplexity:12 */
            if ( error.status === 401 ) {
                redirectToLogonPage();
            }

            var errorMsgTxt = null;
            var errorMsg = null;
            var errorObject = null;

            if ( error.data && error.data.message && error.data.message.length > 0 ) {
                errorObject = error.data;
                errorMsgTxt = error.data.message;
                if ( resources && resources.aml ) {
                    errorMsg = resources.aml.getResource('error.generalError', {errorMessage: error.data.message}) +
                        '<br/>' +
                        error.config.url + ': ' + error.status + ': ' + error.statusText;
                }
                else {
                    errorMsg = 'Error: ' + error.data.message +
                        '<br/>' +
                        error.config.url + ': ' + error.status + ': ' + error.statusText;

                }
            }
            else if ( error.config ) {
                errorObject = error.data;
                errorMsgTxt = error.statusText;
                if ( resources && resources.aml ) {
                    errorMsg =
                        resources.aml.getResource('error.restAPIerror',
                            {url: error.config.url, errorStatusCode: error.status, errorMessage: error.statusText});
                }
                else {
                    // the resources object is not defined; possible failure retrieving the resources file
                    errorMsg = 'Rest error for ' + error.config.url + ': ' + error.status + ': ' + error.statusText;
                }
            }
            else {
                errorMsg = error;
            }

            // handle 404's with a general nicer message, but still log the REST request
            if ( error.status === 404 && resources && resources.aml) {
                if ( redirectOn404 && error.config.method === 'GET') {
                    redirectToNotFoundPage(error);
                }
                else {
                    handleNotFoundError(error, errorMsg, errorObject);
                }
            }
            else if ( error.status === 409 && resources && resources.aml) {
                handleConflictError(error, errorMsg, errorObject);
            }
            else if ( error.status === 403 && error.config.method === 'GET' ) {
                handleForbiddenAccess(errorMsgTxt, errorObject);
            }
            else if ( error.status === 503 ) {
                handleSystemUnavailable(errorMsgTxt, errorObject);
            }
            else {
                logger.error(errorMsg, errorObject);
            }

            return $q.reject(error);
        }

        function getDetailsFromError(error) {
            var errorMsg = null;
            if ( error.data && error.data.message && error.data.message.length > 0 ) {
                errorMsg =
                    resources.aml.getResource( 'error.details', {errorMessageDetails: error.data.message });
            }
            return errorMsg;
        }

    }
}());

/**
 * @ngdoc service
 * @name     aml.core:amlPreferencesService
 *
 * @restrict E
 *
 * @description
 * The amlPreferencesService service is used to handle retrieving local preferences
 */
(function() {
    'use strict';

    amlPreferencesService.$inject = ["amlConfig", "$resource", "exceptionResourceHandler"];
    angular
        .module('aml.core')
        .factory('amlPreferencesService', amlPreferencesService);

    function amlPreferencesService( amlConfig, $resource, exceptionResourceHandler) {
        var localStorageRoot= 'aml';
        var localStorageId = localStorageRoot + '/preferences';

        var amlPreferences = {};

        var amlPreferencesResource = $resource(amlConfig.baseUrl + '/preferences',
            { }, {
                get: {
                    method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}},
                update: {
                    method: 'PUT',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var resetAmlPreferencesResource = $resource(amlConfig.baseUrl + '/preferences/defaults',
            { }, {
                reset: {
                    method: 'POST',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        activate();

        var service = {
            updateAMLPreferences: updateAMLPreferences,
            resetAMLPreferencesToDefaults: resetAMLPreferencesToDefaults,
            setLocalPreference: setLocalPreference,
            saveLocalPreference: saveLocalPreference,
            getLocalPreference: getLocalPreference,
            loadLocalPreference: loadLocalPreference,
            removeLocalPreference: removeLocalPreference,
            deleteLocalPreference: deleteLocalPreference
        };

        return service;

        function activate() {
            loadLocalPreferences();
        }


        function updateAMLPreferences(preferences) {
            return amlPreferencesResource.update({}, preferences).$promise;
        }

        function resetAMLPreferencesToDefaults() {
            return resetAmlPreferencesResource.reset({}).$promise;
        }

        /**
         * set a local preference to local storage under the aml/preferences object AND store it locally in
         * the local preference cache
         *
         * @param prefName
         * @param prefValue
         */
        function setLocalPreference(prefName, prefValue) {
            amlPreferences[prefName] = prefValue;
            if ( localStorage ) {
                localStorage.setItem(localStorageId, JSON.stringify(amlPreferences));
            }
        }


        /**
         * Remove a local preference from local storage under the aml/preferences object AND remove it locally from
         * the local preference cache
         *
         * @param prefName
         */
        function deleteLocalPreference(prefName) {
            delete amlPreferences[prefName];
            if ( localStorage ) {
                localStorage.setItem(localStorageId, JSON.stringify(amlPreferences));
            }
        }


        /**
         * Save a TOP-LEVEL local preference to local storage
         *
         * @param prefName
         * @param prefValue
         */
        function saveLocalPreference(prefName, prefValue) {
            if ( localStorage ) {
                localStorage.setItem(localStorageRoot + '/' + prefName, JSON.stringify(prefValue));
            }
        }

        /**
         * Remove a local preference from local storage
         *
         * @param prefName
         * @param prefValue
         */
        function removeLocalPreference(prefName) {
            if ( localStorage ) {
                localStorage.removeItem(localStorageRoot + '/' + prefName);
            }
        }
        /**
         * Retrieve a local preference from local storage
         *
         * @param prefName
         * @param prefValue
         */
        function loadLocalPreference(prefName) {
            if ( localStorage ) {
                var prefVal = localStorage.getItem(localStorageRoot + '/' + prefName);
                if ( prefVal ) {
                    return JSON.parse(prefVal);
                }
            }
            return null;
        }

        /**
         * Retrieve preference value that was previously set (via setLocalPreference)
         * @param prefName
         * @returns {*}
         */
        function getLocalPreference(prefName) {
            return amlPreferences[prefName];
        }

        function loadLocalPreferences() {
            if ( localStorage ) {
                var localPrefs = localStorage.getItem(localStorageId);
                if ( localPrefs ) {
                    amlPreferences = JSON.parse(localPrefs);
                }
            }
        }

    }
})();

(function() {
    'use strict';

    cddReviewDetailsService.$inject = ["$resource", "$q", "amlConfig", "_", "exceptionResourceHandler", "amlLov", "resources", "$locale", "dateFilter"];
    angular
        .module('cdd.reviews')
        .factory('cddReviewDetailsService', cddReviewDetailsService);

    /* @ngInject */
    /* jshint maxparams: 15*/
    /* jshint maxstatements: 50*/
    function cddReviewDetailsService($resource, $q, amlConfig, _, exceptionResourceHandler, amlLov, resources, $locale,dateFilter) {
//console.log("cddReviewDetailsService!!!");
//console.log(this);

        var reviewOverallScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/overall', {}, {
            get: {
                params: {reviewKey: '@reviewKey'},
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        var newReviewOverallScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/customerRiskRating/scores/overall', {}, {
            get: {
                params: {
                    primaryEntityLevelCode : 'PTY',
                    primaryEntityNumber : null,
                    includeManualReviews : null
                },
                method: 'GET',
                interceptor: {   responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });



        var reviewCategoryScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/category', {}, {
            get: {
                params: {
                    reviewKey: '@reviewKey',
                    date: 'date',
                    primaryEntityLevelCode : 'PTY',
                    primaryEntityNumber : null
                },
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        var newReviewCategoryScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/customerRiskRating/scores/category', {}, {
            get: {
                params: {
                    date: 'date',
                    primaryEntityLevelCode : 'PTY',
                    primaryEntityNumber : null
                },
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        var reviewAttributeScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/attribute', {}, {
            get: {
                params: {
                    reviewKey: '@reviewKey',
                    date: 'date',
                    categoryCode: 'categoryCode',
                    primaryEntityLevelCode : 'PTY',
                    primaryEntityNumber : null
                },
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        var newReviewAttributeScoreResource = $resource(amlConfig.baseUrl + '/cddReviews/customerRiskRating/scores/attribute', {}, {
            get: {
                params: {
                    date: 'date',
                    categoryCode: 'categoryCode',
                    primaryEntityLevelCode : 'PTY',
                    primaryEntityNumber : null
                },
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });

        /**
         * Get a review by review key
         * @param reviewKey
         * @returns {$promise|*}
         */
        function getReview(reviewKey) {
            return reviewOverallScoreResource.get({
                reviewKey:reviewKey}).$promise;
        }

        function getOverallScores(reviewKey){
            return reviewOverallScoreResource.get({
                reviewKey: reviewKey
            }).$promise;
        }

        function getOverallScoresForNewReview(primaryEntityLevelCode, primaryEntityNumber, includeManualReviews){
            return newReviewOverallScoreResource.get({
                primaryEntityLevelCode:primaryEntityLevelCode,
                primaryEntityNumber:primaryEntityNumber,
                includeManualReviews: includeManualReviews
            }).$promise;
        }

        function getCategoryScores(reviewKey, entityNumber, entityLevelCode, eventDate) {
            return reviewCategoryScoreResource.get({reviewKey:reviewKey,
                eventDate:eventDate,
                primaryEntityNumber:entityNumber,
                primaryEntityLevelCode:entityLevelCode}).$promise;
        }

        function getCategoryScoresForNewReview(entityNumber, entityLevelCode, eventDate) {
            return newReviewCategoryScoreResource.get({
                eventDate:eventDate,
                primaryEntityNumber:entityNumber,
                primaryEntityLevelCode:entityLevelCode}).$promise;
        }

        function getAttributeScores(reviewKey, entityNumber, entityLevelCode, eventDate, categoryCode){
            return reviewAttributeScoreResource.get({reviewKey: reviewKey,
                eventDate: eventDate,
                primaryEntityNumber: entityNumber,
                primaryEntityLevelCode: entityLevelCode,
                categoryCode: categoryCode
            }).$promise;
        }

        function getAttributeScoresForNewReview(entityNumber, entityLevelCode, eventDate, categoryCode){
            return newReviewAttributeScoreResource.get({
                eventDate: eventDate,
                primaryEntityNumber: entityNumber,
                primaryEntityLevelCode: entityLevelCode,
                categoryCode: categoryCode
            }).$promise;
        }

        /**
         * run a scatter line plot for score history for a customer
         * @param
         * @returns {svg}
         */
        function scatterLinePlot(scoresData, domId, yAxisLabel, averageScoreLabel, scoreLabel, xAxisLabel, localeString, dateFilter){

            var id = '#' + domId;
            var data = [];
            var dataDates = [];
            data = _.map(scoresData, function(obj){ return [ moment(obj.eventDate)._d, obj.ruleScore ];});
            dataDates = _.map(data, function(obj){
                return obj[0];
            });

            var total = 0;
            var avg;

            for(var i = 0; i < data.length; i++){
                total +=data[i][1];
            }
            if(data.length === 1){

                var tempDateBehind = new Date(data[0][0]);
                var tempDateForward = new Date(data[0][0]);

                tempDateBehind.setDate(tempDateBehind.getDate()-5);
                tempDateForward.setDate(tempDateForward.getDate()+5);

                data.push([tempDateBehind,0]);
                data.push([tempDateForward,0]);
                avg = total;
            }else{
                avg = total / data.length;
            }

            var warnLine = { lineValue: avg, label: averageScoreLabel };

            data.sort(function (a, b) {
                return (new Date(a[0])).getTime() - (new Date(b[0])).getTime();
            });

            /* jshint maxstatements:60 */
            var drawLineGraph = function(dataDates, containerHeight, containerWidth, data, yLabel, warnLine, dateLabel, dateFilter) {
                /*jshint maxcomplexity:18*/

                var svg = d3.select(id).append('svg')
                    .attr('width', containerWidth)
                    .attr('height', containerHeight);

                var tooltip = d3.select(id).append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);

                var margin = { top: 50, left: 50, right: 50, bottom: 50 };

                var height = containerHeight - margin.top - margin.bottom;
                var width = containerWidth - margin.left - margin.right;

                var xDomain = d3.extent(data, function(d) { return d[0]; });
                var yDomain = d3.extent(data, function(d) { return d[1]; });

                var xScale;
                var yScale;
                var minScore;
                var maxScore;

                var minDate;
                var maxDate;
                var dayInterval;

                //if there is only one datapoint, then simply simulate 2 more to create range
                if(data.length === 1){
                    minDate = new Date(data[0][0]);
                    maxDate = new Date(data[0][0]);
                    minDate.setDate(minDate.getDate()-5);
                    maxDate.setDate(maxDate.getDate()+5);
                    minScore = data[0][1]-10;
                    maxScore = data[0][1]+10;
                    xScale = d3.time.scale().range([0, width]).domain([minDate, maxDate]);
                    yScale = d3.scale.linear().range([height, 0]).domain([minScore, maxScore]);
                    minDate = new Date(_.min(dataDates));
                    maxDate = new Date(_.max(dataDates));
                    dayInterval = (((maxDate - minDate)/5)/(1000*60*60))/24;

                }else{
                    maxScore = _.max(data, function(d){ return d[1];});
                    xScale = d3.time.scale().range([0, width]).domain(xDomain);
                    yScale = d3.scale.linear().range([height, 0]).domain([0,maxScore[1]]);

                    minDate = new Date(_.min(dataDates));
                    maxDate = new Date(_.max(dataDates));
                    dayInterval = (((maxDate - minDate)/5)/(1000*60*60))/24;
                }

                var xAxis = d3.svg.axis()
                    .scale(xScale)
                    .orient('bottom')
                    .ticks(function(d){ if(dayInterval > 10){
                        return 10;
                    }else{
                        return Math.ceil(dayInterval);
                    }})
                    .innerTickSize(-height)
                    .outerTickSize(0)
                    .tickPadding(20)
                    .tickFormat(function(d){ return dateFilter(d, 'shortDate');});

                var yAxis = d3.svg.axis().scale(yScale).orient('left').innerTickSize(-width)
                    .outerTickSize(0)
                    .tickPadding(10);

                var line = d3.svg.line()
                    .x(function(d) { return xScale(d[0]); })
                    .y(function(d) { return yScale(d[1]); });

                var area = d3.svg.area()
                    .x(function(d) { return xScale(d[0]); })
                    .y0(function(d) { return yScale(d[1]); })
                    .y1(height);

                var g = svg.append('g').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

                var tempData = [];
                tempData = data.filter(function(d){
                    return d[1] !== 0;
                });

                g.append('path')
                    .datum(data)
                    .attr('class', 'area')
                    .attr('d', area);

                g.append('g')
                    .attr('class', 'x axis')
                    .attr('transform', 'translate(0, ' + height + ')')
                    .call(xAxis);
                
                //------x-axis and y-axis labels------>
                svg.append('text')
                    .attr('class', 'x label')
                    .attr('text-anchor', 'end')
                    .attr('x', width + 30)
                    .attr('y', height + 45)
                    .text(dateLabel);
                
                svg.append('text')
                    .attr('class', 'y label')
                    .attr('text-anchor', 'end')
                    .attr('x', -50)
                    .attr('y', 55)
                    .attr('dy', '.75em')
                    .attr('transform', 'rotate(-90)')
                    .text(yLabel);
                //---------------------->

                g.append('g')
                    .attr('class', 'y axis')
                    .call(yAxis);

                g.append('path')
                    .datum(data)
                    .attr('class', 'line')
                    .attr('d', line);

                g.selectAll('dot').data(tempData).enter().append('circle')
                    .attr('cx', function(d) { return xScale(d[0]); })
                    .attr('cy', function(d) { return yScale(d[1]); })
                    .attr('r', 5)
                    .attr('class', 'circle');

                // focus tracking

                var focus = g.append('g').data(tempData).style('display', 'none');

                focus.append('line')
                    .attr('id', 'focusLineX')
                    .attr('class', 'focusLine');
                focus.append('line')
                    .attr('id', 'focusLineY')
                    .attr('class', 'focusLine');
                focus.data(tempData).append('circle')
                    .attr('id', 'focusCircle')
                    .attr('r', 5)
                    .attr('class', 'circle focusCircle');

                var bisectDate = d3.bisector(function(d) { return d[0]; }).left;
                // var formatTime = d3.time.format('%e %B');
                g.append('rect')
                    .attr('class', 'overlay')
                    .attr('width', width)
                    .attr('height', height)
                    .on('mouseover', function() { focus.style('display', null); })
                    .on('mouseout', function() { focus.style('display', 'none');
                                                    tooltip.transition()
                                                    .duration(500)
                                                    .style('opacity', 0); })
                    .on('mousemove', function(d) {
                        var mouse = d3.mouse(this);
                        var mouseDate = xScale.invert(mouse[0]);
                        var i = bisectDate(data, mouseDate); // returns the index to the current data item
                        var d0, d1;
                        if(i-1 > 0){
                            d0 = data[i - 1];
                            d1 = data[i];
                            // work out which date value is closest to the mouse
                            d = mouseDate - d0[0] > d1[0] - mouseDate ? d1 : d0;
                        }else{
                            d0 = data[i];
                            d1 = data[i];
                            // work out which date value is closest to the mouse
                            d = mouseDate - d0[0] > d1[0] - mouseDate ? d1 : d0;
                        }
                        var x = xScale(d[0]);
                        var y = yScale(d[1]);

                        try{
                            if(d[1] !== 0){
                                focus.select('#focusCircle')
                                    .attr('cx', x)
                                    .attr('cy', y);
                                focus.select('#focusLineX')
                                    .attr('x1', x).attr('y1', yScale(yDomain[0]))
                                    .attr('x2', x).attr('y2', yScale(yDomain[1]));
                                focus.select('#focusLineY')
                                    .attr('x1', xScale(xDomain[0])).attr('y1', y)
                                    .attr('x2', xScale(xDomain[1])).attr('y2', y);

                                tooltip.transition()
                                    .duration(5)
                                    .style('opacity', 1.1);
                                tooltip.html(scoreLabel + ': ' + d[1] + '<br/>' + dateLabel + ': ' + dateFilter(d[0], 'shortDate'))
                                    .style('left', (d3.event.pageX) + 'px')
                                    .style('top', (d3.event.pageY - 5) + 'px');
                            }
                        }catch(typeerror){}
                    });

                // if(warnLine && yDomain[0] < warnLine.lineValue && yDomain[1] > warnLine.lineValue) {
                    g.append('line')
                        .attr('x1', xScale(xDomain[0]))
                        .attr('y1', yScale(warnLine.lineValue))
                        .attr('x2', xScale(xDomain[1]))
                        .attr('y2', yScale(warnLine.lineValue))
                        .attr('class', 'zeroline');
                    g.append('text')
                        .attr('x', xScale(xDomain[1]))
                        .attr('y', yScale(warnLine.lineValue))
                        .attr('dy', '1em')
                        .attr('text-anchor', 'end')
                        .text(warnLine.label)
                        .attr('class', 'zerolinetext');
                // }
            };

            drawLineGraph(dataDates, 479, 1000, data, yAxisLabel, warnLine, xAxisLabel, dateFilter);
        }

        /**
         * get the appropriate triggering value, depending on value typeCode
         * @param cddReview
         * @returns {*}
         */
        function getTypeValue( cddReview ) {
            var typeCode = cddReview.triggeringValue.triggeringValueTypeCode;
            var typeVal = null;
            if ( typeCode === 'CHAR' ) {
                typeVal = cddReview.triggeringValue.triggeringCharValue;
            }
            else if ( typeCode === 'NUM' ) {
                typeVal = cddReview.triggeringValue.triggeringNumValue;
            }
            else if ( typeCode === 'DATE' ) {
                typeVal = cddReview.triggeringValue.triggeringDateValue;
            }
            return typeVal;
        }

        /**
         * Column renderer to render a triggering value, based on the appropriate LOV table and
         * value type
         * @param cddReview
         * @returns {*}
         */
        function triggeringValueRenderer(cddReview) {
            if ( cddReview.triggeringValue ) {

                // Return the value by:
                //  1. get dataItem.triggeringValue.lovTableName.
                //  2. Look at dataItem.triggeringValue.triggeringValueTypeCode
                //  3. based off of triggeringValueTypeCode, get the value from appropriate typed property. Eg: triggeringCharValue
                //  4. look up lovTableName with value from appropriate property. Eg: triggeringCharValue
                var val = null;
                var lovTable = cddReview.triggeringValue.lovTableName;
                if ( lovTable  ) {
                    var typeVal = getTypeValue( cddReview );
                    if ( typeVal ) {
                        var lovValMap = amlLov.getByLovTableName( lovTable );
                        if ( lovValMap ) {
                            var mappingObject = lovValMap[typeVal];
                            if ( mappingObject ) {
                                val = mappingObject.description;
                            }
                        }
                    }
                }

                if ( !val ) {
                    // use a default value if the lov table did not exist in the map
                    val=getTypeValue(cddReview);
                }
                return val;
            }
            else {
                return '';
            }
        }


        var service = {
            getReview: getReview,
            getOverallScores: getOverallScores,
            getOverallScoresForNewReview: getOverallScoresForNewReview,
            getAttributeScores: getAttributeScores,
            getAttributeScoresForNewReview: getAttributeScoresForNewReview,
            getCategoryScores: getCategoryScores,
            getCategoryScoresForNewReview: getCategoryScoresForNewReview,
            triggeringValueRenderer: triggeringValueRenderer,
            scatterLinePlot: scatterLinePlot,
        };

        return service;

    }
})();

/**
 * @ngdoc service
 * @name     aml.admin:usersService
 *
 * @restrict E
 *
 * @description
 * The admin service is used to perform administrative functions, such as retrieving logs and clearing caches
 *
 * @element ANY
 * @required on-click
 */
(function() {
    'use strict';

    usersService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "$q", "$window", "resourceService", "amlCoreUtils", "amlConstants", "resources"];
    angular
        .module('aml.admin')
        .factory('usersService', usersService);

    /* @ngInject */
    function usersService($resource, amlConfig, _, exceptionResourceHandler, $q, $window, resourceService,
            amlCoreUtils, amlConstants, resources) {
        var currentUser = null;
        var currentUserId;
        var currentUserBusinessUnit;
        var currentUserBusinessUnitMemberships;
        var currentUserQueues = [];
        var applicationName;
        var buildVersion;
        var buildDate;
        var currentUserCapabilities;
        var userListPromise = null;
        var userList;
        var cddReviewsVm;
        var commentsVm;

        /**
         * Resources
         */

        // http://d78245.na.sas.com:8780/SASComplianceSolutionsMid/rest/users/current.json?relationships=applicationCapabilities&applicationNames=aml
        var currentUserResource = $resource(amlConfig.baseUrl + '/users/current',
            {relationships:'applicationCapabilities,queues', applicationNames:'aml'},
            { get: {
                method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });

        var usersResource = $resource(amlConfig.baseUrl + '/users',
            {capabilities:'@capabilities', group: '@group'},
            { get: {
                method: 'GET',  interceptor: {responseError: exceptionResourceHandler.resourceErrorHandler}}
            });


        var service = {
            init: init,
            getCurrentUser: getCurrentUser,
            getCurrentUserBusinessUnit: getCurrentUserBusinessUnit,
            getCurrentUserBusinessUnitMemberships: getCurrentUserBusinessUnitMemberships,
            getCurrentUserId: getCurrentUserId,
            getUsersWithCapability: getUsersWithCapability,
            getUsersWithAnyCapability: getUsersWithAnyCapability,
            getUsersForGroup: getUsersForGroup,
            currentUserHasAnyCapability: currentUserHasAnyCapability,
            currentUserHasAnyCapabilityPromise: currentUserHasAnyCapabilityPromise,
            currentUserHasAllCapabilities: currentUserHasAllCapabilities,
            currentUserHasCapability: currentUserHasCapability,
            logoffCurrentUser: logoffCurrentUser,
            logoffCurrentUserTimedOut: logoffCurrentUserTimedOut,
            getApplicationName: getApplicationName,
            getBuildVersion: getBuildVersion,
            getBuildDate: getBuildDate,
            downloadUserList: downloadUserList,
            getUserNames: getUserNames,
            getCurrentUserQueues: getCurrentUserQueues,
            hasQueueAccess : hasQueueAccess,
            getCddReviewsVm: getCddReviewsVm,
            setCddReviewsVm: setCddReviewsVm,
            getCommentsVm: getCommentsVm,
            setCommentsVm: setCommentsVm
        };

        activate();

        return service;
        
        function getCddReviewsVm(){
        	return cddReviewsVm;
        }
        
        function setCddReviewsVm(vm){
        	cddReviewsVm = vm;
        }
        
        function getCommentsVm(){
        	return commentsVm;
        }
        
        function setCommentsVm(vm){
        	commentsVm = vm;
        }

        /////////////////////

        function init() {
            return getCurrentUser().then( function(user ){
                if ( !currentUserId ) {
                    currentUserBusinessUnit = user.businessUnit;
                    currentUserBusinessUnitMemberships = user.businessUnitMemberships;
                    currentUserQueues = user.queues;
                    if (user.applicationCapabilities && user.applicationCapabilities.length > 0) {
                        currentUserCapabilities = user.applicationCapabilities[0];
                    }
                    else {
                        currentUserCapabilities = {};
                    }
                    currentUserId = user.userId;

                    if ( user.applicationInfo ) {
                        applicationName = user.applicationInfo.applicationName;
                        buildDate = user.applicationInfo.buildDate;
                        buildVersion = user.applicationInfo.buildVersion;
                    }

                }
            });
        }

        function activate() {
            init();
        }

        function getCurrentUser() {
            if ( !currentUser ) {
                currentUser = currentUserResource.get({}).$promise;
            }
            return currentUser;
        }

        function logoffCurrentUserTimedOut() {
           resourceService.getLocaleShortCode().then(function(locale) {
               var timedOutUri = amlCoreUtils.formatStr('/SASLogon/TimedOut.do?_locale={0}&_sasapp={1}',
                   locale, getApplicationName() );
               $window.location.href = timedOutUri;
            });

        }

        function logoffCurrentUser() {
            resourceService.getLocaleShortCode().then(function(locale) {
                var timedOutUri = amlCoreUtils.formatStr('/SASLogon/logout?_locale={0}&_sasapp={1}',
                    locale, getApplicationName() );
                $window.location.href = timedOutUri;
            });
        }


        /**
         * Return true if the current user has any of the capabilities in the specified array of capabilities
         *
         * @param capabilities - array of capability names
         *
         * @returns {boolean}
         */
        function currentUserHasAnyCapability( capabilities ) {
            if ( !_.isArray( capabilities )) {
                throw new Error( 'Expecting an array of capabilities, but received: ' +
                    capabilities + ' : ' + (typeof capabilities ));
            }
            var hasAnyCapability = null;
            if ( currentUserCapabilities && currentUserCapabilities.capabilities) {
                 hasAnyCapability = _.find( capabilities, function( capability ) {
                    var hasThisCapability = _.contains( currentUserCapabilities.capabilities, capability );
                    return hasThisCapability;
                });
            }

            // hasAnyCapability is set with the first found capability, or undefined in none found
            return hasAnyCapability !== null && !_.isUndefined( hasAnyCapability );
        }


        function currentUserHasAnyCapabilityPromise( capabilities ) {
            return getCurrentUser().then( function(user ){
                return currentUserHasAnyCapability( capabilities );
            });
        }

        /**
         * Return true if the current user the specified capability
         *
         * @param capability - a string representing the capability name to check
         * @returns {boolean}
         */
        function currentUserHasCapability( capability ) {
            if ( currentUserCapabilities && currentUserCapabilities.capabilities) {
                var hasThisCapability = _.contains( currentUserCapabilities.capabilities, capability );
                return hasThisCapability;
            }
            return false;
        }

        /**
         * Return true if the current user has all of the capabilities in the specified array of capabilities
         *
         * @param capabilities -  array of capability names
         * @returns {boolean}
         */
        function currentUserHasAllCapabilities( capabilities ) {
            if ( !_.isArray( capabilities )) {
                throw new Error( 'Expecting an array of capabilities, but received: ' +
                    capabilities + ' : ' + (typeof capabilities ));
            }
            var hasAllCapabilities = false;
            if ( currentUserCapabilities && currentUserCapabilities.capabilities) {
                hasAllCapabilities = _.every( capabilities, function( capability ) {
                    var hasThisCapability = _.contains( currentUserCapabilities.capabilities, capability );
                    return hasThisCapability;
                });
            }
            return hasAllCapabilities;
        }


        function updateUsersWithDisplayLabel(users) {
            // add displayLabel displaying both user name and id

            var rlmEntity = '';
            if(resources.aml && resources.aml.metadata.textDirection === 'rtl') {
                rlmEntity = '&rlm;';
            }

            _.each(users.items, function (user) {
                user.displayLabel = '';
                if (user.userName) {
                    user.displayLabel = user.userName + ' ';
                }
                if (user.userId) {
                    user.displayLabel = user.displayLabel + rlmEntity + '(' + user.userId + ')';
                }
            });
            return users;
        }

        function getUsersWithCapability(capabilityId) {
            if ( capabilityId ) {
                return usersResource.get({
                    capabilities: capabilityId
                }).$promise.then(updateUsersWithDisplayLabel);
            }
            else {
                var emptyUsers = $q.defer();
                emptyUsers.resolve( [] );
                return emptyUsers.promise;
            }
        }

        function getUsersWithAnyCapability(capabilities) {
            if ( capabilities ) {
                return usersResource.get({
                    capabilities: capabilities
                }).$promise.then(updateUsersWithDisplayLabel);
            }
            else {
                var emptyUsers = $q.defer();
                emptyUsers.resolve( [] );
                return emptyUsers.promise;
            }
        }


        function getUsersForGroup(userGroupName) {
            if ( userGroupName ) {
                return usersResource.get({
                    group: userGroupName
                }).$promise.then(updateUsersWithDisplayLabel);
            }
            else {
                var emptyUsers = $q.defer();
                emptyUsers.resolve( [] );
                return emptyUsers.promise;
            }
        }

        function getCurrentUserBusinessUnitMemberships() {
            return currentUserBusinessUnitMemberships;
        }

        function getCurrentUserBusinessUnit() {
            return currentUserBusinessUnit;
        }

        function getCurrentUserQueues() {
            return currentUserQueues;
        }

        function hasQueueAccess (queueCode) {
            return queueCode === null || !angular.isDefined(queueCode) || queueCode === '' ||  _.indexOf(currentUserQueues, queueCode) !== -1;
        }

        function getApplicationName() {
            return applicationName;
        }

        function getBuildVersion() {
            return buildVersion;
        }

        function getBuildDate() {
            return buildDate;
        }

        function getCurrentUserId() {
            return currentUserId;
        }

        function downloadUserList() {
            if(!userListPromise) {
                userListPromise = getUsersWithAnyCapability(
                    amlConstants.capabilities.restServicesAccess
                ).then(function(data) {
                    userList = data.items;
                    return data;
                });
            }
            return userListPromise;
        }

        function getUserNames() {
            return userList;
        }
    }
})();
/**
 * Created by sasrns on 8/18/2015.
 *
 * Handle message passing between associated reviews list components
 */

(function() {
    'use strict';

    reviewsListDataMessagingService.$inject = ["$rootScope"];
    angular.module('cdd.reviews').factory('reviewsListDataMessagingService', reviewsListDataMessagingService);
    function reviewsListDataMessagingService( $rootScope ) {
        var displayOwnersType = false;
        var getSelectedReviewsFn = null;
        var gridRefershFn = null;

        function reloadGrid() {
            if ( !gridRefershFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No gridRefershFn has been supplied.'
                });
            }
            gridRefershFn();
        }


        function initializeDataRetrievalCallbacks( getSelectedReviewsFnCallback, gridRefershFnCallback ) {
            getSelectedReviewsFn = getSelectedReviewsFnCallback;
            gridRefershFn = gridRefershFnCallback;
        }

        function getSelectedReviewNumbers() {
            return _.pluck( getSelectedReviews(), 'key' );
        }

        function getSelectedReviewOwners() {
            return _.pluck( getSelectedReviews(), 'ownerUserLongId' );
        }

        function getSelectedReviewQueues() {
            return _.pluck( getSelectedReviews(), 'queueCode' );
        }

        function getSelectedReviews() {
            if ( !getSelectedReviewsFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedReviewsFn has been supplied.'
                });
            }
            return getSelectedReviewsFn();
        }


        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function reviewsOwnerChanged( reviewNumbers, owner, queue ) {
            $rootScope.$broadcast( 'reviewsOwnerChanged', { reviewNumbers: reviewNumbers, owner: owner, queue: queue });
        }

        function reviewsStatusChanged( reviewNumbers, statusCode ) {
            $rootScope.$broadcast('reviewsStatusChanged', { reviewNumbers: reviewNumbers, statusCode: statusCode });
        }

        var service = {
            reviewsOwnerChanged: reviewsOwnerChanged,
            reviewsStatusChanged: reviewsStatusChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedReviewNumbers: getSelectedReviewNumbers,
            getSelectedReviews: getSelectedReviews,
            getSelectedReviewOwners: getSelectedReviewOwners,
            getSelectedReviewQueues: getSelectedReviewQueues,
            setDisplayOwnersType: setDisplayOwnersType,
            reloadGrid : reloadGrid,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks
        };
        return service;

    }
})();


/**
 * @ngdoc service
 * @name     aml.customer:customerService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve customers from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    accountService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.customer')
        .factory('accountService', accountService);

    /* @ngInject */
    function accountService($resource, amlConfig, exceptionResourceHandler) {

        /**
         * Resources
         */

        var accountResource = $resource(amlConfig.baseUrl + '/accounts/:id', {
            id: '@id',
            relationships: 'customers,households'

        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
                }
            }
        });

        var accountAlertResource = $resource(amlConfig.baseUrl + '/accounts/:id/alerts', {
            id: '@id'

        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });


        var service = {

            getAccount: getAccount,
            getAccountAlerts: getAccountAlerts

        };

        return service;

        function getAccount(accountid) {
            return accountResource.get({
                id: accountid
            }).$promise;
        }

        /**
         * Get list of account alerts
         * @returns {$promise|*}
         */
        function getAccountAlerts(id) {
            return accountAlertResource.get( {
                id:id
            }).$promise;
        }


    }
})();

(function () {
  'use strict';

  associateService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
  angular
    .module('aml.customer')
    .factory('associateService', associateService);

  /* @ngInject */
  function associateService($resource, amlConfig, exceptionResourceHandler) {

    /**
         * Resources
         */

    var associateResource = $resource(amlConfig.baseUrl + '/associates/:id', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
        }
      }
    });

    var associateAlertResource = $resource(amlConfig.baseUrl + '/associates/:id/alerts', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandler
        }
      }
    });


    var service = {

      getAssociate: getAssociate,
      getAssociateAlerts: getAssociateAlerts

    };

    return service;

    function getAssociate(associateid) {
      return associateResource.get({
        id: associateid
      }).$promise;
    }

    function getAssociateAlerts(associateid) {
      return associateAlertResource.get({
        id: associateid
      }).$promise;
    }

  }
})();

(function () {
  'use strict';

  bankService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
  angular
    .module('aml.customer')
    .factory('bankService', bankService);

  /* @ngInject */
  function bankService($resource, amlConfig, exceptionResourceHandler) {

    /**
         * Resources
         */

    var bankResource = $resource(amlConfig.baseUrl + '/banks/:id', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
        }
      }
    });

    var bankAlertResource = $resource(amlConfig.baseUrl + '/banks/:id/alerts', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandler
        }
      }
    });


    var service = {

      getBank: getBank,
      getBankAlerts: getBankAlerts

    };

    return service;

    function getBank(bankid) {
      return bankResource.get({
        id: bankid
      }).$promise;
    }

    function getBankAlerts(bankid) {
      return bankAlertResource.get({
        id: bankid
      }).$promise;
    }

  }
})();

(function () {
  'use strict';

  branchService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
  angular
    .module('aml.customer')
    .factory('branchService', branchService);

  /* @ngInject */
  function branchService($resource, amlConfig, exceptionResourceHandler) {

    /**
         * Resources
         */

    var branchResource = $resource(amlConfig.baseUrl + '/branches/:id', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
        }
      }
    });


    var service = {

      getBranch: getBranch

    };

    return service;

    function getBranch(branchid) {
      return branchResource.get({
        id: branchid
      }).$promise;
    }
  }
})();

/**
 * Created by tommut on 1/22/2015.
 *
 * Handle message passing between associated entity list components
 */

(function() {
    'use strict';

    entityListDataMessagingService.$inject = ["$rootScope", "entityService", "_"];
    angular.module('aml.customer.details').factory('entityListDataMessagingService', entityListDataMessagingService);
    function entityListDataMessagingService( $rootScope, entityService, _ ) {
        var displayOwnersType = false;
        var getSelectedEntitiesFn = null;

        /*
         * set callback functions to allow for retrieving information about selected rows in the entity grid
         */
        function initializeDataRetrievalCallbacks( getSelectedEntitiesFnCallback ) {
            getSelectedEntitiesFn = getSelectedEntitiesFnCallback;
        }

        /**
         * Get the selected entity ids based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEntityIds() {
            var entityIds = [];
            _.each(getSelectedEntities(), function( entity ) {
                if (entity && (entity.entityKey || entity.entityNumber)) {
                    entityIds.push(entityService.createEntityId(entity));
                }
            });
            return entityIds;
        }

        /**
         * Get the selected entity names based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEntityNames() {
            return _.pluck( getSelectedEntities(), 'entityName' );
        }

        function getSelectedEntityOwners() {
            return _.pluck( getSelectedEntities(), 'ownerUserId' );
        }

        function getSelectedEntityQueues() {
            return _.pluck( getSelectedEntities(), 'queueCode' );
        }

        /**
         * Get the selected entities based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEntities() {
            if ( !getSelectedEntitiesFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedEntitiesFn has been supplied.'
                });
            }
            return getSelectedEntitiesFn();
        }

        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function entitiesOwnerChanged( entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner ) {
            $rootScope.$broadcast( 'entitiesOwnerChanged', { entityIds: entityIds, owner: owner, queue: queue,
                                                             replaceCurrentQueue: replaceCurrentQueue, replaceCurrentOwner: replaceCurrentOwner });
        }

        function reloadGrid() {
            $rootScope.$broadcast( 'reloadEntitiesGridPage' );
        }

        function entitiesAlertCountChanged( entityIds, alertCount ) {
            $rootScope.$broadcast( 'entitiesAlertCountChanged', { entityIds: entityIds, alertCount: alertCount });
        }

        function refreshEntityAlertCount(entityIds) {
            _.each(entityIds, function (entityId) {
                entityService.getEntityAlertCount(entityId).then(
                    function success (data) {
                        entitiesAlertCountChanged( [entityId], data.data );
                    },
                    function error (err) {

                    }
                );
            });
        }

        var service = {
            entitiesOwnerChanged: entitiesOwnerChanged,
            entitiesAlertCountChanged: entitiesAlertCountChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedEntityIds: getSelectedEntityIds,
            getSelectedEntityNames: getSelectedEntityNames,
            getSelectedEntityOwners: getSelectedEntityOwners,
            getSelectedEntityQueues: getSelectedEntityQueues,
            getSelectedEntities: getSelectedEntities,
            setDisplayOwnersType: setDisplayOwnersType,
            refreshEntityAlertCount: refreshEntityAlertCount,
            reloadGrid : reloadGrid,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks
        };
        return service;

    }
})();


(function () {
  'use strict';

  externalPartyService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
  angular
    .module('aml.customer')
    .factory('externalPartyService', externalPartyService);

  /* @ngInject */
  function externalPartyService($resource, amlConfig, exceptionResourceHandler) {

    /**
         * Resources
         */

    var externalPartyResource = $resource(amlConfig.baseUrl + '/externalParties/byNumber/:id', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
        }
      }
    });

    var externalPartyAlertResource = $resource(amlConfig.baseUrl + '/externalParties/byNumber/:id/alerts', {
      id: '@id'

    }, {
      get: {
        method: 'GET',
        interceptor: {
          responseError: exceptionResourceHandler.resourceErrorHandler
        }
      }
    });


    var service = {

      getExternalParty: getExternalParty,
      getExternalPartyAlerts: getExternalPartyAlerts

    };

    return service;

    function getExternalParty(externalpartyid) {
      return externalPartyResource.get({
        id: externalpartyid
      }).$promise;
    }

    function getExternalPartyAlerts(externalpartyid) {
//console.log("externalpartyid : " + externalpartyid);
      return externalPartyAlertResource.get({
        id: externalpartyid
      }).$promise;
    }
  }
})();

/**
 * @ngdoc service
 * @name     aml.customer:customerService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve customers from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';

    householdService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.customer')
        .factory('householdService', householdService);

    /* @ngInject */
    function householdService($resource, amlConfig, exceptionResourceHandler) {

        /**
         * Resources
         */

        var householdResource = $resource(amlConfig.baseUrl + '/households/:id', {
            id: '@id',
            relationships: 'customers,accounts'

        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound
                }
            }
        });

        var householdAlertResource = $resource(amlConfig.baseUrl + '/households/:id/alerts', {
            id: '@id',
            relationships: 'customers,accounts'

        }, {
            get: {
                method: 'GET',
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler
                }
            }
        });


        var service = {

            getHousehold: getHousehold,
            getHouseholdAlerts: getHouseholdAlerts

        };

        return service;

        function getHousehold(householdNumber) {
            return householdResource.get({
                id: householdNumber
            }).$promise;
        }

        function getHouseholdAlerts(householdNumber) {
            return householdAlertResource.get({
                id: householdNumber
            }).$promise;
        }

    }
})();

/**
 * Created by sasrns on 8/18/2015.
 *
 * Handle message passing between associated efiles list components
 */

(function() {
    'use strict';

    efilesListDataMessagingService.$inject = ["$rootScope"];
    angular.module('aml.efiles.details').factory('efilesListDataMessagingService', efilesListDataMessagingService);
    function efilesListDataMessagingService( $rootScope ) {
        var displayOwnersType = false;
        var getSelectedEfileNumbersFn = null;

        function initializeDataRetrievalCallbacks( getSelectedEfileNumbersFnCallback ) {
            getSelectedEfileNumbersFn = getSelectedEfileNumbersFnCallback;
        }

        function getSelectedEfileNumbers() {
            if ( !getSelectedEfileNumbersFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedEfileNumbersFn has been supplied.'
                });
            }

            var selectedEfileNumbers = getSelectedEfileNumbersFn();
            return selectedEfileNumbers;
        }

        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function efilesOwnerChanged( efileNumbers, owner ) {
            $rootScope.$broadcast( 'efilesOwnerChanged', { efileNumbers: efileNumbers, owner: owner });
        }


        var service = {
            efilesOwnerChanged: efilesOwnerChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedEfileNumbers: getSelectedEfileNumbers,
            setDisplayOwnersType: setDisplayOwnersType,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks
        };
        return service;

    }
})();


/**
 * Created by sasrns on 1/11/2016.
 *
 * Handle message passing between associated reports list components
 */

(function() {
    'use strict';

    reportsListDataMessagingService.$inject = ["$rootScope"];
    angular.module('aml.reports.details').factory('reportsListDataMessagingService', reportsListDataMessagingService);
    function reportsListDataMessagingService( $rootScope ) {
        var displayOwnersType = false;
        var getSelectedReportsFn = null;
        var gridRefershFn = null;

        function reloadGrid() {
            if ( !gridRefershFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No gridRefershFn has been supplied.'
                });
            }
            gridRefershFn();
        }


        function initializeDataRetrievalCallbacks( getSelectedReportsFnCallback, gridRefershFnCallback ) {
            getSelectedReportsFn = getSelectedReportsFnCallback;
            gridRefershFn = gridRefershFnCallback;
        }

        function getSelectedReports() {
            if ( !getSelectedReportsFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedReportsFn has been supplied.'
                });
            }

            return getSelectedReportsFn();
        }

        function getSelectedReportNumbers() {
            return _.pluck( getSelectedReports(), 'reportKey' );
        }

        function getSelectedReportOwners() {
            return _.pluck( getSelectedReports(), 'ownerUserLongId');
        }

        function getSelectedReportQueues() {
            return _.pluck( getSelectedReports(), 'queueCode');
        }

        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function reportsOwnerChanged( reportNumbers, owner, queue ) {
            $rootScope.$broadcast( 'reportsOwnerChanged', { reportNumbers: reportNumbers, owner: owner, queue: queue });
        }


        var service = {
            reportsOwnerChanged: reportsOwnerChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedReportNumbers: getSelectedReportNumbers,
            getSelectedReportOwners: getSelectedReportOwners,
            getSelectedReportQueues: getSelectedReportQueues,
            getSelectedReports: getSelectedReports,
            setDisplayOwnersType: setDisplayOwnersType,
            reloadGrid : reloadGrid,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks
        };
        return service;

    }
})();


/**
 * Created by sasrns on 8/18/2015.
 *
 * Handle message passing between associated riskAssessments list components
 */

(function() {
    'use strict';

    riskAssessmentsListDataMessagingService.$inject = ["$rootScope"];
    angular.module('aml.riskAssessments').factory('riskAssessmentsListDataMessagingService', riskAssessmentsListDataMessagingService);
    function riskAssessmentsListDataMessagingService( $rootScope ) {
        var displayOwnersType = false;
        var getSelectedRiskAssessmentsFn = null;

        function initializeDataRetrievalCallbacks( getSelectedRiskAssessmentsFnCallback ) {
            getSelectedRiskAssessmentsFn = getSelectedRiskAssessmentsFnCallback;
        }

        function getSelectedRiskAssessments() {
            if ( !getSelectedRiskAssessmentsFn ) {
                throw new Error( {
                    'name': 'MissingFunctionException',
                    'message': 'No getSelectedRiskAssessments has been supplied.'
                });
            }

            return getSelectedRiskAssessmentsFn();
        }

        function getSelectedRiskAssessmentNumbers() {
            return _.pluck( getSelectedRiskAssessments(), 'assessmentId' );
        }

        function setDisplayOwnersType( displayType ) {
            displayOwnersType = displayType;
        }
        function getDisplayOwnersType( ) {
            return displayOwnersType;
        }

        function riskAssessmentsOwnerChanged( riskAssessmentNumbers, owner ) {
            $rootScope.$broadcast( 'riskAssessmentsOwnerChanged', { riskAssessmentNumbers: riskAssessmentNumbers, owner: owner });
        }


        var service = {
            riskAssessmentsOwnerChanged: riskAssessmentsOwnerChanged,
            getDisplayOwnersType: getDisplayOwnersType,
            getSelectedRiskAssessmentNumbers: getSelectedRiskAssessmentNumbers,
            getSelectedRiskAssessments: getSelectedRiskAssessments,
            setDisplayOwnersType: setDisplayOwnersType,
            initializeDataRetrievalCallbacks: initializeDataRetrievalCallbacks
        };

        return service;

    }
})();


(function() {
    'use strict';

    angular.module('aml.search').factory('popoverOpenService', popoverOpenService);

    function popoverOpenService() {
        var globalSearchPopoverOpen = {open: false};
        var searchCount = 0;

        function toggleGlobalSearchPopover() {
            globalSearchPopoverOpen.open = !globalSearchPopoverOpen.open;
            return globalSearchPopoverOpen;
        }

        function isGlobalSearchPopoverOpen() {
            return globalSearchPopoverOpen;
        }

        function getSearchCount() {
            searchCount ++;
            return searchCount.toString();
        }

        return {
            toggleGlobalSearchPopover: toggleGlobalSearchPopover,
            isGlobalSearchPopoverOpen: isGlobalSearchPopoverOpen,
            getSearchCount: getSearchCount
        };
    }
})();
//(function () {
//    'use strict';
//
//    angular.module('aml').factory('fundsTrackerForceNetworkService', fundsTrackerForceNetworkService);
//    function fundsTrackerForceNetworkService($resource, resources, messageService, amlConfig, amlConstants, linksProcessor,
//                                             exceptionResourceHandler, $window, _) {
//
//        function forceNetwork(data, accountNumber) {
//            var width = 1000,
//                height = 900;
//
//            var linksRaw = data;
//            var links = _.map(linksRaw, function (obj) {
//                return {"source": obj.fromCustomer, "target": obj.toCustomer, value: obj.currencyAmount / 10000};
//            });
//
//            var nodesArray = [];
//            var len = links.length;
//
//            for (i = 0; i < len; i++) {
//                for (var key in links[i]) {
//                    if (key === 'source' || key === 'target') {
//                        nodesArray.push(links[i][key]);
//                    }
//                }
//            }
//
//            var nodesUniq = _.uniq(nodesArray);
//
//
//            var nodes = _.map(nodesUniq, function (obj, index) {
//                return {
//                    name: nodesUniq[index],
//                    group: 1
//                };
//            });
//
//            for (var i = 0; i < links.length; i++) {
//                links[i].source = nodesUniq.indexOf(links[i].source);
//                links[i].target = nodesUniq.indexOf(links[i].target);
//            }
//
//            var graph = {"nodes": nodes, "links": links};
//
//            var color = d3.scale.category20();
//
//            var force = d3.layout.force()
//
//                .linkDistance(function(d) { return  d.value * Math.random() * 9; })
//                .size([width, height]);
//
//            var domId = '#fundstracker-' + accountNumber + '-ForceNetwork';
//            var svg = d3.select(domId).append("svg")
//                .attr("width", width)
//                .attr("height", height);
//
//            //Toggle stores whether the highlighting is on
//            var toggle = 0;
//            //Create an array logging what is connected to what
//
//            var linkedByIndex = {};
//            for (i = 0; i < graph.nodes.length; i++) {
//                linkedByIndex[i + "," + i] = 1;
//            };
//            graph.links.forEach(function (d) {
//                linkedByIndex[d.source.index + "," + d.target.index] = 1;
//            });
//
//            function neighboring(a, b) {
//                return linkedByIndex[a.index + "," + b.index];
//            }
//
//            function connectedNodes() {
//                if (toggle === 0) {
//                    //Reduce the opacity of all but the neighbouring nodes
//                    var d = d3.select(this).node().__data__;
//                    node.style("opacity", function (o) {
//                        return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
//                    });
//                    link.style("opacity", function (o) {
//                        return d.index===o.source.index | d.index===o.target.index ? 3 : 0.1;
//                    });
//
//                    //textLabels.style("opacity", function(o){
//                    //    return checkForLink(d,o) | checkForLink(o,d) ? 1: 0.1;
//                    //});
//                    toggle = 1;
//                } else {
//                    //Put them back to opacity=1
//                    node.style("opacity", 1);
//                    link.style("opacity", 1);
//                    textLabels.style("opacity", 1);
//                    toggle = 0;
//                }
//            }
//
//            var node_drag = d3.behavior.drag()
//                .on("dragstart", dragstart)
//                .on("drag", dragmove)
//                .on("dragend", dragend);
//            function dragstart(d, i) {
//                force.stop(); // stops the force auto positioning before you start dragging
//            }
//            function dragmove(d, i) {
//                d.px += d3.event.dx;
//                d.py += d3.event.dy;
//                d.x += d3.event.dx;
//                d.y += d3.event.dy;
//            }
//            function dragend(d, i) {
//                d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
//                force.resume();
//            }
//            function releasenode(d) {
//                d.fixed = false; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
//                //force.resume();
//            }
//
//            svg.append("defs").selectAll("marker")
//                .data(["suit", "licensing", "resolved"])
//                .enter().append("marker")
//                .attr("id", function(d) { return d; })
//                .attr("viewBox", "0 -5 10 10")
//                .attr("refX", 25)
//                .attr("refY", 0)
//                .attr("markerWidth", 6)
//                .attr("markerHeight", 6)
//                .attr("orient", "auto")
//                .append("path")
//                .attr("d", "M0,-5L10,0L0,5 L10,0 L0, -5")
//                .style("stroke", "#4679BD")
//                .style("opacity", "0.6");
//
//            force
//                .nodes(graph.nodes)
//                .links(graph.links)
//                .charge(function(d){
//                    var charge = -500;
//                    if (d.index === 0) charge = 10 * charge;
//                    return charge;
//                })
//                .gravity(1)
//                .friction(0.4)
//                .start();
//
//            var link = svg.selectAll(".link")
//                .data(graph.links)
//                .enter().append("line")
//                .attr("class", "link")
//                .style("stroke-width", function (d) {
//                    return Math.sqrt(d.value) * 0.1;
//                })
//                .style("stroke-opacity", function(d){
//                    return Math.random() * 0.8;
//                })
//                .style("stroke", "#999")
//                .style("marker-end",  "url(#suit)");
//
//            var node = svg.selectAll(".node")
//                .data(graph.nodes)
//                .enter().append("g")
//                .attr("class", "node")
//                .on("click", connectedNodes)
//                .call(force.drag)
//                .call(node_drag);
//
//            node.append("circle")
//                .attr("r", 15)
//                .style("fill", function (d) {
//                    return color(d.group);
//                })
//
//            var textLabels = svg.selectAll("text.labels")
//                                .data(graph.nodes)
//                                .enter()
//                                .append("text")
//                                .text(function(d) {return d.name})
//                                .style("font-family","sans-serif")
//                                .style("font-size","10px");
//
//            node.append("text.labels")
//                .attr("dx", 10)
//                .attr("dy", ".35em")
//                .style("stroke", "gray");
//
//
//            //Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
//            force.on("tick", function () {
//                link.attr("x1", function (d) {
//                        return d.source.x;
//                    })
//                    .attr("y1", function (d) {
//                        return d.source.y;
//                    })
//                    .attr("x2", function (d) {
//                        return d.target.x;
//                    })
//                    .attr("y2", function (d) {
//                        return d.target.y;
//                    });
//                //node.attr("cx", function(d) { return Math.max(r, Math.min(w - r, d.x)); })
//                //    .attr("cy", function(d) { return Math.max(r, Math.min(h - r, d.y)); });
//
//                d3.selectAll("circle").attr("cx", function (d) {
//                        return d.x;
//                    })
//                    .attr("cy", function (d) {
//                        return d.y;
//                    });
//                textLabels.attr("x", function (d) {
//                        var forceX = d.x;
//                        return forceX;
//                    })
//                    .attr("y", function (d) {
//                        var forceY = d.y;
//                        return forceY;
//                    });
//            });
//
//
//        }
//        var service = {
//            forceNetwork: forceNetwork
//        };
//        return service;
//    }
//
//
//})();
/**
 * @ngdoc service
 * @name     aml.cases:caseTriageService
 *
 * @restrict E
 *
 * @description
 * The caseTriageService service is used to handle case triage actions and opening modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    caseTriageService.$inject = ["messageService", "resources", "$uibModal", "casesService", "$q", "usersService", "exceptionResourceHandler"];
    angular
        .module('aml.cases')
        .factory('caseTriageService', caseTriageService);

    /* @ngInject */
    function caseTriageService(messageService, resources, $uibModal, casesService, $q, usersService,
                                   exceptionResourceHandler) {
        var service = {
            openRouteCasesDialog: openRouteCasesDialog,
            checkinCases: checkinCases,
            checkoutCases: checkoutCases
        };

        return service;


        function openRouteCasesDialog(caseNumbers, caseId, user, queue, onSuccessCallback) {
            if (caseNumbers && caseNumbers.length > 0) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'cases/casesList/triage/dialogs/routeCases.html',
                    controller: 'RouteCasesModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,
                    resolve: {
                        caseNumbers: function () {
                            return caseNumbers;
                        },
                        caseId: function () {
                            return caseId;
                        },
                        user: function () {
                            return user;
                        },
                        queue: function () {
                            return queue;
                        }
                    }
                });

                var dialogResult = modalInstance.result;
                dialogResult.then(function (result) {
                    casesService.routeCases(caseNumbers, result.routeToUser, result.routeToQueue).then(
                        function (data) {
                            // TODO: change message; pass in caseId
                            var msg = resources.aml.getPluralizedResource( caseNumbers.length,
                                'cases.triage.routeActionSuccessMessageOne',
                                'cases.triage.routeActionSuccessMessageOther',
                                {numberOfCases: caseNumbers.length, caseId: caseId});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                onSuccessCallback(caseNumbers, result.routeToUser, result.routeToQueue);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('cases.triage.routeActionErrorMessage',
                                    {caseId: caseId}), null, 4000);
                        });
                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }
        }

        function checkinCases(caseNumbers, caseId, onSuccessCallback) {
            if (caseNumbers && caseNumbers.length > 0) {
                return casesService.checkinCases(caseNumbers).then(
                    function (data) {
                        // TODO: change message; pass in caseId
                        var msg = resources.aml.getPluralizedResource(caseNumbers[0],
                            'cases.triage.checkinActionSuccessMessageOne',
                            'cases.triage.checkinActionSuccessMessageOther',
                            {numOfCases: caseNumbers.length, caseId: caseId});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            // use '' instead of null so the list doesn't display null value
                            onSuccessCallback(caseNumbers, '');
                        }
                    },
                    function (error) {
                        var errorMsg = resources.aml.getResource('cases.triage.checkinActionErrorMessage',
                            {caseId: caseId});

                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

        function checkoutCases(caseNumbers, caseId, onSuccessCallback) {
            if (caseNumbers && caseNumbers.length > 0) {
                casesService.checkoutCases(caseNumbers).then(
                    function (data) {
                        // TODO: change message; pass in caseId
                        var msg = resources.aml.getPluralizedResource(caseNumbers[0],
                            'cases.triage.checkoutActionSuccessMessageOne',
                            'cases.triage.checkoutActionSuccessMessageOther',
                            {numOfCases: caseNumbers.length, caseId: caseId});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            var currentUserId = usersService.getCurrentUserId();
                            onSuccessCallback(caseNumbers, currentUserId);
                        }
                    },
                    function (error) {
                        var errorMsg =  resources.aml.getResource('cases.triage.checkoutActionErrorMessage',
                            {caseId: caseId});
                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.admin:tabAreaNavigationServiceFactory
 *
 * @restrict E
 *
 * @description
 * The tabAreaNavigationServiceFactory service is used to create a service for creating and selecting
 * nested tabb areas, based on the current user's capabilities
 *
 * @element ANY
 */
(function() {
    'use strict';

    tabAreaNavigationServiceFactory.$inject = ["$state", "usersService", "_"];
    angular
        .module('aml.core')
        .factory('tabAreaNavigationServiceFactory', tabAreaNavigationServiceFactory);

    /* @ngInject */
    function tabAreaNavigationServiceFactory($state, usersService, _) {
        //it seems that complexity is not calculated correctly by jshint, override it
        /*jshint maxcomplexity:10 */

        /**
         * Create a TabAreaNav class for each usage, so that every set of tabs can maintain their own state
         *
         * @param parentState - only add tabs for states that specify this parentState as a parent
         * @constructor
         */
        var TabAreaNav = function( parentState ) {
            this.parentState = parentState;
            this.areas = [];
            this.initialized = false;
            this.visibleAreas = this.areas;
        };

        TabAreaNav.prototype.navigate =   function (tabArea) {
            $state.go(tabArea.state.name, tabArea.state.params);
        };

        /**
         * get current user's capabilities and add selection tabs for all areas that they have access to
         */
        TabAreaNav.prototype.initializeVisibleAreas = function(currentState) {
            if (!this.initialized) {
                var that = this;
                usersService.getCurrentUser().then(function (user) {
                    var states = $state.get();

                    _.each(states, function (state) {
                        var parentStateForGivenState = state.parent;
                        if ( parentStateForGivenState && parentStateForGivenState === that.parentState && state.data && state.data.tabArea) {
                            var userHasAccess = true;
                            if ( state.data.tabArea.isVisible ) {
                                if ( angular.isFunction(state.data.tabArea.isVisible) ) {
                                    userHasAccess = state.data.tabArea.isVisible();
                                } else {
                                    userHasAccess = state.data.tabArea.isVisible;
                                }
                            }
                            if ( userHasAccess ) {
                                var requiredCapabilities = state.data.tabArea.requiredCapabilities;

                                // if no required capabilities are listed, then user always has access to that area
                                if (!requiredCapabilities || requiredCapabilities.length === 0) {
                                    userHasAccess = true;
                                }
                                else {
                                    userHasAccess = usersService.currentUserHasAnyCapability(requiredCapabilities);
                                }

                                if (userHasAccess) {
                                    that.addAreaForState(state, that);
                                }
                            }
                        }
                    });

                    // if the current state has sub-tabs, and one of them is not set as default, we will navigate to
                    // the first available tabArea
                    that.redirectToFirstVisibleTabAreaIfNecessary( currentState );

                    that.initialized = true;
                });

            }
        };

        /**
         * If the current state is an area tab that has sub-tabAreas, in some cases the first time we select the area
         * we need to dynamically determine which child area to go to based on which areas are visible.
         * If the area state has deepStateRedirect set to true instead of a default child state name, then that
         * is used as an indication that the initial sub-area should be determined at that time. In such cases, the
         * first available area will be navigated to.
         */
        TabAreaNav.prototype.redirectToFirstVisibleTabAreaIfNecessary = function(currentState) {
            if ( currentState.data && currentState.data.area && currentState.deepStateRedirect === true ) {
                // not set to redirect to a particular state;
                // find the first one available based on capabilities
                var firstDefinedTabArea = _.first( this.areas );
                if ( firstDefinedTabArea ) {
                    this.navigate(firstDefinedTabArea);
                }
            }
        };

        TabAreaNav.prototype.addAreaForState =   function( state, that ) {
            var area = { label: state.data.tabArea.label,
                tooltip: state.data.tabArea.tooltip,
                state: { name: state.name, params: state.params}
            };

            this.areas.push(area);
            return area;
        };

        ///////////////////////////

        var serviceInstanceFactory = {
            getInstance: function (parentState) {
                return new TabAreaNav(parentState);
            }
        };
        return serviceInstanceFactory;
    }
})();
/**
 * @ngdoc service
 * @name     aml.admin:areaNavigationService
 *
 * @restrict E
 *
 * @description
 * The areaNavigationService service is used to manage creating and selecting tabbed functional areas, based on the
 * current user's capabilities
 *
 * @element ANY
 */
(function() {
    'use strict';

    areaNavigationService.$inject = ["$state", "$rootScope", "$q", "usersService", "resourceService", "_"];
    angular
        .module('aml.core')
        .factory('areaNavigationService', areaNavigationService);

    /* @ngInject */
    function areaNavigationService($state, $rootScope, $q, usersService, resourceService, _) {
        //it seems that complexity is not calculated correctly by jshint, override it
        /*jshint maxcomplexity:10 */
        var areas = [];
        var lastSelectedArea;

        var service = {
            navigate: navigate,
            getLastSelectedArea: getLastSelectedArea,
            navigateToLastSelectedArea: navigateToLastSelectedArea,
            initializeVisibleAreas: initializeVisibleAreas,
            redirectToFirstVisibleArea: redirectToFirstVisibleArea,
            visibleAreas: areas
        };

        return service;

        /////////////////////

        function navigate(area) {
            $state.go(area.state.name, area.state.params);
            lastSelectedArea = area;
        }

        function navigateToLastSelectedArea() {
            if ( lastSelectedArea ) {
                navigate( lastSelectedArea );
            }
        }

        function getLastSelectedArea() {
            return lastSelectedArea;
        }

        function addAreaForState( state ) {
            var area = { label: state.data.area.label,
                tooltip: state.data.area.tooltip,
                state: { name: state.name, params: state.params}
            };

            areas.push(area);
            return area;
        }

        /**
         * Get the required capabilities for all the child states of each tabArea
         * @param states
         * @returns {{}}
         */
        function getChildrenRequiredCapabilities(states) {
            var childCapabilitiesMap = {};

            _.each(states, function (state) {
                if (state.data && state.data.tabArea) {
                    // sub tabs
                    var parentTab = state.parent;
                    if (parentTab) {
                        if (state.data.tabArea.requiredCapabilities) {
                            if (!childCapabilitiesMap[parentTab]) {
                                childCapabilitiesMap[parentTab] = [];
                            }
                            childCapabilitiesMap[parentTab] = childCapabilitiesMap[parentTab].concat(
                                state.data.tabArea.requiredCapabilities
                            );
                        }
                    }
                }
            });
            return childCapabilitiesMap;
        }

        /**
         * Get all the required capabilities for this state, including any required by any children of this state
         * @param state
         * @param childCapabilitiesMap
         * @returns {*}
         */
        function getAllRequiredCapabilities(state, childCapabilitiesMap) {
            var requiredCapabilities = state.data.area.requiredCapabilities;
            var requiredChildCapabilities = childCapabilitiesMap[state.name];
            if (requiredChildCapabilities) {
                if (requiredCapabilities) {
                    requiredCapabilities = requiredCapabilities.concat(requiredChildCapabilities);
                }
                else {
                    requiredCapabilities = requiredChildCapabilities;
                }
            }
            return requiredCapabilities;
        }

        /**
         * get current user's capabilities and add selection tabs for all areas that they have access to
         */
        function initializeVisibleAreas() {
            //load current user to get capabilities
            var userPromise = usersService.getCurrentUser();
            //load config to check preferences
            var configPromise = resourceService.init($rootScope, 'aml');

            var loadConfig = $q.all([userPromise, configPromise]);

            loadConfig.then( function() {
                var states = $state.get();
                var childCapabilitiesMap = getChildrenRequiredCapabilities(states);

                _.each( states, function(state) {
                    if ( state.data && state.data.area ) {
                        var userHasAccess = true;

                        if ( state.data.area.isVisible ) {
                            if ( angular.isFunction(state.data.area.isVisible) ) {
                                userHasAccess = state.data.area.isVisible();
                            } else {
                                userHasAccess = state.data.area.isVisible;
                            }
                        }

                        if ( userHasAccess ) {
                            var requiredCapabilities = getAllRequiredCapabilities(state, childCapabilitiesMap);

                            // if no required capabilities are listed, then user always has access to that area
                            if (!requiredCapabilities || requiredCapabilities.length === 0) {
                                userHasAccess = true;
                            }
                            else {
                                userHasAccess = usersService.currentUserHasAnyCapability(requiredCapabilities);
                            }

                            if (userHasAccess) {
                                var addedArea = addAreaForState(state);

                                // set first area as initial selected area (if user starts application via an object tab
                                // and then closes it, the state will change to the first area)
                                if (!lastSelectedArea) {
                                    lastSelectedArea = addedArea;
                                }
                            }
                        }
                    }
                });

            });
        }

        /**
         * When navigating to the base AML URI state, we may need to navigate to the first visible area dynamically
         * @see AmlRedirectController
         */
        function redirectToFirstVisibleArea() {
            var firstDefinedTabArea = _.first( areas );
            if ( firstDefinedTabArea ) {
                navigate(firstDefinedTabArea);
            }
        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.reviews:reviewTriageService
 *
 * @restrict E
 *
 * @description
 * The reviewTriageService service is used to handle review triage actions and opening modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    reviewTriageService.$inject = ["messageService", "resources", "$uibModal", "reviewsService", "$q", "usersService", "exceptionResourceHandler"];
    angular
        .module('cdd.reviews')
        .factory('reviewTriageService', reviewTriageService);

    /* @ngInject */
    function reviewTriageService(messageService, resources, $uibModal, reviewsService, $q, usersService,
                                   exceptionResourceHandler) {
        var service = {
            openRouteReviewsDialog: openRouteReviewsDialog,
            checkinReviews: checkinReviews,
            checkoutReviews: checkoutReviews
        };

        return service;


        function openRouteReviewsDialog(reviewNumbers, key, user, queue, onSuccessCallback) {
            if (reviewNumbers && reviewNumbers.length > 0) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'cddReviews/reviewsList/triage/dialogs/routeReviews.html',
                    controller: 'RouteReviewsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,
                    resolve: {
                        reviewNumbers: function () {
                            return reviewNumbers;
                        },
                        key: function () {
                            return key;
                        },
                        user: function () {
                            return user;
                        },
                        queue: function () {
                            return queue;
                        }
                    }
                });

                var dialogResult = modalInstance.result;
                dialogResult.then(function (result) {
                    reviewsService.routeReviews(reviewNumbers, result.routeToUser, result.routeToQueue).then(
                        function (data) {
                            var msg = resources.aml.getPluralizedResource( reviewNumbers.length,
                                'reviews.triage.routeActionSuccessMessageOne',
                                'reviews.triage.routeActionSuccessMessageOther',
                                {numberOfReviews: reviewNumbers.length, key: key});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                onSuccessCallback(reviewNumbers, result.routeToUser, result.routeToQueue);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('reviews.triage.routeActionErrorMessage',
                                    {key: key}), null, 4000);
                        });
                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }
        }

        function checkinReviews(reviewNumbers, key, onSuccessCallback) {
            if (reviewNumbers && reviewNumbers.length > 0) {
                return reviewsService.checkinReviews(reviewNumbers).then(
                    function (data) {
                        var msg = resources.aml.getPluralizedResource(reviewNumbers.length,
                            'reviews.triage.checkinActionSuccessMessageOne',
                            'reviews.triage.checkinActionSuccessMessageOther',
                            {numberOfReviews: reviewNumbers.length, key: key});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            // use '' instead of null so the list doesn't display null value
                            onSuccessCallback(reviewNumbers, '');
                        }
                    },
                    function (error) {
                        var errorMsg = resources.aml.getResource('reviews.triage.checkinActionErrorMessage',
                            {key: key});

                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

        function checkoutReviews(reviewNumbers, key, onSuccessCallback) {
            if (reviewNumbers && reviewNumbers.length > 0) {
                reviewsService.checkoutReviews(reviewNumbers).then(
                    function (data) {
                        var msg = resources.aml.getPluralizedResource(reviewNumbers.length,
                            'reviews.triage.checkoutActionSuccessMessageOne',
                            'reviews.triage.checkoutActionSuccessMessageOther',
                            {numberOfReviews: reviewNumbers.length, key: key});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            var currentUserId = usersService.getCurrentUserId();
                            onSuccessCallback(reviewNumbers, currentUserId);
                        }
                    },
                    function (error) {
                        var errorMsg =  resources.aml.getResource('reviews.triage.checkoutActionErrorMessage',
                            {key: key});
                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

    }
})();
/**
 * Created by fikhas on 1/26/2015.
 */
(function() {
    'use strict';

    angular.module('aml.customer.details').factory('customerLinksService', customerLinksService);
    function customerLinksService() {
        var clinks = [];
        function setCustomerLinks(clinks) {
            clinks = clinks;
        }
        function getCustomerLinks() {
            return clinks;
        }
        function getAssociateLink() {
            return clinks[1].href;
        }
        var service = {
            setCustomerLinks: setCustomerLinks,
            getCustomerLinks: getCustomerLinks,
            getAssociateLink: getAssociateLink
        };
        return service;

    }
})();

/**
 * @ngdoc service
 * @name     aml.customer:entityTriageService
 *
 * @restrict E
 *
 * @description
 * The entityTriageService service is used to handle customer triage actions and opending modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    entityTriageService.$inject = ["messageService", "resources", "$uibModal", "entityService", "$q", "usersService", "exceptionResourceHandler"];
    angular
        .module('aml.customer')
        .factory('entityTriageService', entityTriageService);

    /* @ngInject */
    function entityTriageService(messageService, resources, $uibModal, entityService, $q, usersService,
                                   exceptionResourceHandler) {
        var service = {
            openRouteEntitiesDialog: openRouteEntitiesDialog,
            checkinEntities: checkinEntities,
            checkoutEntities: checkoutEntities
        };

        return service;


        function openRouteEntitiesDialog(entityIds, entityName, user, queue, onSuccessCallback) {
            if (entityIds && entityIds.length > 0) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'entities/entitiesList/triage/dialogs/routeEntities.html',
                    controller: 'RouteEntitiesModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,
                    resolve: {
                        entityIds: function () {
                            return entityIds;
                        },
                        entityName: function () {
                            return entityName;
                        },
                        user: function() {
                            return user;
                        },
                        queue: function() {
                            return queue;
                        }
                    }
                });

                var dialogResult = modalInstance.result;
                dialogResult.then(function (result) {
                    entityService.routeEntities(entityIds, result.routeToUser, result.routeToQueue, result.replaceCurrentQueue).then(
                        function (data) {
                            var msg = resources.aml.getPluralizedResource( entityIds.length,
                                'customer.triage.routeActionSuccessMessageOne',
                                'customer.triage.routeActionSuccessMessageOther',
                                {numberOfEntities: entityIds.length, entityName: entityName});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                // on route refresh user only if current queue was replaced
                                onSuccessCallback(entityIds, result.routeToUser, result.routeToQueue, result.replaceCurrentQueue, result.replaceCurrentQueue);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('customer.triage.routeActionErrorMessage',
                                    {entityName: entityName}), null, 4000);
                        });
                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }
        }

        function checkinEntities(entityIds, entityName, onSuccessCallback) {
            if (entityIds && entityIds.length > 0) {
                return entityService.checkinEntities(entityIds).then(
                    function (data) {
                        // TODO: change message; pass in entityName
                        var msg = resources.aml.getPluralizedResource(entityIds.length,
                            'customer.triage.checkinActionSuccessMessageOne',
                            'customer.triage.checkinActionSuccessMessageOther',
                            {numberOfEntities: entityIds.length, entityName: entityName});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            onSuccessCallback(entityIds, '', '', false, true); //no queue change, only owner change
                        }
                    },
                    function (error) {
                        var errorMsg = resources.aml.getResource('customer.triage.checkinActionErrorMessage',
                            {entityName: entityName});

                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

        function checkoutEntities(entityIds, entityName, onSuccessCallback) {
            if (entityIds && entityIds.length > 0) {
                entityService.checkoutEntities(entityIds).then(
                    function (data) {
                        var msg = resources.aml.getPluralizedResource(entityIds.length,
                            'customer.triage.checkoutActionSuccessMessageOne',
                            'customer.triage.checkoutActionSuccessMessageOther',
                            {numberOfEntities: entityIds.length, entityName: entityName});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            var currentUserId = usersService.getCurrentUserId();
                            onSuccessCallback(entityIds, currentUserId, '', false, true); //no queue change, only owner change
                        }
                    },
                    function (error) {
                        var errorMsg =  resources.aml.getResource('customer.triage.checkoutActionErrorMessage',
                            {entityName: entityName});
                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.reports:reportTriageService
 *
 * @restrict E
 *
 * @description
 * The reportTriageService service is used to handle report triage actions and opening modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    reportTriageService.$inject = ["messageService", "resources", "$uibModal", "reportsService", "$q", "usersService", "exceptionResourceHandler"];
    angular
        .module('aml.reports')
        .factory('reportTriageService', reportTriageService);

    /* @ngInject */
    function reportTriageService(messageService, resources, $uibModal, reportsService, $q, usersService,
                                   exceptionResourceHandler) {
        var service = {
            openRouteReportsDialog: openRouteReportsDialog,
            checkinReports: checkinReports,
            checkoutReports: checkoutReports
        };

        return service;


        function openRouteReportsDialog(reportNumbers, reportKey, user, queue, onSuccessCallback) {
            if (reportNumbers && reportNumbers.length > 0) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'regulatoryReports/reportsList/triage/dialogs/routeReports.html',
                    controller: 'RouteReportsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,
                    resolve: {
                        reportNumbers: function () {
                            return reportNumbers;
                        },
                        reportKey: function () {
                            return reportKey;
                        },
                        user: function () {
                            return user;
                        },
                        queue: function() {
                            return queue;
                        }
                    }
                });

                var dialogResult = modalInstance.result;
                dialogResult.then(function (result) {
                    reportsService.routeReports(reportNumbers, result.routeToUser, result.routeToQueue).then(
                        function (data) {
                            var msg = resources.aml.getPluralizedResource( reportNumbers.length,
                                'regulatoryReports.triage.routeActionSuccessMessageOne',
                                'regulatoryReports.triage.routeActionSuccessMessageOther',
                                {numberOfReports: reportNumbers.length, reportKey: reportKey});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                onSuccessCallback(reportNumbers, result.routeToUser, result.routeToQueue);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('regulatoryReports.triage.routeActionErrorMessage',
                                    {reportKey: reportKey}), null, 4000);
                        });
                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }
        }

        function checkinReports(reportNumbers, reportKey, onSuccessCallback) {
            if (reportNumbers && reportNumbers.length > 0) {
                return reportsService.checkinReports(reportNumbers).then(
                    function (data) {
                        var msg = resources.aml.getPluralizedResource(reportNumbers[0],
                            'regulatoryReports.triage.checkinActionSuccessMessageOne',
                            'regulatoryReports.triage.checkinActionSuccessMessageOther',
                            {numOfReports: reportNumbers.length, reportKey: reportKey});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            onSuccessCallback(reportNumbers, '');
                        }
                    },
                    function (error) {
                        var errorMsg = resources.aml.getResource('regulatoryReports.triage.checkinActionErrorMessage',
                            {reportKey: reportKey});

                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

        function checkoutReports(reportNumbers, reportKey, onSuccessCallback) {
            if (reportNumbers && reportNumbers.length > 0) {
                reportsService.checkoutReports(reportNumbers).then(
                    function (data) {
                        var msg = resources.aml.getPluralizedResource(reportNumbers[0],
                            'regulatoryReports.triage.checkoutActionSuccessMessageOne',
                            'regulatoryReports.triage.checkoutActionSuccessMessageOther',
                            {numOfReports: reportNumbers.length, reportKey: reportKey});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            var currentUserId = usersService.getCurrentUserId();
                            onSuccessCallback(reportNumbers, currentUserId);
                        }
                    },
                    function (error) {
                        var errorMsg =  resources.aml.getResource('regulatoryReports.triage.checkoutActionErrorMessage',
                            {reportKey: reportKey});
                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.customer:customerTriageService
 *
 * @restrict E
 *
 * @description
 * The customerTriageService service is used to handle customer triage actions and opending modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    riskAssessmentTriageService.$inject = ["messageService", "resources", "$uibModal", "riskAssessmentService", "$q"];
    angular
        .module('aml.riskAssessments')
        .factory('riskAssessmentTriageService', riskAssessmentTriageService);

    /* @ngInject */
    function riskAssessmentTriageService(messageService, resources, $uibModal, riskAssessmentService, $q ) {
        var service = {
            openRouteRiskAssessmentDialog: openRouteRiskAssessmentDialog,
            openAcceptRiskAssessmentDialog: openAcceptRiskAssessmentDialog,
            openRejectRiskAssessmentDialog: openRejectRiskAssessmentDialog
        };
        return service;



        function openRouteRiskAssessmentDialog(assessmentId, onSuccessCallback ) {

            if (assessmentId && assessmentId.length > 0) {

                var modalInstance = $uibModal.open({
                    templateUrl: 'riskAssessments/riskAssessmentDetails/triage/dialogs/routeRiskAssessments.html',
                    controller: 'RouteRiskAssessmentsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,

                    resolve: {
                        assessmentId: function () { return assessmentId; },

                        // This just needs to return an array of length 1, so the directive
                        // knows we're routing one risk assessment.
                        riskAssessmentNumbers: function () { return [null]; }
                    }
                });

                var dialogResult = modalInstance.result;

                dialogResult.then(function (result) {

                    riskAssessmentService.routeRiskAssessment(assessmentId, result.routeToUser).then(
                        function (data) {
                            var msg = resources.aml.getPluralizedResource( assessmentId.length,
                                'riskAssessment.triage.routeActionSuccessMessageOne',
                                'riskAssessment.triage.routeActionSuccessMessageOther',
                                {assessmentIds: assessmentId.length, ownerUserLongId: result.routeToUser});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                onSuccessCallback([assessmentId], result.routeToUser);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('riskAssessment.triage.routeActionErrorMessage',
                                    {assessmentIds: assessmentId}), null, 4000);
                        });

                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }

        }


        function openAcceptRiskAssessmentDialog(assessmentId ) {

            if (assessmentId && assessmentId.length > 0) {

                var modalInstance = $uibModal.open({
                    templateUrl: 'riskAssessments/riskAssessmentDetails/triage/dialogs/acceptRiskAssessment.html',
                    controller: 'AcceptRiskAssessmentsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,

                    resolve: {
                        assessmentId: function () { return assessmentId; }

                    }
                });

                var dialogResult = modalInstance.result;

                dialogResult.then(function (result) {

                    riskAssessmentService.acceptRiskAssessment(assessmentId).then(
                        function (data) {
                            //currently only Details page has Accept button, so number of accepted is always 1
                            var msg = resources.aml.getPluralizedResource( 1,
                                'riskAssessment.triage.acceptActionSuccessMessageOne',
                                'riskAssessment.triage.acceptActionSuccessMessageOther',
                                {numberOfAssments: 1, assessmentId: assessmentId});
                            messageService.success(msg, null, 4000);

                        },
                        function (error) {

                            messageService.danger(
                                resources.aml.getResource('riskAssessment.triage.acceptActionErrorMessage',
                                    {assessmentIds: assessmentId}), null, 4000);

                        });

                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }

        }

        function openRejectRiskAssessmentDialog(assessmentId ) {

            if (assessmentId && assessmentId.length > 0) {

                var modalInstance = $uibModal.open({
                    templateUrl: 'riskAssessments/riskAssessmentDetails/triage/dialogs/rejectRiskAssessment.html',
                    controller: 'RejectRiskAssessmentsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,

                    resolve: {
                        assessmentId: function () { return assessmentId; }
                    }
                });

                var dialogResult = modalInstance.result;

                dialogResult.then(function (result) {

                    riskAssessmentService.rejectRiskAssessment(assessmentId).then(
                        function (data) {
                            //currently only Details page has Accept button, so number of rejected is always 1
                            var msg = resources.aml.getPluralizedResource( 1,
                                'riskAssessment.triage.rejectActionSuccessMessageOne',
                                'riskAssessment.triage.rejectActionSuccessMessageOther',
                                {numberOfAssments: 1, assessmentId: assessmentId});
                            messageService.success(msg, null, 4000);


                        },
                        function (error) {

                            messageService.danger(
                                resources.aml.getResource('riskAssessment.triage.rejectActionErrorMessage',
                                    {assessmentIds: assessmentId}), null, 4000);

                        });

                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }

        }

    }
})();
/**
 * @ngdoc service
 * @name     aml.riskAssessments:riskAssessmentsListTriageService
 *
 * @restrict E
 *
 * @description
 * The riskAssessmentsListService service is used to handle case triage actions and opening modal dialogs
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function() {
    'use strict';

    riskAssessmentsListTriageService.$inject = ["messageService", "resources", "$uibModal", "riskAssessmentService", "$q", "usersService", "exceptionResourceHandler"];
    angular
        .module('aml.riskAssessments')
        .factory('riskAssessmentsListTriageService', riskAssessmentsListTriageService);

    /* @ngInject */
    function riskAssessmentsListTriageService(messageService, resources, $uibModal, riskAssessmentService, $q, usersService,
                                   exceptionResourceHandler) {
        var service = {
            openRouteRiskAssessmentsDialog: openRouteRiskAssessmentsDialog,
            checkinRiskAssessments: checkinRiskAssessments,
            checkoutRiskAssessments: checkoutRiskAssessments
        };

        return service;


        function openRouteRiskAssessmentsDialog(riskAssessmentNumbers, riskAssessmentId, onSuccessCallback) {
            if (riskAssessmentNumbers && riskAssessmentNumbers.length > 0) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'riskAssessments/riskAssessmentDetails/triage/dialogs/routeRiskAssessments.html',
                    controller: 'RouteRiskAssessmentsModalController as vm',
                    backdrop: 'static', // don't allow to click outside of modal,
                    resolve: {
                        riskAssessmentNumbers: function () {
                            return riskAssessmentNumbers;
                        },
                        assessmentId: function () {
                            return riskAssessmentId;
                        }

                    }
                });

                var dialogResult = modalInstance.result;
                dialogResult.then(function (result) {
                    riskAssessmentService.routeRiskAssessments(riskAssessmentNumbers, result.routeToUser).then(
                        function (data) {
                            // TODO: change message; pass in assessmentId
                            var msg = resources.aml.getPluralizedResource( riskAssessmentNumbers.length,
                                'riskAssessment.triage.routeActionSuccessMessageOne',
                                'riskAssessment.triage.routeActionSuccessMessageOther',
                                {numberOfAsessments: riskAssessmentNumbers.length, assessmentIds: riskAssessmentId});
                            messageService.success(msg, null, 4000);

                            if ( onSuccessCallback ) {
                                onSuccessCallback(riskAssessmentNumbers, result.routeToUser);
                            }
                        },
                        function (error) {
                            messageService.danger(
                                resources.aml.getResource('riskAssessment.triage.routeActionErrorMessage',
                                    {assessmentIds: riskAssessmentId}), null, 4000);
                        });
                });
                return dialogResult;
            }
            else {
                // return empty promise
                return $q.when([]);
            }
        }

        function checkinRiskAssessments(riskAssessmentNumbers, assessmentId, onSuccessCallback) {
            if (riskAssessmentNumbers && riskAssessmentNumbers.length > 0) {
                return riskAssessmentService.checkinRiskAssessments(riskAssessmentNumbers).then(
                    function (data) {

                        var msg = resources.aml.getPluralizedResource(riskAssessmentNumbers[0],
                            'riskAssessmentsList.triage.checkinActionSuccessMessageOne',
                            'riskAssessmentsList.triage.checkinActionSuccessMessageOther',
                            {numOfAssessments: riskAssessmentNumbers.length, assessmentIds: assessmentId});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            onSuccessCallback(riskAssessmentNumbers, '');
                        }
                    },
                    function (error) {
                        var errorMsg = resources.aml.getResource('riskAssessmentsList.triage.checkinActionErrorMessage',
                            {assessmentIds: assessmentId});

                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

        function checkoutRiskAssessments(riskAssessmentNumbers, assessmentId, onSuccessCallback) {
            if (riskAssessmentNumbers && riskAssessmentNumbers.length > 0) {
                riskAssessmentService.checkoutRiskAssessments(riskAssessmentNumbers).then(
                    function (data) {

                        var msg = resources.aml.getPluralizedResource(riskAssessmentNumbers[0],
                            'riskAssessmentsList.triage.checkoutActionSuccessMessageOne',
                            'riskAssessmentsList.triage.checkoutActionSuccessMessageOther',
                            {numOfAssessments: riskAssessmentNumbers.length, assessmentId: assessmentId});
                        messageService.success(msg, null, 4000);

                        if ( onSuccessCallback ) {
                            var currentUserId = usersService.getCurrentUserId();
                            onSuccessCallback(riskAssessmentNumbers, currentUserId);
                        }
                    },
                    function (error) {
                        var errorMsg =  resources.aml.getResource('riskAssessmentsList.triage.checkoutActionErrorMessage',
                            {assessmentId: assessmentId});
                        var errorDetails = exceptionResourceHandler.getDetailsFromError(error);
                        if ( errorDetails ) {
                            errorMsg = errorMsg + '<br/>' + errorDetails;
                        }

                        messageService.danger( errorMsg, null, 8000);
                    });
            }
        }

    }
})();
/**
 * Handles configuration and boot-strapping for the AML application
 */
(function () {
    'use strict';

    // ng-inject
    angular.module('aml')
        .constant('amlConfig', {
            baseUrl: 'rest',

            // on startup, the resources, lov, and preference values retrieved; by default
            // we do not cache these on startup. This ensures these values are always up-to-date,
            // at the expense of a modest startup performance gain
            cacheStartupResources: false
        })

        // globals; these should be injected in services as needed (rather than used globally)
        // in order to better keep track of dependencies
        /* jshint: allow globals */
        /* global _ */ /* global kendo */ /* global moment */ /* global $ */
        .constant('_', _)
        .constant('$', $)
        .constant('kendo', kendo)
        .constant('moment', moment)

        .config(["$urlMatcherFactoryProvider", "$stateProvider", "$provide", "$httpProvider", function ($urlMatcherFactoryProvider, $stateProvider,
                          $provide, $httpProvider) {
            $httpProvider.defaults.headers.common = {
                'Accept': 'application/json' // always default to json for all requests
            };

            // set up interceptor to handle globally handling requests and responses
            $httpProvider.interceptors.push('httpInterceptor');

            setLocaleFormats();

            // configure datepicker options; removed from here as we want to load these values from config properties
            //datepickerConfig.showWeeks = false;
            //datepickerConfig.formatYear ='yy';
            //datepickerConfig.startingDay = 2;

            //$stickyStateProvider.enableDebug(true);

            // allow URIs with trailing slashes (allows /customers/ to resolve to /customers, instead
            // of going to /customers/{id} with an empty customer id
            $urlMatcherFactoryProvider.strictMode(false);


            function setLocaleFormats() {
                var customFormats = {
                    'en': {
                        'shortDate': 'M/d/y',
                        'mediumTime': 'HH:mm:ss'
                    },
                    'en-us': {
                        'shortDate': 'M/d/y',
                        'mediumTime': 'HH:mm:ss'
                    },
                    'it': {
                        'shortDate': 'dd/MM/y'
                    },
                    'ru': {
                        'shortDate': 'dd.MM.y'
                    },
                    'ko': {
                        'shortDate': 'y. M. d.',
                        'mediumTime': 'HH:mm:ss'
                    },
                    'nl': {
                        'shortDate': 'dd-MM-y'
                    },
                    'es': {
                        'shortDate': 'd/M/y'
                    },
                    'zh-tw': {
                        'mediumTime': 'HH:mm:ss'
                    },
                    'zh-hk': {
                        'mediumTime': 'HH:mm:ss'
                    },
                    'zh-cn': {
                        'shortDate': 'y/M/d',
                        'mediumTime': 'HH:mm:ss'
                    },
                    'ar': {
                        'shortDate': 'd/M/y',
                        'longDate': 'd/M/y',
                        'mediumTime': 'HH:mm:ss',

                        // we override the 'ar' medium date format as the one defined in angular-locale_ar
                        // does not display properly right-to-left (S1268888)
                        //   "medium": "dd\u200f/MM\u200f/y h:mm:ss a", // (as defined in angular)
                        'medium': 'a h:mm:ss dd/MM/y'
                    }
                };

                /** override angular date filter to use our custom locale formats */
                $provide.decorator('dateFilter', ["$delegate", "$locale", "$location", function ($delegate, $locale, $location) {
                    var locale;

                    //  Use any locale specified in the client side URL (i.e. after any #/)
                    if ($location.search().locale && $location.search().locale !== '_') {
                        locale = $location.search().locale;
                    } else {
                        locale = $locale.id;
                    }

                    return function (input, format) {
                        if ('undefined' !== typeof customFormats[locale]) {
                            return $delegate(input, customFormats[locale][format] || format);
                        } else {
                            return $delegate(input, format);
                        }
                    };
                }]);
            }

        }])
        .run(["$rootScope", "resources", "$state", "tabsListService", "resourceService", "amlUIViewService", "usersService", "$locale", "amlCoreUtils", function ($rootScope, resources, $state, tabsListService, resourceService, amlUIViewService, usersService,
                       $locale, amlCoreUtils) {
            // initialize the resources strings on application startup; note that this is an asynchronous
            // operation and is not guaranteed to be complete before any of the route/states load; this is why
            // the state definitions also call this in their resolve block. That ensures that the route won't load
            // until the resources are truly loaded.
            resourceService.init($rootScope, 'aml');

            addGlobalUtilityFunctions(arguments);

            $rootScope.$on('$stateChangeStart', function (evt, to, params) {

                // if a state has declared a sticky param, then the intent is that we want that state to be sticky
                // across multiple instances, each unique based on a parameter.  The way that stickyStates works, is
                // it that it requires a unique state in order to persist it; so for states that we mark with
                // stickyParam, we create a copy of the initial state with the param, and create a new state with the
                // param directly inserted into the URL. Yeah. Or something.
                if (to.data && to.data.stickyParam) {
                    var paramName = to.data.stickyParam;
                    var idParam = params[paramName];

                    if (idParam !== null && idParam.startsWith('new_')) {
                        // prevent opening a page to create new entity when newEntityFlag parameters is missing
                        // this happens when browser refresh button is used or when URL is directly entered by the user
                        if (!params.newEntityFlag) {
                            evt.preventDefault();
                            $state.go('welcome');
                            return;
                        }
                    }
                    // remember the original state name
                    to.data.stickyBaseStateName = to.name;

                    // set this instance with a unique state name based on id param
                    var stickyStateId = getStickyStateId( to, idParam );

                    // check if state already exists
                    var specificState = $state.get(stickyStateId);
                    if (!specificState) {
                        // make a copy of the default state template
                        specificState = $.extend(true, {}, to);

                        // change the url to include the id value directly, rather than as a parameter
                        specificState.url = to.url.replace(':' + paramName, idParam);
                        specificState.url = specificState.url;
                        // set unique name of the new state (eg: customerDetails_123456789) and clear the redirect for
                        // this specific state
                        specificState.name = stickyStateId;
                        specificState.data.stickyParam = null;

                        // change the name of the views property to be that of the new id (eg:
                        // customerDetails_123456789)
                        specificState.views[stickyStateId] = specificState.views[to.name];
                        delete specificState.views[to.name];

                        // register the new state and broadcast that it has been added
                        angular.module('aml').$stateProvider.state(stickyStateId, specificState);
                    }

                    // add new copy of state (if it doesn't already exist)
                    amlUIViewService.addState(specificState);

                    // prevent the initial state template transition; instead go to the newly created specific state
                    evt.preventDefault();

                    params[paramName] = idParam;
                    $state.go(stickyStateId, params);
                }
            });

            /**
             * Verify that the current user has the required capability to access the given
             * state/route (if the state has explicitly specified requiredCapabilities)
             * @param toState
             * @param usersService
             * @param $state
             * @returns {boolean}
             */
            function verifyRequiredCapabilities(toState, usersService, $state) {
                var authorized = true;
                var requiredCapabilities = null;
                if (toState.data) {
                    if (toState.data.tabArea) {
                        requiredCapabilities = toState.data.tabArea.requiredCapabilities;
                    }
                    else if (toState.data.tabInfo) {
                        requiredCapabilities = toState.data.tabInfo.requiredCapabilities;
                    }
                    if (toState.data.area) {
                        requiredCapabilities = toState.data.area.requiredCapabilities;
                    }
                }

                if (requiredCapabilities && requiredCapabilities.length > 0) {
                    // check current user capabilities to see if they have any one of the capabilities
                    var hasRequiredCapability = usersService.currentUserHasAnyCapability(requiredCapabilities);
                    if (!hasRequiredCapability) {
                        // prevent the initial state template transition; instead go to the newly created specific state
                        authorized = false;
                        $state.go('invalidAccess', {invalidUrl: toState.url});
                    }
                }
                return authorized;
            }

            // change page title based on state/route
            $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                var authorized = verifyRequiredCapabilities(toState, usersService, $state);

                if (authorized) {
                    //Change page title, based on Route information
                    var pageTitle = null;
                    if (resources && resources.aml) {
                        pageTitle = resources.aml.customerExplorerName;
                    }

                    if (!pageTitle) {
                        // fallback default
                        pageTitle = 'Anti-Money Laundering';
                    }
                    $rootScope.title = pageTitle;

                    // if this is a tabbable state, then add it to the list of tabs
                    if (toState.data && toState.data.tabInfo) {
                        tabsListService.addTab(toState.name, toParams, toState);
                    }
                }
                else {
                    event.preventDefault();
                }
            });

            /**
             * Construct a unique state id for a sticky state, based on the original parent name, followed
             * by an underscore and then the unique id parameter value.
             * Example: toState: customerDetails, idParam: '123456'  --> customerDetails_123456
             *
             * Also handles escaping any special characters that may break the state name
             *
             * @param toState
             * @param idParam
             * @returns {string}
             */
            function getStickyStateId( toState, idParam ) {
                if ( idParam ) {
                    // replace any special characters in the id value; ui-router states
                    // can not have . or @ in the name
                    idParam = idParam.replace( '/@/g', '-' )
                        .replace(/\./g, '-').replace(/\//g, '-').replace(/_/g, '-');
                }
                var id = toState.name + '_' + idParam;
                return id;
            }

            /**
             * add any global utility functions
             */
            function addGlobalUtilityFunctions() {

                // add any shims to support older browsers
                addShims();

                // wrap function used by ng-pluralize to only handle 'one' or 'other', as
                // that is all we externalize; if we don't do this, locales like 'pl' that define
                // other plural categories will show an empty string if the pages haven't defined them
                function wrappedPluralCatFn(result) {
                    if (result && (result !== 'one' || result !== 'other')) {
                        result = 'other';
                    }
                    return result;
                }
                $locale.pluralCat = amlCoreUtils.wrap($locale.pluralCat, null, wrappedPluralCatFn);
            }

            function addShims() {
                // add es6 string function polyfill shims if the functions are not supported in browser
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                // jshint freeze:false
                if (!String.prototype.startsWith) {
                    String.prototype.startsWith = function(searchString, position){
                        position = position || 0;
                        return this.substr(position, searchString.length) === searchString;
                    };
                }
                if (!String.prototype.endsWith) {
                    String.prototype.endsWith = function(searchString, position) {
                        var subjectString = this.toString();
                        if (typeof position !== 'number' || !isFinite(position) ||
                            Math.floor(position) !== position || position > subjectString.length) {
                            position = subjectString.length;
                        }
                        position -= searchString.length;
                        var lastIndex = subjectString.lastIndexOf(searchString, position);
                        return lastIndex !== -1 && lastIndex === position;
                    };
                }
                if (!String.prototype.includes) {
                    String.prototype.includes = function(search, start) {
                        if (typeof start !== 'number') {
                            start = 0;
                        }

                        if (start + search.length > this.length) {
                            return false;
                        } else {
                            return this.indexOf(search, start) !== -1;
                        }
                    };
                }

                // Polyfill for the JavaScript 'find' function, which is not
                // supported in IE <=11 or PhantomJS
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
                // https://tc39.github.io/ecma262/#sec-array.prototype.find
                /* jshint ignore:start */
                if (!Array.prototype.find) {
                    Object.defineProperty(Array.prototype, 'find', {
                        value: function(predicate) {
                            // 1. Let O be ? ToObject(this value).
                            if (this == null) {
                                throw new TypeError('"this" is null or not defined');
                            }

                            var o = Object(this);

                            // 2. Let len be ? ToLength(? Get(O, "length")).
                            var len = o.length >>> 0;

                            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                            if (typeof predicate !== 'function') {
                                throw new TypeError('predicate must be a function');
                            }

                            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                            var thisArg = arguments[1];

                            // 5. Let k be 0.
                            var k = 0;

                            // 6. Repeat, while k < len
                            while (k < len) {
                                // a. Let Pk be ! ToString(k).
                                // b. Let kValue be ? Get(O, Pk).
                                // c. Let testResult be ToBoolean(? Call(predicate, T, << kValue, k, O >>)).
                                // d. If testResult is true, return kValue.
                                var kValue = o[k];
                                if (predicate.call(thisArg, kValue, k, o)) {
                                    return kValue;
                                }
                                // e. Increase k by 1.
                                k++;
                            }

                            // 7. Return undefined.
                            return undefined;
                        }
                    });
                }
                /* jshint ignore:end */
            }
        }]);
})();

(function() {
    'use strict';
    /**
     * All of the general AML constants used throughout the application
     */
    // ng-inject
    angular.module('aml')
        .constant('amlConstants', {
            // The config property object contains user-configurable values (from /rest/preferences).
            // These values are filled in via the resource-service at startup/bootstrap time
            config : { },

            // used in about dialog
            copyrightDates: '2003-2019',
            helpVersionNumber: '7.1',
            versionNumber: '7.1.6',

            resourceComponent: 'aml',

            defaultPageSize: 20,
            defaultDescLength: 32,

            resourcesRootPath: 'resources',

            entityListQueueDisplayType: {
                ALL: 'all',
                MY: 'my',
                AVAILABLE: 'available'
            },

            casesListQueueDisplayType: {
                ALL: 'all',
                MY: 'my',
                AVAILABLE: 'available'
            },

            reviewsListQueueDisplayType: {
                ALL: 'all',
                MY: 'my',
                AVAILABLE: 'available'
            },

            efilesListQueueDisplayType: {
                ALL: 'all'
            },

            reportsListQueueDisplayType: {
                ALL: 'all',
                MY: 'my',
                AVAILABLE: 'available'
            },

            riskAssessmentsListQueueDisplayType: {
                ALL: 'all',
                MY: 'my',
                AVAILABLE: 'available'
            },

            entityType: {
                customer: 'PTY',
                account: 'ACC',
                household: 'HHD',
                externalParty: 'EXT',
                bank: 'BNK',
                associate: 'ASC',
                alert: 'ALT',
                case: 'CAS',
                branch: 'BRH',
                report: 'RPT',
                riskAssessment: 'RAS',
                transaction:'TRN',
                cddReview: 'CDR',
                watchList: 'WLT'
            },

            query: {
                sortDirection: {
                    ascending: 'ascending',
                    descending: 'descending'
                }
            },

            createInvestigationAlertActionType: {
                INCLUDE: 'inc',
                CLOSE: 'cls',
                IGNORE: 'ign'
            },

            preferences: {
                defaultEntitiesQueue: 'defaultEntitiesQueue',
                defaultCasesQueue: 'defaultCasesQueue',
                defaultReviewsQueue: 'defaultReviewsQueue',
                defaultReportsQueue: 'defaultReportsQueue',
                defaultEfilesQueue: 'defaultEfilesQueue',
                defaultCommentsSidebarOpen: 'defaultCommentsSidebarOpen',
                selectedBusinessUnit: 'selectedBusinessUnit',
                defaultRiskAssessmentsQueue: 'defaultRiskAssessmentsQueue'
            },

            // capabilities matching the defined capability names in metadata
            capabilities: {
                suppressAlert: 'AML.ALERT.SUPPRESS',
                suppressAllAlerts: 'AML.ALERT.SUPPRESS.ALL',
                closeAlert: 'AML.ALERT.CLOSE',
                closeAllAlerts: 'AML.ALERT.CLOSE.ALL',
                createManualAlert: 'AML.ALERT.CREATE',
                activateClosedByCaseAlert: 'AML.ALERT.ACTIVATE.CASE.CLOSED',
                activateClosedAlert: 'AML.ALERT.ACTIVATE.CLOSED',
                activateSuppressedAlert: 'AML.ALERT.ACTIVATE.SUPPRESSED',
                viewLogs: 'AML.LOGS.ACCESS',
                viewAuditEvent: 'AML.AUDIT_EVENTS.ACCESS',
                manageLists: 'AML.LISTS.MANAGE',
                manageRoutingRules: 'AML.RISK_ASSESSMENTS.MANAGE.ROUTING_RULE',
                manageRiskClassifiers: 'AML.RISK_CLASSIFIERS.MANAGE',
                accessEntitiesAll: 'FCF.ENTITY.ACCESS.ALL',
                accessEntitiesMy: 'FCF.ENTITY.ACCESS.MY',
                accessEntitiesAvailable: 'FCF.ENTITY.ACCESS.AVAILABLE',
                routeEntity: 'AML.ENTITY.ROUTE',
                routeAllEntities: 'AML.ENTITY.ROUTE.ALL',
                checkinEntity: 'AML.ENTITY.CHECKIN',
                checkoutEntity: 'AML.ENTITY.CHECKOUT',
                addToCaseEntityMy: 'AML.ENTITY.ADDTOCASE.MY',
                addToCaseEntityAll: 'AML.ENTITY.ADDTOCASE.ALL',
                accessEmployee: 'FCF.ENTITY.ACCESS.EMPLOYEE',
                createComment: 'AML.COMMENT.CREATE',
                editComment: 'AML.COMMENT.EDIT',
                deleteComment: 'AML.COMMENT.DELETE',
                deleteAllComments: 'AML.COMMENT.DELETE.ALL',
                createAttachment: 'AML.ATTACHMENT.CREATE',
                deleteAttachment: 'AML.ATTACHMENT.DELETE',
                search: 'FCF.SEARCH',
                caseSearch: 'FCF.ACCESS.SEARCH.CASES',
                updatePreferences: 'AML.PREFERENCES.UPDATE',
                //CDD Reviews
                accessCDDReviewsAll: 'CDD.CASE.ACCESS.ALL',
                accessCDDReviewsMy: 'CDD.CASE.ACCESS.MY',
                accessCDDReviewsAvailable: 'CDD.CASE.ACCESS.AVAILABLE',
                accessCDDReviewsClosed: 'CDD.CASE.ACCESS.CLOSED',
                accessCDDReviewsSearch: 'CDD.CASE.ACCESS.SEARCH',
                closeCDDReview: 'CDD.CASE.CLOSE',
                closeAllCDDReviews: 'CDD.CASE.CLOSE.ALL',
                routeCDDReview: 'CDD.CASE.ROUTE',
                routeAllCDDReviews: 'CDD.CASE.ROUTE.ALL',
                checkinCDDReview: 'CDD.CASE.CHECKIN',
                checkoutCDDReview: 'CDD.CASE.CHECKOUT',
                createCDDReview: 'CDD.CASE.CREATE',
                editCDDReview: 'CDD.CASE.EDIT',
                editCDDReviewsAll: 'CDD.CASE.EDIT.ALL',
                //Cases
                accessCasesMy: 'FCF.CASE.ACCESS.MY',
                accessCasesAll: 'FCF.CASE.ACCESS.ALL',
                accessCasesAvailable: 'FCF.CASE.ACCESS.AVAILABLE',
                activateCase: 'AML.CASE.ACTIVATE',
                activateAllCases: 'AML.CASE.ACTIVATE.ALL',
                editCase: 'AML.CASE.EDIT',
                editAllCases: 'AML.CASE.EDIT.ALL',
                createCase: 'AML.CASE.CREATE',
                createCaseFromAlerts: 'AML.CASE.CREATE.FROM.ALERTS',
                closeCase: 'AML.CASE.CLOSE',
                routeCase: 'AML.CASE.ROUTE',
                routeAllCases: 'AML.CASE.ROUTE.ALL',
                checkinCase: 'AML.CASE.CHECKIN',
                checkoutCase: 'AML.CASE.CHECKOUT',
                accessReportsMy: 'FCF.REPORT.ACCESS.MY',
                accessReportsAll: 'FCF.REPORT.ACCESS.ALL',
                accessReportsAvailable: 'FCF.REPORT.ACCESS.AVAILABLE',
                editReport: 'AML.REPORT.EDIT',
                editAllReports: 'AML.REPORT.EDIT.ALL',
                createReport: 'AML.REPORT.CREATE',
                resetReportStatus: 'FCF.EFILE.REPORT.RESET',
                reportReadyToSubmit: 'FCF.EFILE.READY',
                checkinReport: 'AML.REPORT.CHECKIN',
                checkoutReport: 'AML.REPORT.CHECKOUT',
                routeReport: 'AML.REPORT.ROUTE',
                routeAllReports: 'AML.REPORT.ROUTE.ALL',
                closeReport: 'AML.REPORT.CLOSE',
                accessEfiles: 'FCF.EFILE.ACCESS',
                editEfile: 'FCF.EFILE.EDIT',
                accessScenarioAdmin : 'AML.HOME.ACCESS.SA',
                accessRuleAdmin : 'CDD.HOME.ACCESS.SCENARIO_MANAGER',
                accessQueueAdmin : 'AML.QUEUES.ACCESS',
                accessSegmentAdmin : 'AML.SEGMENTS.ACCESS',
                routeRiskAssessment : 'AML.RISK_ASSESSMENT.ROUTE',
                routeAllRiskAssessments : 'AML.RISK_ASSESSMENT.ROUTE.ALL',
                takeOwnershipRiskAssessment : 'AML.RISK_ASSESSMENT.TAKE_OWNERSHIP',
                createRiskAssessment: 'AML.RISK_ASSESSMENT.CREATE',
                acceptRiskAssessment : 'AML.RISK_ASSESSMENT.EDIT',
                accessAllRiskAssessment : 'AML.RISK_ASSESSMENTS.ACCESS.ALL',
                accessMyRiskAssessment : 'AML.RISK_ASSESSMENTS.ACCESS.MY',
                accessAvailableRiskAssessment : 'AML.RISK_ASSESSMENTS.ACCESS.AVAILABLE',
                rejectRiskAssessment : 'AML.RISK_ASSESSMENT.EDIT',
                restServicesAccess : 'FCF.SERVICES.ACCESS.ALL'
            },

            ALERTS_CATEGORY_MANUAL : 'MANUAL',
            ALERTS_PREFIX : 'ALT-',
            ALERTS_PREFIX_MANUAL : 'MAL-',

            csvFileExtension: '.csv',

            /*
             * called at startup via resource-service to populate user-configurable constant values
             */
            initializeConfigValues :function(configValues ) {
                angular.extend( this.config, configValues );
                // remove any $ values brought in from the ngResource
                var cfg = this.config;
                var keys =_.keys( this.config );
                _.each( keys, function( key ) {
                    if (key && key.indexOf('$') === 0) {
                        delete cfg[key];
                    }
                });
            }


        });
})();

/**
 * This configuration defines all of the routes/states for the AML application
 */
(function () {
    'use strict';
    // ng-inject
    angular.module('aml')

    .config(["$urlRouterProvider", "$stateProvider", "amlConstants", function ($urlRouterProvider, $stateProvider, amlConstants) {

        // set default redirect for any unknown routes
        $urlRouterProvider.otherwise('/');


        /***
         * AML States/Routes
         *
         * States should inherit from the 'root' parentState; this provides base resolves that are required
         * for most any application page, in order to make sure resource strings and user capability information is
         * available at the time the route is initialized.
         *
         * States can plug into navigation by specifying an info object in the route's 'data' block:
         *  area: this route will display in the navigation as a top-level functionl area
         *  tabInfo: this route will display as an object details info tab, which is closeable by the user
         *  tabArea: this route will display as a nested tab underneath a top-level functional area; these routes
         *      should specify the 'parent' as the route of the functional area that they belong to
         *
         */
        $stateProvider
        // base top-level state that defines resolves that all states need, to make sure that
        // resource strings and user information is available at the time the route is initialized
            .state('root', {
                abstract: true,
                templateUrl: 'core/state/baseState.html',
                resolve: {
                    // This is a list of promises that must resolve before any controllers load.

                    // make sure that localized resources are loaded before loading page
                    resourcesInit: ["$rootScope", "resourceService", function ($rootScope, resourceService) {
                        return resourceService.init($rootScope, 'aml');
                    }],

                    // need the usersService to be initialized as we need user capabilities on the action menu
                    usersInit: ["usersService", function (usersService) {
                        return usersService.init();
                    }],

                    // The user list for grids needs to be downloaded before any applicable grids are initialized
                    userListInit: ["usersService", function(usersService) {
                        return usersService.downloadUserList();
                    }],

                    // Segments must be downloaded before they are used for grid column filters
                    segmentsInit: ["scenarioService", function(scenarioService) {
                        return scenarioService.downloadSegmentList();
                    }]
                }
            })

            // this is simply a landing page that redirects to the first available 'area' tab
            .state('welcome', {
                parent: 'root',
                url: '/',
                views: {
                    'aml': {
                        controller: 'AmlRedirectController as vm'
                    }
                }
            })
            .state('entities', {
                parent: 'root',
                url: '/entities',
                sticky: true,
                data: {
                    area: {
                        label: 'navbar.subTitle',
                        tooltip: 'navbar.subTitle',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'entities': {
                        templateUrl: 'entities/entitiesList/entitiesList.view.html'
                    }
                }
            })
            .state('cases', {
                url: '/cases',
                sticky: true,
                parent: 'root',
                data: {
                    area: {
                        label: 'customerdetails.casesSectionTitle',
                        tooltip: 'customerdetails.casesSectionTitle',
                        requiredCapabilities:  [amlConstants.capabilities.accessCasesMy, amlConstants.capabilities.accessCasesAll, amlConstants.capabilities.accessCasesAvailable]
                    }
                },
                views: {
                    'cases': {
                        templateUrl: 'cases/casesList/casesList.view.html'
                    }
                }
            })
            .state('reports', {
                url: '/regulatoryReports',
                sticky: true,
                parent: 'root',
                data: {
                    area: {
                        label: 'reports.reportsTitle',
                        tooltip: 'reports.reportsTitle',
                        requiredCapabilities: [amlConstants.capabilities.accessReportsMy, amlConstants.capabilities.accessReportsAvailable, amlConstants.capabilities.accessReportsAll]
                    }
                },
                views: {
                    'reports': {
                        templateUrl: 'regulatoryReports/reportsList/reportsList.view.html'
                    }
                }
            })
            .state('efiles', {
                url: '/efiles',
                sticky: true,
                parent: 'root',
                data: {
                    area: {
                        label: 'efiles.efilesTitle',
                        tooltip: 'efiles.efilesTitle',
                        requiredCapabilities: [amlConstants.capabilities.accessEfiles]
                    }
                },
                views: {
                    'efiles': {
                        templateUrl: 'efiles/efilesList/efilesList.view.html'
                    }
                }
            })
            .state('alertDetails', {
                url: '/alerts/:alertid',
                parent: 'root',
                params: {
                    alertid: null,
                    exttype: null
                },
                sticky: true,
                data: {
                    stickyParam: 'alertid',
                    tabInfo: {
                        label: '{{alertid}}',
                        tooltip: 'tabs.alertTabTooltip',
                        iconClass: 'sas-icon-alert',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'alertDetails': {
                        templateUrl: 'alerts/alertDetails.html',
                        controller: 'AlertController as viewVm'
                    }
                }
            })
            .state('customerDetails', {
                url: '/customers/:customerid',
                parent: 'root',
                // declare customerid also as a ui-router (non-url) param to use for cloned specific states; the
                // cloned state will maintain the original param, so you can still do $stateParams.customerid on the
                // cloned state
                params: {
                    customerid: null,
                    name: null,
                    queueCode: null
                },
                sticky: true,
                data: {
                    stickyParam: 'customerid',
                    tabInfo: {
                        label: '{{name || customerid}}',
                        tooltip: 'tabs.customerTabTooltip',
                        iconClass: 'sas-icon-user',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'customerDetails': {
                        templateUrl: 'entities/customers/customerDetails/customerdetails.html',
                        controller: 'CustomerDetailsViewController as viewVm'
                    }
                }
            })
            .state('auditEvents', {
                url: '/auditEvents/:objectType/:id',
                parent: 'root',
                params: {
                    objectType: null,
                    id: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'id',
                    tabInfo: {
                        label: '{{name || id}}',
                        tooltip: 'tabs.auditEventTabTooltip',
                        iconClass: 'sas-icon-history',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'auditEvents': {
                        templateUrl: 'admin/audit/auditEventView.html',
                        controller: 'AuditEventViewController as viewVm'
                    }
                }
            })
            .state('fundsTracker', {
                url: '/accounts/:accountid/fundsTracker',
                parent: 'root',
                params: {
                    accountid: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'accountid',
                    tabInfo: {
                        label: '{{name || accountid}}',
                        tooltip: 'tabs.accountTabTooltip',
                        iconClass: 'sas-icon-autocompleteProcedures',
                        requiredCapabilities: []
                    }
                },

                views: {
                    'fundsTracker': {
                        templateUrl: 'networks/fundstrackerView.html',
                        controller: 'FundsTrackerViewController as viewVm'
                    }
                }
            })
            .state('caseDetails', {
                url: '/cases/:caseid',
                parent: 'root',
                // declare caseid also as a ui-router (non-url) param to use for cloned specific states; the
                // cloned state will maintain the original param, so you can still do $stateParams.caseid on the
                // cloned state
                params: {
                    caseid: null
                },
                sticky: true,
                data: {
                    stickyParam: 'caseid',
                    tabInfo: {
                        label: 'tabs.caseTabLabel',
                        tooltip: 'tabs.caseTabLabel',
                        iconClass: 'sas-icon-accessControlTemplate',
                        requiredCapabilities:  [amlConstants.capabilities.accessCasesMy, amlConstants.capabilities.accessCasesAll, amlConstants.capabilities.accessCasesAvailable]
                    }
                },
                views: {
                    'caseDetails': {
                        templateUrl: 'cases/caseDetails/casedetails.html',
                        controller: 'CaseDetailsViewController as viewVm'
                    }
                }
            })
            .state('reportDetails', {
                url: '/regulatoryReports/:reportkey',
                parent: 'root',
                // declare reportkey also as a ui-router (non-url) param to use for cloned specific states; the
                // cloned state will maintain the original param, so you can still do $stateParams.reportkey on the
                // cloned state
                params: {
                    reporttype: null,
                    reportkey: null
                },
                sticky: true,
                data: {
                    stickyParam: 'reportkey',
                    tabInfo: {
                        label: 'tabs.reportTabLabel',
                        tooltip: 'tabs.reportTabLabel',
                        iconClass: 'sas-icon-accessControlTemplate',
                        requiredCapabilities: [amlConstants.capabilities.accessReportsMy, amlConstants.capabilities.accessReportsAvailable, amlConstants.capabilities.accessReportsAll]
                    }
                },
                views: {
                    'reportDetails': {
                        templateUrl: 'regulatoryReports/reportDetails/reportdetails.html',
                        controller: 'ReportDetailsViewController as viewVm'
                    }
                }
            })
            .state('customReportDetails', {
                url: '/regulatoryReports/:reportkey',
                parent: 'root',
                // declare reportkey also as a ui-router (non-url) param to use for cloned specific states; the
                // cloned state will maintain the original param, so you can still do $stateParams.reportkey on the
                // cloned state
                params: {
                    reporttype: null,
                    reportkey: null
                },
                sticky: true,
                data: {
                    stickyParam: 'reportkey',
                    tabInfo: {
                        label: 'tabs.reportTabLabel',
                        tooltip: 'tabs.reportTabLabel',
                        iconClass: 'sas-icon-accessControlTemplate',
                        requiredCapabilities: [amlConstants.capabilities.accessReportsMy, amlConstants.capabilities.accessReportsAvailable, amlConstants.capabilities.accessReportsAll]
                    }
                },
                views: {
                    'customReportDetails': {
                        templateUrl: 'regulatoryReports/reportDetails/customReport.html',
                        controller: 'CustomReportDetailsViewController as viewVm'
                    }
                }
            })
            .state('efileDetails', {
                url: '/efiles/:efilekey',
                parent: 'root',
                // declare efileid also as a ui-router (non-url) param to use for cloned specific states; the
                // cloned state will maintain the original param, so you can still do $stateParams.efileid on the
                // cloned state
                params: {
                    efilekey: null
                },
                sticky: true,
                data: {
                    stickyParam: 'efilekey',
                    tabInfo: {
                        label: 'tabs.efileTabLabel',
                        tooltip: 'tabs.efileTabLabel',
                        iconClass: 'sas-icon-accessControlTemplate',
                        requiredCapabilities: [amlConstants.capabilities.accessEfiles]
                    }
                },
                views: {
                    'efileDetails': {
                        templateUrl: 'efiles/efileDetails/efiledetails.html',
                        controller: 'EfileDetailsViewController as viewVm'
                    }
                }
            })
            .state('accountDetails', {
                url: '/accounts/:accountid',
                parent: 'root',
                params: {
                    accountid: null,
                    queueCode: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'accountid',
                    tabInfo: {
                        label: '{{name || accountid}}',
                        tooltip: 'tabs.accountTabTooltip',
                        iconClass: 'sas-icon-customerFacingFacilityScenario',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'accountDetails': {
                        templateUrl: 'entities/accounts/accountDetails.html',
                        controller: 'AccountController as viewVm'
                    }
                }
            })
            .state('associateDetails', {
                url: '/associates/:associateid',
                parent: 'root',
                params: {
                    associateid: null,
                    queueCode: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'associateid',
                    tabInfo: {
                        label: '{{name || associateid}}',
                        tooltip: 'tabs.associateTabTooltip',
                        iconClass: 'sas-icon-usergroup',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'associateDetails': {
                        templateUrl: 'entities/associates/associateDetails.html',
                        controller: 'AssociateController as viewVm'
                    }
                }
            })
            .state('bankDetails', {
                url: '/banks/:bankid',
                parent: 'root',
                params: {
                    bankid: null,
                    queueCode: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'bankid',
                    tabInfo: {
                        label: '{{name || bankid}}',
                        tooltip: 'tabs.bankTabTooltip',
                        iconClass: 'sas-icon-scales',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'bankDetails': {
                        templateUrl: 'entities/banks/bankDetails.html',
                        controller: 'BankController as viewVm'
                    }
                }
            })
            .state('branchDetails', {
                url: '/branches/:branchid',
                parent: 'root',
                params: {
                    branchid: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'branchid',
                    tabInfo: {
                        label: '{{name || branchid}}',
                        tooltip: 'tabs.branchTabTooltip',
                        iconClass: 'sas-icon-internalFacilityScenario',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'branchDetails': {
                        templateUrl: 'entities/branches/branchDetails.html',
                        controller: 'BranchController as viewVm'
                    }
                }
            })
            .state('externalPartyDetails', {
                url: '/externalParties/:externalpartyid',
                parent: 'root',
                params: {
                    externalpartyid: null,
                    queueCode: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'externalpartyid',
                    tabInfo: {
                        label: '{{name || externalpartyid}}',
                        tooltip: 'tabs.externalPartyTooltip',
                        iconClass: 'sas-icon-usergroup',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'externalPartyDetails': {
                        templateUrl: 'entities/externalParties/externalPartyDetails.html',
                        controller: 'ExternalPartyController as viewVm'
                    }
                }
            })
            .state('householdDetails', {
                url: '/households/:householdNumber',
                parent: 'root',
                params: {
                    householdNumber: null,
                    queueCode: null,
                    name: null
                },
                sticky: true,
                data: {
                    stickyParam: 'householdNumber',
                    tabInfo: {
                        label: '{{name || householdNumber}}',
                        tooltip: 'tabs.householdTabTooltip',
                        iconClass: 'sas-icon-CIBusinessContext_obj',
                        requiredCapabilities: [amlConstants.capabilities.accessEntitiesMy, amlConstants.capabilities.accessEntitiesAll, amlConstants.capabilities.accessEntitiesAvailable]
                    }
                },
                views: {
                    'householdDetails': {
                        templateUrl: 'entities/households/householdDetails.html',
                        controller: 'HouseholdController as viewVm'
                    }
                }
            })
            .state('cddreviewsList', {
                url: '/cddreviews',
                sticky: true,
                parent: 'root',
                data: {
                    area: {
                        label: 'reviewsList.cddreviewsListTitle',
                        tooltip: 'reviewsList.cddreviewsListTooltip',
                        isVisible: function () { return !amlConstants.config.fcf || !amlConstants.config.fcf.riskScore || !amlConstants.config.fcf.riskScore.source ||
                                                        amlConstants.config.fcf.riskScore.source === 'CDD';},
                        requiredCapabilities:
                            [amlConstants.capabilities.accessCDDReviewsMy, amlConstants.capabilities.accessCDDReviewsAll,
                             amlConstants.capabilities.accessCDDReviewsAvailable]
                    }
                },
                views: {
                    'cddreviewsList': {
                        templateUrl: 'cddReviews/reviewsList/reviewsList.view.html'
                    }
                }
            })
            .state('cddReviewDetails', {
                url: '/cddReviews/:reviewKey',
                parent: 'root',
                params: {
                    reviewKey: null,
                    name: null,
                    // for Create CDD Review action
                    newEntityFlag: null,
                    partyNumber: null,
                    partyName: null,
                    partyLevel: null,
                    riskClassification: null
                },
                sticky: true,
                data: {
                    stickyParam: 'reviewKey',
                    tabInfo: {
                        label: '{{name || reviewKey}}',
                        tooltip: 'tabs.cddReviewTabLabel',
                        iconClass: 'sas-icon-checkAll',
                        requiredCapabilities: [amlConstants.capabilities.accessCDDReviewsMy, amlConstants.capabilities.accessCDDReviewsAll,
                            amlConstants.capabilities.accessCDDReviewsAvailable]

                    }
                },
                views: {
                    'cddReviewDetails': {
                        templateUrl: 'cddReviews/cddReviewDetails/cddReviewDetails.view.html',
                        controller: 'cddReviewDetailsView as vm'
                    }
                }
            })
            .state('riskAssessmentsList', {
                url: '/riskAssessments',
                parent: 'root',
                sticky: true,
                data: {
                    area: {
                        label: 'riskAssessmentsList.riskAssessmentsListTitle',
                        tooltip: 'riskAssessmentsList.riskAssessmentsListTitle',
                        isVisible: function () { return !amlConstants.config.fcf || !amlConstants.config.fcf.riskScore || !amlConstants.config.fcf.riskScore.source ||
                            amlConstants.config.fcf.riskScore.source === 'AML';},
                        requiredCapabilities: [amlConstants.capabilities.accessMyRiskAssessment, amlConstants.capabilities.accessAvailableRiskAssessment,
                                               amlConstants.capabilities.accessAllRiskAssessment]
                    }
                },
                views: {
                    'riskAssessmentsList': {
                        templateUrl: 'riskAssessments/riskAssessmentsList/riskAssessmentsList.view.html'
                    }
                }
            })
            .state('riskAssessmentDetails', {
                url: '/riskAssessments/:assessmentId',
                parent: 'root',
                params: {
                    assessmentId: null,
                    name: null,
                    // for Create risk assessment action
                    newEntityFlag: null,
                    customerNumber: null,
                    customerName: null,
                    riskClassification: null
                },
                sticky: true,
                data: {
                    stickyParam: 'assessmentId',
                    tabInfo: {
                        label: '{{name || assessmentId}}',
                        tooltip: 'tabs.riskAssessmentTabLabel',
                        iconClass: 'sas-icon-checkAll',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'riskAssessmentDetails': {
                        templateUrl: 'riskAssessments/riskAssessmentDetails/riskAssessmentDetails.html',
                        controller: 'RiskAssessmentController as viewVm'
                    }
                }
            })
            .state('transactionDetails', {
                url: '/transactions/:transactionid',
                parent: 'root',
                params: {
                    transactionid: null,
                    name: null,
                    alertIdVal:null
                },
                sticky: true,
                data: {
                    stickyParam: 'transactionid',
                    tabInfo: {
                        label: '{{name || transactionid}}',
                        tooltip: 'tabs.transactionTabTooltip',
                        iconClass: 'sas-icon-creditcards',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'transactionDetails': {
                        templateUrl: 'transactions/transactionDetails.html',
                        controller: 'TransactionDetailsController as viewVm'
                    }
                }
            })
            .state('peerGroupDetails', {
                url: '/peerGroupAnalysis/:alertId',
                parent: 'root',
                params: {
                    alertId: null
                },
                sticky: true,
                data: {
                    stickyParams: 'alertId',
                    tabInfo: {
                        label: '{{alertId}}',
                        tooltip: '{{alertId}}',
                        iconClass: 'sas-icon-usergroup',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'peerGroupDetails': {
                        templateUrl: 'alerts/peerGroup/peerGroupDetails.html',
                        controller: 'PeerGroupController as vm'
                    }
                }
            })
            .state('watchListDetails', {
                url: '/watchLists/:watchListKey',
                parent: 'root',
                params: {
                    watchListKey: null,
                    entityTabName: null
                },
                sticky: true,
                data: {
                    stickyParam: 'watchListKey',
                    tabInfo: {
                        label: '{{entityTabName}}',
                        tooltip: '{{watchListKey}}',
                        iconClass: 'sas-icon-bulletedList',
                        requiredCapabilities: []
                    }
                },
                views: {
                    'watchListDetails': {
                        templateUrl: 'watchLists/watchListDetails.html',
                        controller: 'WatchListDetailsController as vm'
                    }
                }
            })

        /** search top-level functional area **/
        .state('search', {
                url: '/search',
                parent: 'root',
                data: {
                    area: {
                        label: 'common.searchLabel',
                        tooltip: 'common.searchLabel',
                        requiredCapabilities: [amlConstants.capabilities.search]
                    }
                },
                sticky: true,
                deepStateRedirect: {
                    default: 'transactionSearch'
                },
                views: {
                    'search': {
                        // parent states containing tabs need to reference this
                        templateUrl: 'core/state/baseTabbedContainerState.html',
                        controller: 'StateViewController',
                        resolve: {
                            data: function () {
                                return {
                                    stateName: 'search'
                                };
                            }
                        }
                    }
                }
            })
            .state('transactionSearch', searchState('transaction', amlConstants.capabilities.search,
                                        'transactions/search/transactionSearch.html'))
            .state('accountSearch', searchState('account', amlConstants.capabilities.search))
            .state('customerSearch', searchState('customer', amlConstants.capabilities.search))
            .state('externalPartySearch', searchState('externalParty', amlConstants.capabilities.search))
            .state('householdSearch', searchState('household', amlConstants.capabilities.search))
            .state('caseSearch', searchState('case', amlConstants.capabilities.caseSearch))
            .state('alertSearch', searchState('alert', amlConstants.capabilities.search))
//            .state('riskAssessmentSearch', searchState('riskAssessment', amlConstants.capabilities.search))
            .state('watchListSearch', searchState('watchList', amlConstants.capabilities.search))

        .state('globalSearchResults', {
            url: '/globalSearch?q',
            parent: 'root',
            params: {
                q: null,
                searchId: null
            },
            sticky: true,
            data: {
                stickyParam: 'searchId',
                tabInfo: {
                    label: '{{q}}',
                    tooltip: 'tabs.globalSearchTabToolitp',
                    iconClass: 'sas-icon-search',
                    requiredCapabilities: [amlConstants.capabilities.search]
                }
            },
            views: {
                'globalSearchResults': {
                    templateUrl: 'search/global/globalSearchResults.html',
                    controller: 'GlobalSearchResultsController as vm'
                }
            }
        })

        /** admin top-level functional area **/
        .state('admin', {
                url: '/admin',
                sticky: true,
                parent: 'root',
                data: {
                    area: {
                        label: 'admin.adminTitle',
                        tooltip: 'admin.adminTitle',
                        requiredCapabilities: []
                    }
                },
                // set redirect to true instead of specifying a default child state; in this case, the
                // amlTabAreaNavigation service will instead redirect to the first available child tab.
                // This should be used if some of the subtabs may not be visible due to missing capabilities.
                deepStateRedirect: true,
                views: {
                    'admin': {
                        // parent states containing tabs need to reference this
                        templateUrl: 'core/state/baseTabbedContainerState.html',
                        controller: 'StateViewController',
                        resolve: {
                            data: function () {
                                return {
                                    stateName: 'admin'
                                };
                            }
                        }
                    }
                }
            })
            .state('preferences', {
                url: '/preferences',
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'admin.preferences.preferencesTitle',
                        tooltip: 'admin.preferences.preferencesTitle',
                        requiredCapabilities: [amlConstants.capabilities.updatePreferences]
                    },
                    area: null
                },
                templateUrl: 'admin/preferences/preferences.html',
                controller: 'PreferencesController as vm'
            })
            .state('logs', {
                url: '/logs',
                sticky: false,
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'admin.logs.logsTitle',
                        tooltip: 'admin.logs.logsTitle',
                        requiredCapabilities: [amlConstants.capabilities.viewLogs]
                    },
                    area: null
                },
                templateUrl: 'admin/logs/logViewer.html',
                controller: 'LogViewController as vm'
            })
            .state('listManager', {
                url: '/listManager',
                parent: 'admin',
                sticky: true,
                data: {
                    tabArea: {
                        label: 'admin.complianceAdmin.listManager.listManagerTabTitle',
                        tooltip: 'admin.complianceAdmin.listManager.listManagerTabTooltip',
                        requiredCapabilities: [amlConstants.capabilities.manageLists]
                    },
                    area: null
                },
                views: {
                    'listManager': {
                        templateUrl: 'admin/complianceAdmin/listManager.html',
                        controller: 'ListManagerController as vm'
                    }
                }
            })
            .state('riskClassifiers', {
                url: '/riskClassifiers',
                parent: 'admin',
                sticky: true,
                data: {
                    tabArea: {
                        label: 'admin.complianceAdmin.riskClassifiers.riskClassifierTabTitle',
                        tooltip: 'admin.complianceAdmin.riskClassifiers.riskClassifierTabTooltip',
                        isVisible: function () { return !amlConstants.config.fcf || !amlConstants.config.fcf.riskScore || !amlConstants.config.fcf.riskScore.source ||
                            amlConstants.config.fcf.riskScore.source === 'AML';},
                        requiredCapabilities: [amlConstants.capabilities.manageRiskClassifiers]
                    },
                    area: null
                },
                views: {
                    'riskClassifiers': {
                        templateUrl: 'admin/complianceAdmin/riskClassifiers.html',
                        controller: 'RiskClassifiersManagerController as vm'
                    }
                }
            })
            // state used for redirecting when user does not have authorization (required capabilities) to access a
            // state
            .state('scenarios', {
                url: '/scenarios',
                parent: 'admin',
                sticky: true,
                data: {
                    tabArea: {
                        label: 'scenarioAdmin.tabLabel',
                        tooltip: 'scenarioAdmin.tabTooltip',
                        requiredCapabilities: [amlConstants.capabilities.accessScenarioAdmin]
                    },
                    area: null
                },
                views: {
                    'scenarios': {
                        templateUrl: 'scenarios/scenarioList/scenarioList.view.html',
                        controller: 'ScenarioListViewController as vm'
                    }
                }
            })
            .state('scenarioDetails', {
                url: '/scenarioDetails/:scenarioID',
                sticky: true,
                parent: 'root',
                params: {
                    scenarioID: null, // new scenario has ID in the form: new_12345
                    scenarioName: null, // required
                    headerID: null, // optional
                    newEntityFlag: null //optional
                },
                data: {
                    stickyParam: 'scenarioID',
                    tabInfo: {
                        label: '{{scenarioName || scenarioID}}',
                        tooltip: 'tabs.scenarioTabLabel',
                        requiredCapabilities: [amlConstants.capabilities.accessScenarioAdmin]
                    },
                    area: null
                },
                views: {
                    'scenarioDetails': {
                        templateUrl: 'scenarios/scenarioDetails/scenarioDetails.view.html',
                        controller: 'ScenarioDetailsViewController as vm'
                    }
                }
            })
            .state('headers', {
                url: '/headers',
                sticky: true,
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'headerAdmin.tabLabel',
                        tooltip: 'headerAdmin.tabTooltip',
                        requiredCapabilities: [amlConstants.capabilities.accessScenarioAdmin]
                    },
                    area: null
                },
                views: {
                    'headers': {
                        templateUrl: 'scenarios/headerList/headerList.view.html',
                        controller: 'HeaderListViewController as vm'
                    }
                }
            })
            .state('headerDetails', {
                url: '/headerDetails/:headerID',
                sticky: true,
                parent: 'root',
                params: {
                    headerName: null,
                    headerID: null,
                    newEntityFlag: null //optional
                },
                data: {
                    stickyParam: 'headerID',
                    tabInfo: {
                        label: '{{headerName || headerID}}',
                        tooltip: 'tabs.headerTabLabel',
                        requiredCapabilities: [amlConstants.capabilities.accessScenarioAdmin]
                    },
                    area: null
                },
                views: {
                    'headerDetails': {
                        templateUrl: 'scenarios/headerDetail/headerDetails.view.html',
                        controller: 'HeaderDetailsViewController as vm'
                    }
                }
            })
            .state('rules', {
                url: '/rules',
                parent: 'admin',
                sticky: true,
                data: {
                    tabArea: {
                        label: 'ruleAdmin.tabLabel',
                        tooltip: 'ruleAdmin.tabTooltip',
                        isVisible: function () { return !amlConstants.config.fcf || !amlConstants.config.fcf.riskScore || !amlConstants.config.fcf.riskScore.source ||
                            amlConstants.config.fcf.riskScore.source === 'CDD';},
                        requiredCapabilities: [amlConstants.capabilities.accessRuleAdmin]
                    },
                    area: null
                },
                views: {
                    'rules': {
                        templateUrl: 'cddAdmin/ruleList/ruleList.view.html',
                        controller: 'RuleListViewController as vm'
                    }
                }
            })
            .state('ruleDetails', {
                url: '/ruleDetails/:ruleId',
                sticky: true,
                parent: 'root',
                params: {
                    ruleId: null, // new rule has Id in the form: Rule_new_12345
                    ruleName: null, // required
                    ruleGroupId: null, // optional
                    newRule : null  //optional, values 'yes' or 'no'
                },
                data: {
                    stickyParam: 'ruleId',
                    tabInfo: {
                        label: '{{ruleName || ruleId}}',
                        tooltip: 'tabs.ruleTabLabel',
                        requiredCapabilities: [amlConstants.capabilities.accessRuleAdmin]
                    },
                    area: null
                },
                views: {
                    'ruleDetails': {
                        templateUrl: 'cddAdmin/ruleDetails/ruleDetails.view.html',
                        controller: 'RuleDetailsViewController as vm'
                    }
                }
            })
            .state('ruleGroups', {
                url: '/ruleGroups',
                sticky: true,
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'ruleGroupAdmin.tabLabel',
                        tooltip: 'ruleGroupAdmin.tabTooltip',
                        isVisible: function () { return !amlConstants.config.fcf || !amlConstants.config.fcf.riskScore || !amlConstants.config.fcf.riskScore.source ||
                            amlConstants.config.fcf.riskScore.source === 'CDD';},
                        requiredCapabilities: [amlConstants.capabilities.accessRuleAdmin]
                    },
                    area: null
                },
                views: {
                    'ruleGroups': {
                        templateUrl: 'cddAdmin/ruleGroupList/ruleGroupList.view.html',
                        controller: 'RuleGroupListViewController as vm'
                    }
                }
            })
            .state('ruleGroupDetails', {
                url: '/ruleGroupDetails/:ruleGroupId',
                sticky: true,
                parent: 'root',
                params: {
                    ruleGroupId: null,
                    ruleGroupName: null,
                    newRuleGroup : null  //optional, values 'yes' or 'no'
                },
                data: {
                    stickyParam: 'ruleGroupId',
                    tabInfo: {
                        label: '{{ruleGroupName || ruleGroupId}}',
                        tooltip: 'tabs.ruleGroupTabLabel',
                        requiredCapabilities: [amlConstants.capabilities.accessRuleAdmin]
                    },
                    area: null
                },
                views: {
                    'ruleGroupDetails': {
                        templateUrl: 'cddAdmin/ruleGroupDetails/ruleGroupDetails.view.html',
                        controller: 'RuleGroupDetailsViewController as vm'
                    }
                }
            })
            .state('queues', {
                url: '/queues',
                sticky: true,
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'queueAdmin.tabLabel',
                        tooltip: 'queueAdmin.tabTooltip',
                        requiredCapabilities: [amlConstants.capabilities.accessQueueAdmin]
                    },
                    area: null
                },
                views: {
                    'queues': {
                        templateUrl: 'queues/queueList.view.html',
                        controller: 'QueueListController as vm'
                    }
                }
            })
            .state('segments', {
                url: '/segments',
                sticky: true,
                parent: 'admin',
                data: {
                    tabArea: {
                        label: 'segmentsAdmin.tabLabel',
                        tooltip: 'segmentsAdmin.tabTooltip',
                        requiredCapabilities: [amlConstants.capabilities.accessSegmentAdmin]
                    },
                    area: null
                },
                views: {
                    'segments': {
                        templateUrl: 'segments/segmentList.view.html',
                        controller: 'SegmentListController as vm'
                    }
                }
            })
            .state('notFound', {
                url: '/notFound',
                sticky: false,
                params: {
                    invalidUrl: null,
                    message: null
                },
                templateUrl: 'core/exception/notFound.html',
                controller: 'NoAccessController as vm'
            })
            .state('invalidAccess', {
                url: '/noAccess',
                sticky: false,
                params: {
                    invalidUrl: null,
                    message: null
                },
                templateUrl: 'core/exception/noAccess.html',
                controller: 'NoAccessController as vm'
            });

        function searchState(entity, capability, customTemplateUrl) {
            var returnable = {
                url: '/' + entity,
                parent: 'search',
                data: {
                    tabArea: {
                        label: 'search.subtabs.' + entity,
                        tooltip: 'search.subtabs.' + entity,
                        requiredCapabilities: [capability]
                    },
                    area: null
                },
                sticky: true,
                views: {}
            };

            returnable.views[entity + 'Search'] = {
                templateUrl: customTemplateUrl ?
                    customTemplateUrl : 'search/' + entity + 'Search.html',
                controller: entity.charAt(0).toUpperCase() + entity.slice(1) +
                    'SearchController as vm'
            };

            return returnable;
        }

    }]);
})();

/**
 * @ngdoc factory
 * @name     httpInterceptor
 *
 * @restrict E
 *
 * @description this global interceptor can be used to handle intercepting ALL requests and responses
 * to handle things like errors and logging them.  We use this to handle
 * checking responses to see if it was actually an authentication-request
 * that needs handled.
 *
 * We also use this to handle setting the current selected business unit for ALL requests
 *
 */
(function(){
    'use strict';


    var httpInterceptor = function ($provide, $httpProvider) {
        $provide.factory('httpInterceptor', ["$q", "$location", "$window", "$injector", "amlConstants", "amlConfig", function ($q, $location, $window, $injector, amlConstants, amlConfig) {

            var amlPreferencesService;

            function redirectToLogonPage() {
                $window.location.reload(true);
            }

            function getAmlPreferenceService() {
                if ( !amlPreferencesService ) {
                    amlPreferencesService = $injector.get('amlPreferencesService');
                }
                return amlPreferencesService;
            }

            return {
                response: function (response) {
                    // if using invalid credentials (unknown user), will get a 401
                    if ( response.status === 401 ) {
                        redirectToLogonPage();
                    }

                    // SAS authentication redirects and sends a 200 Response when requiring re-authentication,
                    // rather than return a non-success code.  As such, we need to check all successful responses to
                    // see if is is a reauthentication request.  In that case, we simply will reload the page which will
                    // force reauthentication.  This handles the case where you log out of a page, and then hit the
                    // back button and the cached version of the html page is used but REST requests return a logon
                    // page.

                    // if response is a string (rather than JSON) it may be the logon page;  in that case we check if
                    // the response content-type is html and appears to be the logon page.
                    else if (typeof response.data === 'string' ) {
                        var responseContentType = response.headers('Content-Type');
                        // angular html/js template resources will be string types as well, but the response
                        // contentType
                        // is null in that case; so we check that the response type is HTML, which may indicate the
                        // logon page was sent
                        if ( responseContentType && responseContentType.indexOf( '/html' ) !== -1 &&
                            response.data.indexOf('/SASLogon/login') !== -1) {
                            redirectToLogonPage();
                        }
                    }

                    return response || $q.when(response);
                },

                responseError: function (rejection) {
                    //if(rejection.status === 401) {
                    //    // you are not authorized
                    //}
                    return $q.reject(rejection);
                },

                request: function (config) {
                    // set business unit if this is a /rest request (and user belongs to multiple BUs)
                    if ( config.url && config.url.indexOf( amlConfig.baseUrl) !== -1 ) {

                        // check if the current business unit has been set by the user in the local storage
                        // preferences
                        var prefsService = getAmlPreferenceService();
                        if (prefsService) {
                            var currentUserBusinessUnit = prefsService.getLocalPreference(
                                amlConstants.preferences.selectedBusinessUnit );
                            if (currentUserBusinessUnit) {
                                // if there is a specific business unit set, send it along on this (and every) REST
                                // request
                                if (!config.params) {
                                    config.params = {};
                                }
                                config.params.businessUnit = currentUserBusinessUnit;
                            }
                        }
                    }

                    return config;
                }
            };
        }]);
    };
    httpInterceptor.$inject = ["$provide", "$httpProvider"];

    angular.module('aml.core').config(httpInterceptor);

}());

/**
 * @ngdoc constant
 * @name     aml:resources
 *
 * @description
 * The resources service is used for referencing the localized application strings.
 * The resource strings themselves are defined in resources/i18n/aml/resources*.json.
 *
 * The entire JSON object representing the correct localized version of the strings resources
 * gets populated into this service under the 'aml' property.
 *
 * @example reference from the application code:
 *  resources.aml.case.description --> 'Description'
 */
(function() {
        'use strict';
        angular.module('aml').constant('resources', {
            // this is populated with the i18n resources via the resourceService initialization
        });
})();
(function () {
        'use strict';
        ListManagerController.$inject = ["$scope", "$state", "resources", "listManagerService", "dialogService", "usersService", "tabsListService", "amlConstants"];
        angular.module('aml.admin').controller('ListManagerController', ListManagerController);

        /* jshint maxstatements: 65 */
        function ListManagerController($scope, $state, resources, listManagerService, dialogService, usersService, tabsListService, amlConstants) {
            var vm = this;
            vm.resources = resources;

            vm.changeSelectedCategory = changeSelectedCategory;
            vm.changeSelectedList = changeSelectedList;
            vm.closeCategoryForm = closeCategoryForm;
            vm.closeListForm = closeListForm;
            vm.closeValueForm = closeValueForm;
            vm.collapse = true; //boolean for collapsible Value section header; initialize as true, since mostly empty
            vm.createNewCategory = createNewCategory;
            vm.createNewList = createNewList;
            vm.createNewValue = createNewValue;
            vm.deleteCategory = deleteCategory;
            vm.deleteList = deleteList;
            vm.deleteValue = deleteValue;
            vm.displayCategoryForm = false;
            vm.displayListForm = false;
            vm.displayValueForm = false;
            vm.editableCategory = null;
            vm.editableList = null;
            vm.editableValue = null;
            vm.editSelectedCategory = editSelectedCategory;
            vm.editSelectedList = editSelectedList;
            vm.editSelectedValue = editSelectedValue;
            vm.emptyCategory = false; //there are no categories (implies no lists or values)
            vm.emptyList = false; //no lists in selected category
            vm.emptyValue = false; //no values in selected list
            vm.generateRegExpForLists = generateRegExpForLists;
            vm.lists = null;
            vm.newCategory = false; //distinguish between edit and create modes
            vm.newList = false;
            vm.newValue = false;
            vm.setSelectedValue = setSelectedValue;
            vm.submitCategoryForm = submitCategoryForm;
            vm.submitListForm = submitListForm;
            vm.submitValueForm = submitValueForm;
            vm.toggle = toggle;
            vm.userCanManageLists = usersService.currentUserHasCapability(amlConstants.capabilities.manageLists);
            //what does this allow you to do? are there multiple permission levels? One restriction is not being able to
            //delete, but still can create new and edit.

            activate();

            $scope.$watch(
                function() { //watchExpression
                    return vm.editableList ? vm.editableList.name : null;
                },
                function(newListName) { //listener
                    if(vm.selectedCategory && newListName) {
                        // check if name matches pre-existing name (case insensitive)
                        var isNameDuplicate = vm.selectedCategory.categoryLists.some(function(cList) {
                            return newListName.toLowerCase() === cList.name.toLowerCase();
                        });

                        if(isNameDuplicate && vm.selectedList) {
                            if (vm.newList) { //uniqueness must be held among all lists
                                $scope.listForm.biName.$setValidity('unique', false);
                            } else { //uniqueness only necessary among all OTHER lists
                                var isOwnName = vm.selectedList.name.toLowerCase() === newListName.toLowerCase();
                                $scope.listForm.biName.$setValidity('unique', isOwnName);
                            }
                        } else {
                            $scope.listForm.biName.$setValidity('unique', true);
                        }
                    }
                }
            );

            $scope.$watch(
                function() {
                    return vm.editableCategory ? vm.editableCategory.name : null;
                },
                function(newCategoryName) {
                    if(vm.editableCategory && newCategoryName) {
                        var isNameDuplicate = vm.lists.some(function(category) {
                            return newCategoryName.toLowerCase() === category.name.toLowerCase();
                        });

                        if (isNameDuplicate && vm.selectedCategory) {
                            if (vm.newCategory) {
                                $scope.catForm.biName.$setValidity('unique', false);
                            } else {
                                var isOwnName = vm.selectedCategory.name.toLowerCase() === newCategoryName.toLowerCase();
                                $scope.catForm.biName.$setValidity('unique', isOwnName);
                            }
                        } else {
                            $scope.catForm.biName.$setValidity('unique', true);
                        }
                    }
                }
            );

            $scope.$watch(
                function() {
                    return vm.editableValue ? vm.editableValue.value : null;
                },
                function(newValueName) {
                    if(vm.editableValue && newValueName) {
                        var isNameDuplicate = vm.selectedList.listItems.some(function(listValue) {
                            return newValueName.toLowerCase() === listValue.value.toLowerCase();
                        });

                        if(isNameDuplicate && vm.selectedValue) {
                            if(vm.newValue) {
                                $scope.valueForm.biValue.$setValidity('unique', false);
                            } else {
                                var isOwnName = vm.selectedValue.value.toLowerCase() === newValueName.toLowerCase();
                                $scope.valueForm.biValue.$setValidity('unique', isOwnName);
                            }
                        } else {
                            $scope.valueForm.biValue.$setValidity('unique', true);
                        }
                    }
                }
            );

            //////////////////

            function activate() {
                listManagerService.getLists().then(function (data) {
                    vm.lists = data.items;

                    vm.selectedCategory = vm.lists[0];
                    if (vm.selectedCategory) {
                        vm.selectedList = vm.selectedCategory.categoryLists[0];
                    }
                    if (vm.selectedList) {
                        vm.selectedValue = vm.selectedList.listItems[0];
                    } else {
                        vm.emptyList = true;
                    }
                    if (vm.selectedValue) { //default is hidden collapsible; check if there are values to show
                        vm.collapse = false;
                    } else {
                        vm.emptyValue = true;
                    }
                });
            }

            /**
             * Updates the List select and Values table when the Category select is changed
             */
            function changeSelectedCategory() {
                if (vm.selectedCategory.categoryLists.length > 0) {
                    vm.selectedList = vm.selectedCategory.categoryLists[0];
                    changeSelectedList();
                    vm.emptyList = false;
                } else { //disable edit buttons when there are no lists in a category
                    vm.emptyList = true;
                    hideCollapsible();
                }
            }

            /**
             * Updates the Values table when the List select is changed
             */
            function changeSelectedList() {
                if (vm.selectedList) {
                    if (vm.selectedList.listItems.length > 0) {
                        vm.selectedValue = vm.selectedList.listItems[0];
                        vm.collapse = false;
                        vm.emptyValue = false;
                    } else {   //disable edit buttons when there are no values in a list
                        hideCollapsible();
                        vm.emptyValue = true;
                    }
                }
            }

            /**
             Closes the category form and re-enables any disabled fields, resets validations
             */
            function closeCategoryForm() {
                $scope.catForm.$setPristine();
                $scope.catForm.$setUntouched();
                vm.displayCategoryForm = false;
                vm.newCategory = false;
            }

            /**
             * Closes the list form, re-enables disabled fields, resets validations
             */
            function closeListForm() {
                $scope.listForm.$setPristine();
                $scope.listForm.$setUntouched();
                vm.displayListForm = false;
                vm.newList = false;
            }

            /**
             * Closes the value form, re-enables disabled fields, resets validations
             */
            function closeValueForm() {
                $scope.valueForm.$setPristine();
                $scope.valueForm.$setUntouched();
                vm.displayValueForm = false;
                vm.newValue = false;
            }

            /**
             * Opens form and creates a new object. Actual create logic is within the 'submitXForm' functions
             */
            function createNewCategory() {
                vm.editableCategory = listManagerService.newCategory();
                vm.displayCategoryForm = true;
                vm.newCategory = true;
            }

            function createNewList() {
                vm.editableList = listManagerService.newList();
                vm.displayListForm = true;
                vm.newList = true;
            }

            function createNewValue() {
                vm.editableValue = listManagerService.newValue();
                vm.displayValueForm = true;
                vm.newValue = true;
            }

            function generateRegExpForLists() {
                if (vm.selectedCategory) {
                    var listNames = [];
                    vm.selectedCategory.categoryLists.forEach(function (list) {
                        listNames.push(list.name);
                    });
                    return /((' + listNames.join('|') + ').+|(?!(' + listNames.join('|') + ')).*)/i;
                } else {
                    return null;
                }
            }

            /**
             * Clicking delete opens confirmation dialog. If hit 'OK", deletes the category, updates vm.lists, and reassigns
             * selected category (and selected list and value, if applicable) in the UI.
             */
            function deleteCategory() {
                dialogService.openConfirmDialog(resources.aml.admin.complianceAdmin.listManager.deleteConfirmationCategoryWindowTitle,
                    resources.aml.admin.complianceAdmin.listManager.deleteConfirmationCategoryText).then(function okayPressed() {
                    listManagerService.deleteCategory(vm.selectedCategory.key).then(function () {
                        listManagerService.getLists().then(function (data) {
                            vm.lists = data.items;
                            if (vm.lists.length > 0) {
                                //if other categories exist, reassign select reference
                                vm.selectedCategory = vm.lists[0];
                                if (vm.selectedCategory.categoryLists.length > 0) {
                                    vm.emptyList = false;
                                    vm.selectedList = vm.selectedCategory.categoryLists[0];
                                    if (vm.selectedList.listItems.length > 0) {
                                        vm.selectedValue = vm.selectedList.listItems[0];
                                    } else {
                                        vm.emptyValue = true;
                                    }
                                } else {
                                    vm.emptyList = true;
                                    vm.emptyValue = true;
                                }
                            } else { //if deleted the last category
                                vm.emptyCategory = true;
                                vm.emptyList = true;
                                vm.emptyValue = true;
                            }
                        });
                    });
                });
            }

            /**
             * Clicking delete opens confirmation dialog. If hit 'OK", deletes the list, updates vm.lists, and reassigns
             * selected list (and selected value, if applicable) in the UI.
             */
            function deleteList() {
                dialogService.openConfirmDialog(resources.aml.admin.complianceAdmin.listManager.deleteConfirmationListWindowTitle,
                    resources.aml.admin.complianceAdmin.listManager.deleteConfirmationListText)
                    .then(function okayPressed() {
                        listManagerService.deleteList(vm.selectedCategory.key, vm.selectedList.key).then(function () {
                            listManagerService.getLists().then(function (data) {
                                vm.lists = data.items;
                                vm.selectedCategory = _.findWhere(vm.lists, {name: vm.selectedCategory.name});
                                if (vm.selectedCategory.categoryLists.length > 0) {
                                    vm.selectedList = vm.selectedCategory.categoryLists[0];
                                    if (vm.selectedList.listItems.length > 0) {
                                        vm.selectedValue = vm.selectedList.listItems[0];
                                        vm.collapse = false;
                                    } else {
                                        vm.emptyValue = true;
                                    }
                                } else {
                                    vm.emptyList = true;
                                    vm.emptyValue = true;
                                }
                            });
                        });
                    });
            }

            /**
             * Clicking delete opens confirmation dialog. If hit 'OK", deletes the value, updates vm.lists, and reassigns
             * selected value (if applicable)
             */
            function deleteValue() {
                dialogService.openConfirmDialog(resources.aml.admin.complianceAdmin.listManager.deleteConfirmationValueWindowTitle,
                    resources.aml.admin.complianceAdmin.listManager.deleteConfirmationValueText)
                    .then(function okayPressed() {
                        listManagerService.deleteValue(vm.selectedCategory.key, vm.selectedList.key, vm.selectedValue.key).then(function () {
                                listManagerService.getLists().then(function (data) {
                                    vm.lists = data.items;
                                    vm.selectedCategory = _.findWhere(vm.lists, {name: vm.selectedCategory.name});
                                    vm.selectedList = _.findWhere(vm.selectedCategory.categoryLists, {name: vm.selectedList.name});
                                    if (vm.selectedList.listItems.length > 0) {
                                        vm.selectedValue = vm.selectedList.listItems[0];
                                    } else {
                                        vm.emptyValue = true;
                                        hideCollapsible();
                                    }
                                });
                            });
                        });
            }

            /**
             * Opens the form and copies fields over to a temp object. Actual edits submitted in submitXForm() functions
             */
            function editSelectedCategory() {
                vm.displayCategoryForm = true;
                vm.editableCategory = _.clone(vm.selectedCategory);
            }

            function editSelectedList() {
                vm.displayListForm = true;
                vm.editableList = _.clone(vm.selectedList);
            }

            function editSelectedValue() {
                vm.displayValueForm = true;
                vm.editableValue = _.clone(vm.selectedValue);
            }

            /**
             * Hide the collapsible section header for List Values
             */
            function hideCollapsible() {
                vm.collapse = true;
            }

            /**
             * Called in the view. Updates the selected value (highlighted in the UI) upon click, as long as
             * no forms are open.
             * @param value
             */
            function setSelectedValue(value) {
                if (!(vm.displayValueForm || vm.displayCategoryForm || vm.displayListForm)) {
                    vm.selectedValue = value;
                }
            }

            /**
             * Checks if creating or editing. If edit, simply updates the category. Validations performed in the UI.
             * If creating a new category, adds to beginning of vm.lists for easy assignment as the selected category
             * in the UI. Boolean variables updated to keep the UI clean (collapsing the values header, appropriate
             * buttons are disabled)
             */
            function submitCategoryForm() {
                if (!vm.newCategory) {
                    _.extend(vm.selectedCategory, vm.editableCategory);
                    listManagerService.updateCategory(vm.selectedCategory).then();
                } else {
                    listManagerService.createCategory(vm.editableCategory).then(function (cat) {
                        vm.lists.unshift(cat);
                        vm.selectedCategory = vm.lists[0];
                        //New category won't have any lists or values
                        vm.emptyCategory = false;
                        vm.emptyList = true;
                        vm.emptyValue = true;
                        vm.selectedList = null;
                        vm.selectedValue = null;
                        hideCollapsible();
                    });
                }
                closeCategoryForm();
            }

            /**
             * Checks if creating or editing. If edit, simply updates the list. Validations performed in the UI.
             * If creating a new list, updates vm.lists and assigns as the selected list in UI. Boolean variables
             * updated to keep the UI clean (collapsing the values header, appropriate buttons are disabled)
             */
            function submitListForm() {
                if (!vm.newList) {
                    _.extend(vm.selectedList, vm.editableList);
                    listManagerService.updateList(vm.selectedCategory.key, vm.selectedList);
                } else {
                    listManagerService.createList(vm.selectedCategory.key, vm.editableList).then(function (list) {
                        vm.selectedCategory.categoryLists.unshift(list);
                        vm.selectedList = vm.selectedCategory.categoryLists[0];
                        vm.emptyList = false;
                        //new list won't have any values
                        vm.emptyValue = true;
                        vm.selectedValue = null;
                    });
                }
                closeListForm();
            }

            /**
             * Checks if creating or editing. If edit, simply updates the value. Some validations performed in the UI prior
             * to form submission, other validations performed on server-side. If creating a new value, updates vm.lists
             * and assigns as the selected value in UI. Boolean variables updated to keep the UI clean
             * (expanding the values header, appropriate buttons are enabled)
             */
            function submitValueForm() {
                if (!vm.newValue) {
                    var oldSelectedValue = _.extend({}, vm.selectedValue);
                    _.extend(vm.selectedValue, vm.editableValue);
                    listManagerService.updateValue(vm.selectedCategory.key, vm.selectedList.key, vm.selectedValue).then(
                        function(value) {
                            if(!value) { //error
                                _.extend(vm.selectedValue, oldSelectedValue);
//console.log("vm.selectedValue : " + vm.selectedValue);
                            }
                        }
                    );
                } else {
                    listManagerService.createValue(vm.selectedCategory.key, vm.selectedList.key, vm.editableValue).then(
                        function (value) {
                            if(value) {
                                vm.selectedList.listItems.unshift(value);
                                //the links object causes an error when editing a list after adding a list value
                                //and editing the list.
                                if (value.links) {
                                    delete value.links;
                                }
                                vm.selectedValue = vm.selectedList.listItems[0];
                                vm.emptyValue = false;
                                vm.collapse = false;
                            } else {
                                vm.emptyValue = true;
                                vm.collapse = true;
                            }
                        }
                    );
                }
                closeValueForm();
            }

            /**
             * Toggle expanded view of collapsible Value section header
             */
            function toggle() {
                if (!vm.displayValueForm) {
                    vm.collapse = !vm.collapse;
                }
            }
        }
    })();
/**
 * Created by jokeun on 5/2/2016.
 */
(function () {
    'use strict';
    RiskClassifiersManagerController.$inject = ["$scope", "resources", "riskClassifiersService", "listManagerService", "dialogService", "usersService", "amlConstants"];
    angular.module('aml.admin').controller('RiskClassifiersManagerController', RiskClassifiersManagerController);

    /* jshint maxstatements: 70 */
    function RiskClassifiersManagerController($scope, resources, riskClassifiersService, listManagerService, dialogService, usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        //2 types of categories: RC Categories and List Manager Categories
        vm.categories = [];
        vm.categoryLists = [];
        vm.changeSelectedCategory = changeSelectedCategory;
        vm.changeSelectedSourceTable = changeSelectedSourceTable;
        vm.classifiers = null;
        vm.closeCategoryForm = closeCategoryForm;
        vm.closeClassifierForm = closeClassifierForm;
        vm.collapseToggle = false;
        vm.createNewCategory = createNewCategory;
        vm.createNewClassifier = createNewClassifier;
        vm.deleteCategory = deleteCategory;
        vm.deleteClassifier = deleteClassifier;
        vm.displayCategoryForm = false;
        vm.displayClassifierForm = false;
        vm.editableCategory = null;
        vm.editableClassifier = null;
        vm.editClassifierMode = false;
        vm.thresholdTypeDisabled = false;
        vm.sourceDisabled = false;
        vm.listDisabled = false;

        //Object references for classifier fields that require selects
        vm.editableClassifierCategoryObject = null;
        vm.editableClassifierListCategoryObject = null;
        vm.editableClassifierListObject = null;
        vm.editableClassiiferSourceTableObject = null; //not yet implemented
        vm.editableClassifierSourceColumnObject = null; //not yet implemented

        vm.editSelectedCategory = editSelectedCategory;
        vm.editSelectedClassifier = editSelectedClassifier;
        vm.emptyCategory = false;
        vm.emptyClassifier = false; //no classifiers in selected category
        vm.factColumns = [];
        vm.newCategory = false;
        vm.newClassifier = false;
        vm.operators = [];
        vm.selectedCategory = vm.categories[0];
        vm.selectedClassifier = null;
        vm.setSelectedClassifier = setSelectedClassifier;

        //Lists of source columns for source tables 'Party Dim', 'Account Dim', and 'Party Profile'
        vm.PTYSourceColumns = [];
        vm.PPFSourceColumns = [];
        vm.ACCSourceColumns = [];
        vm.displayedSourceColumns = []; //List of options available in classifier form

        vm.submitCategoryForm = submitCategoryForm;
        vm.submitClassifierForm = submitClassifierForm;
        vm.toggleCollapse = toggleCollapse;
        vm.updateClassifierList = updateClassifierList;
        vm.updateSourceColumns = updateSourceColumns;
        vm.userCanManageLists = usersService.currentUserHasCapability(amlConstants.capabilities.manageLists);

        activate();
        setupWatches();

        //////////////////

        function setupWatches() {
            $scope.$watch(
                function() {
                    return vm.editableCategory? vm.editableCategory.name : null;
                },
                function(newCategoryName) {
                    if(vm.selectedCategory && newCategoryName) {
                        var isNameDuplicate = vm.categories.some(function(category) {
                            return newCategoryName.toLowerCase() === category.name.toLowerCase();
                        });

                        if(isNameDuplicate) {
                            if(vm.newCategory) {
                                $scope.catForm.biName.$setValidity('unique', false);
                            } else {
                                var isOwnName = vm.selectedCategory.name.toLowerCase() === newCategoryName.toLowerCase();
                                $scope.catForm.biName.$setValidity('unique', isOwnName);
                            }
                        } else {
                            $scope.catForm.biName.$setValidity('unique', true);
                        }
                    }
                }
            );

            $scope.$watch(
                function() {
                    return vm.editableClassifier? vm.editableClassifier.classifierName : null;
                },
                function(newClassifierName) {
                    if(vm.selectedClassifier && newClassifierName) {
                        var isNameDuplicate = vm.classifiers.some(function(rc) {
                            return newClassifierName.toLowerCase() === rc.classifierName.toLowerCase();
                        });

                        if(isNameDuplicate) {
                            if(vm.newCategory) {
                                $scope.classForm.biName.$setValidity('unique', false);
                            } else {
                                var isOwnName = vm.selectedClassifier.classifierName.toLowerCase() === newClassifierName.toLowerCase();
                                $scope.classForm.biName.$setValidity('unique', isOwnName);
                            }
                        } else {
                            $scope.classForm.biName.$setValidity('unique', true);
                        }
                    }
                }
            );

            $scope.$watch(
                function() {
                    return vm.editableClassifier ? vm.editableClassifier.type : null;
                },
                function(newClassifierType) { //jshint ignore:line
                    if(vm.operators) {
                        vm.operators.forEach(function(operator) {
                            operator.disabled = ( (newClassifierType === 'RC0' || newClassifierType === 'RC1' || newClassifierType === 'RC3')&&
                                                       (operator.code === 'GT' || operator.code === 'LT') );
                        });
                    }

                    var newThresholdState = ( newClassifierType === 'RC1' ||  newClassifierType === 'RC2' ||
                                                newClassifierType === 'RC4');
                    if (newThresholdState !== vm.thresholdTypeDisabled) {
                        $scope.classForm.biThreshold.$setPristine();
                        $scope.classForm.biThreshold.$setUntouched();
                        vm.editableClassifier.threshold = '';
                    }
                    vm.thresholdTypeDisabled = newThresholdState;

                    var newSourceState = ( newClassifierType === 'RC5');

                    if (newSourceState !== vm.sourceTableDisabled && newSourceState === true) {
                        vm.editableClassifier.source_table = ''; //jshint ignore:line
                        vm.editableClassifier.source_column = ''; //jshint ignore:line
                    }
                    vm.sourceDisabled = newSourceState;

                    var newListState = ( newClassifierType === 'RC3' || newClassifierType === 'RC4' || newClassifierType === 'RC5');

                    if (newListState !== vm.listDisabled && newListState === true) {
                        vm.editableClassifierListCategoryObject = '';
                        vm.editableClassifierListObject = '';
                    }
                    vm.listDisabled = newListState;
                }
            );
        }

        function activate() {
            riskClassifiersService.getCategories().then(function (data) {
                vm.categories = data.items;
                vm.selectedCategory = vm.categories[0];
                if (vm.selectedCategory) {
                    riskClassifiersService.getClassifiers(vm.selectedCategory.key).then(function (data) {
                        vm.classifiers = data.items;
                        vm.selectedClassifier = vm.classifiers[0];
                        if (!vm.selectedClassifier) {
                            vm.emptyClassifier = true;
                            hideCollapsible();
                        }
                    });
                }
                riskClassifiersService.getRCFactColumns().then(function (data) {
                    vm.factColumns = data.items;
                });
                riskClassifiersService.getPartyProfileSourceColumns().then(function (data) {
                    vm.PPFSourceColumns = data.items;
                });
                riskClassifiersService.getAccountDimSourceColumns().then(function (data) {
                    vm.ACCSourceColumns = data.items;
                });
                riskClassifiersService.getPartyDimSourceColumns().then(function (data) {
                    vm.PTYSourceColumns = data.items;
                });
                listManagerService.getLists().then(function (data) {
                    vm.categoryLists = data.items;
                });
                riskClassifiersService.getOperators().then(function(data){
                    vm.operators = data.items;
                });
            });

        }

        /**
         * Updates the Classifier table and collapsible title when the Category select is changed
         */
        function changeSelectedCategory() {
            riskClassifiersService.getClassifiers(vm.selectedCategory.key).then(function (classifiers) {
                vm.classifiers = classifiers.items;
                vm.selectedClassifier = vm.classifiers[0];
                if (!vm.selectedClassifier) {
                    vm.emptyClassifier = true;
                    hideCollapsible();
                } else {
                    vm.collapseToggle = false;
                    vm.emptyClassifier = false;
                }
            });
        }

        /** Updates the Source Column select in the risk classifier form based on which source table is selected.
         * If a source table is selected, must select a source column.
         */
        function changeSelectedSourceTable() {
            /*jshint camelcase: false */
            vm.updateSourceColumns();
            if (vm.displayedSourceColumns) {
                vm.editableClassifier.source_column = vm.displayedSourceColumns[0];
            }
        }

        /**
         Closes the Category form, re-enables any disabled fields, clears errors
         */
        function closeCategoryForm() {
            $scope.catForm.$setPristine();
            $scope.catForm.$setUntouched();
            vm.displayCategoryForm = false;
            vm.newCategory = false;
        }

        /**
         Closes the Classifier form, re-enables any disabled fields, clears errors
         */
        function closeClassifierForm() {
            $scope.classForm.$setPristine();
            $scope.classForm.$setUntouched();
            vm.displayClassifierForm = false;
            vm.editClassifierMode = false;
            vm.newClassifier = false;
        }

        /**
         * Opens form and creates a new object. Actual create logic is within the 'submitXForm' functions
         */
        function createNewCategory() {
            vm.editableCategory = riskClassifiersService.newCategory();
            vm.displayCategoryForm = true;
            vm.newCategory = true;
        }

        function createNewClassifier() {
            /*jshint camelcase: false */
            vm.editableClassifier = riskClassifiersService.newClassifier(vm.selectedCategory.key);
            vm.editableClassifier.threshold = ''; //needed because threshold field doesn't automatically clear itself.
            vm.editableClassifierCategoryObject = _.findWhere(vm.categories, {key: vm.editableClassifier.category_key});
            vm.editableClassifierListCategoryObject = null;
            vm.editableClassifierListObject = null;
            vm.displayClassifierForm = true;
            vm.newClassifier = true;
        }

        /**
         * Clicking delete opens confirmation dialog. If hit 'OK", deletes the category, updates vm.categories, and reassigns
         * selected category (and selected classifier, if applicable) in the UI.
         */
        function deleteCategory() {
            dialogService.openConfirmDialog(resources.aml.admin.complianceAdmin.riskClassifiers.deleteConfirmationCategoryWindowTitle,
                resources.aml.admin.complianceAdmin.riskClassifiers.deleteConfirmationCategoryText)
                .then(function okayPressed() {
                    riskClassifiersService.deleteCategory(vm.selectedCategory.key).then(function () {
                        riskClassifiersService.getCategories().then(function (data) {
                            vm.categories = data.items;
                            if (vm.categories.length > 0) {
                                vm.selectedCategory = vm.categories[0];
                                //update classifiers after new category is selected
                                riskClassifiersService.getClassifiers(vm.selectedCategory.key).then(function (data) {
                                    vm.classifiers = data.items;
                                    vm.selectedClassifier = vm.classifiers[0];
                                    if (!vm.selectedClassifier) {
                                        hideCollapsible();
                                        vm.emptyClassifier = true;
                                    } else {
                                        vm.emptyClassifier = false;
                                        vm.collapseToggle = false;
                                    }
                                });
                            } else { //if deleted the last Category
                                vm.emptyCategory = true;
                                vm.emptyClassifier = true;
                            }
                        });
                    });
                });
        }

        /**
         * Clicking delete opens confirmation dialog. If hit 'OK", deletes the classifier, updates vm.classifiers, and reassigns
         * selected classifier in the UI (to either next selector in list, or to null)
         */
        function deleteClassifier() {
            dialogService.openConfirmDialog(resources.aml.admin.complianceAdmin.riskClassifiers.deleteConfirmationClassifierWindowTitle,
                resources.aml.admin.complianceAdmin.riskClassifiers.deleteConfirmationClassifierText)
                .then(function okayPressed() {
                    riskClassifiersService.deleteClassifier(vm.selectedCategory.key, vm.selectedClassifier.key).then(function(){
                        riskClassifiersService.getClassifiers(vm.selectedCategory.key).then(function (data) {
                            vm.classifiers = data.items;
                            if (vm.classifiers.length > 0){
                                vm.selectedClassifier = vm.classifiers[0];
                                vm.emptyClassifier = false;
                            } else { //if deleted the last classifier in a category
                                vm.emptyClassifier = true;
                                vm.selectedClassifier = null;
                                hideCollapsible();
                            }
                        });
                    });
                });
        }

        /**
         * Opens the form and copies fields over to a temp object. Actual edits submitted in submitXForm() functions
         */
        function editSelectedCategory() {
            vm.editableCategory = _.clone(vm.selectedCategory);
            vm.displayCategoryForm = true;
        }

        /**
         * Classifiers returned from the server only contain the list_key (List) and do not contain the list_id (list category).
         * When the edit form is opened, loops through the 2-D array to first find the list, and then sets the category to
         * whatever index in vm.categoryLists the list was found in.
         */
        function editSelectedClassifier() {
            /*jshint camelcase: false */
            vm.editClassifierMode = true;
            vm.editableClassifier = _.clone(vm.selectedClassifier);
            for (var i = 0; i < vm.categoryLists.length; i++) {
                vm.editableClassifierListObject = _.findWhere(vm.categoryLists[i].categoryLists, {key: vm.editableClassifier.list_key});
                if (vm.editableClassifierListObject) {
                    vm.editableClassifierListCategoryObject = vm.categoryLists[i];
                    break;
                }
            }
            vm.updateSourceColumns();
            vm.editableClassifierCategoryObject = _.findWhere(vm.categories, {key: vm.editableClassifier.category_key});
            vm.displayClassifierForm = true;
        }

        //Controls the collapsible section header for classifiers
        function hideCollapsible() {
            vm.collapseToggle = true;
        }

        /** Updates reference to selected classifier when you click on a classifier in the table.
         Important for tracking which classifier to perform edit/delete actions on.
         */
        function setSelectedClassifier(classifier) {
            if (!vm.editClassifierMode) {
                vm.selectedClassifier = classifier;
            }
        }

        /**
         * Checks if creating or editing. If edit, simply updates the category. Validations performed in the UI.
         * If creating a new category, adds to beginning of vm.categories for easy assignment as the selected category
         * in the UI. Boolean variables updated to keep the UI clean (collapsing the classifiers header, appropriate
         * buttons are disabled)
         */
        function submitCategoryForm() {
            if (!vm.newCategory) {
                _.extend(vm.selectedCategory, vm.editableCategory);
                riskClassifiersService.updateCategory(vm.selectedCategory).then();
            } else {
                riskClassifiersService.createCategory(vm.editableCategory).then(function (cat) {
                    vm.categories.unshift(cat);
                    vm.selectedCategory = vm.categories[0];
                    //a newly created category will not contain any classifiers
                    vm.classifiers = [];
                    vm.emptyClassifier = true;
                    vm.emptyCategory = false;
                    vm.collapseToggle = true;
                });
            }
            closeCategoryForm();
        }

        /**
         * Checks if creating or editing. If edit, updates the classifier. Some validations performed in the UI, but
         * also have some checks to be implemented on server-side (TODO).
         * If creating a new classifier, updates vm.classifiers and assigns as the selected classifier in UI. Boolean variables
         * updated to keep the UI clean
         */
        function submitClassifierForm() {
            /*jshint camelcase: false */
            vm.editableClassifier.category_key = vm.editableClassifierCategoryObject.key;
            if (vm.editableClassifierListObject) {
                vm.editableClassifier.list_key = vm.editableClassifierListObject.key;
            }
            if (!vm.newClassifier) {
                _.extend(vm.selectedClassifier, vm.editableClassifier);
                riskClassifiersService.updateClassifier(vm.selectedClassifier).then();
            } else {
                riskClassifiersService.createClassifier(vm.editableClassifier).then(function(data){
                    //Can create a classifier in different category than was originally selected, so need to update category
                    vm.selectedCategory = _.findWhere(vm.categories, {key : data.category_key});
                    riskClassifiersService.getClassifiers(vm.selectedCategory.key).then(function (data) {
                        vm.classifiers = data.items;
                        vm.selectedClassifier = vm.classifiers[0];
                        if (!vm.selectedClassifier) {
                            vm.emptyClassifier = true;
                            hideCollapsible();
                        } else {
                            //category will be non-empty upon creation of a classifier
                            vm.emptyClassifier = false;
                            vm.collapseToggle = false;
                        }
                    });
                    //TODO make the newly created classifier the selected one upon creation; not as simple as unshift operator since reloading classifiers
                });
            }
            closeClassifierForm();
        }

        /**
         * Show/hide contents of the collapsible Classifier section header
         */
        function toggleCollapse() {
            if (!vm.displayClassifierForm) {
                vm.collapseToggle = !vm.collapseToggle;
            }
        }

        /**
         * Updates the 'List' select in the Classifier form when 'List Category' is changed
         */
        function updateClassifierList() {
            if (vm.editableClassifierListCategoryObject) {
                vm.editableClassifierListObject = vm.editableClassifierListCategoryObject.categoryLists[0];
            }
        }

        /**
         * Maintain the correct list of source columns as source table changes. There are 3 source tables.
         * Relevant for classifiers.
         */
        function updateSourceColumns() {
            /*jshint camelcase: false */
            if (vm.editableClassifier.source_table === 'PTY') {
                vm.displayedSourceColumns = vm.PTYSourceColumns;
            } else if (vm.editableClassifier.source_table === 'PPF') {
                vm.displayedSourceColumns = vm.PPFSourceColumns;
            } else if (vm.editableClassifier.source_table === 'ACC') {
                vm.displayedSourceColumns = vm.ACCSourceColumns;
            } else { //if no source table selected
                vm.displayedSourceColumns = [];
            }
        }
    }
})();



/**
 * Handles displaying alerts messages sent via the central messageService
 */
(function() {
    'use strict';
    AlertMessagesController.$inject = ["messageService"];
    angular.module('aml.core').controller('AlertMessagesController', AlertMessagesController);

    function AlertMessagesController(messageService) {
        var vm = this;
        vm.alerts = messageService.alerts;
        vm.closeAlert = messageService.closeAlert;
    }
})();

(function() {
    'use strict';

    config.$inject = ["$provide"];
    extendExceptionHandler.$inject = ["$delegate", "$injector"];
    angular
        .module('aml.core.exception')
        .provider('exceptionHandler', exceptionHandlerProvider)
        .config(config);


    function exceptionHandlerProvider() {
        /* jshint validthis:true */
        this.config = {
            appErrorPrefix: undefined
        };

        this.configure = function (appErrorPrefix) {
            this.config.appErrorPrefix = appErrorPrefix;
        };

        this.$get = function() {
            return {config: this.config};
        };
    }

    /**
     * Configure by setting an optional string value for appErrorPrefix.
     * Accessible via config.appErrorPrefix (via config value).
     * @param  $provide
     * @return {[type]}
     * @ngInject
     */
    function config($provide) {
        $provide.decorator('$exceptionHandler', extendExceptionHandler);
    }

    /**
     * Extend the $exceptionHandler service to also display a toast.
     * @param  {Object} $delegate
     * @param  {Object} $injector
     * @return {Function} the decorated $exceptionHandler service
     */
    function extendExceptionHandler($delegate, $injector) { //, exceptionHandler) {

        return function(exception, cause) {
           // var appErrorPrefix = exceptionHandler.config.appErrorPrefix || '';
            var appErrorPrefix = 'AML: ';
            var errorData = {exception: exception, cause: cause};
            var amlMessage = appErrorPrefix + exception.message;

            if ( !shouldIgnoreError(errorData)) {
                try   {
                    exception.message = amlMessage;
                } catch (ex) {
                    //ignore exception when message is read only
                }

                $delegate(exception, cause);
                /**
                 * Could add the error to a service's collection,
                 * add errors to scope, log errors to remote web server,
                 * or log locally. Or throw hard.
                 * throw exception;
                 *
                 * @example
                 *     throw { message: 'error message' };
                 */

                // logger can't be injected directly as it causes a circular dependency
                // due to low-level exceptionHandler requiring logger, which requires messageService:
                // $rootScope <- $timeout <- messageService <- logger <- $exceptionHandler
                var logger = $injector.get('logger');
                logger.error(amlMessage, errorData);
            }
        };
    }

    /**
     * Add any logic to ignore errors for certain conditions.  In some cases there
     * are known, non-harmful exceptions from third-party libraries that need not be logged.
     * @param data
     * @returns {boolean}
     */
    function shouldIgnoreError( data ) {
        var ignore = false;
        /*
         // add any exceptions to logging here; the below is an example
        if ( data && data.exception && data.exception.stack ) {
            if ( (data.exception.stack.indexOf( 'jqx.jqxWidgetProxy' ) > -1 ||
                data.exception.stack.indexOf( 'jqx.dataview.databind' ) > -1 ) &&
                (data.exception.message &&
                data.exception.message.indexOf( 'Cannot read property' > -1 ) ) ) {
                // ignore jqxGrid errors that often can be thrown if navigating between pages
                // while a grid is being destroyed
                ignore = true;
            }
            else if ( data.exception.message && data.exception.message.indexOf(
                    'jqxGrid: The data is still loading.' ) > -1 ) {
                // ignore jqxGrid errors where it tries to update the grid
                // while it's still loading
                ignore = true;
            }
        }*/

        return ignore;
    }

})();
/**
 * @ngdoc factory
 * @name    aml.core.links:linksProcessor
 *
 * @description Provides basic functions for handling and processing link and link relations
 *
 */
(function() {
    'use strict';

    linksProcessor.$inject = ["amlConfig", "usersService", "$window"];
    angular
        .module('aml.core.links')
        .factory('linksProcessor', linksProcessor);

    /* @ngInject */
    function linksProcessor(amlConfig, usersService, $window) {
        var service = {
            getLinkHrefForRel   : getLinkHrefForRel,
            buildAbsoluteUri: buildAbsoluteUri,
            openLinkInSeparateTab: openLinkInSeparateTab,
            getBusinessUnitLink: getBusinessUnitLink,
            openDefaultTbmlLink: openDefaultTbmlLink
        };

        return service;
        /////////////////////

        /**
         * construct a URI given a relative uri and an array of parameter objects representing
         * parameter name and value.  The parameters will be added to the URI.
         * @param baseRelativeUri
         * @param paramObject
         * @returns {exports.config.baseUrl|*|baseUrl|j.baseUrl|string|q.baseUrl}
         */
        function buildAbsoluteUri( baseRelativeUri, paramObject) {
            var uri = baseRelativeUri;
            var paramsStr = '';
            _.each( paramObject, function( value, key ) {
                if ( paramsStr ) {
                    paramsStr +='&';
                }
                paramsStr += key + '=' + value;
            });
            if ( paramsStr ) {
                uri += '?' + paramsStr;
            }

            //var absUri = $location.host + '/' + uri;
            var absUri = amlConfig.baseUrl;
            if ( uri && uri.indexOf( '/' ) !== 0 ) {
                uri = '/' + uri;
            }
            absUri = absUri + uri;
            return absUri;
        }

        /**
         * Return the link href for a given rel name from an array of links
         * @param links
         * @param rel
         * @returns {*}
         */
        function getLinkHrefForRel(links, rel) {
            for ( var i = 0; i < links.length; i++ ) {
                if ( links[i].rel === rel ) {
                    return links[i].href;
                }
            }
            return null;

        }

        /**
         * Open the designated link in a separate browser window
         * @param link
         */
        function openLinkInSeparateTab( link ) {
            $window.open(link, '_blank' );
        }


        /**
         * If the user belongs to multiple business units, append the current business unit to a link
         * that will be displayed to the user
         * @param link
         * @returns {*}
         */
        function getBusinessUnitLink( link ) {
            if ( link && usersService.getCurrentUserBusinessUnitMemberships() &&
                usersService.getCurrentUserBusinessUnitMemberships().length > 1 ) {

                var appendedBusinessUnit =  usersService.getCurrentUserBusinessUnit();

                //Need to use & if link already has a parameter
                if (link.includes('?') ) {
                    link += '&businessUnit=' + appendedBusinessUnit;
                }
                else {
                    link += '?businessUnit=' + appendedBusinessUnit;
                }
            }
            return link;
        }

        function openDefaultTbmlLink( ) {
            //$window.open('http://kboamldev.kbstar.com:7980/SASHBI/HBIServlet?sp_pathUrl=SBIP%3A%2F%2FMETASERVER%2FKFI_NY%2FAML+Compliance%2F02.CodeMgt%2F01.CodeMgt%2F05.Channel%28StoredProcess%29&sas_forwardLocation=reportViewer&reportURI=fromExpK&accountNumber=', '_blank' );
            $window.open('http://www.naver.com', '_blank');
        }
    }
}());

/**
 * @ngdoc service
 * @name     aml.core.logger
 *
 * @restrict E
 *
 * @description
 * The logger service is used to handle logging and displaying application error messages.
 * By default the message will be both logged to the console and a visual alertMessage
 * popup.
 *
 * @element ANY
 *
 */

(function() {
    'use strict';

    logger.$inject = ["$log", "messageService", "$state"];
    angular
        .module('aml.core.logger')
        .factory('logger', logger);

    /* @ngInject */
    function logger($log, messageService, $state) {
        var service = {
            displayAlert: true,

            error   : error,
            info    : info,
            success : success,
            warning : warning,

            // log only to console; bypass alert display
            log     : $log.log
        };

        return service;
        /////////////////////

        /**
         * Add any logic to not display toast-style alerts for certain conditions.
         * They will still be logged to the console.
         * @param data
         * @returns {boolean}
         */
        function shouldHideDisplay( data ) {
            var hide = false;
            /*  // add any exceptions to logging here; the below is an example
            if ( data && data.exception && data.exception.stack ) {
                // jqWidgets 1.7 has issues when a grid is loading while another grid was
                // being disposed; this has no functional impact and we can safely ignore
                // these
                if ( data.exception.stack.indexOf( 'jqx' ) > -1 && (
                    data.exception.message &&
                    data.exception.message.indexOf( 'Cannot read property' > -1 ) ) ) {

                    hide = true;
                }
            }*/

            // if we're on the invalidAccess page, don't display error messages, otherwise you might see
            // 3 or 4 of the same errors saying '403 Forbidden' for multiple REST calls. That's not needed
            // as the invalidAccess page displays the reason.
            if ( $state.is( 'invalidAccess')) {
                hide = true;
            }

            return hide;
        }

        function error(message, data, title) {
            if ( service.displayAlert ) {
                if ( !shouldHideDisplay( data ) ) {
                    messageService.danger( message );
                }
            }
            if ( data ) {
                $log.error('Error: ' + message, data);
            }
            else {
                $log.error('Error: ' + message);
            }
        }

        function info(message, data, title) {
            if ( service.displayAlert ) {
                messageService.info( message );
            }
            if ( data ) {
                $log.info('Info: ' + message, data);
            }
            else {
                $log.info('Info: ' + message);
            }

        }

        function success(message, data, title) {
            if ( service.displayAlert ) {
                messageService.success( message );
            }
            if ( data ) {
                $log.info('Success: ' + message, data);
            }
            else {
                $log.info('Success: ' + message);
            }
        }

        function warning(message, data, title) {
            if ( service.displayAlert ) {
                messageService.warning( message );
            }
            if ( data ) {
                $log.warn('Warning: ' + message, data);
            }
            else {
                $log.warn('Warning: ' + message);
            }

        }
    }
}());

(function () {
    'use strict';

    HeaderModalDispositionController.$inject = ["$uibModalInstance", "resources", "$state"];
    angular
        .module('aml.scenario')
        .controller('HeaderModalDispositionController', HeaderModalDispositionController);

    function HeaderModalDispositionController($uibModalInstance, resources, $state) {
        var viewVm = this;
        viewVm.resources = resources;
        viewVm.headerName = $uibModalInstance.headerName;

        viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
            $state.go('headers');
        };
        viewVm.save = function () {
            $uibModalInstance.dismiss('save');
        };
        viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();
(function() {
    'use strict';

HeaderModalController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('aml.scenario')
        .controller('HeaderModalController', HeaderModalController);

   function HeaderModalController($uibModalInstance, resources) {
        var viewVm = this;
        viewVm.resources = resources;

         viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
         };
}
})();
(function() {
    'use strict';

ScenarioModalDispositionController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('aml.scenario')
        .controller('ScenarioModalDispositionController', ScenarioModalDispositionController);

   function ScenarioModalDispositionController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;
        viewVm.scenarioName = $uibModalInstance.scenarioName;

         viewVm.discard = function () {
            $uibModalInstance.dismiss('discard');
         };
         viewVm.save = function () {
            $uibModalInstance.dismiss('save');
         };
         viewVm.cancel = function () {
            $uibModalInstance.dismiss('cancel');
         };
}
})();
(function() {
    'use strict';

ScenarioModalController.$inject = ["$uibModalInstance", "resources"];
    angular
        .module('aml.scenario')
        .controller('ScenarioModalController', ScenarioModalController);

   function ScenarioModalController($uibModalInstance,resources) {
        var viewVm = this;
        viewVm.resources = resources;

         viewVm.ok = function () {
            $uibModalInstance.dismiss('ok');
         };
}
})();
/**
 * Created by sasrns on 4/28/2016.
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlErrorBubble', amlErrorBubble);

    /* @ngInject */
    function amlErrorBubble () {
        return {
            require: ['ngModel', '^form'],
            restrict: 'A',
            link: function (scope, element, attrs, ctrls) {
                var ngModelCtrl = ctrls[0];
                var formCtrl = ctrls[1];

                if (!attrs.name) {
                    throw 'errorBubble must be set on an input element that has a \'name\' attribute';
                }

                if (!formCtrl || !formCtrl.$name) {
                    throw 'errorBubble requires that a name is assigned to the ng-form containing the validated input';
                }

                //watch the current form's validation for the current field name
                scope.$watch(formCtrl.$name + '.' + ngModelCtrl.$name + '.$valid', function (isValid, lastValue) {
                    if (isValid !== undefined) {
                        //emit an event upwards
                        scope.$emit('amlErrorBubble', {
                            isValid: isValid,       // if the field is valid
                            element: element,       // the element that the validation applies to
                            expression: this.exp,   // the expression that was watched to check validity
                            scope: scope,           // the current scope
                            ctrl: ctrls              // the current controller
                        });
                    }
                });
            }
        };
    }
})();
/**
 * @ngdoc directive
 * @name    aml.core:amlPhoneLabel
 *
 * @restrict A
 *
 * @description
 * The 'amlPhoneLabel' directive renders a phone number and ensures that the proper left-to-right format is used, even in
 * right-to-left language locales.  It essentially sets dir="ltr" for the element, overriding whatever the global
 * direction might be set to.
 *
 * @example
 *  <div aml-phone-label>{{ ::vm.customer.phone | phoneNumber }}</div>
 *
 */
(function(){
    'use strict';

    angular
        .module('aml.core')
        .directive('amlPhoneLabel', amlPhoneLabel);

    function amlPhoneLabel() {
        var directive = {
            restrict: 'A',
            transclude: true,

            // force ltr direction for this element
            template: '<span dir="ltr" ng-transclude></span>'
        };
        return directive;
    }
})();

/**
 * created by tommut
 */
(function () {
    'use strict';
    AlertsListController.$inject = ["dataMessagingServiceFactory", "resources", "amlConstants", "$scope", "kendoGridRendererService", "logger", "$stateParams", "entityService", "casesService", "alertsService", "scenarioService", "segmentNameFilter", "messageService", "usersService", "_"];
    angular.module('aml.customer.details').controller('AlertsListController', AlertsListController);
    /*jshint maxparams: 15 */
    function AlertsListController(dataMessagingServiceFactory, resources, amlConstants, $scope, kendoGridRendererService, logger, $stateParams, entityService, casesService, alertsService, scenarioService, segmentNameFilter, messageService, usersService, _) {
        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.entityId = entityService.normalizeEntityId(vm.entityId, vm.entityLevelCode, vm.entityNumber, vm.entityKey);
        vm.caseId = $stateParams.caseid;
        vm.resources = resources;
        vm.totalAmount = 0;
        vm.isCase = !!vm.caseId;
        // grid settings
        vm.grid = {}; // to get a reference
        vm.pageSize = vm.pageSize || 10;
        vm.getAlerts = getAlerts;
        vm.handleRowSelect = handleRowSelect;
        vm.handleDoubleClick = handleDoubleClick;
        vm.displayMLS = true;
        var allAlerts = [];
        // Reset selected alerts to none when loading customer details page, no alerts selected
        // call activate before creating grid column to see if MLS has to be hidden
        activate();
        //update total amount if there is already the value in the messaging service. One the very first triage page load the 'select'
        //event for triage list os processed before this controller is instantiated, so the watch is not there to process the update
        updateTotalAmount(dataMessagingService.getTotalAmount());
        //allow multiple row selection for alert list
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            selectable: 'multiple'
        });
        vm.gridColumns = [
            {
                field: 'alertId',
                title: resources.aml.common.id, width: '8%'
            },
            {
                field: 'alertLevel', lovTable: true,
                title: resources.aml.alert.level,
                width: '10%'
            },
            {
                field: 'employeeIndicator', title: resources.aml.reviews.employeeIndicatorHeaderTitle,
                width: '10%',
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'entitySegmentId', type: 'string',
                title: vm.resources.aml.segment.segmentLabel,
                width: '10%',
                template: segmentNameFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(segmentNameFilter) },
                filterable: kendoGridRendererService.getCheckboxFilterForValues(scenarioService.getSegments('nondeleted'), true, 'segmentName', 'entitySegmentId', 'localizedSegmentName')
            },
            {
                field: 'alertCategory', lovTable: 'scenarioCategory',
                title: resources.aml.alert.type,
                sortable: {
                    compare: function (a, b) {
                        var translate = kendoGridRendererService.enum('scenarioCategory')(a);
                        var translate2 = kendoGridRendererService.enum('scenarioCategory')(b);
                        return translate.localeCompare(translate2);
                    }
                },
                width: '25%'
            },
            {
                field: 'description',
                title: resources.aml.alert.description,
                template: kendoGridRendererService.enum('description', 'manualAlertReason'),
                width: '25%'
            },
            {
                field: 'alertRunDate', type: 'date',
                title: resources.aml.alert.date,
                width: '10%',
                templateType: 'longDate'
            },
            {
                field: 'moneyLaunderingRisk', type: 'number',
                title: resources.aml.alert.score,
                hidden: !vm.displayMLS,
                width: '6%'
            },
            {
                field: 'queueCode', title: resources.aml.entity.queue,
                width: '10%',
                filterable: kendoGridRendererService.getCheckboxFilter('queueName'),
                template: '{{dataItem.queueCode | queueName:true}}'
            }
        ];
        /////
        function clearAllSelections() {
            dataMessagingService.setSelectedAlerts(allAlerts);
            dataMessagingService.setSelectedAlertCount(0);
            dataMessagingService.setAllAlerts(allAlerts);
            //use null not 'all' so that change event is generated and metrics directive reloads aggregate values
            //this is needed for HHD and ACC so that metrics are loaded based on the alert list not on the entity
            //HHD and ACC do not have transaction aggregation data in datamart
            dataMessagingService.setAlertIds('alertids', null);
        }
        function hasAccess(queueCode) {
            return usersService.hasQueueAccess(queueCode);
        }
        function handleRowSelect(data) {
            /*jshint maxcomplexity:12 */
            var selectedAlertsFilter = null;
            var alerts = [];
            if (data && data.length) {
                if (data.length > 0) {
                    //when multiple selection is enabled data is an array
                    selectedAlertsFilter = 'in(alertId';
                    var hasUnselectable = false;
                    for (var i = 0; i < data.length; i++) {
                        var userHasAccess = hasAccess(data[i].queueCode);
                        if (data[i].alertId && userHasAccess) {
                            selectedAlertsFilter = selectedAlertsFilter + ', ' + data[i].alertId;
                            alerts.push(data[i]);
                        }
                        if (!userHasAccess) {
                            messageService.warning(resources.aml.getResource('alerts.triage.alertNoAccessErrorMessage', { alertId: data[i].alertId }), null, 5000);
                            hasUnselectable = true;
                        }
                    }
                    if (hasUnselectable) {
                        vm.grid.clearSelection();
                        for (var j = 0; j < alerts.length; j++) {
                            var row = vm.grid.table.find('[data-uid=' + alerts[j].uid + ']');
                            vm.grid.select(row);
                        }
                    }
                    selectedAlertsFilter = selectedAlertsFilter + ')';
                    // if there are selected alerts use only selected
                    if (alerts.length > 0) {
                        dataMessagingService.setSelectedAlerts(alerts);
                        dataMessagingService.setSelectedAlertCount(alerts.length);
                    }
                    else {
                        clearAllSelections();
                        selectedAlertsFilter = null;
                    }
                }
                else {
                    // no alerts selected
                    clearAllSelections();
                }
            }
            else if (data && data.alertId) {
                //when multiple selection is not enabled data is single row data - this is no longer needed
                selectedAlertsFilter = 'in(alertId,' + data.alertId + ')';
                dataMessagingService.setSelectedAlertCount(1);
            }
            else {
                // no alerts selected
                clearAllSelections();
            }
            dataMessagingService.setAlertIds('alertids', selectedAlertsFilter);
        }
        function getAlertsWithAccess(alerts) {
            var accessibleAlerts = [];
            for (var i = 0; i < alerts.length; i++) {
                var userHasAccess = hasAccess(alerts[i].queueCode);
                if (alerts[i].alertId && userHasAccess) {
                    accessibleAlerts.push(alerts[i]);
                }
            }
            return accessibleAlerts;
        }
        function getAlerts(gridCallback) {
            var filterStr = null;
            var alerts;
            // If the caseId is set, we're on the Case Details page
            if (vm.caseId) {
                // If any of the values of the entity are set, an entity has been selected
                if (vm.entityId.entityLevelCode) {
                    var filter = {
                        logic: 'and',
                        filters: [
                            {
                                logic: 'or',
                                filters: [
                                    {
                                        logic: 'and',
                                        filters: [
                                            {
                                                field: 'alertedEntityLevelCode',
                                                operator: 'eq',
                                                value: vm.entityId.entityLevelCode
                                            },
                                            {
                                                field: 'alertedEntityNumber',
                                                operator: 'eq',
                                                value: vm.entityId.entityNumber
                                            }
                                        ]
                                    },
                                    {
                                        logic: 'and',
                                        filters: [
                                            {
                                                field: 'alertLevel',
                                                operator: 'eq',
                                                value: vm.entityId.entityLevelCode
                                            },
                                            {
                                                field: 'primaryEntityNumber',
                                                operator: 'eq',
                                                value: vm.entityId.entityNumber
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    };
                    filterStr = kendoGridRendererService.getCustomFilterString(filter, vm.gridOptions);
                }
                casesService.getCaseAlerts(vm.caseId, filterStr).then(function (data) {
                    alerts = data.alerts;
                    vm.alertCount = data.alerts.length;
                    allAlerts = alerts;
                    clearAllSelections();
                    gridCallback.success(alerts);
                }, function (data, status) {
                    logger.error(resources.aml.alerts.couldNotLoadAlertsErrorText);
                });
            }
            else {
                // Old behavior from use on the Alerts List
                // Get all alerts for a given customer when not used in Case Details
                // do not get alerts until entityNumber is known - for CDD Review it is know only after review is loaded,
                // but not when the page loads
                if (vm.entityId && vm.entityId.entityNumber) {
                    entityService.getEntityAlerts(vm.entityId, vm.caseId, vm.gridOptions).then(function (data) {
                        // fieldName is set by entityService result; should just use resourceCollection.name
                        var alertsFieldName = data.alertsField;
                        if (alertsFieldName) {
                            alerts = data[alertsFieldName];
                        }
                        else {
                            alerts = data.items;
                        }
                        vm.alertCount = data.alertCount;
                        if (!vm.alertCount && alerts) {
                            vm.alertCount = alerts.length;
                        }
                        allAlerts = getAlertsWithAccess(alerts);
                        clearAllSelections();
                        gridCallback.success(alerts);
                    }, function error(data, status) {
                        logger.error(resources.aml.alerts.couldNotLoadAlertsErrorText);
                    });
                }
                else {
                    allAlerts = [];
                    clearAllSelections();
                    gridCallback.success(allAlerts);
                }
            }
        }
        // on double-click, go to alert detail page
        function handleDoubleClick(selectedEntity) {
            if (selectedEntity && selectedEntity.alertId) {
                var userHasAccess = hasAccess(selectedEntity.queueCode);
                if (!userHasAccess) {
                    messageService.warning(resources.aml.getResource('alerts.triage.alertNoAccessErrorMessage', { alertId: selectedEntity.alertId }), null, 5000);
                }
                else {
//console.log("&&&&&&&&&&&&&& DB click");
//console.log(selectedEntity);
                    alertsService.navigateToAlert(selectedEntity.alertId, selectedEntity.alertLevel);
                }
            }
        }
        function activate() {
            if (amlConstants.config.aml && amlConstants.config.aml.MLS && angular.isDefined(amlConstants.config.aml.MLS.display)) {
                vm.displayMLS = amlConstants.config.aml.MLS.display;
            }
            // when local datagrid is filtered, we want to update the count displayed in the title label similar to
            // how naturally occurs on remote grids
            vm.onDataChange = function alertListFilter(result, e) {
                if (vm.grid && vm.grid.dataSource) {
                    vm.alertCount = vm.grid.dataSource.total();
                }
            };
            setupWatches();
        }
        function updateTotalAmount(newVal) {
            var alertIds = dataMessagingService.getAlertIds('alertids');
            if (alertIds && alertIds === 'all' || alertIds === null) {
                vm.totalAmount = newVal;
            }
        }
        function setupWatches() {
            dataMessagingService.onAlertsChange(function () {
                kendoGridRendererService.refreshGrid(vm.grid);
            });
            // If the customer number value changes (from customer list page)
            // we want to refresh the alerts; so we add a watch on the customerNumber
            if (vm.updateOnEntityChanges) {
                // If the entity changes, (from case details page) refresh the alerts.
                $scope.$watch(function () {
                    return vm.entityId;
                }, function (newEntity, oldEntity) {
                    if (newEntity && newEntity !== oldEntity) {
                        // refresh grid
                        kendoGridRendererService.refreshGrid(vm.grid);
                        // Reset selected alerts to none; transactions controller watches on
                        // alerts and none should be selected initially when a new entity is selected
                        dataMessagingService.setAlertIds('alertids', 'all');
                    }
                }, true);
            }
            // If customer or alert select/deselect changes, update the total amount label to reflect new total
            // total also may be updated by transaction controller for HHD and ACC
            dataMessagingService.onTotalAmountChange(updateTotalAmount);
        }
    }
})();


/**
 * Factory to retrieve a Service for sharing data between separate directive components.
 * This is a factory that returns separate DataMessagingService instances per ui-router state,
 * as each state (from individual object tabs) needs to share their own isolated data between
 * components just on that state.
 */
var aml;
(function (aml) {
    'use strict';
    var DataMessagingService = (function () {
        function DataMessagingService(state, $state, titleCaseFilter, entityService, $stateParams) {
            this.state = state;
            this.$state = $state;
            this.titleCaseFilter = titleCaseFilter;
            this.entityService = entityService;
            this.$stateParams = $stateParams;
            this.CHANGE_HANDLERS_PREFIX = 'changeHandlers_';
        }
        DataMessagingService.prototype.getState = function () {
            if (!this.state) {
                return this.$state.current;
            }
            return this.state;
        };
        DataMessagingService.prototype.initialize = function () {
            if (!this.getState().data) {
                this.getState().data = {};
            }
            if (!this.getState().data.messaging) {
                this.getState().data.messaging = {};
            }
            var entityDetails = this.getState().data.messaging.entityDetails = {};
            entityDetails.selectedIds = { 'alertids': 'all' };
            entityDetails.allAlerts = []; //all alerts that user has access to
            entityDetails.selectedAlerts = []; //either selected alerts or alerts with queues access validated when nothing is selected
            entityDetails.filterStr = { 'filterStr': 'all' };
            entityDetails.entityId = {};
            entityDetails.transactionsOrderBy = null;
            entityDetails.customerName = null;
            entityDetails.notifyAlertsChanged = null; // function set by the alert controller
            entityDetails.totalAmount = 0;
            entityDetails.selectedAlertCount = 0; //count of really selected alerts
            entityDetails.employeeIndicator = null;
        };
        DataMessagingService.prototype.addChangeHandlerFor = function (eventName, eventHandlerFn) {
            var eventHandlerId = this.CHANGE_HANDLERS_PREFIX + eventName;
            if (!this.getData()[eventHandlerId]) {
                this.getData()[eventHandlerId] = [];
            }
            this.getData()[eventHandlerId].push(eventHandlerFn);
        };
        DataMessagingService.prototype.notifyChangeHandler = function (eventName, eventVal) {
            var eventHandlerId = this.CHANGE_HANDLERS_PREFIX + eventName;
            _.each(this.getData()[eventHandlerId], function (fn) {
                fn(eventVal);
            });
        };
        DataMessagingService.prototype.getData = function () {
            if (!this.getState().data || !this.getState().data.messaging || !this.getState().data.messaging.entityDetails) {
                this.initialize();
            }
            return this.getState().data.messaging.entityDetails;
        };
        DataMessagingService.prototype.getActiveAlerts = function () {
            if (this.getData().selectedAlerts) {
                return _.where(this.getData().selectedAlerts, { status: 'ACT' });
            }
            else {
                return [];
            }
        };
        DataMessagingService.prototype.setEntity = function (number, type, key, queue) {
            this.getData().entityId.entityNumber = number;
            this.getData().entityId.entityLevelCode = type;
            this.getData().entityId.entityKey = key;
            this.getData().entityId.queueCode = queue;
        };
        DataMessagingService.prototype.getSelectedAlertCount = function () {
            return this.getData().selectedAlertCount;
        };
        DataMessagingService.prototype.setSelectedAlertCount = function (count) {
            this.getData().selectedAlertCount = count;
        };
        DataMessagingService.prototype.getTotalAmount = function () {
            return this.getData().totalAmount;
        };
        DataMessagingService.prototype.setTotalAmount = function (amount) {
            this.getData().totalAmount = amount;
            this.notifyChangeHandler('totalAmount', amount);
        };
        DataMessagingService.prototype.setFilterStr = function (key, str) {
            this.getData().filterStr[key] = str;
        };
        DataMessagingService.prototype.getFilterStr = function (key) {
            return this.getData().filterStr[key];
        };
        //getEntityType(): string {
        //    return this.getData().entityId.entityType;
        //},
        DataMessagingService.prototype.getEntity = function () {
            return this.getData().entityId;
        };
        DataMessagingService.prototype.setSelectedAlerts = function (alerts) {
            this.getData().selectedAlerts = alerts;
        };
        DataMessagingService.prototype.getSelectedAlerts = function () {
            return this.getData().selectedAlerts;
        };
        DataMessagingService.prototype.getAlertIds = function (key) {
            return this.getData().selectedIds[key];
        };
        DataMessagingService.prototype.setAlertIds = function (key, alerts) {
            this.getData().selectedIds[key] = alerts;
        };
        DataMessagingService.prototype.setAllAlerts = function (alerts) {
            this.getData().allAlerts = alerts;
        };
        DataMessagingService.prototype.getAllAlerts = function () {
            return this.getData().allAlerts;
        };
        DataMessagingService.prototype.getAllAlertsCount = function () {
            if (this.getData().allAlerts) {
                return this.getData().allAlerts.length;
            }
            else {
                return 0;
            }
        };
        DataMessagingService.prototype.setCustomerName = function (custName) {
            this.getData().customerName = this.titleCaseFilter(custName);
        };
        DataMessagingService.prototype.getCustomerName = function () {
            return this.getData().customerName;
        };
        
        DataMessagingService.prototype.setScenarioName = function (scenarioName) {
            this.getData().scenarioName = scenarioName;
        };

        DataMessagingService.prototype.setAlertIdVal = function (alertId) {
            this.getData().alertIdVal = alertId;
        };
        DataMessagingService.prototype.getAlertIdVal = function () {
            return this.getData().alertIdVal;
        };

        DataMessagingService.prototype.setEmployeeIndicator = function (empInd) {
            this.getData().employeeIndicator = empInd;
        };
        DataMessagingService.prototype.getEmployeeIndicator = function () {
            return this.getData().employeeIndicator;
        };
        DataMessagingService.prototype.setEntityKey = function (key) {
            this.getData().entityId.entityKey = key;
        };
        DataMessagingService.prototype.getEntityKey = function () {
            return this.getData().entityId.entityKey;
        };
        DataMessagingService.prototype.setEntityId = function (entityId) {
            this.setEntity(entityId.entityNumber, entityId.entityLevelCode, entityId.entityKey, entityId.queueCode);
        };
        DataMessagingService.prototype.getEntityId = function () {
            var entityId = this.getData().entityId;
            // if entityId was not set by controller, then we'll try to get it from current state
            if (!entityId || !entityId.entityLevelCode) {
                entityId = this.entityService.getEntityIdForState(this.getState().name, this.$stateParams);
            }
            //using 'aml_no_queue' as workaround for ui-router issue will null values for a parameter
            if (entityId.queueCode && entityId.queueCode === 'aml_no_queue') {
                entityId.queueCode = '';
            }
            return entityId;
        };
        DataMessagingService.prototype.onAlertsChange = function (alertsChangeNotifierFn) {
            this.getData().notifyAlertsChanged = alertsChangeNotifierFn;
        };
        //this is invoked when alert count changes, i.e. when alerts are disposed and this updates the alerts grid
        DataMessagingService.prototype.alertsChanged = function () {
            if (this.getData().notifyAlertsChanged) {
                this.getData().notifyAlertsChanged();
            }
        };
        DataMessagingService.prototype.onTotalAmountChange = function (totalAmountChangeFn) {
            this.addChangeHandlerFor('totalAmount', totalAmountChangeFn);
        };
        /**
         * Return just the alerts that have an Active status ('ACT')
         * @returns {Array}
         */
        DataMessagingService.prototype.getActiveAlertsCount = function () {
            return this.getActiveAlerts().length;
        };
        DataMessagingService.prototype.getTransactionsOrderBy = function () {
            return this.getData().transactionsOrderBy;
        };
        DataMessagingService.prototype.setTransactionsOrderBy = function (sortBys) {
            var sortByList;
            if (sortBys && sortBys.length > 0) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            this.getData().transactionsOrderBy = sortByList;
        };
        return DataMessagingService;
    }());
    aml.DataMessagingService = DataMessagingService;
})(aml || (aml = {}));
(function () {
    'use strict';
    dataMessagingServiceFactory.$inject = ["titleCaseFilter", "$state", "entityService", "$stateParams"];
    angular.module('aml.customer.details').factory('dataMessagingServiceFactory', dataMessagingServiceFactory);
    function dataMessagingServiceFactory(titleCaseFilter, $state, entityService, $stateParams) {
        function createNewDataMessagingService(state) {
            if (!state.data) {
                state.data = {};
            }
            if (!state.data.messaging) {
                state.data.messaging = {};
            }
            var dataMessagingService = new aml.DataMessagingService(state, $state, titleCaseFilter, entityService, $stateParams);
            state.data.messaging.entityDetailsDataMessagingService = dataMessagingService;
            return dataMessagingService;
        }
        var serviceInstanceFactory = {
            /**
             * get instance for a specific state
             *
             * @param state
             * @returns {aml.DataMessagingService}
             */
            getInstance: function (state) {
                var dataMessagingService = null;
                // if we already have an instance for this state, return it
                if (state.data && state.data.messaging && state.data.messaging.entityDetailsDataMessagingService) {
                    dataMessagingService = state.data.messaging.entityDetailsDataMessagingService;
                }
                else {
                    // otherwise create (and store) a new instance for this state
                    dataMessagingService = createNewDataMessagingService(state);
                }
                return dataMessagingService;
            },
            /**
             * Get instance for the current state
             *
             * @param state
             * @returns {any}
             */
            getCurrentInstance: function () {
                return this.getInstance($state.$current);
            }
        };
        return serviceInstanceFactory;
    }
})();


/**
 * @ngdoc service
 * @name     aml.cases:casesService
 *
 * @restrict E
 *
 * @description
 * The cases service is used to retrieve cases from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    casesService.$inject = ["$resource", "$q", "amlConfig", "amlConstants", "_", "exceptionResourceHandler", "usersService", "amlCoreUtils", "commentService", "messageService", "resources", "titleCaseFilter", "dateFilter"];
    angular
        .module('aml.cases')
        .factory('casesService', casesService);
    /* @ngInject */
    /* jshint maxparams: 15*/
    function casesService($resource, $q, amlConfig, amlConstants, _, exceptionResourceHandler, usersService, amlCoreUtils, commentService, messageService, resources, titleCaseFilter, dateFilter) {
        /**
         * Resources
         */
        var casesResource = $resource(amlConfig.baseUrl + '/cases', {
            id: '@id',
            // list parameters
            start: '@start',
            limit: '@limit',
            relationships: '@relationships',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter',
            ownerUserLongId: '@ownerUserLongId',
            entityLevelCode: '@entityLevelCode',
            entityNumber: '@entityNumber',
            entityKey: '@entityKey',
            caseId: '@caseId',
            queueCode: '@queueCode'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            create: {
                method: 'POST',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var caseEntitiesResource = $resource(amlConfig.baseUrl + '/cases/:id/entities', {
            id: '@id',
            number: '@number',
            type: '@type'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            update: {
                method: 'PUT',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var caseAlertsResource = $resource(amlConfig.baseUrl + '/cases/:id/alerts', {
            id: '@id',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var caseResource = $resource(amlConfig.baseUrl + '/cases/:id', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound }
            },
            save: {
                method: 'PUT',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var triageCreateECMInvestigationResource = $resource(amlConfig.baseUrl + '/cases/ecm', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var caseRouteResource = $resource(amlConfig.baseUrl + '/cases/triageRequests/route', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var caseCheckInResource = $resource(amlConfig.baseUrl + '/cases/triageRequests/checkin', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var caseCheckOutResource = $resource(amlConfig.baseUrl + '/cases/triageRequests/checkout', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        //TODO: Should this be in a separate Reports Service?
        var triageCreateReportResource = $resource(amlConfig.baseUrl + '/regulatoryReports', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            createCase: createCase,
            saveCase: saveCase,
            getCase: getCase,
            getCases: getCases,
            addCaseEntity: addCaseEntity,
            getCaseEntities: getCaseEntities,
            getCaseAlerts: getCaseAlerts,
            updateCaseEntity: updateCaseEntity,
            getCasesInArrayByNumber: getCasesInArrayByNumber,
            routeCases: routeCases,
            checkinCases: checkinCases,
            checkoutCases: checkoutCases,
            createReport: createReport,
            isCaseReadonly: isCaseReadonly,
            getCasesForEntity: getCasesForEntity,
            getCaseRelatedCases: getCaseRelatedCases,
            getCasesForEntityLookbackFilter: getCasesForEntityLookbackFilter
        };
        return service;
        /**
         *  create AML investigation from an array of alerts
         *
         * @param alerts
         * @param entities
         * @param priorityCode
         * @param caseDescription
         * @param investigator
         * @param category
         * @param subcategory
         * @param queueCode
         * @returns {$promise|*|S.$promise}
         */
        function createAMLCase(alerts, entities, priorityCode, caseDescription, investigator, category, subcategory, queueCode, employeeIndicator) {
            var alertIds = getAlertIds(alerts);
            var alertCategories = _.pluck(alerts, 'alertCategory');
            var caseCreateParameters = {
                alertIds: alertIds,
                alertCategories: alertCategories,
                entities: entities,
                priorityCode: priorityCode,
                description: caseDescription,
                investigator: investigator,
                category: category,
                subcategory: subcategory,
                queueCode: queueCode,
                employeeIndicator: employeeIndicator
            };
            return casesResource.create({}, caseCreateParameters).$promise;
        }
        /**
         *  create AML investigation from an array of alerts
         *
         * @param alerts
         * @param entities
         * @param priorityCode
         * @param caseDescription
         * @param investigator
         * @param category
         * @param subcategory
         * @returns {$promise|*|S.$promise}
         */
        function createCase(alerts, entities, priorityCode, caseDescription, investigator, category, subcategory, queueCode, employeeIndicator) {
            if (amlConstants.config.defaultCaseDestination &&
                amlConstants.config.defaultCaseDestination.toLowerCase() === 'ecm') {
                return createECMCase(alerts, entities, priorityCode, caseDescription, investigator, category, subcategory);
            }
            else {
                return createAMLCase(alerts, entities, priorityCode, caseDescription, investigator, category, subcategory, queueCode, employeeIndicator);
            }
        }
        /**
         * As ECM integration is very loose, we can't assume that ECM has run IEM (as was available in AML 6.3m1 and
         * earlier) and have corresponding entities and alerts. As such, we just put as much information on the AML
         * entities and alerts that were added, and it is up to the ECM user or PSD to view and/or parse out the
         * relevant information as pertains to the ECM ecosystem.
         * @param entities
         * @param alerts
         * @returns {string}
         */
        function getCaseDetailsForDescription(entities, alerts) {
            var info = '';
            if (amlCoreUtils.isArrayNotEmpty(entities)) {
                info += resources.aml.getResource('alerts.triage.createInvestigationEntitiesToIncludeSectionTitle', { count: entities.length }) + '\n';
                info += _.reduce(entities, function (str, entity) {
                    return str +
                        (entity.entityLevelCode + " " + entity.entityNumber + " " + titleCaseFilter(entity.entityName) + "\n");
                }, '');
            }
            if (amlCoreUtils.isArrayNotEmpty(alerts)) {
                if (info.length > 0) {
                    info += '\n';
                }
                info += resources.aml.getResource('alerts.triage.createInvestigationAlertsToPromoteSectionTitle', { count: alerts.length }) + '\n';
                info += _.reduce(alerts, function (str, alert) {
                    return str + (alert.alertId + " " + alert.description + " " + dateFilter(alert.runDate, 'mediumDate') + "\n");
                }, '');
            }
            // add business unit, as that is needed information to determine the alert/parties on ECM side
            if (info.length > 0) {
                info += '\n';
            }
            info += resources.aml.navbar.businessUnitLabelText + '\n' + usersService.getCurrentUserBusinessUnit();
            return info;
        }
        /**
         *  create ECM investigation from an array of alerts
         *
         * @param alerts
         * @param entities
         * @param priorityCode
         * @param caseDescription
         * @param investigator
         * @param category
         * @param subcategory
         * @returns {$promise|*|S.$promise}
         */
        function createECMCase(alerts, entities, priorityCode, caseDescription, investigator, category, subcategory) {
            var alertIds = getAlertIds(alerts);
            // As we don't support deep ECM integration and can't be sure that IEM is running on the external ECM
            // system, instead of adding parties/alerts using expected Party/Incident IDs, we will just add the
            // list of them to an extra UDF field (CASE_DETAILS). It would be up to the ECM Case investigator to manually
            // process that information.
            var caseDetails = getCaseDetailsForDescription(entities, alerts);
            var caseCreateParameters = {
                alertIds: alertIds,
                alertCategories: null,
                //customerNumber: customerNumber, // we don't pass in customer, as we don't create ECM party
                priorityCode: priorityCode,
                description: caseDescription,
                investigator: investigator,
                category: category,
                subcategory: subcategory,
                caseDetails: caseDetails,
                includePartyOnCase: false,
                includeAlertsOnCase: false
            };
            return triageCreateECMInvestigationResource.create({}, caseCreateParameters).$promise;
        }
        function getCasesForEntityLookbackFilter() {
            // we look for cases with activity a period of time,
            // starting with the specified number of days
            var numOfDaysToLookBack = amlConstants.config.customers.caseActivityLookBackNumOfDays;
            var today = moment().startOf('day');
            var activityStartDate = today.subtract(numOfDaysToLookBack, 'days');
            var activityStartDateStr = activityStartDate.format();
            var filter = {
                logic: 'and',
                filters: [{
                        logic: 'or',
                        filters: [
                            {
                                logic: 'and',
                                filters: [
                                    {
                                        field: 'createDate',
                                        operator: 'gte',
                                        value: activityStartDateStr
                                    }
                                ]
                            },
                            {
                                logic: 'and',
                                filters: [
                                    {
                                        field: 'lastUpdateDate',
                                        operator: 'gte',
                                        value: activityStartDateStr
                                    },
                                    {
                                        field: 'statusCode',
                                        operator: 'in',
                                        value: 'T,C'
                                    }
                                ]
                            }
                        ]
                    }]
            };
            return filter;
        }
        /**
         * Get list of cases
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all cases matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getCases(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = amlCoreUtils.getSortByString(sortBys);
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return casesResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }
        /**
         * Get list of cases for a given entity
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all cases matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getCasesForEntity(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount, entityId) {
            var sortByList = amlCoreUtils.getSortByString(sortBys);
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            var key = entityId ? entityId.entityKey : null;
            var number = entityId ? entityId.entityNumber : null;
            return casesResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner,
                entityLevelCode: entityId ? entityId.entityLevelCode : null,
                entityNumber: number,
                entityKey: key
            }).$promise;
        }
        /**
         * Get list of cases related to another case
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param caseId - original case
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getCaseRelatedCases(start, pageSize, sortBys, filterStr, previousCount, currentUserIdOwner, caseId) {
            var sortByList = amlCoreUtils.getSortByString(sortBys);
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return casesResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner,
                caseId: caseId ? caseId : null
            }).$promise;
        }
        /**
         * Get list of case alerts
         * @returns {$promise|*}
         */
        function getCaseAlerts(caseid, filterStr) {
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return caseAlertsResource.get({
                id: caseid,
                filter: filter
            }).$promise;
        }
        /**
         *  create AML investigation from an array of alerts
         *
         * @param alerts
         * @param entities
         * @param investigator
         * @param selectedCaseId
         * @returns {$promise|*|S.$promise}
         */
        function addCaseEntity(alerts, entities, investigator, selectedCaseId) {
            var alertIds = getAlertIds(alerts);
            var caseCreateParameters = {
                alertIds: alertIds,
                entities: entities,
                investigator: investigator
            };
            return caseEntitiesResource.create({
                id: selectedCaseId
            }, caseCreateParameters).$promise;
        }
        /**
         * Get list of case entities
         * @returns {$promise|*}
         */
        function getCaseEntities(caseid, filterStr) {
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return caseEntitiesResource.get({
                id: caseid,
                filter: filter
            }).$promise;
        }
        /**
         * Update a case entities
         * @returns {$promise|*}
         */
        function updateCaseEntity(entity) {
            return caseEntitiesResource.update({
                id: entity.caseId,
                number: entity.entityNumber,
                type: entity.entityLevelCode
            }, entity).$promise;
        }
        /**
         * Get a case by case ID
         * @param caseid
         * @returns {$promise|*}
         */
        function getCase(caseid) {
            return caseResource.get({ id: caseid }).$promise;
        }
        /**
         * Save a case by case ID
         * @param aCase
         * @returns {$promise|*}
         */
        function saveCase(aCase) {
            if (aCase.statusCode !== 'O') {
                return commentService.getCommentsCount(amlConstants.entityType.case, aCase.caseId).then(function (data) {
                    if (data.count > 0) {
                        return caseResource.save({ id: aCase.caseId }, aCase).$promise;
                    }
                    else {
                        var deferred = $q.defer();
                        //Set case status to Open because it shouldn't be anything else until this check passes.
                        aCase.statusCode = 'O';
                        //Display a message
                        messageService.warning(resources.aml.getResource('casedetails.triage.saveCaseActionMissingNoteMessage', { caseId: aCase.caseId }), null, 5000);
                        deferred.reject();
                        return deferred.promise;
                    }
                });
            }
            else {
                return caseResource.save({ id: aCase.caseId }, aCase).$promise;
            }
        }
        function getCasesInArrayByNumber(casesNumber, array) {
            var cases = _.find(array, function (item) {
                return item && item.caseId && item.caseId === casesNumber;
            });
            return cases;
        }
        /**
         * route an array of cases
         * @param caseNumbers
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeCases(caseNumbers, routeToUser, routeToQueue) {
            var casesTriageParams = {
                caseNumbers: caseNumbers,
                ownerUserLongId: routeToUser,
                queueCode: routeToQueue
            };
            return caseRouteResource.create({}, casesTriageParams).$promise;
        }
        /**
         * checkin an array of cases
         * @param caseNumbers
         * @returns {$promise|*}
         */
        function checkinCases(caseNumbers) {
            var casesTriageParams = {
                caseNumbers: caseNumbers
            };
            return caseCheckInResource.create({}, casesTriageParams).$promise;
        }
        /**
         * checkout an array of cases
         * @param caseNumbers
         * @returns {$promise|*}
         */
        function checkoutCases(caseNumbers) {
            var casesTriageParams = {
                caseNumbers: caseNumbers
            };
            return caseCheckOutResource.create({}, casesTriageParams).$promise;
        }
        /**
         * Checks user permissions and case status to see if the case should be editable or just view mode
         * @returns {boolean}
         */
        function isCaseReadonly(aCase) {
            //Default is that case is editable
            var readOnly = false;
            //Check user permission
            if (!usersService.currentUserHasCapability(amlConstants.capabilities.editCase) &&
                !usersService.currentUserHasCapability(amlConstants.capabilities.editAllCases)) {
                readOnly = true;
            }
            //Does the user own the case (i.e. in their work queue)?
            if (aCase.ownerUserLongId !== usersService.getCurrentUserId() &&
                !usersService.currentUserHasCapability(amlConstants.capabilities.editAllCases)) {
                readOnly = true;
            }
            //Case is closed (C or R) then not editable
            if (aCase.statusCode === 'C' || aCase.statusCode === 'R') {
                readOnly = true;
            }
            return readOnly;
        }
        /**
         * create AML investigation from an array of alerts
         * @param parentCaseNumber
         * @param reportDescription
         * @param reportTypeKey
         * @returns {angular.IPromise<T>|angular.IPromise<IResourceArray<T>>|angular.IPromise<Array<T>>|*|Function|promise}
         */
        function createReport(parentCaseNumber, reportDescription, reportTypeKey) {
            var reportCreateParameters = {
                reportParentObjectKey: parentCaseNumber,
                reportParentObjectName: 'CASE',
                description: reportDescription,
                ownerUserLongId: usersService.getCurrentUserId(),
                reportFormTypeKey: reportTypeKey
            };
            return triageCreateReportResource.create({}, reportCreateParameters).$promise;
        }
        /**
         * Get array of alertIds from an array of alerts
         * @param alerts
         * @returns {Array}
         */
        function getAlertIds(alerts) {
            var alertIds = _.pluck(alerts, 'alertId');
            return alertIds;
        }
    }
})();


/**
 * Include some core cross-cutting utility functions used throughout the application
 */
(function () {
    'use strict';
    /* jshint maxparams: 16*/
    angular.module('aml.core').factory('amlCoreUtils', ["amlConstants", "titleCaseFilter", "$interpolate", "kendo", function (amlConstants, titleCaseFilter, $interpolate, kendo) {
        /* jshint maxstatements: 50 */
        var currencySymbol = null;
        function removeFromArray(arrayOfObjects, objectToRemove) {
            if (arrayOfObjects && arrayOfObjects.length > 0) {
                var index = _.indexOf(arrayOfObjects, objectToRemove);
                arrayOfObjects.splice(index, 1);
            }
        }
        function removeListener(listnerFns, newListenerFn) {
            removeFromArray(listnerFns, newListenerFn);
        }
        /**
         * Interpolate the values as a complex expression, retrieved from the params model, like
         *   'accountsList[0].accountName";
         *   The result of interpolation is always a String.
         * @param value
         * @param model
         * @returns {string}
         */
        function interpolateValue(value, model) {
            return $interpolate(value)(model);
        }
        return {
            /**
             * get a nested property; returning null if any property in the chain does not exist.
             * Example: object, 'foo.bar.prop'  -> object['foo']['bar']['prop']
             * @param objectModel
             * @param nestedPropertyName
             * @param shouldInterpolate if set to true, will attempt to interpolate as a complex expression, like
             *   'accountsList[0].accountName", however the result of interpolation is always a String.
             * @returns {any}
             */
            getNestedObjectProperty: function (objectModel, nestedPropertyName, shouldInterpolate) {
                if (shouldInterpolate === void 0) { shouldInterpolate = false; }
                if (shouldInterpolate) {
                    var val = interpolateValue('{{' + nestedPropertyName + '}}', objectModel);
                    return val;
                }
                else {
                    var keys = nestedPropertyName.split('.');
                    for (var i = 0; i < keys.length && objectModel !== null; i++) {
                        objectModel = objectModel[keys[i]];
                    }
                    return objectModel;
                }
            },
            /**
             * get a nested json property object; returning {} if any property in the chain does not exist.
             * Example: object, 'foo.bar.prop'  -> object['foo']['bar']['prop']
             * @param objectModel
             * @param nestedPropertyName
             * @param shouldInterpolate if set to true, will attempt to interpolate as a complex expression, like
             *   'accountsList[0].accountName", however the result of interpolation is always a String.
             * @returns {any}
             */
            getNestedObjectAsJson: function (objectModel, nestedPropertyName, shouldInterpolate) {
                if (shouldInterpolate === void 0) { shouldInterpolate = false; }
                if (shouldInterpolate) {
                    var val = interpolateValue('{{' + nestedPropertyName + '}}', objectModel);
                    if (val) {
                        // if the val appears to be a JSON object or JSON array, parse it
                        if ((val.startsWith('{') && val.endsWith('}')) ||
                            (val.startsWith('[') && val.endsWith(']'))) {
                            val = JSON.parse(val);
                        }
                        else {
                            val = {};
                        }
                    }
                    return val;
                }
                else {
                    var keys = nestedPropertyName.split('.');
                    for (var i = 0; i < keys.length && objectModel !== null; i++) {
                        objectModel = objectModel[keys[i]];
                    }
                    return objectModel;
                }
            },
            getLocaleStartingDayOfWeek: function () {
                var startingDay = 0;
                if (kendo && kendo.culture()) {
                    startingDay = kendo.culture().calendar.firstDay;
                }
                return startingDay;
            },
            /**
             * Format a string containing a list of variable placeholders by replacing with the supplied
             * variable values
             *
             * ex: amlCoreUtils.formatStr( 'Customer {0}, status: {1}', 'Joe Smith', 'active' ); -->
             *      'Customer Joe Smith, status: active'
             */
            formatStr: function (str) {
                var variableValues = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    variableValues[_i - 1] = arguments[_i];
                }
                for (var i = 0; i < variableValues.length; i++) {
                    var regexp = new RegExp('\\{' + i + '\\}', 'gi');
                    str = str.replace(regexp, variableValues[i]);
                }
                return str;
            },
            getSortByString: function (sortBys, separator) {
                // Database sort syntax uses ':', which is set as default here.
                // Solr sort syntax uses ' ', which must be passed in.
                if (separator === void 0) { separator = ':'; }
                var sortByList = null;
                if (sortBys) {
                    sortByList = '';
                    for (var i = 0; i < sortBys.length; i++) {
                        if (i > 0) {
                            sortByList = sortByList + ',';
                        }
                        sortByList = sortByList + sortBys[i].name + separator + sortBys[i].direction;
                    }
                }
                return sortByList;
            },
            titleCase: function (inputStr) {
                return titleCaseFilter(inputStr);
            },
            getBaseCurrency: function () {
                return amlConstants.config.baseCurrency;
            },
            notifyChangeHandler: function (listnerFns, ob) {
                _.each(listnerFns, function (fn) {
                    fn(ob);
                });
            },
            /**
             * Utility function to remove a given object from an array
             *
             * @param arrayOfObjects
             * @param objectToRemove
             */
            removeFromArray: removeFromArray,
            removeListener: removeListener,
            /**
             * Add a listener function to an array; this handles the logic of adding a listener and removing the
             * listener when specified scope is destroyed.
             * The caller of this function is responsible for storing the array of listeners.
             *
             * @param listnerFns
             * @param newListenerFn
             * @param scope
             */
            registerListener: function (listnerFns, newListenerFn, scope) {
                listnerFns.push(newListenerFn);
                if (scope) {
                    scope.$on('$destroy', function () {
                        removeListener(listnerFns, newListenerFn);
                    });
                }
            },
            formatCityStateZip: function (city, state, zip) {
                var addressStr = '';
                if (city && city.length > 0) {
                    addressStr += titleCaseFilter(city);
                }
                if (state && state.length > 0) {
                    // if it's a state code, keep it uppercase
                    if (state.length === 2) {
                        state = state.toUpperCase();
                    }
                    else {
                        state = titleCaseFilter(state);
                    }
                    if (addressStr.length > 0) {
                        addressStr += ', ';
                    }
                    addressStr += state;
                }
                if (zip && zip.length > 0) {
                    if (addressStr.length > 0) {
                        addressStr += ' '; // no comma between state and zipcode
                    }
                    addressStr += zip;
                }
                return addressStr;
            },
            /**
             * takes a string value containing angular expression(s) and interpolates it
             * @param value
             * @param params
             * @returns {any}
             */
            interpolateValue: interpolateValue,
            isNullOrUndefined: function (val) {
                return _.isNull(val) || _.isUndefined(val);
            },
            isNotNullOrUndefined: function (val) {
                return !this.isNullOrUndefined(val);
            },
            isArrayNotEmpty: function (arr) {
                return this.isNotNullOrUndefined(arr) && arr.length > 0;
            },
            getBaseCurrencySymbol: function () {
                if (currencySymbol) {
                    return currencySymbol;
                }
                currencySymbol = amlConstants.config.baseCurrencySymbol;
                // if no symbol is defined in the ref table, then just use the currency code in place of the
                // symbol (example USD12,000 rather than $12,000).
                if (!currencySymbol) {
                    var currencyCode = amlConstants.config.baseCurrency;
                    currencySymbol = currencyCode;
                }
                if (!currencySymbol) {
                    currencySymbol = '';
                }
                return currencySymbol;
            },
            /**
             * strips all characters from the input string that are not valid for HTML element id
             * and for jQuerywe also exclude . and :
             * Valid characters are: a-Z, 0-9, - , _
             * @param val -
             */
            stripInvalidIdCharacters: function (val) {
                return val.replace(/[^\w-]+/gi, '');
            },
            /**
             * wrap a function with before/after functionality
             * @param functionToWrap
             * @param before
             * @param after
             * @param thisObject
             * @returns {function(): *}
             */
            wrap: function (functionToWrap, before, after, thisObject) {
                // if the function to wrap is null, just set to the wrapper function directly
                if (!functionToWrap && before && !after) {
                    return before;
                }
                else {
                    return function () {
                        var result;
                        var args = Array.prototype.slice.call(arguments);
                        if (before) {
                            before.apply(thisObject || this, args);
                        }
                        if (functionToWrap) {
                            result = functionToWrap.apply(thisObject || this, args);
                        }
                        if (after) {
                            // add result as first argument to the after function; the wrapping 'after' function
                            // will get that as the first arg, and can get all function args via 'arguments'
                            if (args) {
                                args.unshift(result);
                            }
                            else {
                                args = [result];
                            }
                            result = after.apply(thisObject || this, args);
                        }
                        return result;
                    };
                }
            }
        };
    }]);
})();


/**
 * @ngdoc service
 * @name     aml.core:recursiveDirectiveService
 *
 * @description
 * When you use recursive directives, AngularJS gets into an endless loop. This service breaks this loop by removing
 * the contents during the compile stage of the directive, and compiling and re-adding the contents in the link stage
 * of the directive
 */
(function () {
    'use strict';
    recursiveDirectiveService.$inject = ["$compile"];
    angular.module('aml.core')
        .factory('recursiveDirectiveService', recursiveDirectiveService);
    /* @ngInject */
    function recursiveDirectiveService($compile) {
        return {
            /**
             * Manually compiles the element, fixing the recursion loop.
             * @param element
             * @param [link] A post-link function, or an object with function(s) registered via pre and post properties.
             * @returns An object containing the linking functions.
             */
            compile: function (element, link) {
                // Break the recursion loop by removing the contents
                var contents = element.contents().remove();
                var compiledContents;
                return {
                    pre: (link && link.pre) ? link.pre : null,
                    /**
                     * Compiles and re-adds the contents
                     */
                    post: function (scope, element) {
                        // Compile the contents
                        if (!compiledContents) {
                            compiledContents = $compile(contents);
                        }
                        // Re-add the compiled contents to the element
                        compiledContents(scope, function (clone) {
                            element.append(clone);
                        });
                        // As this overrides the post link function, we save and call the original directive's post-linking
                        // function afterwards, if any was specified
                        if (link && link.post) {
                            link.post.apply(null, arguments);
                        }
                    }
                };
            }
        };
    }
})();


/**
 * @ngdoc service
 * @name     aml.reviews:reviewsService
 *
 * @restrict E
 *
 * @description
 * The reviews service is used to retrieve reviews from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    reviewsService.$inject = ["$resource", "$q", "amlConfig", "amlConstants", "_", "exceptionResourceHandler", "usersService", "amlCoreUtils", "commentService", "messageService", "resources", "titleCaseFilter", "dateFilter"];
    angular
        .module('cdd.reviews')
        .factory('reviewsService', reviewsService);
    /* @ngInject */
    /* jshint maxparams: 15*/
    function reviewsService($resource, $q, amlConfig, amlConstants, _, exceptionResourceHandler, usersService, amlCoreUtils, commentService, messageService, resources, titleCaseFilter, dateFilter) {
        /**
         * Resources
         */
        var reviewsResource = $resource(amlConfig.baseUrl + '/cddReviews', {
            // list parameters
            start: '@start',
            limit: '@limit',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter',
            ownerUserLongId: '@ownerUserLongId'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            create: {
                method: 'POST',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var reviewResource = $resource(amlConfig.baseUrl + '/cddReviews/:reviewKey', {
            id: '@reviewKey'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound }
            },
            getOverallScores: {
                url: amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/overall',
                params: {},
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            getCategoryScores: {
                url: amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/category',
                params: { 'eventDate': null,
                    'primaryEntityLevelCode': 'PTY',
                    'primaryEntityNumber': null
                },
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            getAttributeScore: {
                url: amlConfig.baseUrl + '/cddReviews/:reviewKey/customerRiskRating/scores/attribute',
                params: { 'eventDate': null,
                    'primaryEntityLevelCode': 'PTY',
                    'primaryEntityNumber': null,
                    'categoryCode': null
                },
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            save: {
                method: 'PUT',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var reviewRouteResource = $resource(amlConfig.baseUrl + '/cddReviews/triageRequests/route', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var reviewCheckInResource = $resource(amlConfig.baseUrl + '/cddReviews/triageRequests/checkin', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var reviewCheckOutResource = $resource(amlConfig.baseUrl + '/cddReviews/triageRequests/checkout', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var service = {
            createReview: createReview,
            createNewReview: createNewReview,
            saveReview: saveReview,
            getReview: getReview,
            getReviews: getReviews,
            getCategoryScores: getCategoryScores,
            getReviewsInArrayByNumber: getReviewsInArrayByNumber,
            routeReviews: routeReviews,
            checkinReviews: checkinReviews,
            checkoutReviews: checkoutReviews,
            isReviewReadonly: isReviewReadonly,
            hasOpenReview: hasOpenReview
        };
        return service;
        function createEDDSteps(eddStepsLov) {
            var eddSteps = [];
            for (var i = 0; i < eddStepsLov.length; i++) {
                eddSteps.push({ stepCode: eddStepsLov[i].key, stepSortPosition: eddStepsLov[i].order });
            }
            return eddSteps;
        }
        function createNewReview(partyNumber, partyLevel, riskClassification, employeeInd, investigator, eddSteps) {
            var reviewRep = {
                key: 0,
                versionNumber: 1,
                primaryEntityNumber: partyNumber,
                primaryEntityLevelCode: partyLevel,
                employeeIndicator: employeeInd,
                statusCode: 'O',
                ownerUserLongId: investigator,
                initialRiskRating: riskClassification,
                initialAutoHighIndicator: 'N',
                initialScoringEventKey: null,
                eddReviews: []
            };
            reviewRep.eddReviews = createEDDSteps(eddSteps);
            return reviewRep;
        }
        /**
         * For any edd steps that were changed to Not Required in the UI, we should ensure
         * eddStepCompleted/Notes are cleared out
         *
         * @param eddSteps
         */
        function clearNonRequiredEddSteps(eddSteps) {
            /*jshint camelcase:false */
            if (eddSteps) {
                for (var _i = 0, eddSteps_1 = eddSteps; _i < eddSteps_1.length; _i++) {
                    var edd = eddSteps_1[_i];
                    if (edd.stepRequired !== 'Y') {
                        edd.stepCompleted = null;
                        edd.notes = null;
                    }
                }
            }
        }
        /**
         *  create CDD review
         *
         * @param alerts
         * @param entities
         * @param priorityCode
         * @param reviewDescription
         * @param investigator
         * @param category
         * @param subcategory
         * @returns {$promise|*|S.$promise}
         */
        function createReview(reviewRep) {
            clearNonRequiredEddSteps(reviewRep.eddReviews);
            return reviewsResource.create({}, reviewRep).$promise;
        }
        /**
         * Get list of reviews
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all reviews matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getReviews(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = amlCoreUtils.getSortByString(sortBys);
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return reviewsResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }
        /**
         * Get a review by review key
         * @param reviewKey
         * @returns {$promise|*}
         */
        function getReview(reviewKey) {
            return reviewResource.get({ reviewKey: reviewKey }).$promise;
        }
        /**
         * Get a review by review key
         * @param reviewKey
         * @returns {$promise|*}
         */
        function getCategoryScores(reviewKey, entityNumber, entityLevelCode, eventDate) {
            return reviewResource.getCategoryScores({ reviewKey: reviewKey,
                eventDate: eventDate,
                primaryEntityNumber: entityNumber,
                primaryEntityLevelCode: entityLevelCode }).$promise;
        }
        /*function getAttributeScores(reviewKey, entityNumber, entityLevelCode, eventDate){
            return reviewResource.getAttributeScores({reviewKey: reviewKey,
                                                      eventDate: eventDate,
                                                      primaryEntityNumber: entityNumber,
                                                      primaryEntityLevelCode: entityLevelCode
            }).$promise;
        }*/
        /*function getOverallScores(reviewKey){
            return reviewResource.getOverallScores;
        }*/
        /**
         * Save a review by review ID
         * @param aReview
         * @returns {$promise|*}
         */
        function saveReview(aReview) {
            clearNonRequiredEddSteps(aReview.eddReviews);
            return reviewResource.save({ reviewKey: aReview.key }, aReview).$promise;
        }
        function getReviewsInArrayByNumber(reviewsNumber, array) {
            var reviews = _.find(array, function (item) {
                return item && item.key && item.key === reviewsNumber;
            });
            return reviews;
        }
        /**
         * route an array of reviews
         * @param reviewNumbers
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeReviews(reviewNumbers, routeToUser, routeToQueue) {
            var reviewsTriageParams = {
                reviewKeys: reviewNumbers,
                ownerUserLongId: routeToUser,
                queueCode: routeToQueue
            };
            return reviewRouteResource.create({}, reviewsTriageParams).$promise;
        }
        /**
         * checkin an array of reviews
         * @param reviewNumbers
         * @returns {$promise|*}
         */
        function checkinReviews(reviewNumbers) {
            var reviewsTriageParams = {
                reviewKeys: reviewNumbers
            };
            return reviewCheckInResource.create({}, reviewsTriageParams).$promise;
        }
        /**
         * checkout an array of reviews
         * @param reviewNumbers
         * @returns {$promise|*}
         */
        function checkoutReviews(reviewNumbers) {
            var reviewsTriageParams = {
                reviewKeys: reviewNumbers
            };
            return reviewCheckOutResource.create({}, reviewsTriageParams).$promise;
        }
        /**
         * Checks user permissions and review status to see if the review should be editable or just view mode
         * @returns {boolean}
         */
        function isReviewReadonly(aReview) {
            //Default is that review is editable
            var readOnly = false;
            //Check user permission
            if (!usersService.currentUserHasCapability(amlConstants.capabilities.editReview) &&
                !usersService.currentUserHasCapability(amlConstants.capabilities.editAllReviews)) {
                readOnly = true;
            }
            //Does the user own the review (i.e. in their work queue)?
            if (aReview.ownerUserLongId !== usersService.getCurrentUserId() &&
                !usersService.currentUserHasCapability(amlConstants.capabilities.editAllReviews)) {
                readOnly = true;
            }
            //Review is closed then not editable
            if (aReview.statusCode === 'C') {
                readOnly = true;
            }
            return readOnly;
        }
        // verify if customer has any open reviews
        function hasOpenReview(partyNumber) {
            var deferred = $q.defer();
            var openFilterStr = 'and(not(eqIgnoreCase(statusCode,"C")),eqIgnoreCase(primaryEntityNumber,"' + partyNumber + '"))';
            getReviews(0, 2, null, openFilterStr, null, 0).then(function (data) {
                var reviewsCount = data.items.length;
                deferred.resolve(reviewsCount > 0);
            }, function (data, status, headers, config) {
                deferred.reject();
            });
            return deferred.promise;
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.entity:entityService
 *
 * @restrict E
 *
 * @description
 * The entities service is used to retrieve entities from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    entityService.$inject = ["$resource", "$http", "amlConfig", "amlConstants", "exceptionResourceHandler", "amlCoreUtils", "accountService", "associateService", "bankService", "customerService", "externalPartyService", "householdService", "casesService", "resources"];
    angular
        .module('aml.entities')
        .factory('entityService', entityService);
    /* jshint maxparams: 14, maxcomplexity: 13, maxstatements: 45 */
    function entityService($resource, $http, amlConfig, amlConstants, exceptionResourceHandler, amlCoreUtils, accountService, associateService, bankService, customerService, externalPartyService, householdService, casesService, resources) {
        var CUSTOMER_DETAILS_STATENAME = 'customerDetails';
        var ACCOUNT_DETAILS_STATENAME = 'accountDetails';
        var HOUSEHOLD_DETAILS_STATENAME = 'householdDetails';
        var BANK_DETAILS_STATENAME = 'bankDetails';
        var ASSOCIATE_DETAILS_STATENAME = 'associateDetails';
        var EXTERNAL_PARTY_DETAILS_STATENAME = 'externalPartyDetails';
        var ALERT_DETAILS_STATENAME = 'alertDetails';
        var CASE_DETAILS_STATENAME = 'caseDetails';
        var BRANCH_DETAILS_STATENAME = 'branchDetails';
        var REPORT_DETAILS_STATENAME = 'reportDetails';
        var RISK_ASSESSMENT_DETAILS_STATENAME = 'riskAssessmentDetails';
        var CDD_REVIEW_DETAILS_STATENAME = 'cddReviewDetails';
        var TRANSACTION_DETAILS_STATENAME = 'transactionDetails';
        var WATCHLIST_DETAILS_STATENAME = 'watchListDetails';
        /**
         * Resources
         */
        var entitiesResource = $resource(amlConfig.baseUrl + '/entities', {
            id: '@id',
            type: '@type',
            // list parameters
            start: '@start',
            limit: '@limit',
            relationships: '@relationships',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter',
            ownerUserLongId: '@ownerUserLongId'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var impactedEntitiesResource = $resource(amlConfig.baseUrl + '/entities/impacted', {
            start: '@start',
            entityLevelCode: '@entityLevelCode',
            entityNumber: '@entityNumber',
            entityKey: '@entityKey'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var alertedEntitiesResource = $resource(amlConfig.baseUrl + '/entities', {
            entityLevelCode: '@entityLevelCode',
            entityNumber: '@entityNumber',
            entityKey: '@entityKey'
        }, {
            getAlertedEntity: {
                url: amlConfig.baseUrl + '/entities/first',
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler }
            }
        });
        var triageRouteEntitiesResource = $resource(amlConfig.baseUrl + '/entities/triageRequests/route', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var triageCheckinEntitiesResource = $resource(amlConfig.baseUrl + '/entities/triageRequests/checkin', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var triageCheckoutEntitiesResource = $resource(amlConfig.baseUrl + '/entities/triageRequests/checkout', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var entitiesAlertResource = $resource(amlConfig.baseUrl + '/alerts', {
            start: '@start',
            limit: '@limit',
            relationships: '@relationships',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter'
        }, { get: {
                method: 'GET', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            createEntityId: createEntityId,
            createGenericEntityFromEntityType: createGenericEntityFromEntityType,
            getEntities: getEntities,
            getImpactedEntities: getImpactedEntities,
            getAlertedEntity: getAlertedEntity,
            getEntityAlerts: getEntityAlerts,
            routeEntities: routeEntities,
            checkinEntities: checkinEntities,
            checkoutEntities: checkoutEntities,
            getStateForEntity: getStateForEntity,
            getEntityIdForState: getEntityIdForState,
            normalizeEntityId: normalizeEntityId,
            ensureAppropriateEntityIds: ensureAppropriateEntityIds,
            getReadableEntityIdentifier: getReadableEntityIdentifier,
            getEntityAlertCount: getEntityAlertCount,
            isEntityObject: isEntityObject,
            canRouteEntity: canRouteEntity
        };
        return service;
        /**
         * Get list of entities
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all entities matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getEntities(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = null;
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return entitiesResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }
        /**
         * Get list of impacted entities along with affected alert and case ids
         * @param entityLevelCode
         * * @param entityNumber
         * @returns {$promise|*}
         */
        function getImpactedEntities(entityLevelCode, entityNumber, entityKey) {
            return impactedEntitiesResource.get({
                entityLevelCode: entityLevelCode,
                entityNumber: entityNumber,
                entityKey: entityKey
            }).$promise;
        }
        /**
         * Get alerted entity
         * @param entityLevelCode
         * @param entityNumber
         * @returns {$promise|*}
         */
        function getAlertedEntity(entityLevelCode, entityNumber, entityKey) {
            return alertedEntitiesResource.getAlertedEntity({
                entityLevelCode: entityLevelCode,
                entityNumber: entityNumber,
                entityKey: entityKey
            }).$promise;
        }
        /**
         * Create an entity id object from a full entity
         * @param entity
         * @returns {{entityNumber: (any|{type}), entityLevelCode: (any|{type}), entityKey: (any|{type})}}
vi          */
        function createEntityId(entity) {
            return {
                entityNumber: entity.entityNumber,
                entityLevelCode: entity.entityLevelCode,
                entityKey: entity.entityKey,
                queueCode: entity.queueCode
            };
        }
        function getCaseAlerts(entityId, alertsPromise, caseId) {
            function success(alertsField) {
                // set the correct alerts field on result
                return function (data) {
                    // should just be able to use resourceCollection.name field, but not all alerts services return a
                    // resources collection
                    data.alertsField = alertsField;
                    return data;
                };
            }
            // do case stuff
            switch (entityId.entityLevelCode) {
                case amlConstants.entityType.customer:
                    alertsPromise = customerService.getAlerts(entityId.entityNumber).then(success('allAlerts'));
                    break;
                case 'ACC':
                    alertsPromise = accountService.getAccountAlerts(entityId.entityNumber).then(success('accountAlerts'));
                    break;
                case 'HHD':
                    alertsPromise = householdService.getHouseholdAlerts(entityId.entityNumber).then(success('householdAlerts'));
                    break;
                case 'BNK':
                    alertsPromise = bankService.getBankAlerts(entityId.entityNumber).then(success('alerts'));
                    break;
                case 'ASC':
                    alertsPromise = associateService.getAssociateAlerts(entityId.entityNumber).then(success('alerts'));
                    break;
                case 'EXT':
                    alertsPromise = externalPartyService.getExternalPartyAlerts(entityId.entityNumber).then(success('alerts'));
                    break;
                default:
                    // Entity object is defined, but has no content
                    // Get all alerts for all entities on the specific case
                    alertsPromise = casesService.getCaseAlerts(caseId).then(success('alerts'));
                    break;
            }
            return alertsPromise;
        }
        function getAlertFieldBasedOnEntity(entityId, isAlerted) {
            var filterColumn = {
                field: null,
                operator: 'eqCaseSensitive',
                value: null
            };
            if (isAlerted) {
                if (entityId.entityKey !== null) {
                    filterColumn.field = 'alertedEntityKey';
                    filterColumn.value = entityId.entityKey;
                }
                else {
                    filterColumn.field = 'alertedEntityNumber';
                    filterColumn.value = entityId.entityNumber;
                }
            }
            else {
                if (entityId.entityKey !== null) {
                    filterColumn.field = 'primaryEntityKey';
                    filterColumn.value = entityId.entityKey;
                }
                else {
                    filterColumn.field = 'primaryEntityNumber';
                    filterColumn.value = entityId.entityNumber;
                }
            }
            return filterColumn;
        }
        function getAlertFilterForRolledEntities(entityId) {
            var filter = {
                logic: 'and',
                filters: [
                    {
                        logic: 'or',
                        filters: [
                            {
                                logic: 'and',
                                filters: [
                                    {
                                        field: 'alertedEntityLevelCode',
                                        operator: 'eqCaseSensitive',
                                        value: entityId.entityLevelCode
                                    },
                                    getAlertFieldBasedOnEntity(entityId, true)
                                ]
                            },
                            {
                                logic: 'and',
                                filters: [
                                    {
                                        field: 'alertLevel',
                                        operator: 'eqCaseSensitive',
                                        value: entityId.entityLevelCode
                                    },
                                    getAlertFieldBasedOnEntity(entityId, false)
                                ]
                            }
                        ]
                    }
                ]
            };
            return filter;
        }
        function getAlertFilter(entityId) {
            var filter = {
                logic: 'and',
                filters: [
                    {
                        field: 'alertLevel',
                        operator: 'eqCaseSensitive',
                        value: entityId.entityLevelCode
                    },
                    getAlertFieldBasedOnEntity(entityId, false)
                ]
            };
            return filter;
        }
        function getEntityAlerts(entityId, caseId, gridOptions) {
            /*jshint maxcomplexity:25 */
            var alertsPromise;
            function success(alertsField) {
                // set the correct alerts field on result
                return function (data) {
                    // should just be able to use resourceCollection.name field, but not all alerts services return a
                    // resources collection
                    data.alertsField = alertsField;
                    return data;
                };
            }
            if (caseId) {
                alertsPromise = getCaseAlerts(entityId, alertsPromise, caseId);
            }
            else {
                var notYetImplemented = false;
                if (notYetImplemented) {
                    var filterStr = null;
                    var filter = null;
                    if (entityId.entityLevelCode === amlConstants.entityType.household ||
                        entityId.entityLevelCode === amlConstants.entityType.account ||
                        entityId.entityLevelCode === amlConstants.entityType.customer) {
                        filter = getAlertFilterForRolledEntities(entityId);
                    }
                    else {
                        filter = getAlertFilter(entityId);
                    }
                    alertsPromise = entitiesAlertResource.get({
                        start: 0,
                        limit: 1000,
                        filter: filterStr
                    }).$promise;
                }
                else {
                    switch (entityId.entityLevelCode) {
                        case amlConstants.entityType.customer:
                            alertsPromise = customerService.getAlerts(entityId.entityNumber).then(success('allAlerts'));
                            break;
                        case 'ACC':
                            alertsPromise = accountService.getAccountAlerts(entityId.entityNumber).then(success('accountAlerts'));
                            break;
                        case 'HHD':
                            alertsPromise = householdService.getHouseholdAlerts(entityId.entityNumber).then(success('householdAlerts'));
                            break;
                        case 'BNK':
                            alertsPromise = bankService.getBankAlerts(entityId.entityNumber).then(success('alerts'));
                            break;
                        case 'ASC':
                            alertsPromise = associateService.getAssociateAlerts(entityId.entityNumber).then(success('alerts'));
                            break;
                        case 'EXT':
                            alertsPromise = externalPartyService.getExternalPartyAlerts(entityId.entityNumber).then(success('alerts'));
                            break;
                        default:
                            break;
                    }
                }
            }
            return alertsPromise;
        }
        /**
         * Construct/update an entity id object sourced from an existing entityId composite parts.
         * Returns the new/updated entity id, essentially a union of the existing and new values.
         *
         * @param entityId
         * @param entityLevelCode
         * @param entityNumber
         * @param entityKey
         * @returns {aml.EntityId}
         */
        function normalizeEntityId(entityId, entityLevelCode, entityNumber, entityKey) {
            if (!entityId) {
                entityId = {};
            }
            if (entityNumber) {
                entityId.entityNumber = entityNumber;
            }
            if (entityLevelCode) {
                entityId.entityLevelCode = entityLevelCode;
            }
            if (entityKey) {
                entityId.entityKey = entityKey;
            }
            return entityId;
        }
        function getStateForEntity(entity) {
            /*jshint maxcomplexity:25 */
            var stateName, stateParams;
            switch (entity.entityLevelCode) {
                case amlConstants.entityType.customer:
                    stateName = CUSTOMER_DETAILS_STATENAME;
                    stateParams = {
                        customerid: entity.entityNumber,
                        name: amlCoreUtils.titleCase(entity.entityName),
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.account:
                    stateName = ACCOUNT_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        accountid: entity.entityNumber,
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.household:
                    stateName = HOUSEHOLD_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        householdNumber: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.bank:
                    stateName = BANK_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        bankid: entity.entityNumber,
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.associate:
                    stateName = ASSOCIATE_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        associateid: entity.entityNumber,
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.externalParty:
                    stateName = EXTERNAL_PARTY_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        externalpartyid: entity.entityNumber,
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.alert:
                    stateName = ALERT_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        alertid: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.case:
                    stateName = CASE_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        caseid: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.branch:
                    stateName = BRANCH_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        branchid: entity.entityNumber,
                        queueCode: (entity.queueCode ? entity.queueCode : ''),
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.report:
                    stateName = REPORT_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        reportkey: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.riskAssessment:
                    stateName = RISK_ASSESSMENT_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        assessmentId: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.cddReview:
                    stateName = CDD_REVIEW_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        reviewKey: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                case amlConstants.entityType.transaction:
                    stateName = TRANSACTION_DETAILS_STATENAME;
//console.log("amlConstants.entityType.transaction Call");
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        transactionid: entity.entityNumber,
                        key: entity.entityKey,
                        alertIdVal: entity.alertIdVal
                    };
                    break;
                case amlConstants.entityType.watchList:
                    stateName = WATCHLIST_DETAILS_STATENAME;
                    stateParams = {
                        name: amlCoreUtils.titleCase(entity.entityName),
                        watchListKey: entity.entityNumber,
                        key: entity.entityKey
                    };
                    break;
                default:
                    break;
            }
            if (!stateParams.queueCode || stateParams.queueCode === '') {
                stateParams.queueCode = 'aml_no_queue';
            }
            return { stateName: stateName, stateParams: stateParams };
        }
        function getEntityIdForState(stateName, stateParams) {
            var entity = {};
            var index = stateName.indexOf('_');
            if (index > -1) {
                stateName = stateName.substring(0, index);
            }
            switch (stateName) {
                case CUSTOMER_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.customer;
                    entity.entityNumber = stateParams.customerid;
                    entity.entityKey = stateParams.key;
                    break;
                case ACCOUNT_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.account;
                    entity.entityNumber = stateParams.accountid;
                    entity.entityKey = stateParams.key;
                    break;
                case HOUSEHOLD_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.household;
                    entity.entityNumber = stateParams.householdid;
                    entity.entityKey = stateParams.key;
                    break;
                case BANK_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.bank;
                    entity.entityNumber = stateParams.bankid;
                    entity.entityKey = stateParams.key;
                    break;
                case ASSOCIATE_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.associate;
                    entity.entityNumber = stateParams.associateid;
                    entity.entityKey = stateParams.key;
                    break;
                case EXTERNAL_PARTY_DETAILS_STATENAME:
                    entity.entityLevelCode = amlConstants.entityType.externalParty;
                    entity.entityNumber = stateParams.externalpartyid;
                    entity.entityKey = stateParams.key;
                    break;
                default:
                    //stateParams = {
                    //    name: amlCoreUtils.titleCase(selectedEntity.entityName),
                    //    externalpartyid: selectedEntity.key
                    //};
                    break;
            }
            entity.queueCode = stateParams.queueCode;
            if (entity.queueCode && entity.queueCode === 'aml_no_queue') {
                entity.queueCode = '';
            }
            return entity;
        }
        function isEntityObject(objectTypeCode) {
            return objectTypeCode && (objectTypeCode === amlConstants.entityType.customer ||
                objectTypeCode === amlConstants.entityType.account ||
                objectTypeCode === amlConstants.entityType.household ||
                objectTypeCode === amlConstants.entityType.bank ||
                objectTypeCode === amlConstants.entityType.associate ||
                objectTypeCode === amlConstants.entityType.externalParty);
        }
        function createGenericEntityFromEntityType(specificEntity, entityLevelCode) {
            var aggregateAmount, alertCount, riskScore;
            aggregateAmount = specificEntity.aggregatedTransactionsAmount;
            riskScore = specificEntity.riskClassification;
            alertCount = specificEntity.alertCount;
            switch (entityLevelCode) {
                case amlConstants.entityType.customer:
                    break;
                case amlConstants.entityType.account:
                    break;
                case amlConstants.entityType.household:
                    break;
                case amlConstants.entityType.bank:
                    break;
                case amlConstants.entityType.associate:
                    break;
                case amlConstants.entityType.externalParty:
                    break;
                default:
                    //stateParams = {
                    //    name: amlCoreUtils.titleCase(selectedEntity.entityName),
                    //    externalpartyid: selectedEntity.key
                    //};
                    break;
            }
            return {
                aggregateAmount: aggregateAmount,
                riskScore: riskScore,
                alertCount: alertCount
            };
        }
        /**
         * account for EXT which has the key as its unique ID. If a client passes an EXT entity id and
         * only has the number set, assume it should be the key.
         * @param entityIds
         */
        function ensureAppropriateEntityIds(entityIds) {
            _.each(entityIds, function (entityId) {
                ensureAppropriateEntityId(entityId);
            });
            return entityIds;
        }
        /**
         * account for EXT which has the key as its unique ID. If a client passes an EXT entity id and
         * only has the number set, assume it should be the key.
         * @param entityId
         */
        function ensureAppropriateEntityId(entityId) {
            return entityId;
        }
        /**
         * route an array of entities
         * @param entityIds
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeEntities(entityIds, routeToUser, routeToQueue, replaceCurrentQueue) {
            var entityTriageParams = {
                entityIds: ensureAppropriateEntityIds(entityIds),
                ownerUserId: routeToUser,
                queueCode: routeToQueue,
                replaceCurrentQueue: replaceCurrentQueue
            };
            return triageRouteEntitiesResource.create({}, entityTriageParams).$promise;
        }
        /**
         * checkin an array of entities
         * @param entityIds
         * @returns {$promise|*}
         */
        function checkinEntities(entityIds) {
            var entitiesTriageParams = {
                entityIds: ensureAppropriateEntityIds(entityIds)
            };
            return triageCheckinEntitiesResource.create({}, entitiesTriageParams).$promise;
        }
        /**
         * checkout an array of entities
         * @param entityIds
         * @returns {$promise|*}
         */
        function checkoutEntities(entityIds) {
            var entitiesTriageParams = {
                entityIds: ensureAppropriateEntityIds(entityIds)
            };
            return triageCheckoutEntitiesResource.create({}, entitiesTriageParams).$promise;
        }
        /**
         * check that entity can be routed, i.e. one of: PTY, EXT, ACC, ASC, BNK
         */
        function canRouteEntity(entityType) {
            if (!entityType) {
                return false;
            }
            if (entityType === amlConstants.entityType.customer ||
                entityType === amlConstants.entityType.associate ||
                entityType === amlConstants.entityType.bank ||
                entityType === amlConstants.entityType.externalParty) {
                return true;
            }
            return false;
        }
        function getReadableEntityIdentifier(entityType, entityId) {
            /*jshint maxcomplexity:14 */
            switch (entityType) {
                case amlConstants.entityType.account:
                    return resources.aml.getResource('tabs.accountTabTooltip', { accountid: entityId });
                case amlConstants.entityType.alert:
                    return resources.aml.getResource('tabs.alertTabTooltip', { alertid: entityId });
                case amlConstants.entityType.associate:
                    return resources.aml.getResource('tabs.associateTabTooltip', { associateid: entityId });
                case amlConstants.entityType.bank:
                    return resources.aml.getResource('tabs.bankTabTooltip', { bankid: entityId });
                case amlConstants.entityType.branch:
                    return resources.aml.getResource('tabs.branchTabTooltip', { branchid: entityId });
                case amlConstants.entityType.case:
                    return resources.aml.getResource('tabs.caseTabLabel', { caseid: entityId });
                case amlConstants.entityType.cddReview:
                    return resources.aml.getResource('tabs.cddReviewTabLabel', { reviewKey: entityId });
                case amlConstants.entityType.customer:
                    return resources.aml.getResource('tabs.customerTabTooltip', { customerid: entityId });
                case amlConstants.entityType.externalParty:
                    return resources.aml.getResource('tabs.externalPartyTooltip', { externalpartyid: entityId });
                case amlConstants.entityType.household:
                    return resources.aml.getResource('tabs.householdTabTooltip', { householdNumber: entityId });
                case amlConstants.entityType.report:
                    return resources.aml.getResource('tabs.reportTabLabel', { reportkey: entityId });
                case amlConstants.entityType.riskAssessment:
                    return resources.aml.getResource('tabs.riskAssessmentTabLabel', { riskassessmentid: entityId,
                        assessmentId: entityId });
                case amlConstants.entityType.transaction:
                    return resources.aml.getResource('tabs.transactionTabLabel', { transactionid: entityId });
            }
        }
        function getEntityAlertCount(entityId) {
            return $http.get(amlConfig.baseUrl + '/entities/alertCount?entityLevelCode=' + entityId.entityLevelCode + '&entityNumber=' + entityId.entityNumber);
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.efiles:efilesService
 *
 * @restrict E
 *
 * @description
 * The efiles service is used to retrieve efiles from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    efilesService.$inject = ["$resource", "amlConfig", "amlConstants", "_", "exceptionResourceHandler", "usersService", "amlCoreUtils"];
    angular
        .module('aml.efiles')
        .factory('efilesService', efilesService);
    /* @ngInject */
    function efilesService($resource, amlConfig, amlConstants, _, exceptionResourceHandler, usersService, amlCoreUtils) {
        /**
         * Resources
         */
        var efilesResource = $resource(amlConfig.baseUrl + '/efiles', {
            id: '@id',
            // list parameters
            start: '@start',
            limit: '@limit',
            relationships: '@relationships',
            sortBy: '@sortBy',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var efileReportsResource = $resource(amlConfig.baseUrl + '/efiles/:id/reports', {
            id: '@id',
            start: '@start',
            limit: '@limit',
            sortBy: '@sotrBy',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            update: {
                method: 'PUT',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var efileResource = $resource(amlConfig.baseUrl + '/efiles/:id', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            save: {
                method: 'PUT',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var efileSaveResource = $resource(amlConfig.baseUrl + '/efiles/save', {
            save: {
                method: 'POST',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var rejectEfileResource = $resource(amlConfig.baseUrl + '/efiles/:id/actions/reject', {
            id: '@id'
        }, {
            reject: {
                method: 'POST',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var responseReportResource = $resource(amlConfig.baseUrl + '/efiles/:id/callStp', {
            id: '@id',
            stpName: '@stpName'
        }, {
            get: {
                method: 'GET',
                headers: { 'Accept': 'text/html' },
                transformResponse: parseHtml,
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var efileEntityInfoResource = $resource(amlConfig.baseUrl + '/efiles/:id/efileEntityInfo', {
            id: '@id',
            start: '@start',
            limit: '@limit',
            sortBy: '@sortBy',
            entityTypeName: '@entityTypeName'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var service = {
            saveEfile: saveEfile,
            getEfile: getEfile,
            getEfiles: getEfiles,
            getEfileReports: getEfileReports,
            updateEfileReport: updateEfileReport,
            getEfilesInArrayByNumber: getEfilesInArrayByNumber,
            isEfileReadonly: isEfileReadonly,
            viewResponseReport: viewResponseReport,
            getEfileEntityInfo: getEfileEntityInfo,
            rejectEfile: rejectEfile
        };
        return service;
        /**
         * Get list of efiles
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all efiles matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getEfiles(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = amlCoreUtils.getSortByString(sortBys);
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return efilesResource.get({
                start: start,
                limit: pageSize,
                sortBy: sortByList,
                filter: filter
            }).$promise;
        }
        /**
         * Get list of efile entities
         * @returns {$promise|*}
         */
        function getEfileReports(efileid, start, pageSize, sortBys, filterStr) {
            return efileReportsResource.get({
                id: efileid,
                start: start,
                limit: pageSize,
                sortBy: sortBys,
                filter: filterStr
            }).$promise;
        }
        /**
         * Update a efile entities
         * @returns {$promise|*}
         */
        function updateEfileReport(entity) {
            return efileReportsResource.update({
                id: entity.efileId,
                number: entity.entityNumber,
                type: entity.entityLevelCode
            }, entity).$promise;
        }
        /**
         * Get a efile by efile ID
         * @param efileKey
         * @returns {$promise|*}
         */
        function getEfile(efileKey) {
            return efileResource.get({ id: efileKey }).$promise;
        }
        /**
         * Save a efile by efile ID
         * @param aEfile
         * @returns {$promise|*}
         */
        function saveEfile(aEfile) {
            return efileSaveResource.save(aEfile).$promise;
        }
        function getEfilesInArrayByNumber(efilesNumber, array) {
            var efiles = _.find(array, function (item) {
                return item && item.efileId && item.efileId === efilesNumber;
            });
            return efiles;
        }
        /**
         * Checks user permissions and efile status to see if the efile should be editable or just view mode
         * @returns {boolean}
         */
        function isEfileReadonly(aEfile) {
            //Default is that efile is editable
            var readOnly = false;
            //Check user permission
            if (!usersService.currentUserHasCapability(amlConstants.capabilities.editEfile)) {
                readOnly = true;
            }
            return readOnly;
        }
        /**
         * Get list entity info for one entity
         * @returns {$promise|*}
         */
        function getEfileEntityInfo(efileKey, entityType) {
            return efileEntityInfoResource.get({
                id: efileKey,
                entityTypeName: entityType
            }).$promise;
        }
        function rejectEfile(efileKey, reportKeys) {
            var efileActionParameters = {
                reportKeys: reportKeys
            };
            return rejectEfileResource.reject({ id: efileKey }, efileActionParameters).$promise;
        }
        function viewResponseReport(efileKey) {
            return responseReportResource.get({ id: efileKey, stpName: 'rc_resp_report' }).$promise;
        }
        /**
         * We have a parseHtml function that just returns the data in a JSON object; otherwise ngResource
         * seems to want to parse it as JSON and returns ArrayBuffer.
         */
        function parseHtml(data, headersGetter) {
            return { data: data };
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml:amlLov
 *
 * @description
 * This service contains objects containing localized mappings from the LOV table, in the form:
 *     LobTable code --> Localized value.
 *
 * @example reference from application code:
 *  amlLov.riskClassification; // contains { 1: 'Low', 2: 'Medium', 3: 'High' }
 */
(function () {
    'use strict';
    amlLov.$inject = ["$injector"];
    angular.module('aml').factory('amlLov', amlLov);
    /* @ngAnnotate */
    function amlLov($injector) {
        /**
         * The values in this map define which LOV tables from FSK_LOV will be loaded
         * and made available for use within the application.
         * These values will be placed in the corresponding name.
         *
         * @type {{riskClassification: string, alertStatus: string}}
         * @see  /rest/lov.json for possible LOV tables
         */
        var objectToRefTableNameMap = {
            entityPriority: 'ENTITY_PRIORITY',
            riskClassification: 'RT_RISK_CLASSIFICATION',
            cdi: 'RT_TRANSACTION_CDI',
            alertStatus: 'RT_ALERT_STATUS',
            priority: 'X_RT_PRIORITY',
            manualAlertReason: 'RT_MANUAL_REASON',
            commentCategory: 'COMMENT_CATEGORY',
            
            commentCategoryCases: 'CASES_COMMENT_CATEGORY',
            commentCategoryTriage: 'TRIAGE_COMMENT_CATEGORY',
            commentCategoryReport: 'REPORT_COMMENT_CATEGORY',
            commentCategoryCddreviews: 'CDDREVIEWS_COMMENT_CATEGORY',
            commentCategoryCasesDel: 'CASES_DEL_COMMENT_CATEGORY',
            
            scenarioType: 'SCENARIO_TYPE',
            scenarioCategory: 'SCENARIO_CATEGORY',
            scenarioStatus: 'SCENARIO_STATUS',
            scenarioFrequency: 'SCENARIO_FREQUENCY',
            scenarioParameterType: 'SCENARIO_PARAM_TYPE_CODE',
            alertColumnUsageCode: 'AC_USAGE_CODE',
            productType: 'PRODUCT_TYPE',
            headerElementUsage: 'HEADER_ELEMENT_USAGE_CODE',
            headerTypeCode: 'HEADER_TYPE_CODE',
            headerCopyAction: 'HEADER_COPY_ACTION',
            alertLevel: 'RT_ENTITY_LEVEL',
            caseEntityLevel: 'RT_CASE_ENTITY_LEVEL',
            yesOrNo: 'RT_YES_NO',
            alertCloseReason: 'RT_CLOSE_REASON',
            alertCategory: 'RT_INCIDENT_CATEGORY',
            associationType: 'ASSOCIATION_TYPE',
            associationAttrCode: 'ASSOCIATION_ATTR_CODE',
            controllerType: 'CONTROLLER_TYPE',
            //Queues
            queueName: 'QUEUE_NAME',
            auditEvent: 'AUDIT_EVENT',
            //Cases
            caseCategory: 'RT_CASE_CATEGORY',
            caseSubcategory: 'RT_CASE_SUBCATEGORY',
            caseStatus: 'FCF_CASE_STATUS',
            // caseDisposition: 'FCF_CASE_DISPOSITION',
            //Reports
            reportStatus: 'FCF_REPORT_STATUS',
            readyCode: 'FCF_REPORT_READY_CODE',
            filingType: 'FCF_REPORT_FILING_TYPE_CODE',
            reportType: 'RC_FORM_NAME_SHORT',
            reportTypeLong: 'RC_FORM_NAME_LONG',
            amountInvolved: 'FCF_REPORT_SAR_AMOUNT_INVOLVED',
            //CDD
            ruleType: 'CDD_RULE_TYPE',
            ruleStatus: 'CDD_RULE_STATUS',
            ruleGroupType: 'CDD_RULE_GROUP_TYPE',
            ruleGroupCategory: 'CDD_CATEGORY',
            cddParmType: 'CDD_PARM_TYPE',
            scoreClassification: 'CDD_SCORE_CLASSIFICATION',
            scoreType: 'CDD_SCORE_TYPE',
            ruleParameterType: 'CDD_PARM_TYPE',
            partyType: 'FCF_PARTY_TYPE',
            reviewStatus: 'CDD_REVIEW_STATUS',
            finalDisposition: 'CDD_FINAL_DISPOSITION',
            cddCountry: 'RT_CDD_COUNTRY',
            cddIndustry: 'RT_CDD_INDUSTRY',
            cddOccupation: 'RT_CDD_OCCUPATION',
            cddLegalEntityType: 'RT_CDD_LEGAL_ENTITY_TYPE',
            cddProduct: 'RT_CDD_PRODUCT',
            //edd
            eddStep: 'CDD_EDD_STEP',
            //FINCEN Report specific ones
            taxIDType: 'SAR.4A.TAX_ID_TYPE_CODE',
            gender: 'SAR.4A.GENDER_CODE',
            NAICS: 'NAICS',
            phoneTypeCode: 'SAR.4E.PHONE_TYPE_CODE',
            subjectRoleCode: 'SAR.4A.SAR_ROLE_CODE',
            stateUSCode: 'STATE_US',
            stateMXCode: 'STATE_MX',
            stateCACode: 'STATE_CA',
            stateASCode: 'STATE_AS',
            stateFMCode: 'STATE_FM',
            stateGUCode: 'STATE_GU',
            stateMHCode: 'STATE_MH',
            stateMPCode: 'STATE_MP',
            statePRCode: 'STATE_PR',
            statePWCode: 'STATE_PW',
            stateVICode: 'STATE_VI',
            countryCode: 'COUNTRY_ISO',
            IDType: 'SAR.4C.SUBJECT_ID_TYPE_CODE',
            relationshipTypeStatusCode: 'SAR.4H.SUBJECT_RELATION_STATUS_CODE',
            federalRegulator: 'SAR.2A.INSTITUTION_PRIM_FED_REG_CODE',
            institutionGamingType: 'SAR.2B.INSTITUTION_GAMING_TYPE_CODE',
            financialInstitutionIDType: 'SAR.2A.INSTITUTION_ID_TYPE_CODE',
            financialInstitutionTINType: 'SAR.2A.INSTITUTION_TAX_ID_TYPE_CODE',
            financialInstitutionType: 'SAR.2A.INSTITUTION_TYPE_CODE',
            branchRoleCode: 'SAR.2C.BRANCH_ROLE_CODE',
            subjectTypeCode: 'CTR.4A.SUBJECT_INVOLVED_TYPE_CODE',
            subjectIDTypeCode: 'CTR.4A.SUBJECT_ID_TYPE_CODE',
            branchGamingTypeCode: 'CTR.2B.BRANCH_GAMING_TYPE_CODE',
            branchTypeCtrCode: 'CTR.2B.BRANCH_TYPE_CODE',
            exemptPersonCode: 'DOEP.3A.EXEMPT_TYPE_CODE',
            DOEPFilingTypeCode: 'DOEP.3A.FILING_TYPE_CODE',
            DOEPTaxIDType: 'DOEP.3A.TAX_ID_TYPE_CODE',
            CTRFilingType: 'CTR.3A.CTR_FILING_TYPE_CODE',
            // for CTRX
            federalRegulator2: 'CTRX.2B.BRANCH_PRIM_FED_REG_CODE',
            subjectTypeCodeX: 'CTRX.4A.SUBJECT_INVOLVED_TYPE_CODE',
            // for SARX
            cyberEventTypeCode: 'SARX.CYBER_EVENT_TYPE_CODE',
            //EFiles
            efileStatus: 'FCF_EFILE_STATUS',
            // Targeted search
            accountType: 'RT_ACCOUNT_TYPE',
            riskAssessmentStatus: 'RT_ASMT_STATUS',
            entityLevel: 'RT_ENTITY_LEVEL',
            closeReason: 'RT_RA_CLOSE_REASON',
            // Peer group analysis
            metric: 'RT_PGA_VALUES',
            // Segments
            segmentName: 'SEGMENT_NAME'
        };
        var amlConstantValues = {
            getIdByValue: getIdByValue,
            getByLovTableName: getByLovTableName,
            getValueByIdCaseInsensitive: getValueByIdCaseInsensitive,
            getAsArray: getAsArray,
            // values are populated in this object by the initialize function which is called
            // via ResourcesService.init, as this requires the resources and LOV Tables values
            // to have been populated (which happens via an asynchronous network call).
            initialize: initialize
        };
        //store browser locale to be used for string sorting
        var appLocale = 'i'; //assign invalid value to catch errors if initialization fails
        /**
         * Any additional local Ref-Table-like mappings (those not stored in the actual
         * REF_TABLES database tables) can be defined here.
         *
         * @param resources
         * @returns {{riskClassification1: {1: (chart.low|x.low), 2:
         *     (exports.SingularToPlural.medium|*|exports.colors.medium|$LocaleProvider.$get.DATETIME_FORMATS.medium|xc.medium|sd.$get.DATETIME_FORMATS.medium),
         *     3: (chart.high|x.high)}, alertStatus2: {ACT: *, CLC: *, CLS:
         *     (Queue.closed|*|fakeDgram.socket.closed|exports.browser.closed|browser.closed|FSWatcher.closed), SUE: *,
         *     SUP: *}}}
         */
        var constantValues = function (resources) {
            return {};
        };
        return amlConstantValues;
        /**
         * Do a reverse lookup to find an id, given a value
         * @param constantEnumMapping
         * @param value
         * @returns {*}
         */
        function getIdByValue(constantEnumMapping, value) {
            if (value) {
                for (var id in constantEnumMapping) {
                    if (constantEnumMapping[id].description) {
                        if (value.toUpperCase() === constantEnumMapping[id].description.toUpperCase()) {
                            return id;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Get the LOV mapping given the actual LOV table name. Ex: 'RT_CLOSE_REASON' will return the mapping for
         * alertCloseReason.
         *
         * @param actualLovTableName
         * @returns {any}
         */
        function getByLovTableName(actualLovTableName) {
            // lookup the key in our map of internal lov properties to actual LOV table names
            var foundKey = null;
            _.find(objectToRefTableNameMap, function (val, key) {
                if (val === actualLovTableName) {
                    foundKey = key;
                    return key;
                }
            });
            if (foundKey) {
                /*jshint validthis:true */
                var mapping = this[foundKey];
                return mapping;
            }
            else {
                return null;
            }
        }
        /**
         * return a given mapped constant as an array of { key, value } objects, sorted by value.
         * This is useful for dropdowns when displaying lov values
         * @param constantEnumMapping
         * @param includeInactive by default, inactive table values are not returned; set this to true to include them
         * @returns {Array}
         */
        function getAsArray(constantEnumMapping, includeInactive) {
            var key, sortedArray = [];
            for (key in constantEnumMapping) {
                if (constantEnumMapping.hasOwnProperty(key)) {
                    var lovTableValue = constantEnumMapping[key];
                    if (lovTableValue.active || includeInactive) {
                        var lovValueDescription = null;
                        if (lovTableValue.description) {
                            lovValueDescription = lovTableValue.description;
                        }
                        if (!lovValueDescription) {
                            lovValueDescription = key;
                        }
                        if (includeInactive) {
                            sortedArray.push({ key: key, value: lovValueDescription, order: lovTableValue.order, active: lovTableValue.active });
                        }
                        else {
                            sortedArray.push({ key: key, value: lovValueDescription, order: lovTableValue.order });
                        }
                    }
                }
            }
            // sort by value name
            sortedArray.sort(function (a, b) {
                // sort by lov value order if present
                if (a.order && b.order) {
                    return a.order - b.order;
                }
                else if (a.order) {
                    return 1;
                }
                else if (b.order) {
                    return -1;
                }
                else {
                    // otherwise sort by alphabetical, specify locale, otherwise browser locale
                    //will be used and that is not guaranteed to be the locale set by the user
                    //in the language options of the browser
                    return a.value.toLowerCase().localeCompare(b.value.toLowerCase(), appLocale);
                }
            });
            return sortedArray;
        }
        /**
         * get a value for a given ID (and perform a case insensitive lookup)
         * @param constantEnumMapping
         * @param id - the id to look up in the enum map to retrieve the value for
         * @returns {*}
         */
        function getValueByIdCaseInsensitive(constantEnumMapping, id) {
            if (id) {
                for (var enumId in constantEnumMapping) {
                    if (id.toUpperCase() === enumId.toUpperCase()) {
                        return constantEnumMapping[id].description;
                    }
                }
            }
            return null;
        }
        function initialize(lovTables, resources) {
            var resourceService = $injector.get('resourceService');
            resourceService.getLocale().then(function (locale) {
                appLocale = locale;
            });
            if (!amlConstantValues.aml) {
                var vals = constantValues(resources);
                angular.extend(amlConstantValues, vals);
            }
            var refTableMappings = {};
            for (var property in objectToRefTableNameMap) {
                if (objectToRefTableNameMap.hasOwnProperty(property)) {
                    var refTableName = objectToRefTableNameMap[property];
                    var refTableMapping = lovTables[refTableName];
                    if (!refTableMapping) {
                        refTableMapping = {};
                    }
                    // add this property -> map to this object
                    refTableMappings[property] = refTableMapping;
                }
            }
            //S1404021 - need to add all tables from FSK_LOV, they may be used by CDD triggering values
            // var tableNames = (<any>Object).values(refTableMappings); - not supported by all browsers
            var tableNames = Object.keys(refTableMappings).map(function (key) {
                return refTableMappings[key];
            });
            //add tables that
            for (var tabName in lovTables) {
                if (lovTables.hasOwnProperty(tabName)) {
                    var refTableName1 = tableNames[tabName];
                    if (!refTableName1) {
                        objectToRefTableNameMap[tabName] = tabName;
                        // add this property -> map to this object
                        refTableMappings[tabName] = lovTables[tabName];
                    }
                }
            }
            angular.extend(amlConstantValues, refTableMappings);
        }
    }
})();


/**
 * Created by shasho on 6/27/2017.
 */
(function () {
    'use strict';
    RiskFactorsController.$inject = ["$scope", "resources", "riskFactorsService", "logger", "$stateParams", "scenarioService", "kendoGridRendererService"];
    angular.module('aml.customer.details').controller('RiskFactorsController', RiskFactorsController);
    function RiskFactorsController($scope, resources, riskFactorsService, logger, $stateParams, scenarioService, kendoGridRendererService) {
        var vm = this;
        vm.grid = {};
        vm.pageSize = vm.pageSize || 10;
        vm.alertId = $stateParams.alertid;
        vm.resources = resources;
        vm.riskFactorsCount = 0;
        vm.currentSelectedScenario = null;
        vm.gridColumns = [
            { field: 'scenarioID', title: resources.aml.riskFactors.scenarioId,
                width: 50, type: 'number', hidden: true },
            { field: 'scenarioName', title: resources.aml.riskFactors.scenarioNumber,
                width: 50, type: 'string'
            },
            {
                field: 'description', title: resources.aml.riskFactors.scenarioDescription,
                type: 'string', width: 180
            },
            {
                field: 'entityLevelCode', title: resources.aml.riskFactors.entityLevelCode,
                width: 100, type: 'string', template: kendoGridRendererService.enum('entityLevelCode', 'entityLevel'),
                filterable: kendoGridRendererService.getCheckboxFilter('entityLevel')
            },
            { field: 'entityNumber', title: resources.aml.riskFactors.entityNumber,
                type: 'string', width: 100
            },
            { field: 'actualValuesText', title: resources.aml.riskFactors.riskDescription,
                type: 'string', width: 170
            }
        ];
        vm.scenarioParameterGridColumns = [
            { field: 'name', title: resources.aml.riskFactors.parameterName,
                width: 50, type: 'string' },
            { field: 'description', title: resources.aml.riskFactors.parameterDescription,
                width: 50, type: 'string' },
            { field: 'type', title: resources.aml.riskFactors.parameterType,
                width: 50, type: 'string' },
            { field: 'value', title: resources.aml.riskFactors.parameterValue,
                width: 50, type: 'string' }
        ];
        vm.gridOptions = {
            scrollable: true // Let the grid scroll horizontally,
        };
        vm.scenarioParametersGridOptions = {
            scrollable: true
        };
        vm.getRiskFactors = getRiskFactors;
        vm.getScenarioParameters = getScenarioParameters;
        vm.handleRowSelect = handleRowSelect;
        vm.scenarioParametersGrid = {};
        activate();
        function activate() {
            vm.onDataChange = function riskFactorsListFilter(result, e) {
                if (vm.grid && vm.grid.dataSource) {
                    vm.riskFactorsCount = vm.grid.dataSource.total();
                }
            };
            vm.onScenarioParametersDataChange = function scenarioParametersListFilter(result, e) {
                if (vm.scenarioParametersGrid && vm.scenarioParametersGrid.dataSource) {
                    vm.scenarioParametersCount = vm.scenarioParametersGrid.dataSource.total();
                }
            };
            setupWatches();
        }
        function setupWatches() {
            $scope.$watch(function () {
                if (vm.currentSelectedScenario) {
                    return vm.currentSelectedScenario.name;
                }
                else {
                    return null;
                }
            }, function (newScenario, oldScenario) {
                if (newScenario && newScenario !== oldScenario) {
                    kendoGridRendererService.refreshGrid(vm.scenarioParametersGrid);
                }
            }, true);
        }
        function getRiskFactors(gridCallback) {
            var riskFactors;
            riskFactorsService.getRiskFactors(vm.alertId).then(function (data) {
                riskFactors = data.riskFactors;
                vm.riskFactorsCount = data.riskFactors.length;
                gridCallback.success(riskFactors);
            }, function (data, status) {
                logger.error('Error in getRiskFactors()');
            });
        }
        function getScenarioParameters(gridCallback) {
            gridCallback.success(vm.currentSelectedScenario.parms);
        }
        function handleRowSelect(data) {
            if (data) {
                scenarioService.getScenarioNoSource(data.scenarioID).then(function (fullData) {
                    vm.currentSelectedScenario = fullData;
                    vm.scenarioParametersCount = vm.currentSelectedScenario.parms.length;
                });
            }
            else {
                vm.currentSelectedScenario = null;
                vm.scenarioParametersCount = 0;
            }
        }
    }
})();


/**
 * Created by tommut on 1/22/2015.
 */
(function () {
    'use strict';
    TransactionsController.$inject = ["transactionsService", "$q", "dataMessagingServiceFactory", "amlConstants", "amlCoreUtils", "$scope", "$state", "logger", "resources", "kendoGridRendererService", "entityService", "entityListDataMessagingService"];
    angular.module('aml.customer.details').controller('TransactionsController', TransactionsController);
    /* jshint maxstatements: 50 */
    /* jshint maxparams: 11 */
    function TransactionsController(transactionsService, $q, dataMessagingServiceFactory, amlConstants, amlCoreUtils, $scope, $state, logger, resources, kendoGridRendererService, entityService, entityListDataMessagingService) {
    	
//console.log("TransactionsController !!!");

        var vm = this;
        
//console.log("vm.alertId : " + vm.alertId);
//console.log("vm.exttype : " + vm.exttype);

        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.lookbackDays = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
        vm.alertIsSelected = false;
        vm.caseId = null;
        // grid settings
        vm.pageSize = vm.pageSize || 10;
        vm.handleDoubleClick = handleDoubleClick;
        vm.getTransactions = getTransactions;
        vm.onGridInitialized = onGridInitialized;
        vm.grid = {}; // to get a reference
        vm.filterString = null;
        vm.totalAmount = 0;
        vm.resources = resources;
        vm.transactionsCount = 0;
        vm.alertCount = dataMessagingService.getSelectedAlertCount();
        vm.customActions = [{
                id: 'exportCsv', label: resources.aml.grid.actions.exportTitle,
                action: exportTransactions }];
        // Handle entity object
        vm.entityId = entityService.normalizeEntityId(vm.entityId, vm.entityLevelCode, vm.entityNumber, vm.entityKey);
        function isEntitySelected() {
            return vm.entityId.entityLevelCode && (vm.entityId.entityNumber || vm.entityId.entityKey);
        }
        //newly added variables for querying core
        vm.lookbackDaysInput = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
        vm.switchSource = switchSource;
        vm.queryCoreAction = queryCoreAction;
        vm.shouldSearchCoreTransactions = false;
        vm.sourceDataLabel = false;
        /**
         * If no alerted transactions, the user may request to get transactions from the core instead.
         * This is a poor-performing query, so it requires such a manual user gesture to instigate it.
         */
        // if an alertId is passed directly into the directive, then use that as 'selected' alert
        if (vm.alertId) {
            dataMessagingService.setAlertIds('alertids', "in(alertId," + vm.alertId + ")");
            vm.alertIsSelected = true;
        }
        else {
            // Reset selected alerts to none when loading customer details page.
            //TODO: is this really necessary? Alert list controller already does this.
            dataMessagingService.setAlertIds('alertids', 'all');
        }
        
//        dataMessagingService.setAlertIdVal(vm.alertId);
        
        // Keep track of the last customer used to retrieve alerts for
        var transactions = [];
        var transactionDateTemplate = 'longDateMediumTime';
        if (amlConstants.config.useDateOnlyForTransactions) {
            transactionDateTemplate = 'longDate';
        }

//console.log(JSON.stringify(vm));
/*
console.log("*******************************");
console.log(entityListDataMessagingService.getSelectedEntityIds().length);
console.log(entityListDataMessagingService.getSelectedEntityIds()[0]);
console.log(entityListDataMessagingService.getSelectedEntityIds()[0].entityLevelCode);
console.log("########################## vm");
console.log(vm);
*/
        var hrefStr = $(location).attr('href').toUpperCase();
        if(hrefStr.indexOf('EXTERNALPARTIES') != -1){	//  
	        vm.gridColumns = [
	            { field: 'triggerInd', width: 80, title: resources.aml.transaction.triggering,
	                template: function (dataItem) {
	                    if (dataItem.triggerInd === 'Y') {
	                        return '<span class="sas-icon sas-icon-alert" style="color:#ffad33" alt="Triggering transaction"/></span>';
	                    }
	                    else {
	                        return '';
	                    }
	                },
	                filterable: kendoGridRendererService.getCheckboxFilterForValues([{ name: resources.aml.transaction.triggering, value: 'Y' },
	                    { name: resources.aml.transaction.nonTriggering, value: 'N' }
	                ])
	            },
	            { field: 'accountNumber', title: resources.aml.transaction.accountnumber,
	                width: 170
	            },
	            {
	                field: 'transactionDate', title: resources.aml.transaction.date,
	                type: 'date', templateType: transactionDateTemplate, 
	                width: 190
	            },
	            {
	                field: 'currencyAmount', title: resources.aml.transaction.amount,
	                width: 120, type: 'number', templateType: 'currency'
	            },
	            { field: 'transactionCDIDesc', title: 'Remitter Country'//resources.aml.transaction.cdi
	                , type: 'string'
	                //templateType: 'titleCase'
	                , width: 150
	            },
	/*
	            { field: 'remitterExtCountryCode', title: 'ABCD',
	                templateType: 'titleCase', width: 100
	            },
	            { field: 'beneCreditDebit', title: 'AAAA',
	                templateType: 'titleCase', width: 100
	            },
	*/          
	            { field: 'primaryMediumDesc', title: 'Remitter Name'//resources.aml.transaction.primary
	                , type: 'string'
	                //templateType: 'titleCase'
	                , width: 170
	            },
	            { field: 'secondaryMediumDesc', title: 'Remitter Bank Country'//resources.aml.transaction.secondary 
	            		, type: 'string'
	            		//templateType: 'titleCase'
	            		, width: 120
	            },
	            { field: 'mechanismDesc', title: 'Remitter Address' //resources.aml.transaction.mechanism
	            		, type: 'string'
	            		//templateType: 'titleCase'
	            		, width: 250
	            },
	            { field: 'associateName', title: 'Remitter Bank BIC' //resources.aml.transaction.associate
	            	, type: 'string'
	            	//templateType: 'titleCase'
	            	, width: 150
	            },

	            { field: 'branchName', title: 'Beneficiary Country' //resources.aml.transaction.branch
	            		, type: 'string'
	                //templateType: 'titleCase'
	                , width: 200
	            },
	            { field: 'beneficiaryName', title: 'Beneficiary Name' //resources.aml.transaction.beneficiary
	            		, type: 'string'
	            		//templateType: 'titleCase'
	            		, width: 250
	            },
	            { field: 'transactionDesc', title: 'Beneficiary Bank Country' //resources.aml.transaction.description
	            		, type: 'string'
	            		//templateType: 'titleCase'
	            		, width: 180
	            },
	            { field: 'statusDesc', title: 'Beneficiary Address' //resources.aml.transaction.status
	                , type: 'string'
	                //templateType: 'titleCase'
	                ,width: 250
	            },
	            { field: 'transactionNumber', title: resources.aml.transaction.id
	            	, type: 'string', width: 180
	            }
	        ];
        }else if(hrefStr.indexOf('ALERTS') != -1 && vm.exttype == 'EXT'){	//  
	        vm.gridColumns = [
	            { field: 'triggerInd', width: 80, title: resources.aml.transaction.triggering,
	                template: function (dataItem) {
	                    if (dataItem.triggerInd === 'Y') {
	                        return '<span class="sas-icon sas-icon-alert" style="color:#ffad33" alt="Triggering transaction"/></span>';
	                    }
	                    else {
	                        return '';
	                    }
	                },
	                filterable: kendoGridRendererService.getCheckboxFilterForValues([{ name: resources.aml.transaction.triggering, value: 'Y' },
	                    { name: resources.aml.transaction.nonTriggering, value: 'N' }
	                ])
	            },
	            { field: 'accountNumber', title: resources.aml.transaction.accountnumber,
	                width: 150
	            },
	            {
	                field: 'transactionDate', title: resources.aml.transaction.date,
	                type: 'date', templateType: transactionDateTemplate, 
	                width: 180
	            },
	            {
	                field: 'currencyAmount', title: resources.aml.transaction.amount,
	                width: 100, type: 'number', templateType: 'currency'
	            },
	            { field: 'transactionCDIDesc', title: 'Remitter C/D/I',//resources.aml.transaction.cdi
	                templateType: 'titleCase', width: 100
	            },
	/*
	            { field: 'remitterExtCountryCode', title: 'ABCD',
	                templateType: 'titleCase', width: 100
	            },
	            { field: 'beneCreditDebit', title: 'AAAA',
	                templateType: 'titleCase', width: 100
	            },
	*/          
	            { field: 'primaryMediumDesc', title: 'Remitter Name',//resources.aml.transaction.primary
	                templateType: 'titleCase', width: 120
	            },
	            { field: 'secondaryMediumDesc', title: 'Remitter Country',//resources.aml.transaction.secondary 
	            		templateType: 'titleCase', width: 120
	            },
	            { field: 'mechanismDesc', title: 'Remitter Address', //resources.aml.transaction.mechanism
	            		templateType: 'titleCase', width: 150
	            },
	            { field: 'branchName', title: 'Beneficiary C/D/I', //resources.aml.transaction.branch
	                templateType: 'titleCase', width: 150
	            },
	            { field: 'beneficiaryName', title: 'Beneficiary Name', //resources.aml.transaction.beneficiary
	            		templateType: 'titleCase', width: 150
	            },
	            { field: 'transactionDesc', title: 'Beneficiary Country', //resources.aml.transaction.description
	            		templateType: 'titleCase', width: 180
	            },
	            { field: 'statusDesc', title: 'Beneficiary Address',//resources.aml.transaction.status
	                templateType: 'titleCase',
	                width: 150
	            },
	            { field: 'associateName', title: resources.aml.transaction.associate, templateType: 'titleCase',
	                width: 150
	            },
	            { field: 'transactionNumber', title: resources.aml.transaction.id, type: 'string',
	                width: 180
	            }
	        ];
        }else{	//  
					vm.gridColumns = [
	            { field: 'triggerInd', width: 80, title: resources.aml.transaction.triggering,
	                template: function (dataItem) {
	                    if (dataItem.triggerInd === 'Y') {
	                        return '<span class="sas-icon sas-icon-alert" style="color:#ffad33" alt="Triggering transaction"/></span>';
	                    }
	                    else {
	                        return '';
	                    }
	                },
	                filterable: kendoGridRendererService.getCheckboxFilterForValues([{ name: resources.aml.transaction.triggering, value: 'Y' },
	                    { name: resources.aml.transaction.nonTriggering, value: 'N' }
	                ])
	            },
	            { field: 'accountNumber', title: resources.aml.transaction.accountnumber,
	                width: 150
	            },
	            {
	                field: 'transactionDate', title: resources.aml.transaction.date,
	                type: 'date', templateType: transactionDateTemplate, 
	                width: 200
	            },
	            {
	                field: 'currencyAmount', title: resources.aml.transaction.amount,
	                width: 120, type: 'number', templateType: 'currency'
	            },
	            { field: 'transactionCDIDesc', title: resources.aml.transaction.cdi,
	                templateType: 'titleCase', width: 100
	            },
	            { field: 'primaryMediumDesc', title: resources.aml.transaction.primary,
	                templateType: 'titleCase', width: 120
	            },
	            { field: 'mechanismDesc', title: resources.aml.transaction.mechanism, templateType: 'titleCase',
	                width: 150
	            },
	            { field: 'branchName', title: 'Remitter Bank Country'//resources.aml.transaction.branch
	            	, templateType: 'titleCase', width: 150
	            },
	            { field: 'secondaryMediumDesc', title: 'Remitter Name'//resources.aml.transaction.secondary
	            	, templateType: 'titleCase', width: 120
	            },
	            { field: 'associateName', title: 'Remitter Address'//resources.aml.transaction.associate
	            	, templateType: 'titleCase', width: 150
	            },
	            { field: 'beneficiaryName', title: resources.aml.transaction.beneficiary, templateType: 'titleCase',
	                width: 150
	            },
	            { field: 'transactionDesc', title: 'Beneficiary Address'//resources.aml.transaction.description
	            	, templateType: 'titleCase', width: 180
	            },
							{ field: 'statusDesc', title: 'Beneficiary Bank Country',	//resources.aml.transaction.status,
	                templateType: 'titleCase',
	                width: 150
	            },
	            { field: 'transactionNumber', title: resources.aml.transaction.id
	            	, type: 'string', width: 180
	            }

	        ];
        }
        

        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            remotePaging: true,
            scrollable: true // Let the grid scroll horizontally,
        });

//console.log("pre activate vm.alertId : " + vm.alertId);

//console.log("TransactionController Vm : " + JSON.stringify(vm));
        activate();
        /////////////////
        function onGridInitialized(kendoGridOptions) {
            var alertids = dataMessagingService.getAlertIds('alertids');
            // initialize no records message to show "Search for core transactions" provided that the grid
            // is not initialized with a saved filter; in which case, we'll show the default 'no-records' message
            if (!(isAlertSelected(alertids) || vm.shouldSearchCoreTransactions ||
                amlCoreUtils.isNotNullOrUndefined(vm.gridOptions.dataSource.filter))) {
                // only display this if NO FILTERS are set.
                // This will bind the vm.searchCoreTransactions action to the resulting button in the No Records button
                kendoGridOptions.noRecords.template = transactionsService.getNoRecordTemplateForCoreTransactions($state.params.caseid);
            }
        }
        // on double-click, go to entity detail page
        function handleDoubleClick(selectedEntity) {
        	
//console.log("selectedEntity : " + JSON.stringify(selectedEntity));

            selectedEntity.entityLevelCode = amlConstants.entityType.transaction;
            selectedEntity.entityNumber = selectedEntity.transactionNumber;
            selectedEntity.entityKey = selectedEntity.transactionKey;
            
//console.log("selectedEntity.alertIdVal = vm.alertId; : " + vm.alertId);
            selectedEntity.alertIdVal = vm.alertId;
            
            if (selectedEntity) {

//console.log("JSON.stringify(selectedEntity) : " + JSON.stringify(selectedEntity));

                var entityState = entityService.getStateForEntity(selectedEntity);
                
//console.log("JSON.stringify(entityState) : " + JSON.stringify(entityState));

                $state.go(entityState.stateName, entityState.stateParams);
            }
            
//console.log("selectedEntity : " + JSON.stringify(entityState));
        }
        function activate() {
            setupWatches();
        }
        function setupWatches() {
            // Entity watch must come before Alert watch as deselect on the Entity will also deselect the Alert
            $scope.$watch(function () {
                return vm.entityId;
            }, function (newEntity, oldEntity) {
                if (newEntity && newEntity !== oldEntity) {
                    // Reset selected alerts to none; transactions controller watches on
                    // alerts and none should be selected initially when a new entity is selected
                    dataMessagingService.setAlertIds('alertids', 'all');
                    if (!vm.entityId.entityLevelCode) {
                        vm.alertIsSelected = false;
                    }
                    // refresh grid
                    kendoGridRendererService.refreshGrid(vm.grid);
                }
            }, true);
            $scope.$watch(function () {
                return dataMessagingService.getAlertIds('alertids');
            }, function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    if (newVal && newVal !== 'all') {
                        vm.alertIsSelected = true;
                    }
                    else {
                        vm.alertIsSelected = false;
                        //no matter what table you were working with, if you un-select all alerts, switch to 'Historical Transactions'
                        vm.shouldSearchCoreTransactions = false;
                        vm.lookbackDays = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
                        vm.sourceDataLabel = false;
                        kendoGridRendererService.refreshGrid(vm.grid);
                    }
                    var filterStr = newVal;
                    vm.filterString = filterStr;
                    dataMessagingService.setFilterStr('filterStr', filterStr);
                    // refresh grid
                    kendoGridRendererService.refreshGrid(vm.grid);
                }
            });
            dataMessagingService.onTotalAmountChange(function txListHandler(newVal) {
                vm.totalAmount = newVal;
            });
        }
        function switchSource() {
            vm.shouldSearchCoreTransactions = !vm.shouldSearchCoreTransactions;
            if (!vm.shouldSearchCoreTransactions) {
                vm.lookbackDays = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
                vm.sourceDataLabel = false;
                kendoGridRendererService.refreshGrid(vm.grid);
            }
        }
        function queryCoreAction() {
            vm.lookbackDays = vm.lookbackDaysInput; //update the displayed 'lookbackDays' value to match the user input
            vm.sourceDataLabel = true;
            kendoGridRendererService.refreshGrid(vm.grid);
        }
        function isAlertSelected(alertids) {
            return alertids && alertids !== 'all';
        }
        function getSortBys(alertIsSelected, data) {
            // set default sort (triggerInd) if alert is selected; otherwise include no default
            var defaultSort = alertIsSelected ? vm.defaultSortColumn : null;
            var sortCols = kendoGridRendererService.getSortColumns(data, defaultSort, vm.defaultSortDirection);
            if (!alertIsSelected) {
                // remove triggerInd sort/filter
                sortCols = _.reject(sortCols, function (sortCol) {
                    return sortCol.name === 'triggerInd';
                });
                kendoGridRendererService.removeFromFilter(data, 'triggerInd');
            }
            return sortCols;
        }
        function getAlertTransactionsAggregates(alertId, groupBy, filterStr) {
            transactionsService.getAlertTransactionsAggregates(alertId, groupBy).then(function (data) {
                var aggregates = data.items;
                // if there were no results, just set to an empty array. This can happen if a selected alert was
                // not captured in the FSK_ALRT_TX_AGG table
                if (!aggregates || aggregates.length === 0) {
                    aggregates = [];
                }
                var total = 0;
                _.each(aggregates, function (aggregate) {
                    total = total + aggregate.amount;
                });
                vm.totalAmount = kendoGridRendererService.formatCurrency(total);
                dataMessagingService.setTotalAmount(vm.totalAmount);
            });
        }
        function getTransactions(e) {
            /*jshint maxcomplexity:11*/
            var alertids = dataMessagingService.getAlertIds('alertids');
            
//console.log(" getTransactions JSON.stringify(dataMessagingService.getData()) : " + JSON.stringify(dataMessagingService.getData()));
						var _temp = dataMessagingService.getData();
						
//console.log("_temp.allAlerts[0] : " + JSON.stringify(_temp.allAlerts[0]));


						if(_temp.allAlerts[0] != undefined){
//console.log("_temp.allAlerts[0].alertId : " + _temp.allAlerts[0].alertId);
							vm.alertId = _temp.allAlerts[0].alertId;
						}
						

//console.log("vm.alertId : " + vm.alertId);
//console.log("alerties : " + alertids);
//console.log("JSON.stringify(alerties) : " + JSON.stringify(alertids));

            var alertIsSelected = isAlertSelected(alertids);
            
//console.log("alertIsSelected : " + alertIsSelected);
//console.log("JSON.stringify(alertIsSelected) : " + JSON.stringify(alertIsSelected));

            var entityIsSelected = isEntitySelected();

//console.log("entityIsSelected : " + entityIsSelected);
//console.log("JSON.stringify(entityIsSelected) : " + JSON.stringify(entityIsSelected));

            var sortCols = getSortBys(alertIsSelected, e.data);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.pageSize);
            vm.filterString = filterStr; //has to be set here to prevent alertId from affecting the filter check for string pluralization, don't move this after the if condition below!
            vm.alertCount = dataMessagingService.getSelectedAlertCount();
            // if alert(s) selected, we need to additionally filter by the alerts
            if (alertIsSelected) {
                filterStr = constructFilterStr(alertids, filterStr);
            }
            var data = {};
            //in the case of clicking an alert while queryInput had an invalid input, when un-clicking all alerts
            // the getTransactions function that you are currently in, will be called, using the invalid input,
            //in the case of the input being invalid, we just use the default preferences value
            if ($scope.$$childHead.$$childHead.$$childHead.$$childHead.queryCoreForm.$invalid) {
                vm.lookbackDays = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
                vm.lookbackDaysInput = amlConstants.config.fcf.svr.aml.entityTriageDMLookback;
            }
            //this is for the corner case, when switching to core data but not selecting 'Search',
            //if you select and then un-select an alert, the app automatically queries core data, so we then switch the
            //label to 'Core Data'
            if (vm.shouldSearchCoreTransactions) {
                vm.sourceDataLabel = true;
                vm.lookbackDays = vm.lookbackDaysInput;
            }
            dataMessagingService.setFilterStr('filterStr', filterStr);
            dataMessagingService.setTransactionsOrderBy(sortCols);
            transactionsService.setNoRecordTemplateForTransactions(vm.grid, alertids, $state.params.caseid, vm.shouldSearchCoreTransactions, e);
            if (entityIsSelected || vm.alertIsSelected) {
                // If Alerts are on a case, they will be closed. Set boolean to tell service to go to Knowledge Center
                if (!!$state.params.caseid) {
                    vm.caseId = $state.params.caseid;
                }
                if (alertIsSelected) {

//console.log("if (alertIsSelected) {");
//console.log("==================== TransactionsController.getTransactions if DATA ================");
//console.log("##### data : " + JSON.stringify(e.data));
//console.log("======================================");
/*
console.log("vm.caseId : " + vm.caseId);
console.log("vm.entityId.entityLevelCode : " + vm.entityId.entityLevelCode);
console.log("filterStr : " + filterStr);
console.log("pageInfo.start : " + pageInfo.start);
console.log("pageInfo.limit : " + pageInfo.limit);
console.log("sortCols : " + sortCols);

console.log(vm);

console.log("001 : " + vm.caseId);
console.log("002 : " + vm.entityId.entityLevelCode);
console.log("003 : " + filterStr);
console.log("004 : " + pageInfo.start);
console.log("005 : " + pageInfo.limit);
console.log("006 : " + sortCols);
console.log("007 : " + vm.entityId.entityLevelCode);
*/
                    // Get transactions for specific alert (only for the selected alerted entity level)
                    transactionsService.getPagedTransactionsByAlertIds(vm.caseId, vm.entityId.entityLevelCode, filterStr, pageInfo.start, pageInfo.limit, sortCols).then(function (data) {
//console.log("!!data : ");
//console.log(data);

//data.item[0].append('beneCreditDebit', 'aaaa');


/*					,
            { field: 'remitterExtCountryCode', title: 'ABCD',
                templateType: 'titleCase', width: 100
            },
            { field: 'beneCreditDebit', title: 'AAAA',
                templateType: 'titleCase', width: 100
            }
*/


//data.items[0].beneCreditDebit='aaaa';

                        transactions = data.transactions;
                        vm.transactionsCount = data.count;
                        e.success(data);
                    }, function (data, status, headers, config) {

                        logger.error(resources.aml.transaction.couldNotLoadTransactionsErrorText);
                    });
                    
//console.log("vm.hostPage : " + vm.hostPage);

                    if (vm.hostPage === 'alert') {
                        getAlertTransactionsAggregates(vm.alertId, 'CDI', null);
                    }
                }
                else if (entityIsSelected) {

//console.log("else if (entityIsSelected) {");
//console.log("==================== TransactionsController.getTransactions else if DATA ================");
//console.log("##### data : " + JSON.stringify(e.data));
//console.log("======================================");

                    // Get transactions for specific entity
                    transactionsService.getTransactionsByPage(vm.caseId, vm.entityId, filterStr, pageInfo.start, pageInfo.limit, sortCols, vm.shouldSearchCoreTransactions, vm.lookbackDaysInput).then(function (data) {
                        transactions = data.transactions;
                        vm.transactionsCount = data.count;
                        e.success(data);
                    }, function (data, status, headers, config) {
                        logger.error(resources.aml.transaction.couldNotLoadTransactionsErrorText);
                    });
                }
                else {

//console.log("==================== TransactionsController.getTransactions Else DATA ================");
//console.log("##### data : " + JSON.stringify(e.data));
//console.log("======================================");
                    transactions = [];
                    vm.transactionsCount = 0;

                    e.success(data);
                }
            }
            else {
                // Default to blank grid to avoid later vm.grid referencing issues
                e.success(data);
            }
        }
        function exportTransactions() {
            var filterStr = null;
            var relationship = 'triggerInd';
            var txType = 'entity';
            var alertids = dataMessagingService.getAlertIds('alertids');
            var alertIsSelected = isAlertSelected(alertids);
            if (!!$state.params.caseid) {
                if (alertIsSelected) {
                    txType = 'caseAlert';
                }
                else {
                    txType = 'caseEntity';
                }
            }
            else if (alertIsSelected) {
                relationship = 'alertTx';
                txType = 'alert';
            }
            else if (vm.shouldSearchCoreTransactions) {
                txType = 'entityCore';
            }
            var currentFilter = dataMessagingService.getFilterStr('filterStr');
            if (currentFilter && currentFilter !== 'all') {
                filterStr = currentFilter;
            }
            // set default sort (triggerInd) if alert is selected; otherwise include no default
            var sortCols = getSortBys(alertIsSelected, vm.grid);
            transactionsService.exportTransactionsToCSV($state.params.caseid, vm.entityId, filterStr, sortCols, relationship, txType);
        }
        function constructFilterStr(alertids, filterStr) {
            if (filterStr) {
                if (isAlertSelected(alertids)) {
                    filterStr = 'and(' + filterStr + ',' + alertids + ')';
                }
            }
            else {
                if (isAlertSelected(alertids)) {
                    filterStr = alertids;
                }
                else {
                    filterStr = 'all';
                }
            }
            return filterStr;
        }
    }
})();


/**
 * Created by fikhas on 1/22/2015.
 */
(function () {
    'use strict';
    transactionsService.$inject = ["$resource", "resources", "messageService", "amlConfig", "amlConstants", "linksProcessor", "exceptionResourceHandler", "$window", "kendoGridRendererService", "amlCoreUtils"];
    angular.module('aml.customer.details').factory('transactionsService', transactionsService);
    function transactionsService($resource, resources, messageService, amlConfig, amlConstants, linksProcessor, exceptionResourceHandler, $window, kendoGridRendererService, amlCoreUtils) {
        // endpoint for entity transactions in triage
        var transactionsEntityUri = '/transactions/entity';
        // endpoint for alert transactions in triage
        var transactionsAlertUri = '/transactions/alert';
        // endpoint for non-alerted entities in triage, and entities in archived investigations
        var transactionsEntityCoreUri = '/transactions/entity/core';
        // endpoint for alerts in active investigations --> /case/:caseid/transactions/alert
        var transactionsAlertCaseUri = '/cases/:id/alert/transactions';
        // endpoint for alerts in archived investigations --> /case/:caseid/transactions/alert/archived
        var transactionsEntityCaseUri = '/cases/:id/entity/transactions';
        var transactionsSearchUri = '/transactions';
        // define resources
        var entityTransactionsResource = $resource(amlConfig.baseUrl + transactionsEntityUri, {
            entityKey: '@entityKey',
            entityNumber: '@entityNumber',
            entityLevelCode: '@entityLevelCode',
            start: '@start', limit: '@limit',
            sortBy: '@sortBy', relationships: '@relationships',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        var entityTransactionsCoreResource = $resource(amlConfig.baseUrl + transactionsEntityCoreUri, {
            entityKey: '@entityKey',
            entityNumber: '@entityNumber',
            entityLevelCode: '@entityLevelCode',
            start: '@start', limit: '@limit',
            sortBy: '@sortBy', relationships: '@relationships',
            filter: '@filter',
            lookbackDaysInput: '@lookbackDaysInput'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        var entityTransactionsCaseResource = $resource(amlConfig.baseUrl + transactionsEntityCaseUri, {
            id: '@id',
            entityKey: '@entityKey',
            entityNumber: '@entityNumber',
            entityLevelCode: '@entityLevelCode',
            start: '@start', limit: '@limit',
            sortBy: '@sortBy', relationships: '@relationships',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        // Transaction resource for datamart replicated transactions
        var alertTransactionsResource = $resource(amlConfig.baseUrl + transactionsAlertUri, { start: '@start', limit: '@limit',
            sortBy: '@sortBy', relationships: '@relationships',
            alertedEntityLevelCode: '@alertedEntityLevelCode',
            alertedEntityKey: '@alertedEntityKey',
            filter: '@filter' }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        // Transaction resource for case replicated transactions
        var alertTransactionsCaseResource = $resource(amlConfig.baseUrl + transactionsAlertCaseUri, {
            id: '@id',
            start: '@start', limit: '@limit',
            sortBy: '@sortBy', relationships: '@relationships',
            alertedEntityLevelCode: '@alertedEntityLevelCode',
            alertedEntityKey: '@alertedEntityKey',
            filter: '@filter' }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        var customerTransactionAggregatesResource = $resource(amlConfig.baseUrl + '/transactions/aggregates', { id: '@id' }, {
            get: {
                method: 'GET',
                params: {
                    entityKey: '@entityKey',
                    entityNumber: '@entityNumber',
                    entityLevelCode: '@entityLevelCode',
                    groupBy: '@groupBy', relationships: '@relationships', filter: '@filter'
                },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var alertTransactionAggregatesResource = $resource(amlConfig.baseUrl + '/transactions/aggregates/alert', { id: '@id' }, {
            get: {
                method: 'GET',
                params: {
                    alertId: '@alertId',
                    groupBy: '@groupBy', relationships: '@relationships', filter: '@filter'
                },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var transactionSearchResource = $resource(amlConfig.baseUrl + transactionsSearchUri, {
            start: '@start', limit: '@limit',
            sortBy: '@sortBy', filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            exportCsv: {
                method: 'GET',
                headers: { 'Accept': 'text/csv' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler },
                transformResponse: parseCsv
            }
        });
        function getTransactionsByPage(caseId, entityId, filterStr, startPage, pageSize, sortBys, shouldSearchCoreTransactions, lookbackDaysInput) {
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var sortByList = kendoGridRendererService.getSortByString(sortBys);
            var transactionsParams = {
                entityLevelCode: entityId.entityLevelCode,
                start: startPage,
                limit: pageSize,
                sortBy: sortByList
            };
            setEntityIdField(entityId, transactionsParams);
            if (filterStr) {
                transactionsParams.filter = filterStr;
            }
            if (!isNaN(lookbackDaysInput)) {
                transactionsParams.lookbackDaysInput = lookbackDaysInput;
            }
            if (!!caseId) {
                // If called from the case details page, return transactions from the case details in the datamart
                return entityTransactionsCaseResource.get({ id: caseId }, transactionsParams).$promise;
            }
            else {
                if (shouldSearchCoreTransactions) {
                    return entityTransactionsCoreResource.get(transactionsParams).$promise;
                }
                else {
//console.log("return entityTransactionsResource.get(transactionsParams).$promise" + JSON.stringify(transactionsParams));
                    return entityTransactionsResource.get(transactionsParams).$promise;
                }
            }
        }
        /**
         * Get the results of a transaction search
         *
         * @param filterStr
         * @returns {$promise|*}
         */
        function getTransactionSearchResult(filterStr, start, limit, sortBys) {
            // Copied from above
            if (!limit) {
                limit = amlConstants.defaultPageSize;
            }
            var sortByList = kendoGridRendererService.getSortByString(sortBys);
            var params = {
                filter: filterStr,
                start: start,
                limit: limit,
                sortBy: sortByList
            };
            return transactionSearchResource.get(params).$promise;
        }
        function requestCsv(caseId, entityId, filterStr, sortBys, relationships, transactionType) {
            var sortByList = kendoGridRendererService.getSortByString(sortBys);
            var MAX_NUMBER_CSV_EXPORT_ITEMS = 1000000;
            var transactionsParams = {
                entityLevelCode: entityId.entityLevelCode,
                start: 0,
                limit: MAX_NUMBER_CSV_EXPORT_ITEMS,
                sortBy: sortByList,
                filter: filterStr,
                relationships: relationships,
                alertedEntityLevelCode: entityId.entityLevelCode
            };
            setEntityIdField(entityId, transactionsParams);
            if (filterStr) {
                transactionsParams.filter = filterStr;
            }
            if (transactionType === 'entity') {
                return entityTransactionsResource.exportCsv(transactionsParams).$promise;
            }
            else if (transactionType === 'entityCore') {
                return entityTransactionsCoreResource.exportCsv(transactionsParams).$promise;
            }
            else if (transactionType === 'alert') {
                return alertTransactionsResource.exportCsv(transactionsParams).$promise;
            }
            else if (transactionType === 'caseEntity') {
                // If called from the case details page, return transactions from the case details in the datamart
                return entityTransactionsCaseResource.exportCsv({ id: caseId }, transactionsParams).$promise;
            }
            else if (transactionType === 'caseAlert') {
                // If called from the case details page, return transactions from the case details in the datamart
                return alertTransactionsCaseResource.exportCsv({ id: caseId }, transactionsParams).$promise;
            }
            else {
                return transactionSearchResource.exportCsv(transactionsParams).$promise;
            }
        }
        function exportTransactionsToCSV(caseId, entityId, filterStr, sortBys, relationships, transactionType) {
            // for IE, we need to open link in a separate browser window instead
            var doc = document;
            var isIE = !!doc.documentMode; // At least IE6
            if (isIE || amlConstants.exportListsInSeparateWindow) {
                // build URI from this:
                var sortByList = kendoGridRendererService.getSortByString(sortBys);
                var transactionsParams = {
                    entityLevelCode: entityId.entityLevelCode,
                    start: 0,
                    limit: 1000000,
                    sortBy: sortByList,
                    filter: filterStr,
                    relationships: relationships
                };
                setEntityIdField(entityId, transactionsParams);
                var transactionsUri = transactionsSearchUri;
                if (transactionType === 'entity') {
                    transactionsUri = transactionsEntityUri;
                }
                else if (transactionType === 'entityCore') {
                    transactionsUri = transactionsEntityCoreUri;
                }
                else if (transactionType === 'alert') {
                    transactionsUri = transactionsAlertUri;
                }
                else if (transactionType === 'caseEntity') {
                    transactionsUri = transactionsEntityCaseUri.replace(':id', caseId);
                }
                else if (transactionType === 'caseAlert') {
                    transactionsUri = transactionsAlertCaseUri.replace(':id', caseId);
                }
                else {
                    transactionsUri = transactionsSearchUri;
                }
                var specificTransactionsCSVUri = linksProcessor.buildAbsoluteUri(transactionsUri + '.csv', transactionsParams);
                $window.open(specificTransactionsCSVUri, '_blank');
            }
            else {
                // otherwise we can make the request via ngResource and create an in-page hidden link to download the
                // csv
                requestCsv(caseId, entityId, filterStr, sortBys, relationships, transactionType).then(function (result) {
                    if (result && result.data) {
                        // this works in FF/Chrome, but not IE
                        var hiddenLinkElement = document.createElement('a');
                        hiddenLinkElement.href = 'data:attachment/csv;charset=utf-8,' + encodeURI(result.data);
                        hiddenLinkElement.target = '_blank';
                        hiddenLinkElement.download = 'transactions.csv';
                        document.body.appendChild(hiddenLinkElement);
                        hiddenLinkElement.click();
                    }
                    else {
                        messageService.info(resources.aml.transaction.exportCSVNoResults);
                    }
                });
            }
        }
        function setEntityIdField(entityId, transactionsParams) {
            transactionsParams.entityNumber = entityId.entityNumber;
        }
        function setEntityIdFieldsFromEntityId(entityId, transactionsParams) {
            transactionsParams.entityLevelCode = entityId.entityLevelCode;
            transactionsParams.entityKey = entityId.entityKey;
            transactionsParams.entityNumber = entityId.entityNumber;
        }
        /**
         * Get all transactions for an alert on a case.
         * @param caseId
         * @param entityType - type of entity associated for this alert. This pulls from the FSK_ALERT_TRANSACTIONS
         *     which contains transactions for all alerted_entities. As such, it is possible to pull back duplicate
         *     transactions (for HHD AND PTY, for instance), so to prevent that the entityType is also needed in order
         *     to filter on the entities we want.
         * @param alertidsFilter
         * @param startPage
         * @param pageSize
         * @param sortBys
         * @returns {$promise|any|*|Function}
         */
        function getPagedTransactionsByAlertIds(caseId, entityType, alertidsFilter, startPage, pageSize, sortBys) {
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var sortByList = kendoGridRendererService.getSortByString(sortBys);
            // Because of the entity resolution, if the entityType is ACC or HHD, set it to PTY
            if (entityType === 'ACC' || entityType === 'HHD') {
                entityType = 'PTY';
            }
            var transactionsParams = {
                start: startPage,
                limit: pageSize,
                sortBy: sortByList,
                filter: alertidsFilter,
                alertedEntityLevelCode: entityType
            };

//console.log("getPagedTransactionsByAlertIds > caseId : " + caseId);
//console.log("getPagedTransactionsByAlertIds > entityType : " + entityType);

            if (!!caseId) {
//console.log("IF !!!");
                // If called from the case details page, return transactions from the case details in the datamart
                return alertTransactionsCaseResource.get({ id: caseId }, transactionsParams).$promise;
            }
            else {
//console.log("ELSE !!!");
                // If called from the entity details page, return transactions from the daily datamart
//console.log("getPagedTransactionsByAlertIds transactionsParams ", JSON.stringify(transactionsParams));
                return alertTransactionsResource.get(transactionsParams).$promise;
            }
        }
        /**
         * We have a parseCSV function that just returns the data in a JSON object; otherwise ngResource
         * seems to want to parse it as JSON and returns each data character as a property/value.
         */
        function parseCsv(data, headersGetter) {
            return { data: data };
        }
        function getTransactionsAggregates(entityId, groupBy, filterStr) {
            var transactionsParams = {
                groupBy: groupBy
            };
            setEntityIdFieldsFromEntityId(entityId, transactionsParams);
            if (filterStr !== 'all' && filterStr !== null) {
                transactionsParams.relationships = 'alertAggregates';
                transactionsParams.filter = filterStr;
            }
            return customerTransactionAggregatesResource.get(transactionsParams).$promise;
        }
        function getAlertTransactionsAggregates(alertId, groupBy) {
            var transactionsParams = {
                groupBy: groupBy,
                alertId: alertId
            };
            return alertTransactionAggregatesResource.get(transactionsParams).$promise;
        }
        function getNoRecordTemplateForCoreTransactions(caseId) {
            if (!!caseId) {
                return "<b>" + resources.aml.transaction.noAlertedTransactionsForArchivedCaseText + "</b>";
            }
            else {
                //there is no data, ask user to search for core data
                return "<b> " + resources.aml.transaction.noKCTransactions + " </b>";
            }
        }
        function isGridFilterSet(e) {
            return amlCoreUtils.isNotNullOrUndefined(e.data.filter) &&
                e.data.filter.filters && e.data.filter.filters.length > 0;
        }
        function setNoRecordTemplateForTransactions(grid, alertids, caseId, shouldSearchCoreTransactions, e) {
            if (grid && grid.options) {
                if (alertids && alertids !== 'all' || shouldSearchCoreTransactions || isGridFilterSet(e)) {
                    // if there's alerts or filters set or we are already searching core transactions, use default
                    // no-records message
                    grid.options.noRecords.template = kendoGridRendererService.getDefaultNoRecordsTemplate();
                }
                else {
                    grid.options.noRecords.template = getNoRecordTemplateForCoreTransactions(caseId);
                }
                // this uses internal API to have kendo re-generate the template from the noRecords; it typically only
                // generates it once on grid initialization and then caches it; if we update the template during
                // datasource.read() function after the grid initialized, we need to tell kendo to regen the template
                // jscs:disable disallowDanglingUnderscores
                grid.noRecordsTemplate = grid._noRecordsTmpl();
            }
        }
        var service = {
            getTransactionsByPage: getTransactionsByPage,
            getPagedTransactionsByAlertIds: getPagedTransactionsByAlertIds,
            getTransactionsAggregates: getTransactionsAggregates,
            getAlertTransactionsAggregates: getAlertTransactionsAggregates,
            exportTransactionsToCSV: exportTransactionsToCSV,
            getTransactionSearchResult: getTransactionSearchResult,
            getNoRecordTemplateForCoreTransactions: getNoRecordTemplateForCoreTransactions,
            setNoRecordTemplateForTransactions: setNoRecordTemplateForTransactions,
        };
        return service;
    }
})();


(function () {
    'use strict';
    WatchListDetailsController.$inject = ["resources", "$stateParams", "watchListService", "$state", "tabsListService"];
    angular.module('aml.customer').controller('WatchListDetailsController', WatchListDetailsController);
    function WatchListDetailsController(resources, $stateParams, watchListService, $state, tabsListService) {
        var vm = this;
        vm.watchListKey = $stateParams.watchListKey;
        watchListService.getWatchListRecordDetails(vm.watchListKey).then(function (data) {
            vm.watchListRecordData = data;
            updateTabTitle(data.lastName ? data.lastName : data.entityName);
        });
        function updateTabTitle(newTabTitle) {
            var tabInfo = tabsListService.getTabInfo($state.$current.name);
            tabInfo.title = newTabTitle;
            tabInfo.params.entityTabName = newTabTitle;
            tabsListService.updateTabInfo(tabInfo, true);
        }
    }
})();


(function () {
    'use strict';
    AuditEventListController.$inject = ["auditService", "resources", "usersService", "amlConstants", "linksProcessor", "entityService"];
    angular.module('aml.admin').controller('AuditEventListController', AuditEventListController);
    /* jshint maxparams: 12*/
    function AuditEventListController(auditService, resources, usersService, amlConstants, linksProcessor, entityService) {
        var vm = this;
        vm.resources = resources;
        vm.title = entityService.getReadableEntityIdentifier(vm.objectTypeCode, vm.objectId);
        vm.navigateToEvent = navigateToEvent;
        vm.getMoreAuditEvents = getMoreAuditEvents;
        // set permissions based on capabilities
        vm.userCanViewAuditEvents = usersService.currentUserHasCapability(amlConstants.capabilities.viewAuditEvent);
        vm.hasMoreAuditEvents = false;
        var currentAuditEventsPage = 1;
        var auditEventsPageSize = amlConstants.config.audit.events.paging.size;
        activate();
        ////////////////////
        function activate() {
            getAuditEvents();
        }
        function checkForMoreAuditEvents(data) {
            var nextLink = linksProcessor.getLinkHrefForRel(data.links, 'next');
            if (nextLink) {
                vm.hasMoreAuditEvents = true;
            }
            else {
                vm.hasMoreAuditEvents = false;
            }
        }
        function navigateToEvent(event) {
            auditService.navigateToEvent(event, vm.objectTypeCode);
        }
        function getLimit() {
            return currentAuditEventsPage * auditEventsPageSize;
        }
        function getCurrentPageStart() {
            return currentAuditEventsPage * auditEventsPageSize - auditEventsPageSize;
        }
        function processEvents(events) {
            _.each(events, function (auditEvent) {
                auditEvent.activityStr = auditService.getAction(auditEvent, vm.objectTypeCode);
                auditEvent.attribute = auditService.getAttribute(auditEvent, vm.objectTypeCode);
            });
        }
        function getAuditEvents() {
            auditService.getAuditEvents(vm.objectTypeCode, vm.objectId, null, 0, getLimit()).then(function (data) {
                vm.auditEvents = data.items;
                vm.auditEventsCount = data.count;
                checkForMoreAuditEvents(data);
                processEvents(vm.auditEvents);
            });
        }
        function getMoreAuditEvents() {
            currentAuditEventsPage++;
            auditService.getAuditEvents(vm.objectTypeCode, vm.objectId, null, getCurrentPageStart(), auditEventsPageSize).then(function (data) {
                processEvents(data.items);
                vm.auditEventsCount = data.count;
                // add new page of auditEvents to existing list
                _.each(data.items, function (item) {
                    vm.auditEvents.push(item);
                });
                checkForMoreAuditEvents(data);
            });
        }
    }
})();


(function () {
    'use strict';
    AuditLinkController.$inject = ["resources", "usersService", "amlConstants"];
    angular.module('aml.admin').controller('AuditLinkController', AuditLinkController);
    function AuditLinkController(resources, usersService, amlConstants) {
        var vm = this;
        vm.resources = resources;
        // set permissions based on capabilities
        vm.userCanViewAuditEvents = usersService.currentUserHasCapability(amlConstants.capabilities.viewAuditEvent);
    }
})();


/**
 * @ngdoc service
 * @name     aml.admin:auditService
 *
 * @restrict E
 *
 * @description
 * The audit service is used to retrieve and display audit events
 *
 * @element ANY
 *
 * @example
 */
(function () {
    'use strict';
    auditService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "amlConstants", "$state", "entityService", "resources", "amlCoreUtils", "scoreClassificationFilter", "finalDispositionFilter", "alertCloseReasonFilter", "reviewStatusFilter"];
    angular
        .module('aml.admin')
        .factory('auditService', auditService);
    /* jshint maxparams: 13 */
    function auditService($resource, amlConfig, _, exceptionResourceHandler, amlConstants, $state, entityService, resources, amlCoreUtils, scoreClassificationFilter, finalDispositionFilter, alertCloseReasonFilter, reviewStatusFilter) {
        /*
         * mappings for Audit event codes to unique lookup codes
         */
        var AUDIT_EVENT_CODE_MAPPINGS = {
            // general
            CMT: 'CMT',
            DCM: 'DCM',
            ECM: 'ECM',
            DOC: 'DOC',
            DDO: 'DDO',
            EDO: 'EDO',
            CIN: 'CIN',
            OUT: 'OUT',
            RTE: 'RTE',
            // case
            MAN: 'MAN',
            MANCASE: 'MANCASE',
            UPD: 'UPD',
            ADD: 'ADD',
            ADDCASEENTITY: 'ADDCASEENTITY',
            ADDCASEALERT: 'ADDCASEALERT',
            // alert
            CRE: 'CRE',
            CREALERT: 'CREALERT',
            UNS: 'UNS',
            REO: 'REO',
            CLS: 'CLS',
            CLSALERT: 'CLSALERT',
            SUP: 'SUP',
            SUE: 'SUE',
            REM: 'REM',
            IRT: 'IRT',
            // risk assessment
            CLSRA: 'CLSRA',
            CLC: 'CLC',
            CRERA: 'CRERA',
            // Report
            MANREPORT: 'MANREPORT',
            // CDD Review
            MANREVIEW: 'MANREVIEW',
            UPDREVIEW: 'UPDREVIEW'
        };
        /**
         * Resources
         */
        var auditEventsResource = $resource(amlConfig.baseUrl + '/auditEvents', {
            objectTypeCode: '@objectTypeCode',
            categoryCode: '@categoryCode',
            // list parameters
            start: '@start',
            limit: '@limit',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter'
        }, { get: {
                method: 'GET', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            getAuditEvents: getAuditEvents,
            getAction: getAction,
            getAttribute: getAttribute,
            navigateToEvent: navigateToEvent
        };
        return service;
        /////////////////////
        /**
         * Retrieve the localized action name based on the audit event's action code
         *
         * @param auditEvent
         * @param objectTypeCode
         * @returns {null}
         */
        function getAction(auditEvent, objectTypeCode) {
            /*jshint maxcomplexity:17 */
            var actionStr = null;
            if (auditEvent.activity === 'ADD') {
                if (auditEvent.alertId) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.ADDCASEALERT;
                }
                else {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.ADDCASEENTITY;
                }
            }
            else if (auditEvent.activity === 'CLS') {
                if (auditEvent.alertId) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.CLSALERT;
                }
                else if (auditEvent.caseId) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.CLS;
                }
                else if (!auditEvent.reviewKey) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.CLSRA;
                }
            }
            else if (auditEvent.activity === 'CRE') {
                if (auditEvent.alertId) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.CREALERT;
                }
                else {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.CRERA;
                }
            }
            else if (auditEvent.activity === 'MAN') {
                if (auditEvent.caseId) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.MANCASE;
                }
                else if (auditEvent.reviewKey) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.MANREVIEW;
                }
                else {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.MANREPORT;
                }
            }
            else if (auditEvent.activity === 'UPD') {
                if (auditEvent.reviewKey) {
                    actionStr = AUDIT_EVENT_CODE_MAPPINGS.UPDREVIEW;
                }
            }
            if (!actionStr) {
                actionStr = AUDIT_EVENT_CODE_MAPPINGS[auditEvent.activity];
            }
            if (!actionStr) {
                actionStr = auditEvent.activity;
            }
            return actionStr;
        }
        /**
         * Navigate to a related object tab, as specified in an audit event
         * @param auditEvent
         * @param objectTypeCode
         */
        function navigateToEvent(auditEvent, objectTypeCode) {
            /*jshint maxcomplexity:16 */
            if (objectTypeCode === amlConstants.entityType.case) {
                if (auditEvent.activity === 'ADD') {
                    if (auditEvent.alertId) {
                        $state.go('alertDetails', { alertid: auditEvent.alertId });
                    }
                }
                if (auditEvent.entityNumber && auditEvent.entityLevelCode) {
                    var entityId = {
                        entityNumber: auditEvent.entityNumber,
                        entityLevelCode: auditEvent.entityLevelCode,
                        entityKey: auditEvent.entityKey
                    };
                    var entityState = entityService.getStateForEntity(entityId);
                    $state.go(entityState.stateName, entityState.stateParams);
                }
            }
            else if (objectTypeCode === amlConstants.entityType.alert) {
                if (auditEvent.activity === 'ADD') {
                    if (auditEvent.caseId) {
                        $state.go('caseDetails', { caseid: auditEvent.caseId });
                    }
                }
            }
            else if (entityService.isEntityObject(objectTypeCode)) {
                if (auditEvent.activity === 'ADD') {
                    if (auditEvent.caseId) {
                        $state.go('caseDetails', { caseid: auditEvent.caseId });
                    }
                }
                if (auditEvent.activity === 'UPD') {
                    if (auditEvent.caseId) {
                        $state.go('caseDetails', { caseid: auditEvent.caseId });
                    }
                }
            }
        }
        /**
         * Get a readable attribute value based on an audit event attribute
         *
         * @param auditEvent
         * @param objectTypeCode
         * @returns {null}
         */
        function getAttribute(auditEvent, objectTypeCode) {
            /*jshint maxcomplexity:16 */
            var attribute = null;
            if (auditEvent.activity === 'UPD') {
                handleEntityUpdatedEvents(objectTypeCode, auditEvent);
            }
            else if (auditEvent.activity === 'ADD') {
                attribute = handleAddedEvents(objectTypeCode, attribute, auditEvent);
            }
            else if (auditEvent.activity === 'CLS') {
                if (objectTypeCode === amlConstants.entityType.alert && auditEvent.attribute) {
                    attribute = alertCloseReasonFilter(auditEvent.attribute);
                }
                else {
                    handleReviewUpdatedEvents(objectTypeCode, auditEvent);
                }
            }
            else if (auditEvent.activity === 'MAN' || auditEvent.activity === 'CRE') {
                // for "case created/alert created, etc..." don't need to show the attribute
                // as it's just the case/alert id that we're already viewing
                attribute = ''; // don't relist the object id
            }
            else if (auditEvent.activity === 'CMT' ||
                auditEvent.activity === 'DCM' ||
                auditEvent.activity === 'ECM') {
                attribute = resources.aml.getResource('audit.noteIdLabelText', {
                    id: auditEvent.attribute
                });
            }
            else if (auditEvent.activity === 'DOC' ||
                auditEvent.activity === 'DDO' ||
                auditEvent.activity === 'EDO') {
                attribute = resources.aml.getResource('audit.documentIdLabelText', {
                    id: auditEvent.attribute
                });
            }
            if (objectTypeCode === amlConstants.entityType.case && auditEvent.entityNumber && auditEvent.entityLevelCode) {
                auditEvent.clickable = true;
            }
            if (amlCoreUtils.isNullOrUndefined(attribute)) {
                attribute = auditEvent.attribute;
            }
            return attribute;
        }
        function handleEntityUpdatedEvents(objectTypeCode, auditEvent) {
            // Entity-updated attributes are of the form {version}-{requiredYorN}-{relationshipDescription}, like:
            // "2-Y-self"; we will parse this to display a human-readable form of the version
            var vals;
            if (objectTypeCode === amlConstants.entityType.case) {
                vals = auditEvent.attribute.split('-');
                if (vals.length > 1 && auditEvent.entityNumber && auditEvent.entityLevelCode) {
                    auditEvent.attribute = entityService.getReadableEntityIdentifier(auditEvent.entityLevelCode, auditEvent.entityNumber);
                    auditEvent.attribute2 = resources.aml.getResource('audit.entityAddedDescriptionLabelText', {
                        entityVersionNumber: vals[0], requiredYesOrNo: vals[1] });
                }
                auditEvent.clickable = true;
            }
            else if (objectTypeCode === amlConstants.entityType.cddReview && auditEvent.attribute) {
                handleReviewUpdatedEvents(objectTypeCode, auditEvent);
            }
            else if (entityService.isEntityObject(objectTypeCode) && auditEvent.caseId) {
                vals = auditEvent.attribute.split('-');
                if (vals.length > 1 && auditEvent.entityNumber && auditEvent.entityLevelCode) {
                    auditEvent.attribute = entityService.getReadableEntityIdentifier(amlConstants.entityType.case, auditEvent.caseId);
                    auditEvent.attribute2 = resources.aml.getResource('audit.entityAddedDescriptionLabelText', {
                        entityVersionNumber: vals[0], requiredYesOrNo: vals[1] });
                }
                auditEvent.clickable = true;
            }
        }
        function handleReviewUpdatedEvents(objectTypeCode, auditEvent) {
            // Review-updated attributes are either of the form {disposition}--{ratingOverride}, like:
            // "DOWNGRADE--H";  - this one used for CLS event
            // or in the form {updateCode}--{oldValue}--{newValue}, for example: "STA-O-N" - this form
            // is used for UPD event, STA - status change from O to N
            var vals;
            if (objectTypeCode === amlConstants.entityType.cddReview && auditEvent.attribute && auditEvent.activity === 'CLS') {
                vals = auditEvent.attribute.split('--'); // '--' is separator for cdd events
                if (vals.length > 1) {
                    auditEvent.attribute = resources.aml.getResource('audit.reviewDispositionText', { disposition: finalDispositionFilter(vals[0]) });
                    auditEvent.attribute2 = resources.aml.getResource('audit.reviewFinalOverrideText', {
                        rating: scoreClassificationFilter(vals[1]) });
                }
            }
            if (objectTypeCode === amlConstants.entityType.cddReview && auditEvent.attribute && auditEvent.activity === 'UPD') {
                vals = auditEvent.attribute.split('--'); // '--' is separator for cdd events
console.log("----- 0003");
console.log(vals);
                if (vals.length > 1 && vals[0] === 'STA') {
console.log("----- 0004");
console.log(reviewStatusFilter);
                    auditEvent.attribute = resources.aml.getResource('audit.reviewStatusFromText', { status: reviewStatusFilter(vals[1]) });
                    auditEvent.attribute2 = resources.aml.getResource('audit.reviewStatusToText', { status: reviewStatusFilter(vals[2]) });
                }
            }
            if (auditEvent.attribute === '--') {
                // to handle pre- HF4 attributes that can have only '--' value
                // due to error that existed in Java code
                auditEvent.attribute = '';
            }
        }
        function handleAddedEvents(objectTypeCode, attribute, auditEvent) {
            // for alert display, we want to show the case it was added to
            if (objectTypeCode === amlConstants.entityType.alert) {
                // 'add alert to case' action stores case id in the attribute
                attribute = entityService.getReadableEntityIdentifier(amlConstants.entityType.case, auditEvent.attribute);
                // set the attribute as caseid
                auditEvent.caseId = auditEvent.attribute;
                auditEvent.clickable = true;
            }
            else if (objectTypeCode === amlConstants.entityType.case && auditEvent.alertId) {
                attribute = entityService.getReadableEntityIdentifier(amlConstants.entityType.alert, auditEvent.alertId);
                auditEvent.clickable = true;
            }
            else if (entityService.isEntityObject(objectTypeCode) && auditEvent.caseId) {
                // 'add alert to case' action stores case id in
                attribute = entityService.getReadableEntityIdentifier(amlConstants.entityType.case, auditEvent.caseId);
                auditEvent.clickable = true;
            }
            return attribute;
        }
        /**
         * Get a list of all audit events for a given object
         *
         * @returns {$promise|*}
         */
        function getAuditEvents(objectTypeCode, objectId, categoryCode, start, pageSize, sortBys, filterStr, previousCount) {
            var sortByList = null;
            if (!sortBys) {
                // default sort to createdDate, descending
                var sortby = {
                    name: 'createdDate',
                    direction: amlConstants.query.sortDirection.descending };
                sortBys = [sortby];
            }
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return auditEventsResource.get({
                objectTypeCode: objectTypeCode,
                objectId: objectId,
                categoryCode: categoryCode,
                filter: filter,
                sortBy: sortByList,
                start: start,
                limit: pageSize,
                previousCount: previousCount
            }).$promise;
        }
    }
})();


/**
 * Created by jokeun on 5/2/2016.
 */
(function () {
    'use strict';
    listManagerService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler", "resources", "logger"];
    angular
        .module('aml.admin')
        .factory('listManagerService', listManagerService);
    /* @ngInject */
    function listManagerService($resource, amlConfig, exceptionResourceHandler, resources, logger) {
        var categoriesResource = $resource(amlConfig.baseUrl + '/complianceAdmin/categories/:id', {
            id: '@id' // only to get a specific category
        }, {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            delete: {
                method: 'DELETE',
                headers: { 'Content-type': 'application/json' },
                interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var listsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/categories/:catid/lists/:listid', {
            catid: '@id',
            listid: '@id'
        }, {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            delete: {
                method: 'DELETE', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var valuesResource = $resource(amlConfig.baseUrl + '/complianceAdmin/categories/:catid/lists/:listid/values/:valueid', {
            catid: '@id',
            listid: '@id',
            valueid: '@id'
        }, {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST', interceptor: {
                    responseError: invalidListValueErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: invalidListValueErrorHandler } },
            delete: {
                method: 'DELETE', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            createCategory: createCategory,
            createList: createList,
            createValue: createValue,
            deleteCategory: deleteCategory,
            deleteList: deleteList,
            deleteValue: deleteValue,
            getLists: getLists,
            newCategory: newCategory,
            newValue: newValue,
            newList: newList,
            updateCategory: updateCategory,
            updateList: updateList,
            updateValue: updateValue
        };
        return service;
        /////////////////////
        function createCategory(category) {
            return categoriesResource.create(category).$promise;
        }
        function createList(categoryId, list) {
            return listsResource.create({ catid: categoryId }, list).$promise;
        }
        function createValue(categoryId, listId, entry) {
            return valuesResource.create({ catid: categoryId, listid: listId }, entry).$promise;
        }
        function deleteCategory(categoryId) {
            return categoriesResource.delete({ id: categoryId }).$promise;
        }
        function deleteList(categoryId, listId) {
            return listsResource.delete({ catid: categoryId, listid: listId }).$promise;
        }
        function deleteValue(categoryId, listId, valueId) {
            return valuesResource.delete({ catid: categoryId, listid: listId, valueid: valueId }).$promise;
        }
        function getLists() {
            return categoriesResource.get().$promise;
        }
        function updateCategory(category) {
            return categoriesResource.edit({ id: category.key }, category).$promise;
        }
        function updateList(categoryID, list) {
            return listsResource.edit({ catid: categoryID, listid: list.key }, list).$promise;
        }
        function updateValue(categoryID, listID, value) {
            return valuesResource.edit({ catid: categoryID, listid: listID }, value).$promise;
        }
        function newCategory() {
            var category = {
                'name': '',
                'description': '',
                'categoryLists': []
            };
            return category;
        }
        function newValue() {
            var value = {
                'value': '',
                'valuedesc': ''
            };
            return value;
        }
        function newList() {
            var list = {
                'name': '',
                'description': '',
                'validation_type_code': 'N',
                'listItems': []
            };
            return list;
        }
        /////////////////////
        function invalidListValueErrorHandler(error) {
            exceptionResourceHandler.handleResourceError(error, {
                400: function () {
                    var errorMsg = resources.aml.getResource('admin.complianceAdmin.listManager.valueInvalidErrorTxt');
                    logger.error(errorMsg, error.data);
                } });
        }
    }
})();


/**
 * Created by jokeun on 5/2/2016.
 */
(function () {
    'use strict';
    riskClassifiersService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.admin')
        .factory('riskClassifiersService', riskClassifiersService);
    /* @ngInject */
    function riskClassifiersService($resource, amlConfig, exceptionResourceHandler) {
        var categoriesResource = $resource(amlConfig.baseUrl + '/complianceAdmin/classifierCategories/:id', {
            id: '@id' // only to get a specific category
        }, {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            delete: {
                method: 'DELETE', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var classifiersResource = $resource(amlConfig.baseUrl + '/complianceAdmin/classifierCategories/:catid/classifiers/:classifierid', {
            catid: '@id',
            classifierid: '@id'
        }, {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            create: {
                method: 'POST', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            delete: {
                method: 'DELETE', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var factColumnsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/classifierFactColumns', {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var partyDimSourceColumnsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/partyDimSourceColumns', {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var accountDimSourceColumnsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/accountDimSourceColumns', {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var partyProfileSourceColumnsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/partyProfileFactSourceColumns', {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var operatorsResource = $resource(amlConfig.baseUrl + '/complianceAdmin/classifierOperators', {
            get: {
                method: 'GET', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            createCategory: createCategory,
            createClassifier: createClassifier,
            getAccountDimSourceColumns: getAccountDimSourceColumns,
            getCategories: getCategories,
            getClassifiers: getClassifiers,
            getRCFactColumns: getRCFactColumns,
            getOperators: getOperators,
            getPartyDimSourceColumns: getPartyDimSourceColumns,
            getPartyProfileSourceColumns: getPartyProfileSourceColumns,
            deleteCategory: deleteCategory,
            deleteClassifier: deleteClassifier,
            newCategory: newCategory,
            newClassifier: newClassifier,
            updateCategory: updateCategory,
            updateClassifier: updateClassifier
        };
        return service;
        /////////////////////
        function createCategory(category) {
            return categoriesResource.create(category).$promise;
        }
        function createClassifier(classifier) {
            /*jshint camelcase: false */
            return classifiersResource.create({ catid: classifier.category_key, classifierid: classifier.key }, classifier).$promise;
        }
        function deleteCategory(categoryId) {
            return categoriesResource.delete({ id: categoryId }).$promise;
        }
        function deleteClassifier(categoryId, classifierId) {
            return classifiersResource.delete({ catid: categoryId, classifierid: classifierId }).$promise;
        }
        function getCategories() {
            return categoriesResource.get().$promise;
        }
        function getClassifiers(categoryId) {
            return classifiersResource.get({ catid: categoryId }).$promise;
        }
        function getRCFactColumns() {
            return factColumnsResource.get().$promise;
        }
        function getOperators() {
            return operatorsResource.get().$promise;
        }
        function getAccountDimSourceColumns() {
            return accountDimSourceColumnsResource.get().$promise;
        }
        function getPartyDimSourceColumns() {
            return partyDimSourceColumnsResource.get().$promise;
        }
        function getPartyProfileSourceColumns() {
            return partyProfileSourceColumnsResource.get().$promise;
        }
        function updateCategory(category) {
            return categoriesResource.edit({ id: category.key }, category).$promise;
        }
        function updateClassifier(classifier) {
            /*jshint camelcase: false */
            return classifiersResource.edit({ catid: classifier.category_key, classifierid: classifier.key }, classifier).$promise;
        }
        function newCategory() {
            var category = {
                'name': '',
                'description': ''
            };
            return category;
        }
        function newClassifier(categoryKey) {
            var classifier = {
                'active': 'Y',
                'category_key': categoryKey,
                'classifierDesc': '',
                'classifierName': '',
                'classifierShortDesc': '',
                'key': '',
                'list_id': '',
                'list_key': '',
                'locked': '',
                'rc_fact_column': '',
                'risk_classifier_category_id': '',
                'source_column': '',
                'source_table': '',
                'type': '',
                'version_number': 1,
                'weight': ''
            };
            return classifier;
        }
    }
})();


/**
 * Created by tomutd on 4/10/2015.
 */
(function () {
    'use strict';
    PreferencesController.$inject = ["adminService", "linksProcessor", "_", "$window", "resources", "amlConstants", "amlPreferencesService", "messageService", "$scope", "dialogService"];
    angular.module('aml.admin').controller('PreferencesController', PreferencesController);
    function PreferencesController(adminService, linksProcessor, _, $window, resources, amlConstants, amlPreferencesService, messageService, $scope, dialogService) {
        var vm = this;
        vm.resources = resources;
        vm.preferenceObjects = [];
        vm.updatePreferences = updatePreferences;
        vm.resetPreferencesToDefaults = resetPreferencesToDefaults;
        activate();
        //////////////////
        function activate() {
            var prefs = amlConstants.config;
            collectAllPreferenceNamesFromObjectTree(prefs, null);
        }
        function collectAllPreferenceNamesFromObjectTree(obj, parent) {
            for (var property in obj) {
                if (obj.hasOwnProperty(property) && property.indexOf('$') !== 0) {
                    var parentProp = parent ? parent + '.' : '';
                    var propName = parentProp + property;
                    if (typeof obj[property] === 'object') {
                        collectAllPreferenceNamesFromObjectTree(obj[property], propName);
                    }
                    else {
                        var type = typeof obj[property];
                        var prefObject = {
                            name: propName,
                            description: getDescription(propName),
                            type: type,
                            value: obj[property],
                            readOnly: false
                        };
                        vm.preferenceObjects.push(prefObject);
                    }
                }
            }
        }
        /**
         * Get description for this preference from resources file, found in the form:
         *  preferences.description._full_._preference_._path_
         * @param preferenceName
         * @returns {string}
         */
        function getDescription(preferenceName) {
            var description = null;
            // look for full dot-based json name
            description = resources.aml.preferences.descriptions[preferenceName];
            if (!description) {
                // otherwise look for it via json path
                var keys = preferenceName.split('.');
                var resourceValue = resources.aml.preferences.descriptions;
                for (var i = 0; i < keys.length - 1; i++) {
                    if (resourceValue) {
                        resourceValue = resourceValue[keys[i]];
                    }
                }
                var propLeafName = keys[keys.length - 1];
                // make sure it actually exists
                if (resourceValue && resourceValue.hasOwnProperty(propLeafName)) {
                    description = resourceValue[propLeafName];
                }
            }
            return description;
        }
        function resetPreferencesToDefaults() {
            dialogService.openConfirmDialog(resources.aml.admin.preferences.resetToDefaultsConfirmationWindowTitle, resources.aml.admin.preferences.resetToDefaultsConfirmationWindowText)
                .then(function okayPressed() {
                amlPreferencesService.resetAMLPreferencesToDefaults().then(function (data) {
                    adminService.clearLocalClientCache();
                    adminService.refreshPageWithMessage(resources.aml.admin.preferences.resetToDefaultsSuccess);
                });
            });
        }
        function updatePreferences() {
            var existingPrefsToBeUpdated = $.extend(true, {}, amlConstants.config);
            _.each(vm.preferenceObjects, function (prefObject) {
                var keys = prefObject.name.split('.');
                var resourceValue = existingPrefsToBeUpdated;
                for (var i = 0; i < keys.length - 1; i++) {
                    if (resourceValue) {
                        resourceValue = resourceValue[keys[i]];
                    }
                }
                var propLeafName = keys[keys.length - 1];
                // make sure it actually exists
                if (resourceValue.hasOwnProperty(propLeafName)) {
                    if (prefObject.type === 'boolean' && !prefObject.value) {
                        prefObject.value = false;
                    }
                    resourceValue[propLeafName] = prefObject.value;
                }
            });
            amlPreferencesService.updateAMLPreferences(existingPrefsToBeUpdated).then(function (data) {
                adminService.clearLocalClientCache();
                adminService.refreshPageWithMessage(resources.aml.admin.preferences.updatedSuccess);
            });
            // reset form dirty flag
            $scope.preferencesForm.$dirty = false;
        }
    }
})();


/**
 * Created by dabock on 11/14/2016.
 */
(function () {
    'use strict';
    PeerGroupController.$inject = ["resources", "kendoGridRendererService", "peerGroupService", "$stateParams", "$filter", "moment"];
    angular.module('aml.customer.details').controller('PeerGroupController', PeerGroupController);
    function PeerGroupController(resources, kendoGridRendererService, peerGroupService, $stateParams, $filter, moment) {
        var vm = this;
        vm.resources = resources;
        vm.alertId = $stateParams.alertId;
        /* ACCOUNT SUMMARY GROUP METRICS */
        vm.accountSummaryGroupGridColumns = [
            {
                field: 'profileGroupName',
                title: resources.aml.peerGroupAnalysis.profileGroupNameHeaderTitle,
                width: 80
            },
            {
                field: 'summaryGroupName',
                title: resources.aml.peerGroupAnalysis.summaryGroupNameHeaderTitle,
                width: 80
            },
            {
                field: 'transCount',
                title: resources.aml.peerGroupAnalysis.transCountHeaderTitle,
                width: 80
            },
            {
                field: 'transAmount',
                title: resources.aml.peerGroupAnalysis.transAmountHeaderTitle,
                width: 80
            },
            {
                field: 'log10TransCount',
                title: resources.aml.peerGroupAnalysis.log10TransCountHeaderTitle,
                width: 80
            }
        ];
        vm.getAccountSummaryGroupMetrics = function (gridCallBack) {
            peerGroupService.getAccountSummaryGroupMetrics($stateParams.alertId)
                .then(function (data) {
                gridCallBack.success(data.items);
                if (data.items[0]) {
                    vm.summaryPeriodCode = data.items[0].summaryPeriodCode;
                    vm.period = periodString(data.items[0].summaryBeginDateKey, vm.summaryPeriodCode);
                    // Now that vm.summaryPeriodCode is set, call these:
                    getAggregatedAccountMetrics();
                    getHistoricalMetrics();
                }
            });
        };
        function periodString(summaryBeginDateKey, summaryPeriodCode) {
            var startDateMoment = moment(summaryBeginDateKey, 'YYYYMMDD');
            var startDate = moment(startDateMoment).toDate();
            var endDate;
            if (summaryPeriodCode === 'M') {
                endDate = startDateMoment.add(1, 'months').toDate();
            }
            else if (summaryPeriodCode === 'W') {
                endDate = startDateMoment.add(1, 'weeks').toDate();
            }
            else if (summaryPeriodCode === 'D') {
                endDate = startDateMoment.add(1, 'days').toDate();
            }
            return $filter('date')(startDate, 'shortDate') +
                ' - ' +
                $filter('date')(endDate, 'shortDate');
        }
        /* AGGREGATED ACCOUNT METRICS */
        function getAggregatedAccountMetrics() {
            peerGroupService.getAggregatedAccountMetrics($stateParams.alertId)
                .then(function (data) {
                vm.currentDate = data.items[0].summaryBeginDateKey;
                vm.previousDate = data.items[0].summaryBeginDateKey2;
                vm.aggregatedAccountMetricsItems = data.items;
                vm.aggregatedAccountMetricsGridColumns = [
                    {
                        field: 'profileGroupName',
                        title: resources.aml.peerGroupAnalysis.profileGroupNameHeaderTitle,
                        width: 80
                    },
                    {
                        field: 'metric',
                        title: resources.aml.peerGroupAnalysis.metricHeaderTitle,
                        width: 80,
                        template: '{{dataItem.metric | metric}}'
                    },
                    {
                        field: 'value',
                        title: resources.aml.getResource('peerGroupAnalysis.periodHeaderTitle', { period: periodString(vm.currentDate, vm.summaryPeriodCode) }),
                        width: 80
                    }
                ];
                // If there's a previousDate, then add a previous date column.
                if (vm.previousDate) {
                    vm.aggregatedAccountMetricsGridColumns.push({
                        field: 'value2',
                        title: resources.aml.getResource('peerGroupAnalysis.periodHeaderTitle', { period: periodString(vm.previousDate, vm.summaryPeriodCode) }),
                        width: 80
                    });
                }
            });
        }
        vm.getAggregatedAccountMetrics = function (gridCallback) {
            gridCallback.success(vm.aggregatedAccountMetricsItems);
        };
        /* HISTORICAL METRICS */
        function getHistoricalMetrics() {
            peerGroupService.getHistoricalMetrics($stateParams.alertId)
                .then(function (data) {
                vm.historicalMetricsItems = data.items;
                vm.historicalMetricsGridColumns = [
                    {
                        field: 'profileGroupName',
                        title: resources.aml.peerGroupAnalysis.profileGroupNameHeaderTitle,
                        width: 80
                    },
                    {
                        field: 'metric',
                        title: resources.aml.peerGroupAnalysis.metricHeaderTitle,
                        width: 80,
                        template: '{{dataItem.metric | metric}}'
                    },
                    {
                        field: 'entityValue',
                        title: resources.aml.getResource('peerGroupAnalysis.accountMetricsForPeriodHeaderTitle', { period: periodString(data.entityStartDate, vm.summaryPeriodCode) }),
                        width: 160
                    },
                    {
                        field: 'groupValue',
                        title: resources.aml.getResource('peerGroupAnalysis.peerGroupMetricsForPeriodHeaderTitle', { period: periodString(data.groupStartDate, vm.summaryPeriodCode) }),
                        width: 160
                    }
                ];
            });
        }
        vm.getHistoricalMetrics = function (gridCallback) {
            gridCallback.success(vm.historicalMetricsItems);
        };
    }
})();


(function () {
    'use strict';
    peerGroupService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler"];
    angular
        .module('aml.customer.details')
        .factory('peerGroupService', peerGroupService);
    function peerGroupService($resource, amlConfig, exceptionResourceHandler) {
        var accountSummaryGroupMetricsResource = $resource(amlConfig.baseUrl + '/alerts/:id/accountSummaryGroupMetrics', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var aggregatedAccountMetricsResource = $resource(amlConfig.baseUrl + '/alerts/:id/aggregatedAccountMetrics', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var historicalMetricsResource = $resource(amlConfig.baseUrl + '/alerts/:id/historicalMetrics', {
            id: '@id'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        function getAccountSummaryGroupMetrics(id) {
            return accountSummaryGroupMetricsResource.get({ id: id }).$promise;
        }
        function getAggregatedAccountMetrics(id) {
            return aggregatedAccountMetricsResource.get({ id: id }).$promise;
        }
        function getHistoricalMetrics(id) {
            return historicalMetricsResource.get({ id: id }).$promise;
        }
        return {
            getAccountSummaryGroupMetrics: getAccountSummaryGroupMetrics,
            getAggregatedAccountMetrics: getAggregatedAccountMetrics,
            getHistoricalMetrics: getHistoricalMetrics
        };
    }
})();


/**
 * Created by raniel on 3/10/2016.
 */
(function () {
    'use strict';
    AlertTriageCaseListController.$inject = ["resources", "customerService", "amlConstants", "linksProcessor", "kendoGridRendererService", "logger", "$scope", "amlLov", "$state", "casesService", "entityService", "usersService"];
    angular.module('aml.core').controller('AlertTriageCaseListController', AlertTriageCaseListController);
    /* jshint maxparams: 14*/
    function AlertTriageCaseListController(resources, customerService, amlConstants, linksProcessor, kendoGridRendererService, logger, $scope, amlLov, $state, casesService, entityService, usersService) {
        var vm = this;
        vm.resources = resources;
        vm.casesCount = 0;
        vm.selectedCaseId = null;
        vm.grid = {};
        // display case duration in months based on configurable lookback value
        var numOfDaysToLookBack = amlConstants.config.customers.caseActivityLookBackNumOfDays;
        vm.caseDuration = Math.round(numOfDaysToLookBack / 30);
        //closeDate: {type: 'date'},
        var dataSourceOptions = {
            transport: {
                read: getCases
            },
            schema: {
                model: {
                    fields: {
                        caseId: { type: 'string' },
                        description: { type: 'string' },
                        statusCode: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: vm.pageSize || 10,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            { field: 'caseId', title: resources.aml.cases.id,
                width: 130,
                template: kendoGridRendererService.titleCase('caseId')
            },
            {
                field: 'description', title: resources.aml.cases.description,
                template: kendoGridRendererService.titleCase('description'),
                width: 300
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            selectable: 'true'
        });
        vm.handleRowSelect = function (data) {
            if (data && data.caseId) {
                vm.selectedCaseId = data.caseId;
            }
            else {
                vm.selectedCaseId = null;
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'customerCasesList');
        }
        function getCases(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data);
            var currentUserId = usersService.getCurrentUserId();
            var filterStr = null;
            if (vm.editable === true) {
                var filter = {
                    logic: 'or',
                    filters: [
                        {
                            field: 'CASE_STATUS_CODE',
                            operator: 'eq',
                            value: 'O'
                        },
                        {
                            field: 'CASE_STATUS_CODE',
                            operator: 'eq',
                            value: 'S'
                        }
                    ]
                };
                filterStr = kendoGridRendererService.getCustomFilterString(filter, vm.gridOptions, e.data.filter);
            }
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.casesCount;
            }
            casesService.getCases(pageInfo.start, pageInfo.limit, sortCols, filterStr, currentUserId, previousCount, vm.entityId).then(function (data) {
                vm.casesCount = data.count;
                e.success(data);
            }, function (data, status, headers, config) {
                logger.error(resources.aml.cases.couldNotLoadCasesErrorText);
            });
        }
    }
})();


(function () {
    'use strict';
    CasesListController.$inject = ["casesService", "logger", "linksProcessor", "kendoGridRendererService", "$state", "$q", "$timeout", "resources", "amlConstants", "amlLov", "usersService", "$scope", "casesListDataMessagingService"];
    angular
        .module('aml.cases')
        .controller('CasesListDirectiveController', CasesListController);
    /* jshint maxparams: 14*/
    /* jshint maxstatements: 50 */
    function CasesListController(casesService, logger, linksProcessor, kendoGridRendererService, $state, $q, $timeout, resources, amlConstants, amlLov, usersService, $scope, casesListDataMessagingService /*, $locale*/) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        var firstDataLoad = true;
        vm.showOverview = false;
        vm.casesCount = null;
        var defaultPageSize = Math.max(50, amlConstants.config.caseListPageSize);
        vm.selectedItemsCount = 0;
        var resetToFirstPage = (amlConstants.config && amlConstants.config.caseList && angular.isDefined(amlConstants.config.caseList.resetToFirstPage) ?
            amlConstants.config.caseList.resetToFirstPage : true);
        var dataSourceOptions = {
            transport: {
                read: getCases
            },
            schema: {
                model: {
                    fields: {
                        timeRemaining: { type: 'number' },
                        caseId: { type: 'number' },
                        description: { type: 'string' },
                        casePriorityCode: { type: 'string' },
                        caseCategoryCode: { type: 'string' },
                        caseSubcategoryCode: { type: 'string' },
                        statusCode: { type: 'string' },
                        createDate: { type: 'date' },
                        activateDate: { type: 'date' },
                        queueCode: { type: 'string' },
                        employeeIndicator: { type: 'string' },
                        ownerUserLongId: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: defaultPageSize,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            {
                field: 'timeRemaining', title: resources.aml.cases.timeRemaining,
                width: '6%',
                template: kendoGridRendererService.countdownColumnRenderer('CAS'),
                filterable: false,
                sortable: false
            },
            {
                field: 'caseId', title: resources.aml.cases.id,
                width: '6%'
            },
            {
                field: 'description', title: resources.aml.cases.description,
                width: '15%'
            },
            {
                field: 'employeeIndicator', title: resources.aml.reviews.employeeIndicatorHeaderTitle,
                width: '5%',
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'caseCategoryCode', title: resources.aml.cases.caseCategoryCode,
                template: '{{dataItem.caseCategoryCode}} {{dataItem.caseCategoryCode | caseCategory}}',
                filterable: kendoGridRendererService.getCheckboxFilter('caseCategory'),
                width: '10%'
            },
            {
                field: 'caseSubcategoryCode', title: resources.aml.cases.caseSubcategoryCode,
                template: '{{dataItem.caseSubcategoryCode}} {{dataItem.caseSubcategoryCode | caseSubcategory}}',
                filterable: kendoGridRendererService.getCheckboxFilter('caseSubcategory'),
                width: '10%'
            },
            {
                field: 'casePriorityCode', title: resources.aml.cases.casePriorityCode,
                width: '7%',
                template: kendoGridRendererService.enum('casePriorityCode', 'priority'),
                filterable: kendoGridRendererService.getCheckboxFilter('priority')
            },
            {
                field: 'statusCode', title: resources.aml.cases.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'caseStatus'),
                filterable: kendoGridRendererService.getCheckboxFilter('caseStatus'),
                width: '7%'
            },
            {
                field: 'createDate',
                width: '9%',
                title: resources.aml.cases.createDate,
                template: kendoGridRendererService.longDate('createDate')
            },
            {
                field: 'activateDate',
                width: '9%',
                title: resources.aml.cases.activateDate,
                template: kendoGridRendererService.longDate('activateDate')
            },
            {
                field: 'queueCode', title: resources.aml.entity.queue,
                width: '8%',
                filterable: kendoGridRendererService.getCheckboxFilter('queueName'),
                template: '{{dataItem.queueCode | queueName:true}}'
            },
            {
                field: 'ownerUserLongId',
                width: '9%',
                title: resources.aml.cases.owner,
                template: '{{dataItem.ownerUserLongId | userName:true}}'
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: Math.max(400, amlConstants.config.caseListTableHeight),
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            dataBound: function (val) {
                if (firstDataLoad) {
                    kendoGridRendererService.selectFirstRow(vm.grid);
                    firstDataLoad = false;
                }
            }
        });
        function updateSelectedCount(items) {
            vm.selectedItemsCount = 0;
            if (items) {
                vm.selectedItemsCount = items.length;
                return;
            }
            if (vm.grid) {
                var selectedItems = vm.grid.select();
                if (selectedItems) {
                    vm.selectedItemsCount = selectedItems.length;
                }
            }
        }
        function getFilterWithQueueDisplayType(filter) {
            var combinedFilter;
            var displayQueueType = getDisplayCasesType();
            if (displayQueueType === amlConstants.casesListQueueDisplayType.MY) {
                var currentUserName = getMyCasesOnlyUser();
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'eq( ownerUserLongId, \'' + currentUserName + '\')');
            }
            else if (displayQueueType === amlConstants.casesListQueueDisplayType.AVAILABLE) {
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'blank( ownerUserLongId )');
            }
            else {
                combinedFilter = filter;
            }
            return combinedFilter;
        }
        vm.handleRowSelect = function (casesRows) {
            if (casesRows && casesRows.length > 0) {
                // update case overview when a case is selected;
                // if multiple rows selected, don't updated the case summary
                vm.selectedItemsCount = casesRows.length;
                if (casesRows.length === 1) {
                    selectCases(casesRows[0]);
                }
            }
            else {
                // if no case selected, clear the overview
                clearCases();
                vm.selectedItemsCount = 0;
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'casesList');
            // set function on the dataMessagingService to get selected cases based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            casesListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedCasesFromSelectedRows, refreshGrid);
            $scope.$watch(function () {
                return casesListDataMessagingService.getDisplayOwnersType();
            }, function (displayCasesWithOwnersType, oldValue) {
                if (displayCasesWithOwnersType === oldValue) {
                    return;
                }
                myCasesFilterChanged(displayCasesWithOwnersType);
            });
            $scope.$on('casesOwnerChanged', function (event, changedData) {
                updateCasesOwner(changedData.caseNumbers, changedData.owner, changedData.queue);
            });
        }
        function refreshGrid() {
            kendoGridRendererService.refreshGrid(vm.grid, resetToFirstPage);
        }
        // on double-click, go to case detail page
        function handleDoubleClick(evt, data) {
            var selectedCase = vm.grid.dataItem(evt.currentTarget);
            updateSelectedCount();
            if (selectedCase && selectedCase.caseId) {
                $state.go('caseDetails', { caseid: selectedCase.caseId });
            }
        }
        function updateCasesOwner(caseNumbers, owner, queue) {
            /*
             If queue = '', that means remove any currently-assigned queue.
             If queue is undefined, that means don't change the queue.
            */
            kendoGridRendererService.updateDataItems(caseNumbers, 'caseId', function (caseToBeUpdated) {
                caseToBeUpdated.ownerUserLongId = owner;
                if (typeof queue !== 'undefined') {
                    // queue is undefined if the user is clicking "Claim" or "Return to Queue".
                    caseToBeUpdated.queueCode = queue;
                }
            }, vm.grid);
        }
        /**
         * Get the selected cases based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedCasesFromSelectedRows() {
            var cases = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aCase = vm.grid.dataItem(rowSelection);
                    if (aCase) {
                        cases.push(aCase);
                    }
                });
            }
            updateSelectedCount(cases);
            return cases;
        }
        function getCases(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            // add queue filtering (My Cases, etc) to the grid filter
            filterStr = getFilterWithQueueDisplayType(filterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.casesCount;
            }
            casesService.getCases(pageInfo.start, pageInfo.limit, sortCols, filterStr, null, previousCount).then(function (data) {
                vm.casesCount = data.count;
                // if no cases returned, clear the case summary
                if (vm.casesCount === 0) {
                    clearCases();
                }
                e.success(data);
                updateSelectedCount();
            }, function (data, status, headers, config) {
                clearCases();
                updateSelectedCount();
                logger.error(resources.aml.cases.couldNotLoadCasesErrorText);
            });
        }
        function myCasesFilterChanged(displayCasesType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
            updateSelectedCount();
        }
        function getDisplayCasesType() {
            return casesListDataMessagingService.getDisplayOwnersType();
        }
        function getMyCasesOnlyUser() {
            return usersService.getCurrentUserId();
        }
        function selectCases(aCase) {
            vm.currentCase = aCase;
            // Reset selected alerts to none when loading case details page.
            //        dataMessagingService.setAlertIds('alertids', 'all');
            //        casesListDataMessagingService.setTotalAmount(amount);
            vm.showOverview = true;
        }
        function clearCases() {
            vm.currentCase = null;
            vm.showOverview = false;
        }
    }
})();


(function () {
    'use strict';
    CommentsSidebarDirectiveController.$inject = ["resources", "commentService", "amlLov", "usersService", "amlConstants", "dialogService", "$scope", "linksProcessor", "attachmentService"];
    angular.module('aml.core').controller('CommentsSidebarDirectiveController', CommentsSidebarDirectiveController);
    function CommentsSidebarDirectiveController(resources, commentService, amlLov, usersService, amlConstants, dialogService, $scope, linksProcessor, attachmentService) {
        var vm = this;
//console.log("000011" + amlLov.commentCategoryCases);
//console.log(amlLov.commentCategoryCasesDel);
//console.log("$(location).attr('pathname') : " + $(location).attr('pathname'));
console.log("CommentsSidebarDirectiveController $(location).attr('href') : " + $(location).attr('href'));
        var tmp_commentCategory = amlLov.commentCategory;
        var hrefStr = $(location).attr('href').toUpperCase();
        if(hrefStr.indexOf('CUSTOMERS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('EXTERNALPARTIES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('CASES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCases;
        }else if(hrefStr.indexOf('ENTITIES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('REGULATORYREPORTS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryReport;
        }else if(hrefStr.indexOf('CDDREVIEWS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCddreviews;
        }else if(hrefStr.indexOf('ALERTS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCasesDel;
        }
        
        vm.resources = resources;
        vm.getLinkForAttachment = getLinkForAttachment;
        vm.commentCategories = amlLov.getAsArray(tmp_commentCategory);
        vm.commentCategoriesForFilter = amlLov.getAsArray(tmp_commentCategory);
        // add default All Categories as the first filter
        vm.commentCategoriesForFilter.unshift({ key: null, value: resources.aml.comments.categoriesFilterAllLabel });
        vm.categoryCodeFilter = null;
        vm.categoryCodeFilterChanged = categoryCodeFilterChanged;
        vm.togglePinSidebar = togglePinSidebar;
        vm.closeSidebar = closeSidebar;
        vm.addNewComment = addNewComment;
        vm.editComment = editComment;
        vm.deleteComment = deleteComment;
        vm.commentAdded = commentAdded;
        vm.getMoreComments = getMoreComments;
        // current user to use when determining if user can delete comments they own
        vm.currentUser = usersService.getCurrentUserId();
        // set permissions based on capabilities
        vm.userCanCreateComments = usersService.currentUserHasCapability(amlConstants.capabilities.createComment);
        vm.userCanDeleteAllComments = usersService.currentUserHasCapability(amlConstants.capabilities.deleteAllComments);
        vm.userCanDeleteMyComment = usersService.currentUserHasCapability(amlConstants.capabilities.deleteComment);
        vm.userCanEditComments = usersService.currentUserHasCapability(amlConstants.capabilities.editComment);
        vm.hasMoreComments = false;
        var currentCommentsPage = 1;
        var commentsPageSize = amlConstants.config.comments.paging.size;
        activate();
        ////////////////////
        function activate() {
            vm.commentsOptions.defaultOpen = commentService.getDefaultCommentsSidebarOpen();
            $scope.$watch(function () { return vm.commentsOptions.displayComments; }, function (newVal) {
                if (newVal) {
                    getComments();
                }
                else {
                    vm.comments = null;
                    vm.hasMoreComments = false;
                }
            });
            if (vm.commentsOptions.displayComments) {
                getComments();
            }
        }
        function checkForMoreComments(data) {
            var nextLink = linksProcessor.getLinkHrefForRel(data.links, 'next');
            if (nextLink) {
                vm.hasMoreComments = true;
            }
            else {
                vm.hasMoreComments = false;
            }
        }
        function togglePinSidebar() {
            commentService.toggleDefaultSidebarState();
        }
        function closeSidebar() {
            vm.commentsOptions.displayComments = false;
        }
        function getLimit() {
            return currentCommentsPage * commentsPageSize;
        }
        function getCurrentPageStart() {
            return currentCommentsPage * commentsPageSize - commentsPageSize;
        }
        function getComments() {
console.log(vm.objectTypeCode);
console.log(vm.objectId);
console.log(vm.categoryCodeFilter);
console.log(getLimit());
            commentService.getComments(vm.objectTypeCode, vm.objectId, vm.categoryCodeFilter, 0, getLimit()).then(function (data) {
                vm.comments = data.items;
                // set count on the commentsOptions which is shared by the comment toggle button (which displays
                // current comment count) but only if no filters were set, as in that case the count is only for
                // number of filtered items
                if (!vm.categoryCodeFilter) {
                    vm.commentsOptions.commentsCount = data.count;
                }
                checkForMoreComments(data);
            });
        }
        function getLinkForAttachment(attachment) {
            return attachmentService.getLinkForAttachment(attachment);
        }
        function getMoreComments() {
            currentCommentsPage++;
            commentService.getComments(vm.objectTypeCode, vm.objectId, vm.categoryCodeFilter, getCurrentPageStart(), commentsPageSize).then(function (data) {
                // add new page of comments to existing list
                _.each(data.items, function (item) {
                    vm.comments.push(item);
                });
                // set count on the commentsOptions which is shared by the comment toggle button (which displays
                // current comment count); actually don't want to do this as if filter, then the count is less
                //vm.commentsOptions.commentsCount = data.count;
                checkForMoreComments(data);
            });
        }
        function categoryCodeFilterChanged() {
            getComments();
        }
        function addNewComment() {
            vm.commentsOptions.addingNewComment = true;
        }
        function editComment(comment) {
            comment.isEditing = true;
        }
        function commentAdded(comment, commentRequestPromise) {
//console.log("commentAdd 001");
            if (vm.comments) {
                vm.comments.unshift(comment);
            }
            commentRequestPromise.then(function (comment) {
                // update count with new comment
                vm.commentsOptions.commentsCount = vm.commentsOptions.commentsCount + 1;
            
							var hrefStr = $(location).attr('href').toUpperCase();
	        		if(hrefStr.indexOf('CDDREVIEWS') != -1){
		            var tempVm = usersService.getCddReviewsVm();
		                
//console.log("commentAdded ::::::::::: ");
//console.log(usersService.getCddReviewsVm())
		
								if(vm.commentsOptions.commentsCount > 0 
										&& tempVm.reviewDetail.initialRiskRating == "H" 
										&& tempVm.grpLevel == "3"){
		            	$("#tranStatusShow").show();
		          	}else if(vm.commentsOptions.commentsCount > 0 
		          			&& tempVm.reviewDetail.initialRiskRating == "H" 
		          			&& tempVm.grpLevel != "3"){
		          		$("#tranStatusShow").hide();
		          	}else{
		          		$("#tranStatusShow").show();
		          	}
								tempVm.reviewDetail.transStatus = "";
	
		          }	// CDDREVIEWS  

            });
//console.log(vm);
	      }
        function deleteComment(comment) {
//console.log("deleteComment 001");
            dialogService.openConfirmDialog(resources.aml.comments.deleteConfirmationWindowTitle, resources.aml.comments.deleteConfirmationText)
                .then(function okayPressed() {
                // TODO: should also cascade attachment deletes on server
                commentService.deleteComment(comment).then(function () {
                    // update count to reflect the deleted comment
                    vm.commentsOptions.commentsCount = vm.commentsOptions.commentsCount > 0 ?
                        vm.commentsOptions.commentsCount - 1 : 0;

										var hrefStr = $(location).attr('href').toUpperCase();
				        		if(hrefStr.indexOf('CDDREVIEWS') != -1){

											var tempVm = usersService.getCddReviewsVm();
//console.log(comment);
//console.log("vm.commentsOptions.commentsCount : " + vm.commentsOptions.commentsCount);
					          	
											if(vm.commentsOptions.commentsCount > 0 
													&& tempVm.reviewDetail.initialRiskRating == "H" 
													&& tempVm.grpLevel == "3"){
					            	$("#tranStatusShow").show();
					          	}else if(vm.commentsOptions.commentsCount > 0 
					          			&& tempVm.reviewDetail.initialRiskRating == "H" 
					          			&& tempVm.grpLevel != "3"){
					          		$("#tranStatusShow").hide();
					          	}else if(vm.commentsOptions.commentsCount > 0 
					          			&& tempVm.reviewDetail.initialRiskRating != "H" 
					          			&& tempVm.grpLevel != "3"){
					          		$("#tranStatusShow").show();
					          	}else{
					          		$("#tranStatusShow").hide();
					          	}
					          	tempVm.reviewDetail.transStatus = "";
			          		}	// CDDREVIEWS 
	                

                });
                var index = _.indexOf(vm.comments, comment);
                vm.comments.splice(index, 1);
                
            });
        }
    }
})();


/**
 * @ngdoc directive
 * @name    aml.core:commentsSidebar
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'customerList' directive is used to generate a list of customers
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-comments-sidebar></aml-comments-sidebar>
 </pre>
 */
(function () {
    'use strict';
    angular
        .module('aml.core')
        .directive('amlCommentsSidebar', amlCommentsSidebar);
    /* @ngInject */
    function amlCommentsSidebar() {
        var directive = {
            restrict: 'E',
            templateUrl: 'core/comments/commentsSidebarDirective.html',
            controller: 'CommentsSidebarDirectiveController',
            controllerAs: 'vm',
            scope: {
                //  the scope is isolated
                objectId: '=',
                objectTypeCode: '=',
                commentsOptions: '='
            },
            bindToController: true
        };
        return directive;
    }
})();


/**
 * @ngdoc service
 * @name     aml.customer:attachmentService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve comments from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    attachmentService.$inject = ["$resource", "amlConfig", "exceptionResourceHandler", "linksProcessor", "amlCoreUtils"];
    angular
        .module('aml.core')
        .factory('attachmentService', attachmentService);
    /* @ngInject */
    function attachmentService($resource, amlConfig, exceptionResourceHandler, linksProcessor, amlCoreUtils) {
        var attachmentAddedCallbackFns = [];
        var attachmentDeletedCallbackFns = [];
        var attachmentsContentResource = $resource(amlConfig.baseUrl + '/attachments/content', {}, {
            save: {
                method: 'POST',
                transformRequest: formDataObject,
                headers: { 'Content-Type': undefined, enctype: 'multipart/form-data' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler }
            }
        });
        var attachmentsResource = $resource(amlConfig.baseUrl + '/attachments/:id', { id: '@id' }, {
            delete: {
                method: 'DELETE', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        function formDataObject(data, headers) {
            // need to use FormData to upload a file
            var fd = new FormData();
            fd.append('file', data.file);
            fd.append('name', data.file.name);
            fd.append('commentId', data.commentId);
            fd.append('objectId', data.objectId);
            fd.append('objectTypeCode', data.objectTypeCode);
            return fd;
        }
        // to allow drag-and-drop support for kendo-upload, must set 'async' mode;
        // we set dummy URLs since we handle actual uploading ourselves. We hide the 'upload'
        // button (that enabling the async option sets by default) via CSS
        var kendoUploadAsyncForDnD = { autoUpload: false, saveUrl: 'DUMMY_URL', removeUrl: 'DUMMY_URL' };
        var service = {
            createAttachment: createAttachment,
            deleteAttachment: deleteAttachment,
            getLinkForAttachment: getLinkForAttachment,
            handleOnFileSelect: handleOnFileSelect,
            handleOnFileSelectRemove: handleOnFileSelectRemove,
            clearSelectedFiles: clearSelectedFiles,
            onAttachmentAdded: onAttachmentAdded,
            onAttachmentRemoved: onAttachmentRemoved,
            kendoUploadAsyncForDnD: kendoUploadAsyncForDnD
        };
        return service;
        ////////
        function getLinkForAttachment(attachment) {
            var attachmentUrl = null;
            if (attachment && attachment.id) {
                attachmentUrl = amlConfig.baseUrl + '/attachments/' + attachment.id + '/content';
                // since attachment URI is a direct link in the UI, we need to append the appropriate business unit
                // to the link URI
                attachmentUrl = linksProcessor.getBusinessUnitLink(attachmentUrl);
            }
            return attachmentUrl;
        }
        function createAttachment(file, commentId, objectId, objectTypeCode) {
            var fileOb = { file: file, commentId: commentId, objectId: objectId, objectTypeCode: objectTypeCode };
            return attachmentsContentResource.save({}, fileOb).$promise.then(function (data) {
                amlCoreUtils.notifyChangeHandler(attachmentAddedCallbackFns, data);
                return data;
            });
        }
        function deleteAttachment(attachment) {
            return attachmentsResource.delete({ id: attachment.id }).$promise.then(function (data) {
                // notify and pass the removed attachment object
                amlCoreUtils.notifyChangeHandler(attachmentDeletedCallbackFns, attachment);
                return data;
            });
        }
        function handleOnFileSelect(selectedFiles) {
            return function onSelect(e) {
                _.each(e.files, function (file) {
                    selectedFiles.push(file);
                });
            };
        }
        function handleOnFileSelectRemove(selectedFiles) {
            return function onSelectRemove(e) {
                _.each(e.files, function (file) {
                    var index = _.indexOf(selectedFiles, file);
                    selectedFiles.splice(index, 1);
                });
            };
        }
        function clearSelectedFiles(selectedFiles) {
            selectedFiles.length = 0;
        }
        /**
         * Add a handler function that will be called when an attachment gets added
         * @param scope - is used to handle cleaning up listener when the scope gets destroyed
         * @param attachmentAddedFn
         * @example:
         * attachmentService.onAttachmentAdded( $scope, function reportDetailsAttachmentHandler( attachment ) {
         *     if ( attachment.objectTypeCode === 'RPT' && attachment.objectId === viewVm.reportKey ) {
         *          console.log( "attachment added for this report")
         *       }
         *  });
         */
        function onAttachmentAdded(scope, attachmentAddedFn) {
            amlCoreUtils.registerListener(attachmentAddedCallbackFns, attachmentAddedFn, scope);
        }
        /**
         * Add a handler function that will be called when an attachment gets removed. Only the attachment id is
         * guaranteed to exist on the delete callback.
         * @param scope - is used to handle cleaning up listener when the scope gets destroyed
         * @param attachmentRemovedFn
         */
        function onAttachmentRemoved(scope, attachmentRemovedFn) {
            amlCoreUtils.registerListener(attachmentDeletedCallbackFns, attachmentRemovedFn, scope);
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.customer:commentService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve comments from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    commentService.$inject = ["$resource", "amlConfig", "amlConstants", "exceptionResourceHandler", "amlPreferencesService"];
    angular
        .module('aml.core')
        .factory('commentService', commentService);
    /* @ngInject */
    function commentService($resource, amlConfig, amlConstants, exceptionResourceHandler, amlPreferencesService) {
        // preference for whether the comments sidebar is open by default
        var defaultCommentsSidebarOpen;
        /**
         * Resources
         */
        var commentsResource = $resource(amlConfig.baseUrl + '/comments/:id', {
            id: '@id',
            objectId: '@objectId',
            objectTypeCode: '@objectTypeCode',
            categoryCode: '@categoryCode',
            relationships: 'attachments',
            // list parameters
            start: '@start',
            limit: '@limit',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            },
            getCount: {
                method: 'GET',
                params: { fields: 'count' },
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var commentResource = $resource(amlConfig.baseUrl + '/comments/:id', {
            id: '@id' // only to get a specific comment
        }, {
            create: {
                method: 'POST', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            edit: {
                method: 'PUT', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } },
            delete: {
                method: 'DELETE', interceptor: {
                    responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var service = {
            getComments: getComments,
            getCommentsCount: getCommentsCount,
            createComment: createComment,
            editComment: editComment,
            deleteComment: deleteComment,
            toggleDefaultSidebarState: toggleDefaultSidebarState,
            getDefaultCommentsSidebarOpen: getDefaultCommentsSidebarOpen
        };
        activate();
        return service;
        //////////////////
        function activate() {
            // read default sidebar open/closed state from HTML5 local storage preferences
            var defaultCommentsSidebarOpenPref = amlPreferencesService.getLocalPreference(amlConstants.preferences.defaultCommentsSidebarOpen);
            if (!defaultCommentsSidebarOpenPref) {
                defaultCommentsSidebarOpen = false;
            }
            else {
                defaultCommentsSidebarOpen = true;
            }
        }
        function getDefaultCommentsSidebarOpen() {
            return defaultCommentsSidebarOpen;
        }
        /**
         * Get all of the comments for a given objectTypeCode/objectId
         *
         * @param objectTypeCode
         * @param objectId
         * @param categoryCode
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {any}
         */
        function getComments(objectTypeCode, objectId, categoryCode, start, pageSize, sortBys, filterStr, previousCount) {
            var sortByList = null;
            if (!sortBys) {
                // default sort to createdDate, descending
                var sortby = {
                    name: 'createdDate',
                    direction: amlConstants.query.sortDirection.descending };
                sortBys = [sortby];
            }
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return commentsResource.get({
                objectTypeCode: objectTypeCode,
                objectId: objectId,
                categoryCode: categoryCode,
                filter: filter,
                sortBy: sortByList,
                start: start,
                limit: pageSize,
                previousCount: previousCount
            }).$promise;
        }
        function getCommentsCount(objectTypeCode, objectId) {
            return commentsResource.getCount({
                objectTypeCode: objectTypeCode,
                objectId: objectId
            }).$promise;
        }
        function toggleDefaultSidebarState() {
            // toggle current state
            defaultCommentsSidebarOpen = !defaultCommentsSidebarOpen;
            // save default sidebar open/closed state to preferences
            amlPreferencesService.setLocalPreference(amlConstants.preferences.defaultCommentsSidebarOpen, defaultCommentsSidebarOpen);
            return defaultCommentsSidebarOpen;
        }
        function createComment(comment) {
            return commentResource.create({}, comment).$promise;
        }
        function editComment(comment) {
            return commentResource.edit({ id: comment.id }, comment).$promise;
        }
        function deleteComment(comment) {
            return commentResource.delete({ id: comment.id }, comment).$promise;
        }
    }
})();


(function () {
    'use strict';
    /* jshint maxparams: 17*/
    angular.module('aml.core').factory('kendoGridRendererService', ["$filter", "_", "amlConstants", "amlLov", "$log", "$timeout", "moment", "resources", "titleCaseFilter", "currencyFilter", "dateFilter", "amlPreferencesService", "$locale", "amlCoreUtils", "blankNAFilter", function ($filter, _, amlConstants, amlLov, $log, $timeout, moment, resources, titleCaseFilter, currencyFilter, dateFilter, amlPreferencesService, $locale, amlCoreUtils, blankNAFilter) {
        /* jshint maxstatements: 60 */
        var STORAGE_PREFNAME_GRID_OPTIONS = 'gridOptions/';
        activate();
        // note: that kendoGridRendererService relies on resources already being initialized, so should only
        // be used in services that are called from a route which uses resolves to ensure resoruces already loaded.
        // Otherwise would need to try to ensure that this was only called after resources complete.
        //resourceService.init($rootScope, 'aml' ).then( function(result) {
        //    activate(defaultKendoGridOptions);
        //});
        var STRING_FILTER_OPERATORS_KENDO = {
            //EMPTY: { name: 'blank', isStandaloneOperator: true },
            //NOT_EMPTY: { name: 'blank', requiresNotOperator: true, isStandaloneOperator: true } ,
            contains: { name: 'containsIgnoreCase' },
            //CONTAINS_CASE_SENSITIVE: {name: 'contains' },
            doesnotcontain: { name: 'containsIgnoreCase', requiresNotOperator: true },
            //DOES_NOT_CONTAIN_CASE_SENSITIVE: {name: 'contains', requiresNotOperator: true } ,
            startswith: { name: 'startsWithIgnoreCase' },
            //STARTS_WITH_CASE_SENSITIVE: {name: 'startsWith' },
            endswith: { name: 'endsWithIgnoreCase' },
            //ENDS_WITH_CASE_SENSITIVE: {name:'endsWith' },
            eq: { name: 'eqIgnoreCase' },
            eqCaseSensitive: { name: 'eq' },
            neq: { name: 'eqIgnoreCase', requiresNotOperator: true },
            in: { name: 'in' }
        };
        var NUMERIC_AND_DATE_FILTER_OPERATORS_KENDO = {
            eq: { name: 'eq' },
            neq: { name: 'ne' },
            lt: { name: 'lt' },
            lte: { name: 'le' },
            gt: { name: 'gt' },
            gte: { name: 'ge' }
        };
        function getDefaultNoRecordsTemplate() {
            return '<div style="margin: 10px 0px 10px 0px">' + resources.aml.kendoUi.Pager.empty + '</div>';
        }
        /**
         * Default values that should be shared for most grids; use initGridOptionsWithDefaults function
         * to initialize with these defaults and provide specific overrides
         */
        var maxPageSizeForGrids = amlConstants.config.maxPageSizeForGrids;
        if (!maxPageSizeForGrids) {
            maxPageSizeForGrids = 15000;
        }
        else {
            if (maxPageSizeForGrids !== 'all') {
                if (isNaN(parseInt(maxPageSizeForGrids, 10))) {
                    maxPageSizeForGrids = 202;
                }
                else {
                    if (maxPageSizeForGrids < 100) {
                        maxPageSizeForGrids = 201;
                    }
                }
            }
        }
        var defaultKendoGridOptions = {
            //height: 300,
            //width: 950,
            //sortable: true,
            sortable: {
                mode: 'multiple'
            },
            // navigatable makes grid keyboard navigatable; but doesn't look great as it
            // hightlights the cell even when a row is selected; could externalize this
            // option into the preferences
            //navigatable: true,
            //filterable: true,
            scrollable: false,
            // set default order of String filter so that contains is first; kendo puts 'eq' first by default
            filterable: {
                operators: {
                    string: {
                        'contains': resources.aml.kendoUi.FilterMenu.operators.string.contains,
                        'doesnotcontain': resources.aml.kendoUi.FilterMenu.operators.string.doesnotcontain,
                        'eq': resources.aml.kendoUi.FilterMenu.operators.string.eq,
                        'neq': resources.aml.kendoUi.FilterMenu.operators.string.neq,
                        'startswith': resources.aml.kendoUi.FilterMenu.operators.string.startswith,
                        'endswith': resources.aml.kendoUi.FilterMenu.operators.string.endswith
                    }
                }
            },
            resizable: true,
            reorderable: true,
            filterMenuInit: function (e) {
                createValidator(e.container);
            },
            noRecords: {
                template: getDefaultNoRecordsTemplate()
            },
            selectable: 'row',
            //columnMenu: true,
            pageable: {
                pageSizes: [5, 10, 20, 50, 100, maxPageSizeForGrids],
                //input: true,
                numeric: false,
                refresh: true,
                buttonCount: 5
            }
        };
        /**
         * get timezone offset for current session
          */
        //let today = new Date();
        //let timezoneOffset = today.getTimezoneOffset();
        function createValidator(container) {
            container.kendoValidator({
                messages: {
                    // defines a message for the 'custom' validation rule
                    custom: resources.aml.dialogs.validationValidDate
                },
                rules: {
                    custom: function (input) {
                        if (input.is('[data-role=datepicker]')) {
                            // if there's input in the field, but the datepicker's value is null, that means
                            // it's an invalidly formatted date
                            var valid = input.data('kendoDatePicker').value() !== null;
                            if (!valid) {
                                if (!input.val()) {
                                    valid = true;
                                }
                            }
                            return valid;
                        }
                        return true;
                    }
                }
            });
        }
        /**
         * add default list of grid actions used by most grids
         *
         * @param ctrl
         * @param originalColumns
         * @param gridId
         */
        function addDefaultGridActions(ctrl, originalColumns, gridId) {
            var exportLabel = resources.aml.grid.actions.exportPageToExcelTitle;
            if (amlConstants.config.exportAllGridPagesToExcel) {
                exportLabel = resources.aml.grid.actions.exportAllPagesToExcelTitle;
            }
            ctrl.amlGridActions = [
                {
                    id: 'clearFilters',
                    label: resources.aml.grid.actions.clearFiltersActionTitle,
                    action: function () {
                        clearFilters(ctrl.grid);
                    }
                },
                {
                    id: 'clearSorts',
                    label: resources.aml.grid.actions.clearSortsActionTitle,
                    action: function () {
                        clearSorts(ctrl.grid);
                    }
                },
                {
                    id: 'resetGridDefaults',
                    label: resources.aml.grid.actions.resetGridDefaultsActionTitle,
                    action: function () {
                        resetGridDefaults(ctrl.grid, originalColumns, gridId);
                    }
                },
                {
                    id: 'persistGridDefaults',
                    label: resources.aml.grid.actions.saveGridDefaultsActionTitle,
                    action: function () {
                        persistGridDefaults(ctrl.grid, gridId);
                    }
                },
                {
                    id: 'exportToExcel',
                    label: exportLabel,
                    action: function () {
                        exportGridToExcel(ctrl.grid);
                    }
                }
            ];
        }
        /**
         * Create the Export to Excel action for a grid; this uses the Kendo client-side export (and not
         * the AML server-side CSV representation export functionality) and only exports the current
         * visible page.
         */
        function constructExportToExcelAction(ctrl) {
            return {
                id: 'exportToExcel',
                label: resources.aml.grid.actions.exportTitle,
                action: function () {
                    exportGridToExcel(ctrl.grid);
                }
            };
        }
        function getSort(grid) {
            var sortBy = '';
            var first = true;
            if (grid.dataSource) {
                angular.forEach(grid.dataSource.sort(), function (sortObject) {
                    var field = sortObject.field;
                    var direction = sortObject.dir.indexOf('d') === 0 ? 'descending' : 'ascending';
                    if (first) {
                        first = false;
                    }
                    else {
                        sortBy += ',';
                    }
                    sortBy += field + ':' + direction;
                });
            }
            return sortBy;
        }
        function italicizeItem(value) {
            return '<i>' + value + '</i>';
        }
        function updateCellTemplate(template, cell, dataItem, column) {
            if (template !== undefined) {
                var kendoTemplate = kendo.template(template);
                // Render using template
                var templateValue = kendoTemplate(dataItem);
                // if the value is a string containing angular expression, resolve it
                if (templateValue && templateValue.indexOf && templateValue.indexOf('{{') >= 0) {
                    // Render using template, interpolate to resolve angular expressions {{dataItem.x}}
                    templateValue = amlCoreUtils.interpolateValue(templateValue, { dataItem: dataItem });
                }
                cell.html(templateValue);
            }
            else {
                var fieldValue = dataItem[column.field];
                var format = column.format;
                var values = column.values;
                if (values !== undefined && values !== null) {
                    // use the text value mappings (for enums)
                    for (var j = 0; j < values.length; j++) {
                        var value = values[j];
                        if (value.value === fieldValue) {
                            cell.html(value.text);
                            break;
                        }
                    }
                }
                else if (format !== undefined) {
                    // use the format
                    cell.html(kendo.format(format, fieldValue));
                }
                else {
                    // Just dump the plain old value
                    cell.html(fieldValue);
                }
            }
        }
        function kendoFastRedrawRow(grid, row) {
            var dataItem = grid.dataItem(row);
            if (dataItem) {
                var rowChildren = $(row).children('td[role="gridcell"]');
                for (var i = 0; i < grid.columns.length; i++) {
                    var column = grid.columns[i];
                    var template = column.template;
                    var cell = rowChildren.eq(i);
                    updateCellTemplate(template, cell, dataItem, column);
                }
            }
        }
        function getFilterFunctionForGridOperator(type, operator) {
            var functionOp = null;
            if (type === 'string' || !type) {
                functionOp = STRING_FILTER_OPERATORS_KENDO[operator];
            }
            if (!functionOp) {
                functionOp = NUMERIC_AND_DATE_FILTER_OPERATORS_KENDO[operator];
                if (!functionOp) {
                    functionOp = STRING_FILTER_OPERATORS_KENDO[operator];
                }
            }
            return functionOp;
        }
        function validateNumericFilter(value) {
            //var numbers = /^[0-9]+$/;
            //if (!value.match(numbers)) {
            if (isNaN(value)) {
                var message = resources.aml.getResource('grid.invalidFilterWarningMsg', { gridFilterValue: italicizeItem(value) }) +
                    '<br>' + resources.aml.grid.invalidFilterMustBeNumberWarningMsg;
                throw new Error(message);
            }
        }
        function getValueForType(value, type, operator) {
            var valueString = null;
            if (value !== null) {
                // see if need to get enum value
                //if (dataField.enumMapping) {
                //    validateEnum(value, dataField.enumMapping);
                //    value = getEnumIdForValue(value, dataField.enumMapping);
                //}
                // convert grid filter date format to iso date
                if (type === 'date') {
                    //value = getISODateFormat(value);
                    var mom = moment(value);
                    var convertedDateStr = mom.format();
                    value = convertedDateStr;
                }
                else if (type === 'number' || type === 'float') {
                    validateNumericFilter(value);
                }
                if (type === 'string') {
                    // values containing single quotes in filter expressions should be
                    // escaped by double-quoting.
                    var escapedValue = value.replace('\'', '\'\'');
                    var multiValued = operator === 'in';
                    if (multiValued) {
                        var vals = escapedValue.split(',');
                        valueString = '';
                        _.each(vals, function (val) {
                            if (valueString.length > 0) {
                                valueString += ',';
                            }
                            valueString += '\'' + val + '\'';
                        });
                    }
                    else {
                        // string values should be quoted
                        valueString = '\'' + escapedValue + '\'';
                    }
                }
                else {
                    valueString = value;
                }
            }
            return valueString;
        }
        function addFilter(filterItem, columnFilters, logicSeparator) {
            var field = filterItem.field;
            var operator = filterItem.operator;
            var value = filterItem.value;
            if (!columnFilters[field]) {
                columnFilters[field] = {
                    logic: logicSeparator,
                    filters: []
                };
            }
            columnFilters[field].filters.push({
                operator: operator,
                value: value
            });
        }
        function addFilters(filterInfo, columnFilters) {
            var logicSeparator = filterInfo.logic;
            if (filterInfo.filters) {
                for (var i = 0; i < filterInfo.filters.length; i++) {
                    var filter = filterInfo.filters[i];
                    // for some reason in some cases, the filters are nested one level
                    if (filter.filters) {
                        addFilters(filter, columnFilters);
                    }
                    else {
                        addFilter(filter, columnFilters, logicSeparator);
                    }
                }
            }
            else {
                addFilter(filterInfo, columnFilters, logicSeparator);
            }
        }
        /**
         * This should be used when programmatically constructing a filter (outside of the grid filter) as it allows
         * for handling all types of composite filters, without making assumptions of certain restrictions found
         * in grid filtering.
         *
         * @param customFilter
         * @param gridOptions
         * @returns {string}
         */
        function getCustomFilterString(customFilter, gridOptions, gridFilterToCombine) {
            var filterStr = '';
            // if there's additional filters from the grid, combine them with the custom filters into a
            // single AND'd filter
            if (gridFilterToCombine && customFilter) {
                _.each(gridFilterToCombine.filters, function (filter) {
                    customFilter.filters.push(filter);
                });
            }
            // check if this is a composite filter (the filter is made up of sub-filters)
            var childHasFilters = false;
            if (customFilter) {
                childHasFilters = _.some(customFilter.filters, function (filter) {
                    return filter.filters;
                });
            }
            // if this is a composite filter, we'll recursively call this to build up the filters
            if (childHasFilters) {
                if (customFilter) {
                    var filterInfo = customFilter;
                    var logicSeparator = filterInfo.logic;
                    if (!logicSeparator) {
                        logicSeparator = 'and'; // set default logic operator if none set
                    }
                    filterStr += logicSeparator + '(';
                    // go through all of the sub-filters and construct a filter string from each of them
                    for (var i = 0; i < filterInfo.filters.length; i++) {
                        var filter = filterInfo.filters[i];
                        var retStr = getCustomFilterString(filter, gridOptions);
                        if (i > 0) {
                            filterStr += ',';
                        }
                        filterStr += retStr;
                    }
                    filterStr += ')';
                }
            }
            else {
                filterStr = getFilterString({ filter: customFilter }, gridOptions);
            }
            return filterStr;
        }
        function getFilterString(data, gridOptions) {
            var filterString = '';
            if (data.filter) {
                var columnFilters = {};
                addFilters(data.filter, columnFilters);
                var columnNames = _.keys(columnFilters);
                var multipleColumnFiltersApplied = columnNames && columnNames.length > 1;
                if (columnNames && columnNames.length > 1) {
                    // if there's multiple columns being filtered, we'll AND them all
                    filterString += 'and(';
                }
                var first = true;
                _.each(columnFilters, function (filter, propertyName) {
                    //$log.debug('grid:: ' + element[0].id + ':: parameterMap called:: ' + propertyName + ' == ' +
                    // value);
                    if (!first) {
                        filterString += ',';
                    }
                    first = false;
                    filterString += buildFilterString(filter.logic, propertyName, filter.filters, gridOptions);
                });
                if (multipleColumnFiltersApplied) {
                    filterString += ')';
                }
            }
            return filterString;
        }
        function getLocalizedOperatorName(type, operator) {
            /* @see http://docs.telerik.com/kendo-ui/api/javascript/ui/grid?#configuration-filterable.operators */
            var kendoUi = (kendo.ui);
            var functionOp;
            if (type === 'string' || !type) {
                functionOp = kendoUi.FilterMenu.prototype.options.operators[type][operator];
            }
            if (!functionOp) {
                functionOp = kendoUi.FilterMenu.prototype.options.operators[type][operator];
                if (!functionOp) {
                    functionOp = kendoUi.FilterMenu.prototype.options.operators[operator];
                }
            }
            return functionOp ? functionOp.toLowerCase() : functionOp;
        }
        function getTextForFilter(grid, gridOptions) {
            var filterInfo;
            if (grid.dataSource) {
                filterInfo = grid.dataSource.filter();
            }
            var filterString = '';
            if (filterInfo) {
                var columnFilters = {};
                addFilters(filterInfo, columnFilters);
                var keys = _.keys(columnFilters);
                // if more than one column is filtered, just display the column names
                if (keys && keys.length > 1) {
                    _.each(keys, function (colName) {
                        var columnDefinition = _.findWhere(grid.getOptions().columns, { field: colName });
                        if (filterString) {
                            filterString += ', ';
                        }
                        filterString += columnDefinition.title;
                    });
                }
                else if (keys && keys.length === 1) {
                    filterString = constructSingleTextFilter(keys, columnFilters, grid, gridOptions);
                }
            }
            return filterString;
        }
        function getValueForEnumColumn(columnDefinition, filterVal, filter) {
            // check if column has datasource values set for the filter (indicating an enum column)
            if (columnDefinition.filterable && columnDefinition.filterable.dataSource &&
                columnDefinition.filterable.dataSource.length > 0) {
                var enumMapping = _.findWhere(columnDefinition.filterable.dataSource, { value: filterVal });
                if (enumMapping) {
                    // get the value stored in the field name: ( {alertLevel: "Party"})
                    filterVal = enumMapping[columnDefinition.field];
                    // if there's no value, it may be stored in the name field (like: name: "Triggering")
                    if (!filterVal) {
                        filterVal = enumMapping.name;
                    }
                    if (!filterVal) {
                        filterVal = filter.value;
                    }
                }
            }
            return filterVal;
        }
        function getTextValueForType(filterVal, columnDefinition, filter, type) {
            if (type === 'date') {
                // display localized date format
                filterVal = dateFilter(filterVal, 'mediumDate');
            }
            else {
                filterVal = getValueForEnumColumn(columnDefinition, filterVal, filter);
            }
            return filterVal;
        }
        /**
         * Return display name of the logic operator (and/or). This value is localized.
         * @param logicOp
         * @returns {any}
         */
        function getNameForLogicOperator(logicOp) {
            if (logicOp === 'or') {
                return resources.aml.kendoUi.FilterMenu.messages.or;
            }
            else {
                return resources.aml.kendoUi.FilterMenu.messages.and;
            }
        }
        function constructSingleTextFilter(keys, columnFilters, grid, gridOptions) {
            var colName = keys[0];
            var colFilter = columnFilters[colName];
            var allFilters = colFilter.filters;
            var columnDefinition = _.findWhere(grid.getOptions().columns, { field: colName });
            var columnTitle = columnDefinition.title;
            var type = gridOptions.dataSource.schema.model.fields[colName].type;
            var logic = getNameForLogicOperator(colFilter.logic);
            var filterString;
            _.each(allFilters, function (filter) {
                var addLogicSeparator = !!filterString;
                var op = filter.operator;
                var filterFn = getFilterFunctionForGridOperator(type, op);
                if (addLogicSeparator) {
                    filterString = filterString + ' ' + logic + ' ' + getLocalizedOperatorName(type, op);
                }
                else {
                    filterString = columnTitle + ' ' + getLocalizedOperatorName(type, op);
                }
                var filterVal = filter.value;
                if (!filterFn || !filterFn.isStandaloneOperator) {
                    filterVal = getTextValueForType(filterVal, columnDefinition, filter, type);
                    filterString = filterString + ' ' + '\'' + filterVal + '\'';
                }
            });
            return filterString;
        }
        function buildFilterString(andOr, field, array, gridOptions) {
            var column = field;
            var appendAndOr = array.length > 1;
            var filterString = '';
            if (appendAndOr) {
                filterString += andOr + '(';
            }
            var first = true;
            _.each(array, function (entry) {
                if (!first) {
                    filterString += ',';
                }
                first = false;
                var modelField = gridOptions.dataSource.schema.model.fields[field];
                var type = modelField ? modelField.type : 'string';
                // get the equivalent REST API function for the specified grid filter operator
                var functionOp = getFilterFunctionForGridOperator(type, entry.operator);
                var currentFilter = functionOp.name + '(' + column;
                if (!functionOp.isStandaloneOperator) {
                    var valueString = getValueForType(entry.value, type, entry.operator);
                    currentFilter += ',' + valueString;
                }
                currentFilter += ')';
                if (functionOp.requiresNotOperator) {
                    currentFilter = 'not(' + currentFilter + ')';
                }
                filterString += currentFilter;
                /* if (type === 'string' || type === 'text') {
                 filterString += entry.operator + '(' + column + ',\'' + entry.value + '\')';
                 } else {
                 filterString += entry.operator + '(' + column + ',' + entry.value + ')';
                 }*/
            });
            if (appendAndOr) {
                filterString += ')';
            }
            return filterString;
        }
        /**
         * Save the current state of the grid (columns, sort, filter, pageSize) to localStorage,
         * so that it will be used every time the grid is shown.
         *
         * @param grid
         * @param gridId
         */
        function persistGridDefaults(grid, gridId) {
            if (gridId) {
                var columns = grid.getOptions().columns;
                var dataSource = _.pick(grid.getOptions().dataSource, 'sort', 'filter', 'pageSize');
                var gridOptionsObject = { columns: columns, dataSource: dataSource };
                amlPreferencesService.saveLocalPreference(STORAGE_PREFNAME_GRID_OPTIONS + gridId, gridOptionsObject);
            }
        }
        function calculateGridEndDate(dataItem) {
            if (dataItem) {
                // If the case is not closed or terminated then use today
                if (dataItem.statusCode !== 'C' &&
                    dataItem.statusCode !== 'R') {
                    return moment();
                }
                else {
                    if (amlCoreUtils.isNotNullOrUndefined(dataItem.lastUpdateDate)) {
                        //Case
                        return dataItem.lastUpdateDate;
                    }
                    else {
                        //Report
                        return dataItem.updateDate;
                    }
                }
            }
        }
        /**
         * Reset the default state of the grid (columns, sort, filter, pagesize) by clearing any
         * grid state saved in localStorage and then refreshing the grid.
         *
         * @param grid
         * @param columns
         * @param gridId
         */
        function resetGridDefaults(grid, columns, gridId) {
            var uid = getSelectedRowId(grid);
            if (gridId) {
                amlPreferencesService.removeLocalPreference(STORAGE_PREFNAME_GRID_OPTIONS + gridId);
            }
            // clear sort and filters
            if (grid.getOptions().dataSource.sort) {
                grid.getOptions().dataSource.sort.length = 0;
            }
            if (grid.getOptions().dataSource.filter && grid.getOptions().dataSource.filter.filters) {
                grid.getOptions().dataSource.filter.filters.length = 0;
            }
            // reset columns to original representation
            var options = { columns: columns };
            // set back to the first page of results
            if (grid.getOptions().dataSource && grid.getOptions().dataSource.page !== 1) {
                // need to set a new datasource in order to update the page; if we use
                // grid.datSource.page(1) it will do a read for that and then a second for setOptions
                var ds = grid.getOptions().dataSource;
                ds.page = 1;
                options.dataSource = ds;
            }
            grid.setOptions(options);
            resetGridSelection(uid, grid);
            // TODO: reset original pageSize? we don't currently keep a hold of original pagesize
        }
        function getSelectedRowId(grid) {
            var uid;
            if (grid) {
                var selectedRows = grid.select();
                // just get the first row if there are multiple
                if (selectedRows && selectedRows.length > 0) {
                    var selectedRow = selectedRows[0];
                    uid = selectedRow.getAttribute('data-uid');
                }
            }
            return uid;
        }
        /**
         * when filters/sorts are cleared, kendo grid loses the selection styling but does not call
         * rowUnselect event. As such calling grid.select will not work as kendo still has that row
         * selected though the row does not appear highlighted.
         * This function resets the selection by just setting the 'selected' css rule to the last selected row.
         * If that row is no longer visible (such as now showing on a separate page),
         * then the grid selection is cleared.
         * @param uid
         * @param grid
         */
        function resetGridSelection(uid, grid) {
            var selectionReset = false;
            if (uid) {
                // find the grid row with the specific uid. Note that for remote paged grids,
                // the uids are generated each refresh from the server, so this usually only
                // works for local-data grids.
                var row = $("tr[data-uid=\"" + uid + "\"]");
                if (row && row.length > 0) {
                    row.addClass('k-state-selected');
                    selectionReset = true;
                }
            }
            if (!selectionReset) {
                grid.clearSelection();
            }
        }
        function clearFilters(grid) {
            var uid = getSelectedRowId(grid);
            grid.dataSource.filter({});
            resetGridSelection(uid, grid);
        }
        function clearSorts(grid) {
            var uid = getSelectedRowId(grid);
            grid.dataSource.sort([]);
            resetGridSelection(uid, grid);
        }
        function registerDoubleClickHandler(grid, doubleClickHandlerFn, val) {
            var element = grid.element;
            if (!element) {
                element = val.element;
            }
            element.on('dblclick', 'tbody > tr', doubleClickHandlerFn);
        }
        function activate() {
            // set locale-specific strings for kendo widgets
            setKendoLocalization();
        }
        /**
         * Though kendo does supply kendo.messages.{locale} files, it doesn't include every locale we
         * support (noticably: 'ar'). As such we can't use their messages support and have to use this
         * other mechanism to set localized versions of kendo ui messages
         */
        function setKendoLocalization() {
            /*jshint maxcomplexity:12 */
            if (kendo && kendo.ui) {
                var kendoUi = kendo.ui;
                if (kendoUi.FilterMenu) {
                    kendoUi.FilterMenu.prototype.options.messages =
                        $.extend(true, kendoUi.FilterMenu.prototype.options.messages, {
                            'info': resources.aml.kendoUi.FilterMenu.messages.info,
                            'isTrue': resources.aml.kendoUi.FilterMenu.messages.isTrue,
                            'isFalse': resources.aml.kendoUi.FilterMenu.messages.isFalse,
                            'filter': resources.aml.kendoUi.FilterMenu.messages.filter,
                            'clear': resources.aml.kendoUi.FilterMenu.messages.clear,
                            'and': resources.aml.kendoUi.FilterMenu.messages.and,
                            'or': resources.aml.kendoUi.FilterMenu.messages.or,
                            'selectValue': resources.aml.kendoUi.FilterMenu.messages.selectValue,
                            'operator': resources.aml.kendoUi.FilterMenu.messages.operator,
                            'value': resources.aml.kendoUi.FilterMenu.messages.value,
                            'cancel': resources.aml.kendoUi.FilterMenu.messages.cancel
                        });
                }
                /* FilterMenu operator messages */
                if (kendoUi.FilterMenu) {
                    kendoUi.FilterMenu.prototype.options.operators =
                        $.extend(true, kendoUi.FilterMenu.prototype.options.operators, {
                            'string': {
                                'eq': resources.aml.kendoUi.FilterMenu.operators.string.eq,
                                'neq': resources.aml.kendoUi.FilterMenu.operators.string.neq,
                                'startswith': resources.aml.kendoUi.FilterMenu.operators.string.startswith,
                                'contains': resources.aml.kendoUi.FilterMenu.operators.string.contains,
                                'doesnotcontain': resources.aml.kendoUi.FilterMenu.operators.string.doesnotcontain,
                                'endswith': resources.aml.kendoUi.FilterMenu.operators.string.endswith
                            },
                            'number': {
                                'eq': resources.aml.kendoUi.FilterMenu.operators.number.eq,
                                'neq': resources.aml.kendoUi.FilterMenu.operators.number.neq,
                                'gte': resources.aml.kendoUi.FilterMenu.operators.number.gte,
                                'gt': resources.aml.kendoUi.FilterMenu.operators.number.gt,
                                'lte': resources.aml.kendoUi.FilterMenu.operators.number.lte,
                                'lt': resources.aml.kendoUi.FilterMenu.operators.number.lt
                            },
                            'date': {
                                'eq': resources.aml.kendoUi.FilterMenu.operators.date.eq,
                                'neq': resources.aml.kendoUi.FilterMenu.operators.date.neq,
                                'gte': resources.aml.kendoUi.FilterMenu.operators.date.gte,
                                'gt': resources.aml.kendoUi.FilterMenu.operators.date.gt,
                                'lte': resources.aml.kendoUi.FilterMenu.operators.date.lte,
                                'lt': resources.aml.kendoUi.FilterMenu.operators.date.lt
                            },
                            'enums': {
                                'eq': resources.aml.kendoUi.FilterMenu.operators.enums.eq,
                                'neq': resources.aml.kendoUi.FilterMenu.operators.enums.neq
                            }
                        });
                }
                /* FilterMultiCheck messages */
                if (kendoUi.FilterMultiCheck) {
                    kendoUi.FilterMultiCheck.prototype.options.messages =
                        $.extend(true, kendoUi.FilterMultiCheck.prototype.options.messages, {
                            'checkAll': resources.aml.kendoUi.FilterMultiCheck.checkAll,
                            'clear': resources.aml.kendoUi.FilterMultiCheck.clear,
                            'filter': resources.aml.kendoUi.FilterMultiCheck.filter
                        });
                }
                /* NumericTextBox messages */
                if (kendoUi.NumericTextBox) {
                    kendoUi.NumericTextBox.prototype.options =
                        $.extend(true, kendoUi.NumericTextBox.prototype.options, {
                            'upArrowText': resources.aml.kendoUi.NumericTextBox.upArrowText,
                            'downArrowText': resources.aml.kendoUi.NumericTextBox.downArrowText
                        });
                }
                /* Pager messages */
                if (kendoUi.Pager) {
                    kendoUi.Pager.prototype.options.messages =
                        $.extend(true, kendoUi.Pager.prototype.options.messages, {
                            'allPages': resources.aml.kendoUi.Pager.allPages,
                            'display': resources.aml.kendoUi.Pager.display,
                            'empty': resources.aml.kendoUi.Pager.empty,
                            'page': resources.aml.kendoUi.Pager.page,
                            'of': resources.aml.kendoUi.Pager.of,
                            'itemsPerPage': resources.aml.kendoUi.Pager.itemsPerPage,
                            'first': resources.aml.kendoUi.Pager.first,
                            'previous': resources.aml.kendoUi.Pager.previous,
                            'next': resources.aml.kendoUi.Pager.next,
                            'last': resources.aml.kendoUi.Pager.last,
                            'refresh': resources.aml.kendoUi.Pager.refresh,
                            'morePages': resources.aml.kendoUi.Pager.morePages
                        });
                }
                /* ColumnMenu messages */
                if (kendoUi.ColumnMenu) {
                    kendoUi.ColumnMenu.prototype.options.messages =
                        $.extend(true, kendoUi.ColumnMenu.prototype.options.messages, {
                            'sortAscending': resources.aml.kendoUi.Pager.sortAscending,
                            'sortDescending': resources.aml.kendoUi.Pager.sortDescending,
                            'filter': resources.aml.kendoUi.Pager.filter,
                            'columns': resources.aml.kendoUi.Pager.columns,
                            'done': resources.aml.kendoUi.Pager.done,
                            'settings': resources.aml.kendoUi.Pager.settings,
                            'lock': resources.aml.kendoUi.Pager.lock,
                            'unlock': resources.aml.kendoUi.Pager.unlock
                        });
                }
                /** Editor messages */
                if (kendoUi.Editor) {
                    // See: http://docs.telerik.com/kendo-ui/api/javascript/ui/editor#configuration-messages
                    kendoUi.Editor.prototype.options.messages =
                        $.extend(true, kendoUi.Editor.prototype.options.messages, {
                            'bold': resources.aml.kendoUi.Editor.messages.bold,
                            'italic': resources.aml.kendoUi.Editor.messages.italic,
                            'strikethrough': resources.aml.kendoUi.Editor.messages.strikethrough,
                            'insertUnorderedList': resources.aml.kendoUi.Editor.messages.insertUnorderedList,
                            'insertOrderedList': resources.aml.kendoUi.Editor.messages.insertOrderedList,
                            'createLink': resources.aml.kendoUi.Editor.messages.createLink,
                            'unlink': resources.aml.kendoUi.Editor.messages.unlink,
                            'linkWebAddress': resources.aml.kendoUi.Editor.messages.linkWebAddress,
                            'linkText': resources.aml.kendoUi.Editor.messages.linkText,
                            'linkToolTip': resources.aml.kendoUi.Editor.messages.linkToolTip,
                            'linkOpenInNewWindow': resources.aml.kendoUi.Editor.messages.linkOpenInNewWindow,
                            'createTable': resources.aml.kendoUi.Editor.messages.createTable,
                            'createTableHint': resources.aml.kendoUi.Editor.messages.createTableHint,
                            'addColumnLeft': resources.aml.kendoUi.Editor.messages.addColumnLeft,
                            'addColumnRight': resources.aml.kendoUi.Editor.messages.addColumnRight,
                            'addRowAbove': resources.aml.kendoUi.Editor.messages.addRowAbove,
                            'addRowBelow': resources.aml.kendoUi.Editor.messages.addRowBelow,
                            'deleteRow': resources.aml.kendoUi.Editor.messages.deleteRow,
                            'deleteColumn': resources.aml.kendoUi.Editor.messages.deleteColumn,
                            'formatBlock': resources.aml.kendoUi.Editor.messages.formatBlock,
                            'formatting': resources.aml.kendoUi.Editor.messages.formatting,
                            'dialogCancel': resources.aml.kendoUi.Editor.messages.dialogCancel,
                            'dialogInsert': resources.aml.kendoUi.Editor.messages.dialogInsert
                        });
                }
                /** Editor messages */
                if (kendoUi.Upload) {
                    // See: http://docs.telerik.com/kendo-ui/api/javascript/ui/editor#configuration-messages
                    kendoUi.Upload.prototype.options.localization =
                        $.extend(true, kendoUi.Upload.prototype.options.localization, {
                            'remove': resources.aml.kendoUi.Upload.localization.remove,
                            'select': resources.aml.kendoUi.Upload.localization.select,
                            'dropFilesHere': resources.aml.kendoUi.Upload.localization.dropFilesHere
                        });
                }
                /** Grid messages */
                if (kendoUi.Grid) {
                    kendoUi.Grid.prototype.options.messages =
                        $.extend(true, kendoUi.Grid.prototype.options.messages, {
                            'commands': {
                                'canceledit': resources.aml.kendoUi.Grid.messages.commands.canceledit,
                                'destroy': resources.aml.kendoUi.Grid.messages.commands.destroy,
                                'edit': resources.aml.kendoUi.Grid.messages.commands.edit,
                                'update': resources.aml.kendoUi.Grid.messages.commands.update,
                                'create': resources.aml.kendoUi.Grid.messages.commands.create
                            }
                        });
                }
            }
        }
        function isHighPriority(priority) {
            return priority === 3;
        }
        function isMediumPriority(priority) {
            return priority === 2;
        }
        function isLowPriority(priority) {
            return priority === 1;
        }
        function ensurePropertiesDefined(cust) {
            _.each(cust, function (val, key) {
                if (_.isUndefined(val)) {
                    cust[key] = null;
                }
            });
        }
        function isCountdownHighPriority(remainingTime, type) {
            if (type === 'CAS' || type === 'CAS90') {
                return remainingTime <= amlConstants.config.caseCountdownPriority.HIGH_DAY_START_RANGE;
            }
            else if (type === 'RPT') {
                return remainingTime <= amlConstants.config.reportCountdownPriority.HIGH_DAY_START_RANGE;
            }
        }
        /**
         * Select the first row in the grid
         * @param grid
         */
        function selectFirstRow(grid) {
            var row = grid.element.find('tbody tr:first');
            grid.select(row);
        }
        function isCountdownMediumPriority(remainingTime, type) {
            if (type === 'CAS' || type === 'CAS90') {
                return (remainingTime <= amlConstants.config.caseCountdownPriority.MEDIUM_DAY_START_RANGE) &&
                    (remainingTime > amlConstants.config.caseCountdownPriority.HIGH_DAY_START_RANGE);
            }
            else if (type === 'RPT') {
                return (remainingTime <= amlConstants.config.reportCountdownPriority.MEDIUM_DAY_START_RANGE) &&
                    (remainingTime > amlConstants.config.reportCountdownPriority.HIGH_DAY_START_RANGE);
            }
        }
        function validateField(element, identifier, validator, msg) {
            if (element.is("[name=\"" + identifier + "\"]")) {
                if (validator(element.val())) {
                    return true;
                }
                else {
                    element.attr("data-" + identifier + "Validation-msg", msg);
                    return false;
                }
            }
            else {
                return true;
            }
        }
        function calculateRemainingTime(startDate, endDate, type) {
            /*jshint maxcomplexity:10*/
            var differenceInDays;
            //Calendar Days
            differenceInDays = endDate.diff(startDate, 'days');
            if (amlConstants.config.caseCountdown.calculateDaysMethod === 'Business' &&
                (type === 'CAS' || type === 'CAS90')) {
                //Business Days
                // Subtract two weekend days for every week in between
                differenceInDays = differenceInDays - (differenceInDays / 7 * 2);
                // Handle special cases
                var startDay = startDate.day();
                var endDay = endDate.day();
                // Remove weekend not previously removed.
                if (startDay - endDay > 1) {
                    differenceInDays = differenceInDays - 2;
                }
                // Remove start day if span starts on Sunday but ends before Saturday
                if (startDay === 0 && endDay !== 6) {
                    differenceInDays = differenceInDays - 1;
                }
                // Remove end day if span ends on Saturday but starts after Sunday
                if (endDay === 6 && startDay !== 0) {
                    differenceInDays = differenceInDays - 1;
                }
            }
            if (type === 'CAS') {
                return amlConstants.config.caseCountdown.countdownMaximum - differenceInDays;
            }
            if (type === 'CAS90') {
                return amlConstants.config.caseCountdown.countdownMaximum + amlConstants.config.fcf.svr.sar90.suspendedDays - differenceInDays;
            }
            if (type === 'RPT') {
                return amlConstants.config.reportCountdown.countdownMaximum - differenceInDays;
            }
        }
        /**
         * When updating the kendo rows directly, a null or undefined value will get rendered by the template as
         *  'null' or 'undefined'. We want to render it as '' in that case.
         * @param cust
         */
        /*   function convertNullPropertiesToEmpty(cust) {
         _.each(cust, function (val, key) {
         if ( !val ) {
         cust[key] = '';
         }
         });
         }*/
        /**
         * find an item in the kendo grid that matches an object with all required properties to match, and then
         * call the specified update function to perform an update on the found item
         * @param items
         * @param searchOb
         * @param updateFn
         * @param grid
         */
        function searchAndUpdateKendoItem(items, searchOb, updateFn, grid) {
            var customers = _.where(items, searchOb);
            if (customers.length > 0) {
                for (var i = 0; i < customers.length; i++) {
                    updateFn(customers[i]);
                    // get the uid for the dataItem, and look up the corresponding table row with that uid
                    var uid = customers[i].uid;
                    if (uid) {
                        var rows = grid.tbody.children("tr[data-uid=" + uid + "]");
                        if (rows && rows.length > 0) {
                            // update the row manually by updating the table row cell values
                            kendoFastRedrawRow(grid, rows[0]);
                        }
                    }
                }
            }
        }
        /**
         * saves the visible page of the grid to Excel, using Kendo's client-side export
         *
         * @param grid
         */
        function exportGridToExcel(grid) {
            var options = {};
            if (amlConstants.config.exportAllGridPagesToExcel) {
                options = { excel: {
                        fileName: 'AML_export_all_pages.xlsx',
                        allPages: true
                    } };
            }
            else {
                options = { excel: {
                        fileName: 'AML_export_current_page.xlsx',
                        allPages: false
                    } };
            }
            grid.setOptions(options);
//console.log(grid);     
            grid.saveAsExcel();
        }
        /**
         * If the user has requested to persist grid state (sorts, filters, pagesize, columns) for a given grid,
         * then load that state info from localStorage and apply that to the grid about to be loaded.
         *
         * @param gridId
         * @param ctrl
         * @param originalColumns
         * @param gridOptions
         */
        function loadGridState(gridId, ctrl, originalColumns, gridOptions) {
            /*jshint maxcomplexity:12 */
            var copyOrigCompareFunction = function (sortItem) {
                var column = _.findWhere(ctrl.gridColumns, { field: sortItem.field });
                if (column) {
                    if (column.sortable) {
                        if (column.sortable.compare) {
                            sortItem.compare = column.sortable.compare;
                        }
                    }
                }
            };
            var copyOrigColumnProperties = function (column) {
                var origColumn = _.findWhere(originalColumns, { field: column.field });
                if (origColumn) {
                    column.template = origColumn.template;
                    column.filterable = origColumn.filterable;
                    column.editor = origColumn.editor;
                    column.sortable = origColumn.sortable;
                }
            };
            if (gridId) {
                var loadedOptions = amlPreferencesService.loadLocalPreference(STORAGE_PREFNAME_GRID_OPTIONS + gridId);
                if ((loadedOptions || {}).columns) {
                    // have to maintain original template and filterable settings,
                    // as the stored gridOptions does not persist functions
                    ctrl.gridColumns = loadedOptions.columns;
                    _.each(ctrl.gridColumns, copyOrigColumnProperties);
                }
                // if datasource information was saved, load it
                if ((loadedOptions || {}).dataSource) {
                    if (loadedOptions.dataSource.sort) {
                        // add compare function to sort item if one was defined on the column
                        _.each(loadedOptions.dataSource.sort, copyOrigCompareFunction);
                        //depending on initialization order dataSource object may have sort
                        //defined as a setter function (see Kendo DataSource class), if so we must use setter,
                        //otherwise we will override it with property and break kendo runtime. Same for filter.
                        if (typeof gridOptions.dataSource.sort === 'function') {
                            gridOptions.dataSource.sort(loadedOptions.dataSource.sort);
                        }
                        else {
                            gridOptions.dataSource.sort = loadedOptions.dataSource.sort;
                        }
                    }
                    if (loadedOptions.dataSource.filter) {
                        if (typeof gridOptions.dataSource.filter === 'function') {
                            gridOptions.dataSource.filter(loadedOptions.dataSource.filter);
                        }
                        else {
                            gridOptions.dataSource.filter = loadedOptions.dataSource.filter;
                        }
                    }
                    if (loadedOptions.dataSource.pageSize) {
                        if (typeof gridOptions.dataSource.pageSize === 'function') {
                            gridOptions.dataSource.pageSize(loadedOptions.dataSource.pageSize);
                        }
                        else {
                            gridOptions.dataSource.pageSize = loadedOptions.dataSource.pageSize;
                        }
                    }
                }
            }
        }
        return {
            exportGridToExcel: exportGridToExcel,
            ensurePropertiesDefined: ensurePropertiesDefined,
            getSort: getSort,
            /**
             * Select the first row in the grid
             * @param grid
             */
            selectFirstRow: selectFirstRow,
            registerDoubleClickHandler: registerDoubleClickHandler,
            constructExportToExcelAction: constructExportToExcelAction,
            initGridOptionsWithDefaults: function (gridSettingsOverrides) {
                if (gridSettingsOverrides === void 0) { gridSettingsOverrides = {}; }
                // intialize with defaults; create a DEEP copy (so we get new copy of noRecords object, etc)
                var gridSettings = $.extend(true, {}, defaultKendoGridOptions);
                // copy over the specific grid settings
                gridSettings = angular.extend(gridSettings, gridSettingsOverrides);
                return gridSettings;
            },
            constructSingleFilter: function (filterStr1, filterStr2) {
                if (filterStr1) {
                    if (filterStr2) {
                        filterStr1 = 'and(' + filterStr1 + ',' + filterStr2 + ')';
                    }
                }
                else {
                    if (filterStr2) {
                        filterStr1 = filterStr2;
                    }
                }
                return filterStr1;
            },
            loadGridState: loadGridState,
            getTextForFilter: getTextForFilter,
            addDefaultGridActions: addDefaultGridActions,
            /**
             *  Updates a single row in a kendo grid without firing a databound event.
             * This is needed since otherwise the entire grid will be redrawn.
             * @param grid
             * @param row
             */
            kendoFastRedrawRow: kendoFastRedrawRow,
            /**
             * This function extracts date value from a timestamp and return date only value as
             * JavaScript Date object with time fields set to zero in the current timezone
             * Examples:
             *     For input string: 2016-10-26T18:12:44.000+0000   function returns Date object with value:  Wed Oct 26 2016 00:00:00 GMT-0400
             *     For input string: 2016-12-14T01:33:58.000+0000   function returns Date object with value:  Tue Dec 13 2016 00:00:00 GMT-0500
             *     Note the day change in the second example because of the timezone change.
             *
             * @param value - date string with date and time value as returned by rest service
             * @returns {Date} Date object with time fields set to zero in the current timezone
             */
            getLocalDateOnlyValue: function (value) {
                return new Date(new Date(kendo.parseDate(value).getTime()).setHours(0, 0, 0, 0));
            },
            getDefaultNoRecordsTemplate: getDefaultNoRecordsTemplate,
            /**
             * Update data items without firing a databound event; takes a list of item id's for which to apply the
             * specified updateFn.  The update function should actually handle updating the item.
             * @param listOfItemIdsToUpdate
             * @param itemIdPropertyName
             * @param updateFn
             * @param grid
             */
            updateDataItems: function (listOfItemIdsToUpdate, itemIdPropertyName, updateFn, grid) {
                var items = grid.dataItems();
                if (items) {
                    // for all customers whose owner was routed, update them in the grid's list of customers
                    _.each(listOfItemIdsToUpdate, function (id) {
                        var searchOb = {};
                        searchOb[itemIdPropertyName] = id;
                        searchAndUpdateKendoItem(items, searchOb, updateFn, grid);
                    });
                }
            },
            /**
             * Update data items without firing a databound event; takes a list of item id objects for which to apply the
             * specified updateFn.  The update function should actually handle updating the item.
             * @param listOfItemIdsToUpdate
             * @param itemIdPropertyNames
             * @param updateFn
             * @param grid
             */
            updateDataItemsWithCompositeKey: function (listOfItemIdsToUpdate, itemIdPropertyNames, updateFn, grid) {
                var items = grid.dataItems();
                if (items) {
                    // for all customers whose owner was routed, update them in the grid's list of customers
                    _.each(listOfItemIdsToUpdate, function (id) {
                        var searchOb = {};
                        _.each(itemIdPropertyNames, function (property) {
                            searchOb[property] = id[property];
                        });
                        searchAndUpdateKendoItem(items, searchOb, updateFn, grid);
                    });
                }
            },
            /**
             * Filter with titleCase. By default, it will also set the value to 'n/a' if no value is set.
             *
             * @param propertyName
             * @param naIfNull if true, the blankNaFilter will also be run on this.  Note that
             * if false, the return value will come back as 'undefined' if the property does not exist.
             * @returns {function(any): *}
             */
            titleCase: function (propertyName, naIfNull) {
                if (naIfNull === void 0) { naIfNull = true; }
                // essentially this:
                //  return `{{dataItem.${propertyName} | titleCase }}`;
                // but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    var titleCased = titleCaseFilter(dataItem[propertyName]);
                    if (naIfNull) {
                        titleCased = blankNAFilter(titleCased);
                    }
                    return titleCased;
                };
            },
            /**
             * Filter with titleCase, and default to 'n/a' if no value is set
             * @param propertyName
             * @returns {any|(function(any): *)}
             */
            titleCaseWithNA: function (propertyName) {
                return function (dataItem) {
                    var titleCased = titleCaseFilter(dataItem[propertyName]);
                    titleCased = blankNAFilter(titleCased);
                    return titleCased;
                };
            },
            naFilter: function (propertyName) {
                // essentially this:
                //  return `{{dataItem.${propertyName} | titleCase }}`;
                // but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    var naFiltered = blankNAFilter(dataItem[propertyName]);
                    return naFiltered;
                };
            },
            longDate: function (propertyName) {
                // essentially this:
                //  return '{{::dataItem.customerSince | date:"longDate" }}'
                // but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    var dateVal = dateFilter(dataItem[propertyName], 'longDate');
                    // if date value was null, return an empty string. Otherwise
                    // the grid will display 'null' or 'undefined'
                    if (!dateVal) {
                        return '';
                    }
                    return dateVal;
                };
            },
            mediumDate: function (propertyName) {
                // essentially this:
                //  return '{{::dataItem.customerSince | date:"mediumDate" }}'
                // but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    var dateVal = dateFilter(dataItem[propertyName], 'mediumDate');
                    // if date value was null, return an empty string. Otherwise
                    // the grid will display 'null' or 'undefined'
                    if (!dateVal) {
                        return '';
                    }
                    return dateVal;
                };
            },
            longDateMediumTime: function (propertyName) {
                // essentially this:
                //  return '{{::dataItem.transactionDate | date:"longDate" }} {{:: dataItem.transactionDate |
                // date:"mediumTime" }}' but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    // if date value was null, return an empty string. Otherwise
                    // the grid will display 'null null' or 'undefined undefined'
                    if (!dataItem[propertyName]) {
                        return '';
                    }
                    var dateVal = dateFilter(dataItem[propertyName], 'longDate') + ' ' +
                        dateFilter(dataItem[propertyName], 'mediumTime');
                    // if date value was null, return an empty string.
                    if (!dateVal) {
                        return '';
                    }
                    return dateVal;
                };
            },
            enum: function (propertyName, enumFilter, hideUndefined) {
                // essentially this:
                //  return '{{dataItem.riskClassification | riskClassification }}''
                // but performs better as the filter doesn't need applied each re-render
                // For some grids column may have null values and they will show up as
                // 'undefined', to prevent this call with true for hideUndefined
                if (!enumFilter) {
                    // if specific filter not passed in, assume the filter is the same name as the property
                    enumFilter = propertyName;
                }
                return function (dataItem) {
                    var enumValue = '';
                    //support two level names, like uiJSON.taxIDType - needed for SARX reports
                    var dotIndex = propertyName.indexOf('.');
                    if (dotIndex >= 0) {
                        var value = dataItem[propertyName.substr(0, dotIndex)][propertyName.substr(dotIndex + 1)];
                        enumValue = $filter(enumFilter)(value);
                    }
                    else {
                        enumValue = $filter(enumFilter)(dataItem[propertyName]);
                    }
                    if (hideUndefined && !enumValue) {
                        return '';
                    }
                    return enumValue;
                };
            },
            getSortFunction: function (propertyName, enumFilter) {
                var filter = this.enum(propertyName, enumFilter);
                return function (a, b) {
                    var va = filter(a), vb = filter(b);
                    if (va < vb) {
                        return -1;
                    }
                    if (va > vb) {
                        return 1;
                    }
                    return 0;
                };
            },
            getFilterSortFunction: function (filter) {
                return function (a, b) {
                    var va = filter(a), vb = filter(b);
                    if (va < vb) {
                        return -1;
                    }
                    if (va > vb) {
                        return 1;
                    }
                    return 0;
                };
            },
            currency: function (propertyName) {
                // essentially this:
                //  '{{::dataItem.aggregatedTransactionsAmount | currency : ' + kendoGridRendererService.getCurrencySymbol()
                // + ' : 2  }}', but performs better as the filter doesn't need applied each re-render
                return function (dataItem) {
                    var currencyVal = currencyFilter(dataItem[propertyName], amlCoreUtils.getBaseCurrencySymbol(), 2);
                    return currencyVal;
                };
            },
            isHighPriority: isHighPriority,
            isMediumPriority: isMediumPriority,
            isLowPriority: isLowPriority,
            entityPriorityRenderer: function (priorityField) {
                return function (dataItem) {
                    var priority = dataItem[priorityField];
                    var backgroundStyle = null;
                    var alertLevel = null;
                    if (isHighPriority(priority)) {
                        alertLevel = 'high-icon';
                        backgroundStyle = 'high-alert-background';
                    }
                    else if (isMediumPriority(priority)) {
                        alertLevel = 'medium-icon';
                        backgroundStyle = 'medium-alert-background';
                    }
                    else if (isLowPriority(priority)) {
                        alertLevel = 'low-icon';
                        backgroundStyle = 'low-alert-background';
                    }
                    var imgspan = $('<span/>', { class: alertLevel });
                    var html = $('<div/>', { class: [backgroundStyle, 'alert-text'], text: '' });
                    html.prepend(imgspan);
                    return html[0].outerHTML;
                };
            },
            countdownColumnRenderer: function (type) {
                return function (dataItem) {
                    var remainingTime;
                    if (type === 'CAS' && dataItem.caseCategoryCode === 'SAR90') {
                        if (dataItem.statusCode !== 'S') {
                            if (dataItem.activateDate) {
                                remainingTime = calculateRemainingTime(moment(dataItem.activateDate), moment(calculateGridEndDate(dataItem)), type);
                            }
                            else {
                                remainingTime = calculateRemainingTime(moment(dataItem.createDate), moment(calculateGridEndDate(dataItem)), 'CAS90');
                            }
                        }
                        else if (dataItem.statusCode === 'S') {
                            remainingTime = calculateRemainingTime(moment(dataItem.createDate), moment(calculateGridEndDate(dataItem)), 'CAS90');
                        }
                    }
                    else {
                        remainingTime = calculateRemainingTime(moment(dataItem.createDate), moment(calculateGridEndDate(dataItem)), type);
                    }
                    var backgroundStyle = 'low-alert-background';
                    var priorityLevel = 'low-icon';
                    if (isCountdownHighPriority(remainingTime, type)) {
                        priorityLevel = 'high-icon';
                        backgroundStyle = 'high-alert-background';
                    }
                    else if (isCountdownMediumPriority(remainingTime, type)) {
                        priorityLevel = 'medium-icon';
                        backgroundStyle = 'medium-alert-background';
                    }
                    var imgspan = $('<span/>', { class: priorityLevel });
                    var html = $('<div/>', { class: [backgroundStyle, 'alert-text'].join(' '), text: remainingTime });
                    html.prepend(imgspan);
                    return html[0].outerHTML;
                };
            },
            calculateRemainingTime: calculateRemainingTime,
            isCountdownHighPriority: isCountdownHighPriority,
            isCountdownMediumPriority: isCountdownMediumPriority,
            validateField: validateField,
            /**
             * add a multi-checkbox filter display for a specific list of values
             * @param {{name: string; value: any}[]} sourceValues
             * @param {boolean} addAll - optional - whether to add "Select All" option
             * @param {string} name - name of the property for "name" field
             * @param {string} value - name of the property for "value" field
             * @returns {{multi: boolean; dataSource: {name: string; value: any}[]; itemTemplate: (e) => string}}
             */
            getCheckboxFilterForValues: function (sourceValues, addAll, name, value, filterName) {
                if (!name) {
                    name = 'name';
                }
                if (!value) {
                    value = 'value';
                }
                if (filterName) {
                    sourceValues.forEach(function (sourceValue) {
                        sourceValue.filteredName = $filter(filterName)(sourceValue[name]);
                    });
                }
                return {
                    multi: true,
                    dataSource: sourceValues,
                    itemTemplate: function (e) {
                        if (e.field === 'all') {
                            if (addAll) {
                                //handle the check-all checkbox template
                                return '<div><label><i><input type="checkbox" />#= all#</i></label></div>';
                            }
                            else {
                                return '<div/>';
                            }
                        }
                        else {
                            if (filterName) {
                                return '<li class="k-item"><span><label class="k-label"><input type="checkbox" name="' +
                                    e.field + '" class="" value="#=' + value + '#"/><span>#=filteredName#</span></label></span></li>';
                            }
                            else {
                                return '<li class="k-item"><span><label class="k-label"><input type="checkbox" name="' +
                                    e.field + '" class="" value="#=' + value + '#"/><span>#=' + name + '#</span></label></span></li>';
                            }
                        }
                    }
                };
            },
            /**
             * add a multi-checkbox filter display for an enum type (like 'alertLevel' )
             * @param enumtypeString
             * @returns {{multi: boolean, checkAll: boolean, dataSource: (any|Array), itemTemplate: (function(any):
             *     (string|string))}}
             */
            getCheckboxFilter: function (enumtypeString) {
                return {
                    multi: true,
                    checkAll: true,
                    dataSource: this.getFiltersForEnum(enumtypeString),
                    itemTemplate: function (e) {
                        if (e.field === 'all') {
                            //handle the check-all checkbox template
                            return '<div><label><i><input type="checkbox" />#= all#</i></label></div>';
                        }
                        else {
                            //handle the other checkboxes
                            return '<li class="k-item"><span><label class="k-label"><input type="checkbox" name="' +
                                e.field + '" class="" value="#=value#"/><span>#= ' +
                                enumtypeString + ' #</span></label></span></li>';
                        }
                    }
                };
            },
            /**
             * add a multi-checkbox filter display for an enum type like priority
             * description is expected to contain high-icon, low-icon, medium-icon
             * when such description is found then it is used as an icon class for
             * checkbox label (there will be no text for such checkbox)
             * all other descriptions are not changed.
             * @param enumtypeString
             * @returns {{multi: boolean, checkAll: boolean, dataSource: (any|Array), itemTemplate: (function(any):
             *     (string|string))}}
             */
            getPriorityCheckboxFilter: function (enumtypeString) {
                return {
                    multi: true,
                    checkAll: true,
                    dataSource: this.getFiltersForEnum(enumtypeString),
                    itemTemplate: function (e) {
                        if (e.field === 'all') {
                            //handle the check-all checkbox template
                            return '<div><label><i><input type="checkbox" />#= all#</i></label></div>';
                        }
                        else {
                            //handle the other checkboxes
                            return '<li class="k-item"><label class="k-label"><input type="checkbox" name="' +
                                e.field + '" class="" value="#=value#">&nbsp<span class="#=icon#"></span><span>#=description#</span></label></span></li>';
                        }
                    }
                };
            },
            resetGridDefaults: resetGridDefaults,
            clearFilters: clearFilters,
            clearSorts: clearSorts,
            compareLovValues: function (a, b) {
                // sort by lov value order if present
                if (a.order && b.order) {
                    return a.order - b.order;
                }
                else if (a.order) {
                    return 1;
                }
                else if (b.order) {
                    return -1;
                }
                else {
                    // otherwise sort by alphabetical
                    return a.description.toLowerCase().localeCompare(b.description.toLowerCase());
                }
            },
            /**
             * generate data source for checkbox filter
             * items with description that ends with -icon are treated as they have no
             * description
              * @param mapVal
             * @returns {Array}
             */
            getFiltersForEnum: function (mapVal) {
                var map = [];
                if (amlLov[mapVal]) {
                    for (var _i = 0, _a = Object.keys(amlLov[mapVal]); _i < _a.length; _i++) {
                        var key = _a[_i];
                        var ob = {};
                        ob[mapVal] = amlLov[mapVal][key].description;
                        ob.icon = amlLov[mapVal][key].description;
                        ob.value = key;
                        ob.order = amlLov[mapVal][key].order;
                        ob.description = amlLov[mapVal][key].description;
                        if (ob.description.endsWith('-icon')) {
                            ob.description = '';
                        }
                        map.push(ob);
                    }
                }
                // sort by value name
                map.sort(this.compareLovValues);
                return map;
            },
            getSortByString: function (sortBys, separator) {
                if (separator === void 0) { separator = ':'; }
                return amlCoreUtils.getSortByString(sortBys, separator);
            },
            /**
             * convert kendo filters to a readable string for display
             * @returns {*}
             */
            getFilterString: getFilterString,
            getCustomFilterString: getCustomFilterString,
            /**
             * Remove a given field from the datagrid filter
             *
             * @param data
             * @param fieldName
             */
            removeFromFilter: function (data, fieldName) {
                if (data.filter) {
                    // if only a single filter set, it will be on this base level
                    var triggerIndFilters = _.where(data.filter.filters, { field: fieldName });
                    if (triggerIndFilters && triggerIndFilters.length > 0) {
                        _.each(triggerIndFilters, function (filt) {
                            amlCoreUtils.removeFromArray(data.filter.filters, filt);
                        });
                    }
                    else {
                        // if multiple columns filtered, need to iterate over all child filters
                        _.each(data.filter.filters, function (filt) {
                            var triggerIndFilter = _.findWhere(filt.filters, { field: fieldName });
                            if (triggerIndFilter) {
                                amlCoreUtils.removeFromArray(filt.filters, triggerIndFilter);
                            }
                        });
                    }
                }
            },
            getPageInfo: function (data, defaultPageSize) {
                var start = data.skip ? data.skip : 0;
                var limit = data.take ? data.take : defaultPageSize;
                return { start: start, limit: limit };
            },
            getPageStartingIndex: function (grid) {
                var start = 0;
                if (grid && grid.dataSource) {
                    start = (grid.dataSource.page() - 1) * grid.dataSource.pageSize();
                }
                return start;
            },
            getPageLimit: function (grid, defaultPageSize) {
                var limit;
                if (grid && grid.dataSource) {
                    limit = grid.dataSource.pageSize();
                }
                else {
                    limit = defaultPageSize;
                }
                return limit;
            },
            /**
             * @param data
             * @param defaultSortColumn
             * @param defaultSortDirection
             * @param ascWord  Database sort syntax uses 'ascending' and 'descending', which
             * are set as defaults here. Solr sort syntax uses 'asc' and 'desc', which must be passed in as
             * paramters.
             * @param descWord
             * @returns {U[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|any}
             */
            getSortColumns: function (data, defaultSortColumn, defaultSortDirection, ascWord, descWord) {
                if (ascWord === void 0) { ascWord = 'ascending'; }
                if (descWord === void 0) { descWord = 'descending'; }
                var sortCols = _.map(data.sort, function (sortObject) {
                    var direction = sortObject.dir.indexOf('d') === 0 ? descWord : ascWord;
                    return { name: sortObject.field, direction: direction };
                });
                // if not sorted, use a default sort (if specified in directive)
                if (!sortCols || sortCols.length === 0 && defaultSortColumn) {
                    sortCols = [];
                    var direction = defaultSortDirection ? defaultSortDirection : descWord;
                    var sortBy = { name: defaultSortColumn, direction: direction };
                    sortCols.push(sortBy);
                }
                return sortCols;
            },
            /**
             * Refresh the grid (calls the grid.dataSource.read), and if the grid
             * is not on the first page, will reset the page to the first as well
             * @param grid
             * @param resetToFirstPage
             */
            refreshGrid: function (grid, resetToFirstPage) {
                if (resetToFirstPage === void 0) { resetToFirstPage = true; }
                if (grid.dataSource) {
                    if (resetToFirstPage && grid.dataSource.page() !== 1) {
                        if (grid.options && grid.options.dataSource && grid.options.dataSource.serverPaging) {
                            // calling page will reset the page and read the datasource
                            grid.dataSource.page(1);
                        }
                        else {
                            // for local paging, just setting the page doesn't do a read, so have to call both
                            grid.dataSource.page(1);
                            grid.dataSource.read();
                        }
                    }
                    else {
                        grid.dataSource.read();
                    }
                }
            },
            /**
             * Refresh the grid and select the first row afterwards
             *
             * @param grid
             * @param resetToFirstPage
             */
            refreshGridSelectFirstRow: function (grid) {
                if (grid.dataSource) {
                    // perform a read to refresh the grid, and then wait until that read completes before selecting
                    // the first row via the promise
                    grid.dataSource.read().then(function (data) {
                        selectFirstRow(grid);
                    }, function (error) {
                        $log.warn(error);
                    });
                }
            },
            getTextDirection: function () {
                var dir = resources.aml.metadata.textDirection === 'rtl' ? true : false;
                return dir;
            },
            formatCurrency: function (value) {
                var NUMBER_OF_DECIMALS_FOR_CURRENCY = 2;
                var filteredVal = value;
                if (value !== '') {
                    filteredVal = $filter('currency')(value, amlCoreUtils.getBaseCurrencySymbol(), NUMBER_OF_DECIMALS_FOR_CURRENCY);
                }
                return filteredVal;
            },
            getNumSeparators: function () {
                var numFormat = $locale.NUMBER_FORMATS;
                var grpSep = ',';
                var decSep = '.';
                if (numFormat) {
                    grpSep = numFormat.GROUP_SEP;
                    decSep = numFormat.DECIMAL_SEP;
                }
                if (typeof grpSep === 'undefined') {
                    grpSep = ',';
                }
                if (typeof decSep === 'undefined') {
                    decSep = ',';
                }
                var seps = {
                    'grpSep': grpSep,
                    'decSep': decSep
                };
                return seps;
            },
            /**
             * return subset of available kendo editor tools.
             * @see http://docs.telerik.com/kendo-ui/api/javascript/ui/editor#configuration-tools
             *
             * We exclude any tools (such as underline) that use 'style' attribute as angular
             * considers that unsafe and won't render the style (unless using $sce).
             * @returns {string[]}
             */
            getDefaultEditorTools: function () {
                return [
                    'bold',
                    'italic',
                    'strikethrough',
                    'insertUnorderedList',
                    'insertOrderedList',
                    'createLink',
                    'unlink',
                    'createTable',
                    'formatting',
                    'addRowAbove',
                    'addRowBelow',
                    'addColumnLeft',
                    'addColumnRight',
                    'deleteRow',
                    'deleteColumn'
                ];
            },
            /**
             *
             * @param ctrl - the controller object that various properties will be set on
             * @param grid - the kendo grid instance
             * @param gridOptions
             * @param scope
             * @param processDoubleClickFn
             * @param gridId - this is a unique id name for the grid (it does not have to be the element id in the
             *  HTML). This must be passed in order for the grid to persist its state, as the gridId will be used as
             *  a key in the localStorage.
             */
            initialize: function (ctrl, grid, gridOptions, scope, processDoubleClickFn, gridId) {
                var initialized = false;
                var dataSourceFn = function (e) {
                    var filterString = getTextForFilter(ctrl.grid, gridOptions);
                    ctrl.filterString = filterString;
                    // need to run angular eval since if using local filtering, it happens outside of angular lifecycle.
                    // Use evalAsync vs $digest because on initial load it does run in digest cycle and will get
                    // angular cylcical digest cycle warning
                    scope.$evalAsync();
                };
                gridOptions.dataSource.change = amlCoreUtils.wrap(gridOptions.dataSource.change, dataSourceFn);
                var originalColumns = ctrl.gridColumns; // keep a copy via extend
                loadGridState(gridId, ctrl, originalColumns, gridOptions);
                /**
                 * When a column is resized or reordered, persist just those changes.  This is just for
                 * user convenience, so that they are not required to select the Save Grid Defaults action
                 * for simple usecases.
                 * @param e
                 */
                // currently we don't persist grid column changes automatically; we require explicit
                // 'Save as Grid Defaults' user action
                /*
                function persistGridColumnChanges(e) {
                    // when kendo grid calls reorder/resize event function, the columns aren't yet modified;
                    // call this in a timeout which allows to get the state of the columns after kendo completes
                    // the event
                    if (gridId) {
                        $timeout(function () {
                            // get existing full stored options
                            let loadedOptions =
                                amlPreferencesService.loadLocalPreference(STORAGE_PREFNAME_GRID_OPTIONS + gridId);
                            if ( !loadedOptions ) {
                                // options don't exist yet; will just store column information
                                loadedOptions = { };
                            }
                            let columns = ctrl.grid.getOptions().columns;
                            loadedOptions.columns = columns;
                            amlPreferencesService.saveLocalPreference(STORAGE_PREFNAME_GRID_OPTIONS + gridId, loadedOptions);
                        });
                    }
                }

                gridOptions.columnResize = amlCoreUtils.wrap(gridOptions.columnResize, persistGridColumnChanges);
                gridOptions.columnReorder = amlCoreUtils.wrap(gridOptions.columnReorder, persistGridColumnChanges);

                */
                //set default resetGridDefaults/clearSorts/clearFilters functions for use by the aml-grid-actions directive
                addDefaultGridActions(ctrl, originalColumns, gridId);
                // register doubleClickFn
                if (processDoubleClickFn) {
                    if (ctrl.grid && ctrl.grid.element) {
                        //if grid is already bound then do not wait for bound event, it may have been fired already
                        registerDoubleClickHandler(ctrl.grid, processDoubleClickFn, null);
                    }
                    else {
                        var dataBound = function (val) {
                            if (!initialized) {
                                initialized = true;
                                registerDoubleClickHandler(ctrl.grid, processDoubleClickFn, this);
                            }
                        };
                        gridOptions.dataBound = amlCoreUtils.wrap(gridOptions.dataBound, dataBound);
                    }
                }
            }
        };
    }]);
})();


/*

Accepts a numeric segment ID and returns the corresponding localized segment name.
Returns the segment's alphabetic code if the localized segment name doesn't exist.
Returns ths segment ID if neither the name nor the alphabetic code exists.
Returns '' if none of the above exists.

For the filter that accepts an alphabetic code and returns a localized segment name, see: localizedSegmentName.

 */
(function () {
    'use strict';
    angular.module('aml.core').filter('segmentName', ["_", "scenarioService", "$filter", function (_, scenarioService, $filter) {
        var segments = scenarioService.getSegments();
        return function (input) {
            if (!input.entitySegmentId || input.entitySegmentId === '0') {
                return '';
            }
            else {
                var parmSegment = _.find(segments, function (segment) { return Number(segment.entitySegmentId) === Number(input.entitySegmentId); });
                return parmSegment ? $filter('localizedSegmentName')(parmSegment.segmentName) : input.entitySegmentId;
            }
        };
    }]);
})();


/**
 * This simply creates a list of states-with-named-views and all other states, so that the
 * <div ui-view="..."> elements can be created for each.
 *
 */
(function () {
    'use strict';
    AMLUIViewController.$inject = ["$state", "amlUIViewService"];
    angular.module('aml.core').controller('AMLUIViewController', AMLUIViewController);
    function AMLUIViewController($state, amlUIViewService) {
        var vm = this;
        vm.$state = $state;
        vm.states = amlUIViewService.states;
        vm.viewlessStates = [];
        vm.isViewlessState = amlUIViewService.isViewlessState;
        vm.isViewState = amlUIViewService.isViewState;
        activate();
        /////////
        function activate() {
            amlUIViewService.initialize(vm.includeStatesWithNoParent, vm.parentState);
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:amlUIViewService
 *
 * @restrict E
 *
 * @description
 * This simply creates a list of states-with-named-views and all other states, so that the
 * <div ui-view="..."> elements can be created for each.
 *
 * @element ANY
 * @required on-click
 */
(function () {
    'use strict';
    amlUIViewService.$inject = ["$state", "$stickyState"];
    angular
        .module('aml.core')
        .factory('amlUIViewService', amlUIViewService);
    /* @ngInject */
    function amlUIViewService($state, $stickyState) {
        var states = [];
        var viewlessStates = [];
        var includeStatesWithNoParent = null;
        var parentState = null;
        var service = {
            states: states,
            initialize: initialize,
            isViewlessState: isViewlessState,
            isViewState: isViewState,
            addState: addState,
            removeState: removeState
        };
        return service;
        /////////////////////
        function addStates() {
            // add all of the view states to a list, so that a <div ui-view="..."> can be created for each
            _.each($state.get(), function (state) {
                addState(state);
            });
        }
        function initialize(shouldIncludeStatesWithNoParent, vmParentState) {
            includeStatesWithNoParent = shouldIncludeStatesWithNoParent;
            parentState = vmParentState;
            addStates();
        }
        function addState(state) {
            if (!state.abstract && state.name) {
                var name = state.name;
                var views = _.keys(state.views);
                // if a parentState was specified for this state, only add states for that specified parent;
                // or if no parentState was specified for the state, but the directive requested to include states
                // with no parents, then include it
                var parentStateForGivenState = state.parent;
                if ((parentStateForGivenState && parentStateForGivenState === parentState) ||
                    (includeStatesWithNoParent && !parentStateForGivenState)) {
                    if (views && views.length > 0) {
                        _.each(views, function (view) {
                            var stateToAdd = { name: name, view: view };
                            // only add state if it doesn't yet exist
                            var existingState = _.findWhere(states, { name: name });
                            if (!existingState) {
                                states.push(stateToAdd);
                            }
                        });
                    }
                    else {
                        viewlessStates.push(name);
                    }
                }
            }
        }
        function removeState(stateName) {
            var item = _.findWhere(states, { name: stateName });
            if (item) {
                var foundIndex = _.indexOf(states, item);
                if (foundIndex > -1) {
                    states.splice(foundIndex, 1);
                }
            }
            // TODO: check in viewlesstates; actually we should not have any viewless states
            //else {
            //}
            // clear out the sticky state; note that states/route definitions themselves can not be removed; that is
            // how the ui router works - you can not remove states.  But we can clear the sticky state.
            $stickyState.reset(stateName);
        }
        /**
         * This returns true if this is a standard state without a named view defined; this is used to show all other
         * standard states in a single <div ui-view>
         *
         * @returns {boolean} true if the current state has no defined named view
         */
        function isViewlessState() {
            var stateName = $state.current.name;
            var item = _.findWhere(states, { name: stateName });
            var viewless = !item;
            return viewless;
            // recording viewless states doesn't work, as if a substate is activeated, it doesn't
            // match the parent state; would have to go through each
            //var viewlessState = _.contains( vm.viewlessStates, stateName );
            //return viewlessState;
        }
        function isViewState(name) {
            var isState = $state.includes(name);
            return isState;
        }
    }
})();


(function () {
    'use strict';
    ReviewsListController.$inject = ["reviewsService", "logger", "linksProcessor", "kendoGridRendererService", "$state", "$q", "resources", "customerService", "amlConstants", "amlLov", "usersService", "$scope", "$rootScope", "reviewsListDataMessagingService", "titleCaseFilter", "_", "$filter", "segmentNameFilter", "scenarioService"];
    angular
        .module('cdd.reviews')
        .controller('ReviewsListDirectiveController', ReviewsListController);
    /* jshint maxparams: 19*/
    /* jshint maxstatements: 70 */
    function ReviewsListController(reviewsService, logger, linksProcessor, kendoGridRendererService, $state, $q, resources, customerService, amlConstants, amlLov, usersService, $scope, $rootScope, reviewsListDataMessagingService, titleCaseFilter, _, $filter, segmentNameFilter, scenarioService) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        var firstDataLoad = true;
        vm.showOverview = false;
        vm.reviewsCount = null;
        vm.defaultPageSize = Math.max(50, amlConstants.config.CDDReviewListPageSize);
        vm.selectedItemsCount = 0;
        var reviewStatusFilter = null;
        var resetToFirstPage = (amlConstants.config && amlConstants.config.CDDReviewList && angular.isDefined(amlConstants.config.CDDReviewList.resetToFirstPage) ?
            amlConstants.config.CDDReviewList.resetToFirstPage : true);
        // build review status code filter. Exclude status codes specified by the preference,
        // such reviews are not returned by mid-tier query, so the codes must be excluded from the filter
        var createStatusFilter = function () {
            var reviewStatusMap = amlLov.reviewStatus;
            if (amlConstants.config.excludedCDDReviewStatusList && amlConstants.config.excludedCDDReviewStatusList.trim() !== '') {

//console.log(amlConstants.config.excludedCDDReviewStatusList);
			        //var hrefStr = $(location).attr('href').toUpperCase();
			        //if(hrefStr.indexOf('CDDREVIEWS') != -1){
			        //	amlConstants.config.excludedCDDReviewStatusList = "";
			        //}
			        amlConstants.config.excludedCDDReviewStatusList = "";
			        
//console.log(amlConstants.config.excludedCDDReviewStatusList);
			        
                var excludedStatusArray = amlConstants.config.excludedCDDReviewStatusList.trim().split(' ');
                //convert map to array and sort full list by order
                var map = Object.keys(reviewStatusMap).map(function (key) {
                    return { key: key, order: reviewStatusMap[key].order, description: reviewStatusMap[key].description };
                });

                // sort by order
                map.sort(kendoGridRendererService.compareLovValues);
                var excludeCode = function (code) {
//console.log("---- code");
//console.log(excludedStatusArray);
                    return _.find(excludedStatusArray, function (str) { 
                    	console.log(str + " === " + code + " : " + (str == code));
                    		return str == code; 
                    });
                };
                //create an array of values to display in the filter excluding values specified in the preference
                var filterList = [];
//console.log(map);
                for (var i = 0; i < map.length; i++) {
                    if (!excludeCode(map[i].key)) {
                        filterList.push({ name: map[i].description, value: map[i].key });
                    }
                }
//console.log("---- 001");
//console.log(filterList);
                reviewStatusFilter = kendoGridRendererService.getCheckboxFilterForValues(filterList);
            }
            else {
//console.log("---- 002");
//console.log(filterList);
                //use full lov table if the preference is empty
                reviewStatusFilter = kendoGridRendererService.getCheckboxFilter('reviewStatus');
            }
        };
        createStatusFilter();
        var dataSourceOptions = {
            transport: {
                read: getReviews
            },
            schema: {
                model: {
                    fields: {
                        reviewAge: { type: 'number' },
                        key: { type: 'number' },
                        partyName: { type: 'string' },
                        primaryEntityNumber: { type: 'string' },
                        employeeIndicator: { type: 'string' },
                        initialRiskRating: { type: 'string' },
                        initialRiskScore: { type: 'number' },
                        initialAutoHighIndicator: { type: 'string' },
                        lastRiskRating: { type: 'string' },
                        lastRiskScore: { type: 'number' },
                        lastAutoHighInd: { type: 'string' },
                        statusCode: { type: 'string' },
                        createDate: { type: 'date' },
                        queueCode: { type: 'string' },
                        ownerUserLongId: { type: 'string' },
                        entitySegmentId: { type: 'number' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: vm.defaultPageSize,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        var undefinedOwnerAsBlankFilter = function undefinedOwnerAsBlankFilter(dataItem) {
            if (!dataItem.ownerUserLongId || dataItem.ownerUserLongId === 'undefined') {
                return '';
            }
            return $filter('userName')(dataItem.ownerUserLongId, true);
        };
        vm.gridColumns = [
            {
                field: 'reviewAge', title: resources.aml.reviews.ageHeaderTitle,
                attributes: { class: 'number-display' },
                width: '4%'
            },
            {
                field: 'key', title: resources.aml.reviews.id,
                attributes: { class: 'number-display' },
                width: '6%'
            },
            {
                field: 'partyName', title: resources.aml.reviews.entityNameHeaderTitle,
                template: kendoGridRendererService.titleCase('partyName'),
                width: '10%'
            },
            {
                field: 'primaryEntityNumber', title: resources.aml.reviews.entityNumberHeaderTitle,
                width: '7%',
                attributes: { class: 'number-display' },
                template: '<a href="\\#/customers/{{dataItem.primaryEntityNumber}}">{{dataItem.primaryEntityNumber}}</a>'
            },
            {
                field: 'entitySegmentId',
                title: vm.resources.aml.segment.segmentLabel,
                width: '8%',
                template: segmentNameFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(segmentNameFilter) },
                filterable: kendoGridRendererService.getCheckboxFilterForValues(scenarioService.getSegments('nondeleted'), true, 'segmentName', 'entitySegmentId', 'localizedSegmentName')
            },
            {
                field: 'employeeIndicator', title: resources.aml.reviews.employeeIndicatorHeaderTitle,
                width: '5%',
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'initialRiskRating', title: resources.aml.reviews.initialRiskRating,
                width: '5%',
                template: kendoGridRendererService.enum('initialRiskRating', 'scoreClassification', true),
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification')
            },
            {
                field: 'initialRiskScore', title: resources.aml.reviews.initialRiskScoreHeaderTitle,
                attributes: { class: 'number-display' },
                width: '5%'
            },
            {
                field: 'initialAutoHighIndicator', title: resources.aml.reviews.autoHighIndicatorHeaderTitle,
                width: '5%',
                template: kendoGridRendererService.enum('initialAutoHighIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'lastRiskRating', title: resources.aml.reviews.lastRiskRating,
                width: '7%',
                template: kendoGridRendererService.enum('lastRiskRating', 'scoreClassification', true),
                filterable: kendoGridRendererService.getCheckboxFilter('scoreClassification')
            },
            {
                field: 'lastRiskScore', title: resources.aml.reviews.lastRiskScoreHeaderTitle,
                attributes: { class: 'number-display' },
                width: '5%'
            },
            {
                field: 'lastAutoHighIndicator', title: resources.aml.reviews.lastAutoHighIndicatorHeaderTitle,
                width: '5%',
                template: kendoGridRendererService.enum('lastAutoHighIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'statusCode', title: resources.aml.reviews.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'reviewStatus'),
                filterable: reviewStatusFilter,
                width: '5%'
            },
            {
                field: 'createDate',
                width: '10%',
                title: resources.aml.reviews.createDate,
                template: kendoGridRendererService.longDateMediumTime('createDate')
            },
            {
                field: 'queueCode', title: resources.aml.entity.queue,
                width: '8%',
                filterable: kendoGridRendererService.getCheckboxFilter('queueName'),
                template: '{{dataItem.queueCode | queueName:true}}'
            },
            {
                field: 'ownerUserLongId', title: resources.aml.reviews.owner,
                width: '9%',
                template: undefinedOwnerAsBlankFilter
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: Math.max(400, amlConstants.config.CDDReviewListTableHeight),
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            dataBound: function (val) {
                if (firstDataLoad) {
                    kendoGridRendererService.selectFirstRow(vm.grid);
                    firstDataLoad = false;
                }
            }
        });
        function updateSelectedCount(items) {
            vm.selectedItemsCount = 0;
            if (items) {
                vm.selectedItemsCount = items.length;
                return;
            }
            if (vm.grid) {
                var selectedItems = vm.grid.select();
                if (selectedItems) {
                    vm.selectedItemsCount = selectedItems.length;
                }
            }
        }
        function getFilterWithQueueDisplayType(filter) {
            var combinedFilter;
            var displayQueueType = getDisplayReviewsType();
            if (displayQueueType === amlConstants.reviewsListQueueDisplayType.MY) {
                var currentUserName = getMyReviewsOnlyUser();
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'eq( ownerUserLongId, \'' + currentUserName + '\')');
            }
            else if (displayQueueType === amlConstants.reviewsListQueueDisplayType.AVAILABLE) {
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'blank( ownerUserLongId )');
            }
            else {
                combinedFilter = filter;
            }
            return combinedFilter;
        }
        vm.handleRowSelect = function (reviewsRows) {
            if (reviewsRows && reviewsRows.length > 0) {
                // update review overview when a review is selected;
                // if multiple rows selected, don't updated the review summary
                vm.selectedItemsCount = reviewsRows.length;
                if (reviewsRows.length === 1) {
                    selectReviews(reviewsRows[0]);
                }
                else {
                    clearReviews();
                }
            }
            else {
                // if no review selected, clear the overview
                clearReviews();
                vm.selectedItemsCount = 0;
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'reviewsList');
            // set function on the dataMessagingService to get selected reviews based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            reviewsListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedReviewsFromSelectedRows, refreshGrid);
            $scope.$watch(function () {
                return reviewsListDataMessagingService.getDisplayOwnersType();
            }, function (displayReviewsWithOwnersType, oldValue) {
                if (displayReviewsWithOwnersType === oldValue) {
                    return;
                }
                myReviewsFilterChanged(displayReviewsWithOwnersType);
            });
            $scope.$on('reviewsOwnerChanged', function (event, changedData) {
                updateReviewsOwner(changedData.reviewNumbers, changedData.owner, changedData.queue);
            });
            $rootScope.$on('reviewsStatusChanged', function (event, changedData) {
                updateReviewsStatus(changedData.reviewNumbers, changedData.statusCode);
            });
            $scope.$on('reviewListRefresh', function (event) {
                kendoGridRendererService.refreshGrid(vm.grid);
            });
            clearReviews();
        }
        function refreshGrid() {
            kendoGridRendererService.refreshGrid(vm.grid, resetToFirstPage);
        }
        // on double-click, go to review detail page
        function handleDoubleClick(evt, data) {
            var selectedReview = vm.grid.dataItem(evt.currentTarget);
            updateSelectedCount();
            if (selectedReview && selectedReview.key) {
                $state.go('cddReviewDetails', { reviewKey: selectedReview.key, partyNumber: selectedReview.primaryEntityNumber, newEntityFlag: false });
            }
        }
        function updateReviewsOwner(reviewNumbers, owner, queue) {
            /*
             If queue = '', that means remove any currently-assigned queue.
             If queue is undefined, that means don't change the queue.
            */
            kendoGridRendererService.updateDataItems(reviewNumbers, 'key', function (reviewToBeUpdated) {
                reviewToBeUpdated.ownerUserLongId = owner;
                if (typeof queue !== 'undefined') {
                    // queue is undefined if the user is clicking "Claim" or "Return to Queue".
                    reviewToBeUpdated.queueCode = queue;
                }
            }, vm.grid);
        }
        function updateReviewsStatus(reviewNumbers, statusCode) {
            kendoGridRendererService.updateDataItems(reviewNumbers, 'key', function (reviewToBeUpdated) {
                reviewToBeUpdated.statusCode = statusCode;
            }, vm.grid);
        }
        /**
         * Get the selected reviews based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedReviewsFromSelectedRows() {
            var reviews = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aReview = vm.grid.dataItem(rowSelection);
                    if (aReview) {
                        reviews.push(aReview);
                    }
                });
            }
            updateSelectedCount(reviews);
            return reviews;
        }
        function getReviews(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            // add queue filtering (My Reviews, etc) to the grid filter
            filterStr = getFilterWithQueueDisplayType(filterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.reviewsCount;
            }
            reviewsService.getReviews(pageInfo.start, pageInfo.limit, sortCols, filterStr, null, previousCount).then(function (data) {
                vm.reviewsCount = data.count;
                // if no reviews returned, clear the review summary
                if (vm.reviewsCount === 0) {
                    clearReviews();
                }
                e.success(data);
                updateSelectedCount();
            }, function (data, status, headers, config) {
                clearReviews();
                logger.error(resources.aml.reviews.couldNotLoadReviewsErrorText);
                updateSelectedCount();
            });
        }
        function myReviewsFilterChanged(displayReviewsType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
        }
        function getDisplayReviewsType() {
            return reviewsListDataMessagingService.getDisplayOwnersType();
        }
        function getMyReviewsOnlyUser() {
            return usersService.getCurrentUserId();
        }
        function selectReviews(aReview) {
            vm.currentReview = aReview;
            if (aReview && aReview.primaryEntityNumber) {
                customerService.getCustomer(aReview.primaryEntityNumber).then(function (data) {
                    vm.currentCustomer = data;
                    vm.currentReview.currentCustomer = data;
                    //console.log(vm.currentCustomer);
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reviews.couldNotLoadCustomerErrorText);
                });
                reviewsService.getCategoryScores(aReview.key, aReview.primaryEntityNumber, aReview.primaryEntityLevelCode, aReview.createDate).then(function (data) {
                    vm.currentReview.categoryScores = data.items;
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reviews.couldNotLoadCustomerErrorText);
                });
                if (aReview.lastScoreDate) {
                    reviewsService.getCategoryScores(aReview.key, aReview.primaryEntityNumber, aReview.primaryEntityLevelCode, aReview.lastScoreDate).then(function (data) {
                        vm.currentReview.lastCategoryScores = data.items;
                    }, function (data, status, headers, config) {
                        logger.error(resources.aml.reviews.couldNotLoadCustomerErrorText);
                    });
                }
            }
            vm.showOverview = true;
        }
        function clearReviews() {
            vm.currentReview = null;
            vm.currentCustomer = null;
            vm.showOverview = false;
        }
    }
})();


(function () {
    'use strict';
    CustomDetailsDisplayDirectiveController.$inject = ["amlConstants", "restControlService", "logger", "resources"];
    angular.module('aml.core').controller('CustomDetailsDisplayDirectiveController', CustomDetailsDisplayDirectiveController);
    function CustomDetailsDisplayDirectiveController(amlConstants, restControlService, logger, resources) {
        var vm = this;
        vm.models = [];
        activate();
        ////////////////////
        function activate() {
            // check if a custom details preference has been set for this id
            if (vm.customId && amlConstants.config.custom && amlConstants.config.custom.details &&
                amlConstants.config.custom.details[vm.customId] && amlConstants.config.custom.details[vm.customId].url) {
                // if one (or more) URLs have been configured for this custom details sections, make the request(s)
                restControlService.makeRequests(vm.customId, vm.domainModel).then(function successCallback(responses) {
                    responses.forEach(function (resp) {
                        var model = {
                            title: resp.title,
                            data: resp.data,
                            usePrettyLabels: resp.usePrettyLabels,
                            processLinks: resp.processLinks,
                            ignoreProperties: resp.ignoreProperties
                        };
                        vm.models.push(model);
                    });
                }, function errorCallback(error) {
                    logger.error(resources.aml.getResource('custom.details.errorMessageText', { customDetailsSection: vm.customId }) +
                        '<br/>' +
                        resources.aml.getResource('error.generalError', { errorMessage: error.data.message }) +
                        '<br/>' +
                        error.config.url + ': ' + error.status + ': ' + error.statusText);
                });
            }
        }
    }
})();


/**
 * @ngdoc directive
 * @name    aml.core:amlCustomDetailsDisplay
 * @param {string} customId an id for this custom details panel; this will be checked for to see if it has been configured in
 *  the preferences (custom.details.customId)
 * @param {any} domainModel the model from the page, used to pass parameters to the configured URLs
 *
 * @restrict E
 *
 * @description
 * The 'amlCustomDetailsDisplay' directive is used to display additional details retrieved
 * by a REST request (as configured in the preferences).
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-custom-details-display custom-id="account" domain-model="viewVm.account"></aml-custom-details-display>
 </pre>
 */
(function () {
    'use strict';
    angular
        .module('aml.core')
        .directive('amlCustomDetailsDisplay', amlRestDisplayDirective);
    /* @ngInject */
    function amlRestDisplayDirective() {
        var directive = {
            restrict: 'E',
            templateUrl: 'custom/customDetails/amlCustomDetailsDisplayDirective.html',
            controller: 'CustomDetailsDisplayDirectiveController',
            controllerAs: 'vm',
            scope: {
                //  the scope is isolated
                customId: '@',
                domainModel: '='
            },
            bindToController: true
        };
        return directive;
    }
})();


(function () {
    'use strict';
    CustomDetailsSectionDirectiveController.$inject = ["amlConstants", "resources"];
    angular.module('aml.core').controller('CustomDetailsSectionDirectiveController', CustomDetailsSectionDirectiveController);
    function CustomDetailsSectionDirectiveController(amlConstants, resources) {
        var vm = this;
        vm.resources = resources;
        vm.enabled = false;
        activate();
        ////////////////////
        function activate() {
            // look in preferences and see if a configuration has been set for this details page
            if (vm.customId && amlConstants.config.custom && amlConstants.config.custom.details &&
                amlConstants.config.custom.details[vm.customId] && amlConstants.config.custom.details[vm.customId].url) {
                // if so, we will display the custom details section on the page
                vm.enabled = true;
            }
        }
    }
})();


/**
 * @ngdoc directive
 * @name    aml.core:amlCustomDetailsSection
 * @param {string} customId an id for this custom section; this will be checked to see if it has been configured in
 *  the preferences (custom.details.{customId})
 * @param {any} domainModel the model from the page, used to pass parameters to the configured URLs
 *
 * @restrict E
 *
 * @description
 * The 'amlCustomDetailsSection' directive is used to add a section to a page containing additional details retrieved
 * by a REST request (as configured in the preferences).
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
    <aml-custom-details-section custom-id="account" domain-model="viewVm.account"></aml-custom-details-section>
 </pre>
 */
(function () {
    'use strict';
    angular
        .module('aml.core')
        .directive('amlCustomDetailsSection', amlCustomDetailsSection);
    /* @ngInject */
    function amlCustomDetailsSection() {
        var directive = {
            restrict: 'E',
            templateUrl: 'custom/customDetails/amlCustomDetailsSectionDirective.html',
            controller: 'CustomDetailsSectionDirectiveController',
            controllerAs: 'vm',
            scope: {
                //  the scope is isolated
                customId: '@',
                domainModel: '='
            },
            bindToController: true
        };
        return directive;
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:restControlService
 *
 * @restrict E
 *
 * @description
 * The restControlService service is used to handle processing for generic rest service functions
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    restControlService.$inject = ["amlConfig", "amlConstants", "$q", "$http", "amlCoreUtils", "$"];
    angular
        .module('aml.core')
        .factory('restControlService', restControlService);
    /* @ngInject */
    function restControlService(amlConfig, amlConstants, $q, $http, amlCoreUtils, $) {
        var service = {
            processUrl: processUrl,
            getTokenName: getTokenName,
            getParams: getParams,
            makeRequests: makeRequests
        };
        return service;
        /**
         * look up any parameters defined in the preference configuration, and create a name/value object map by
         * retrieving the value from the same name as the map
         * @param restPref
         * @param domainModel
         * @returns {{}}
         */
        function getParameterMap(restPref, domainModel) {
            var paramsList = restPref.params;
            var paramMap = {};
            if (paramsList) {
                paramsList.split(',').forEach(function (paramName) {
                    paramName = paramName.trim();
                    var paramVal = amlCoreUtils.getNestedObjectProperty(domainModel, paramName, true);
                    if (amlCoreUtils.isNullOrUndefined(paramVal)) {
                        paramVal = ''; // set empty value if none was found
                    }
                    paramMap[paramName] = paramVal;
                });
            }
            return paramMap;
        }
        /**
         * Make HTTP requests for any URLs configured in the preferences for the specified 'customId'.
         *
         * @param customId - the id for the custom details preferences to use (ie: custom.details.<id>.*)
         * @param domainModel - the model to use to resolve variables in the configured URL and parameters
         * @returns {PromiseLike<any[]>|Promise<any[]>|JQueryPromise<any>|JQueryPromise<void>|IPromise<any[]>|JQueryPromise<any[]>}
         */
        function makeRequests(customId, domainModel) {
            var currentCustomId = customId;
            var index = 1;
            var requests = [];
            var restPref = null;
            if (amlConstants.config.custom && amlConstants.config.custom.details) {
                restPref = amlConstants.config.custom.details[currentCustomId];
            }
            while (restPref && restPref.url) {
                var url = restPref.url;
                var httpMethod = 'GET'; // default
                if (restPref.httpMethod === 'POST') {
                    httpMethod = 'POST'; // can be configured to use POST for long parameter names
                }
                var paramMap = getParameterMap(restPref, domainModel);
                if (httpMethod === 'GET') {
                    url = processUrl(url, domainModel, paramMap);
                    requests.push($http({
                        method: httpMethod,
                        url: url
                    }));
                }
                else {
                    // For POST requests, we do not add parameters to the url; rather, we add them to the data body
                    // for a url-encoded form POST
                    url = processUrl(url, domainModel);
                    requests.push($http({
                        method: httpMethod,
                        url: url,
                        data: $.param(paramMap),
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                    }));
                }
                // check to see if there's additional cusomId.<index>... preferences defined
                index++;
                currentCustomId = customId + '.' + index;
                restPref = amlConstants.config.custom.details;
                restPref = amlCoreUtils.getNestedObjectProperty(restPref, currentCustomId);
            }
            // collect all the response promises into a single promise
            return $q.all(requests).then(function (responses) {
                responses.forEach(function (response, index) {
                    var id = customId;
                    // handle the case where there's additional configured URLs for this id
                    // (ex: customer.2..., customer.3...)
                    if (index > 0) {
                        var oneBasedIndex = index + 1;
                        id = id + '.' + oneBasedIndex;
                    }
                    // get any additional configured preferences for this requests, and include them in the response
                    var configurationObject = amlCoreUtils.getNestedObjectProperty(amlConstants.config.custom.details, id);
                    if (configurationObject) {
                        if (configurationObject.title) {
                            response.title = configurationObject.title;
                        }
                        if (configurationObject.ignoreProperties) {
                            response.ignoreProperties = configurationObject.ignoreProperties.split(',').map(function (val) { return val.trim(); });
                        }
                        // if a preference was set to disable pretty formatting, then we'll just leave original JSON property names
                        if (configurationObject.disableNiceFormatting) {
                            response.usePrettyLabels = false;
                        }
                        else {
                            response.usePrettyLabels = true;
                        }
                        response.processLinks = getProcessLinks(configurationObject.disableLinks);
                        if (configurationObject.rootProperty) {
                            // if a rootProperty was specified, then return the JSON starting at that property, rather
                            // than the whole JSON object
                            var interpolate = true;
                            if (!isNaN(configurationObject.rootProperty)) {
                                // if a number is listed, assume this is an array, and we will not interpolate so that
                                // we look up the value: model['0'] which is a property of an array.
                                interpolate = false;
                            }
                            var nestedOb = amlCoreUtils.getNestedObjectAsJson(response.data, configurationObject.rootProperty, interpolate);
                            response.data = nestedOb;
                        }
                    }
                    return response;
                });
                return responses;
            });
        }
        function getProcessLinks(disableLinks) {
            // AML-782: If disableLinks is set to true, then don't make links out of alert IDs and party numbers
            // If this is not set in the database, then response.processLinks = true
            if (disableLinks) {
                return false;
            }
            else {
                return true;
            }
        }
        /**
         * Extract just the name from a variable token;
         * example: '${customerName}' and returns 'customerName'
         * @param variableMatch
         * @returns {string}
         */
        function getTokenName(variableMatch) {
            if (variableMatch && variableMatch.length >= 3) {
                return variableMatch.substr(2, variableMatch.length - 3);
            }
            else {
                return variableMatch;
            }
        }
        function getParams(paramsString) {
            var params = null;
            if (paramsString) {
                params = paramsString.split(',');
                params = params.map(function (param) { return param.trim(); });
            }
            return params;
        }
        /**
         * take a map of parameter name/values and append them to a given url string
         * @param paramsMap
         * @param url
         * @returns {string}
         */
        function addParametersToUrl(paramsMap, url) {
            if (paramsMap) {
                var paramStr = $.param(paramsMap);
                if (paramStr) {
                    if (url.indexOf('?') === -1) {
                        url += '?' + paramStr;
                    }
                    else {
                        url += '&' + paramStr;
                    }
                }
            }
            return url;
        }
        /**
         * Take a url with variable tokens (eg: ${customerNumber}) and replace them with values taken from the
         * specified model using the same key
         *
         * @param url - the url, possibly containing replacement tokens
         * @param model - the domain model to use for resolving variables into model values
         * @param paramsMap object map representing parameter name/values
         * @returns {string}
         */
        function processUrl(url, model, paramsMap) {
            if (url && model) {
                var variables = url.match(/\${.*?}/g);
                if (variables) {
                    variables.forEach(function (variableToken) {
                        var variableName = getTokenName(variableToken);
                        var val = amlCoreUtils.getNestedObjectProperty(model, variableName, true);
                        if (val) {
                            url = url.replace(variableToken, val);
                        }
                    });
                }
            }
            // handle relative url (ex: /customers/1234.json); in that case assumes making an AML /rest request
            if (url.indexOf('/') === 0) {
                url = amlConfig.baseUrl + url;
            }
            // if there are any params, add them to the url
            url = addParametersToUrl(paramsMap, url);
            return url;
        }
    }
})();


(function () {
    'use strict';
    JsonDisplayDirectiveController.$inject = ["jsonDisplayService"];
    angular.module('aml.core').controller('JsonDisplayDirectiveController', JsonDisplayDirectiveController);
    function JsonDisplayDirectiveController(jsonDisplayService) {
        var vm = this;
        vm.properties = [];
        vm.arrayLists = [];
        vm.nestedObjects = [];
        vm.excludedPropertyMap = {};
        activate();
        ///////////
        function activate() {
            if (vm.model) {
                // convert list of excluded properties to a faster hashmap lookup object
                _.each(vm.ignoreProperties, function (prop) {
                    vm.excludedPropertyMap[prop] = true;
                });
                collectPropertiesFromJsonObject(vm.model);
            }
        }
        /**
         * if prettyLabels has been set, then get a nicely-formatted name for the property label.
         * This is the default generally, unless a preference was set to use original unaltered property name
         * @param propertyName
         * @returns {any}
         */
        function getNiceName(propertyName) {
            if (vm.usePrettyLabels) {
                return jsonDisplayService.getNiceName(propertyName);
            }
            else {
                return propertyName;
            }
        }
        function collectPropertiesFromJsonObject(obj) {
            var jsonPropObject = null;
            // if top level is just an array, add it as a grid
            if (Array.isArray(obj)) {
                jsonPropObject = {
                    type: 'array',
                    isArray: true,
                    value: obj
                };
                jsonDisplayService.setGridProperties(jsonPropObject, obj, vm.excludedPropertyMap, vm.usePrettyLabels, vm.processLinks);
                vm.arrayLists.push(jsonPropObject);
            }
            else {
                // iterate over all properties and add them to either the property, array, or nestedObject lists
                // to be rendered appropriately
                for (var property in obj) {
                    if (obj.hasOwnProperty(property) && property.indexOf('$') !== 0 &&
                        !jsonDisplayService.isExcludedProperty(property, vm.excludedPropertyMap)) {
                        var propName = getNiceName(property);
                        var isArray = Array.isArray(obj[property]);
                        var value = obj[property];
                        // if a string value is a link, we'll set the isLink property to have this value linkified in the UI
                        var isLink = jsonDisplayService.isSafeLink(value);
                        var type = jsonDisplayService.getType(value);
                        jsonPropObject = {
                            name: propName,
                            type: type,
                            value: value,
                            isArray: isArray,
                            isLink: isLink
                        };
                        if (isArray) {
                            var arrayModel = obj[property];
                            jsonPropObject.title = getNiceName(property);
                            jsonDisplayService.setGridProperties(jsonPropObject, arrayModel, vm.excludedPropertyMap, vm.usePrettyLabels, vm.processLinks);
                            vm.arrayLists.push(jsonPropObject);
                        }
                        else if (type === 'object') {
                            vm.nestedObjects.push(jsonPropObject);
                        }
                        else {
                            vm.properties.push(jsonPropObject);
                        }
                    }
                }
            }
        }
    }
})();


/**
 * @ngdoc directive
 * @name    aml.core:amlJsonDisplay
 * @param {any} model the JSON model to display
 * @param {boolean} usePrettyLabels - if set to true, use pretty labels (ex: CUSTOMER_FIRST_NAME --> Customer First Name)
 * @param {any} ingoreProperties array of propery names to ignore; any properties with this name will not be displayed
 *
 * @restrict E
 *
 * @description
 * The 'amlJsonDisplay' directive is used to display a JSON object in a nicely formatted view.
 * JSON properties are displayed in the following manner in the following order:
 *  1. Top-level simple properties displayed as label/value rows
 *  2. Any nested object properties (recursively rendered using these rules)
 *  3. Top-level array property values (rendered as grids)
 *
 * @element ANY
 * @required on-click
 *
 * @example
 <pre>
 <aml-json-display model="model.data" />
 </pre>
 */
(function () {
    'use strict';
    amlJsonDisplayDirective.$inject = ["recursiveDirectiveService"];
    angular
        .module('aml.core')
        .directive('amlJsonDisplay', amlJsonDisplayDirective);
    /* @ngInject */
    function amlJsonDisplayDirective(recursiveDirectiveService) {
        var directive = {
            restrict: 'E',
            templateUrl: 'custom/jsonDisplay/amlJsonDisplayDirective.html',
            controller: 'JsonDisplayDirectiveController',
            controllerAs: 'vm',
            scope: {
                //  the scope is isolated
                model: '=',
                usePrettyLabels: '=',
                processLinks: '=',
                ignoreProperties: '='
            },
            compile: function (element) {
                // This directive recursively calls itself to render nested JSON objects.
                // To enable this, use the compile function from the recursiveDirectiveService,
                // and return the linking function(s) which it returns
                return recursiveDirectiveService.compile(element);
            },
            bindToController: true
        };
        return directive;
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:jsonDisplayService
 *
 * @restrict E
 *
 * @description
 * The jsonDisplayService service provides utilities used to handle displaying and nicely rendering JSON objects
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    jsonDisplayService.$inject = ["$sanitize", "titleCaseFilter", "kendoGridRendererService", "amlCoreUtils"];
    angular
        .module('aml.core')
        .factory('jsonDisplayService', jsonDisplayService);
    /* @ngInject */
    function jsonDisplayService($sanitize, titleCaseFilter, kendoGridRendererService, amlCoreUtils) {
        var service = {
            setGridProperties: setGridProperties,
            constructGridColumnsFromObject: constructGridColumnsFromObject,
            getNiceName: getNiceName,
            isSafeLink: isSafeLink,
            isDateType: isDateType,
            isDateTimeType: isDateTimeType,
            getType: getType,
            isExcludedProperty: isExcludedProperty,
            getGridTemplate: getGridTemplate
        };
        return service;
        /**
         * Get type of the value, handling inspecting JSON string types to see if it's actually a 'date' value
         *
         * @param value
         * @returns {any}
         */
        function getType(value, useDateOnly) {
            if (useDateOnly === void 0) { useDateOnly = false; }
            // if the value is null, don't set any type.  (The default 'typeof null' is object)
            if (amlCoreUtils.isNullOrUndefined(value)) {
                return null;
            }
            var type = typeof value;
            // inspect if a string type is really a JSON date representation
            if (isDateTimeType(value, type)) {
                if (useDateOnly) {
                    type = 'date';
                }
                else {
                    type = 'dateTime';
                }
            }
            else if (isDateType(value, type)) {
                type = 'date';
            }
            return type;
        }
        function isDateType(value, type) {
            if (value && (type === 'string' || type === 'date') &&
                value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}/)) {
                return true;
            }
            else {
                return false;
            }
        }
        function isDateTimeType(value, type) {
            if (value && (type === 'string' || type === 'date' || type === 'dateTime') &&
                value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}/)) {
                return true;
            }
            else {
                return false;
            }
        }
        /**
         * Checks if a string value is a link (of the form http://... or https://...) and that it is safe.
         * It uses the angular sanitizer to determine if there is anything unsafe found in the link value; if so,
         * this function returns false.
         * @param potentialLinkValue
         * @returns {boolean} true if the value is an http(s) link and is found to be safe
         */
        function isSafeLink(potentialLinkValue) {
            var isLink = false;
            var type = typeof potentialLinkValue;
            if (type === 'string' && potentialLinkValue && (potentialLinkValue.indexOf('http://') === 0 || potentialLinkValue.indexOf('https://') === 0)) {
                if (potentialLinkValue.indexOf('<') === -1 && potentialLinkValue.indexOf('>') === -1) {
                    var checkValue = "<a href=\"" + potentialLinkValue + "\"></a>";
                    // $sanitize changes all & to encoded value, so we do the same in order to compare the original value
                    checkValue = checkValue.replace(/&/g, '&amp;');
                    var sanitizeValue = null;
                    try {
                        sanitizeValue = $sanitize(checkValue);
                    }
                    catch (e) {
                    }
                    // if anything was found that needed sanitized; then don't linkify this link
                    if (checkValue === sanitizeValue) {
                        isLink = true;
                    }
                }
            }
            return isLink;
        }
        function getNiceName(propertyName) {
            /*
            AML-782: If the customer has added p_ or a_ to the beginning of their column name to indicate the field
            contains party numbers or alert IDs, respectively, those prefixes need to be removed here. (By the time
            this function is called, they have already served their purpose, in the getGridTemplate function).
             */
            if (propertyName.substring(0, 2) === 'a_' || propertyName.substring(0, 2) === 'p_') {
                propertyName = propertyName.substring(2);
            }
            var niceName = null;
            // separate snakeCase/camelcase into separate words
            if (propertyName.indexOf('_') > -1) {
                // nice-ify-words
                niceName = propertyName.replace(/(_+)/g, ' ');
            }
            else {
                niceName = propertyName.replace(/([A-Z]+)/g, ' $1'); // .replace(/([A-Z][a-z])/g, ' $1');
            }
            // capitalize the start of each word
            niceName = titleCaseFilter(niceName);
            return niceName;
        }
        function isExcludedProperty(propertyName, excludedPropertyMap) {
            return excludedPropertyMap && !!excludedPropertyMap[propertyName];
        }
        /**
         * Set properties specific to JSON grids.
         * 1. We add a custom Export to CSV action to use Kendo grid, since we don't own this rest service and can't
         * use our generic .csv approach.
         * 2. We want to override with a large maximum pagesize, as we use the kendo grid export to CSV and it can
         * only export visible items for a single page.
         * @param jsonPropObject
         * @param arrayModel
         */
        function setGridProperties(jsonPropObject, arrayModel, ignoreProperties, usePrettyLabels, processLinks) {
            if (usePrettyLabels === void 0) { usePrettyLabels = true; }
            if (processLinks === void 0) { processLinks = true; }
            jsonPropObject.grid = {};
            jsonPropObject.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults();
            // add extra large 1000 pagesize option and 'all'
            jsonPropObject.gridOptions.pageable.pageSizes = [5, 10, 20, 50, 100, 1000, 'all'];
            // we disable refresh, because we do not hook up a remote action to the grid; rather we just
            // seed it with local already-fetched data. There's no way to refresh since the grid doesn't
            // know about the request that the CustomDetails controller made
            jsonPropObject.gridOptions.pageable.refresh = false;
            jsonPropObject.gridColumns = constructGridColumnsFromObject(arrayModel, ignoreProperties, usePrettyLabels, processLinks);
            jsonPropObject.gridOptions.scrollable = true; // Let the grid scroll horizontally S1394919
        }
        function getGridTemplate(value, type, property, processLinks) {
            var template = null;
            if (processLinks && property.substring(0, 2).toUpperCase() === 'A_') {
                template = '<a href="\\#/alerts/{{dataItem.' + property + '}}">{{dataItem.' + property + '}}</a>';
            }
            else if (processLinks && property.substring(0, 2).toUpperCase() === 'P_') {
                template = '<a href="\\#/customers/{{dataItem.' + property + '}}">{{dataItem.' + property + '}}</a>';
            }
            else if (isDateTimeType(value, type)) {
                template = kendoGridRendererService.longDateMediumTime(property);
            }
            else if (isDateType(value, type)) {
                template = kendoGridRendererService.longDate(property);
            }
            return template;
        }
        /**
         * iterate through all objects in the array and construct a list of grid columns based on each
         * unique property found across all the objects
         *
         * @param arrayModel
         * @returns {Array}
         */
        function constructGridColumnsFromObject(arrayModel, ignorePropertiesMap, usePrettyLabels, processLinks) {
            if (usePrettyLabels === void 0) { usePrettyLabels = true; }
            if (processLinks === void 0) { processLinks = true; }
            var gridColumns = {};
            var orderIndex = 0;
            arrayModel.forEach(function (item, index) {
                // go through each item in the array; if it's a JSON object, create a gridColumn for each object property
                if (typeof item === 'object') {
                    addOrUpdateColumnForObject(item, ignorePropertiesMap, gridColumns, usePrettyLabels, processLinks, orderIndex);
                }
                else {
                    // this is a non-json Object, regular primitive array object. In this case
                    // we'll wrap it in a single JSON object so that it can be used with the grid (which operates
                    // on JSON objects only)
                    var wrapperPropertyName = 'item';
                    arrayModel[index] = {};
                    arrayModel[index][wrapperPropertyName] = item;
                    var wrapperColumn = { field: wrapperPropertyName };
                    gridColumns[wrapperPropertyName] = wrapperColumn;
                }
            });
            // convert the map of gridcolumns to a sorted array, which is the order Kendo displays the columns.
            // This maintains the order that the properties were found in the JSON object.
            var gridColumnList = _.values(gridColumns).sort(function (col1, col2) {
                return col1.order - col2.order;
            });
            return gridColumnList;
        }
        /**
         * add a grid column for this object
         * @param item
         * @param ignorePropertiesMap
         * @param gridColumns
         * @param usePrettyLabels
         * @param orderIndex
         */
        function addOrUpdateColumnForObject(item, ignorePropertiesMap, gridColumns, usePrettyLabels, processLinks, orderIndex) {
            /*jshint maxcomplexity:12 */
            for (var property in item) {
                if (item.hasOwnProperty(property) && property.indexOf('$') !== 0 && !isExcludedProperty(property, ignorePropertiesMap)) {
                    var value = item[property];
                    var type = getType(value, true);
                    var gridColumn = gridColumns[property];
                    //rename columns not confirming to Angular identifier requirements to avoid errors when
                    // external request returns JSON with property names not supported by Angular, see S1468839
                    var newName = property;
                    var doNotRename = /^[$_a-zA-Z]+\w*$/.test(property);
                    if (!gridColumn) {
                        if (!doNotRename) {
                            newName = 'AML$$_' + orderIndex;
                            item[newName] = value;
                        }
                        var template = getGridTemplate(value, type, property, processLinks);
                        var column = {
                            field: newName,
                            title: usePrettyLabels ? getNiceName(property) : property,
                            type: type,
                            template: template,
                            order: orderIndex++ // used for sort
                        };
                        gridColumns[property] = column;
                    }
                    else {
                        if (!doNotRename) {
                            newName = gridColumn.field;
                            item[newName] = value;
                        }
                        // check existing type
                        if (gridColumn.type !== type) {
                            // if the previous recorded value was null, set current type as type
                            if (gridColumn.type === null) {
                                gridColumn.template = getGridTemplate(value, type, property, processLinks);
                                gridColumn.type = type;
                            }
                            else if (type !== null) {
                                // value types differ; since there's no consistent value types across all objects, we
                                // can't determine the type of this column. So default the type to string.
                                gridColumn.type = 'string';
                                gridColumn.template = null; // should not be any type-based template in this case
                            }
                        }
                    }
                }
            }
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.customer:customerService
 *
 * @restrict E
 *
 * @description
 * The customers service is used to retrieve customers from the back-end services
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    customerService.$inject = ["$resource", "amlConfig", "amlConstants", "_", "exceptionResourceHandler"];
    angular
        .module('aml.customer')
        .factory('customerService', customerService);
    /* @ngInject */
    function customerService($resource, amlConfig, amlConstants, _, exceptionResourceHandler) {
        /**
         * Resources
         */
        var alertsResource = $resource(amlConfig.baseUrl + '/customers/:id/alerts', {
            id: '@id', relationships: 'allAlerts' }, {
            get: { method: 'GET', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var associatedDetailsResource = $resource(amlConfig.baseUrl + '/customers/:id/associatedDetails', { id: '@id' }, { get: {
                method: 'GET', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var customersResource = $resource(amlConfig.baseUrl + '/customers/:id', {
            id: '@id',
            relationships: 'accounts,households,relatedAddresses,associatedEntities' // pull in related information to display
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandlerRedirectOnNotFound }
            }
        });
        var associatedCustomerAttributesResource = $resource(amlConfig.baseUrl + '/customers/:id/associatedCustomerAttributes', {
            id: '@id',
            relationshipCode: '@relationshipCode',
            relatedPartyNumber: '@relatedPartyNumber'
        }, {
            get: {
                method: 'GET', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var alertedCustomersResource = $resource(amlConfig.baseUrl + '/customers/alerted', {
            // list parameters
            start: '@start',
            limit: '@limit',
            relationships: '@relationships',
            sortBy: '@sortBy',
            previousCount: '@previousCount',
            filter: '@filter',
            ownerUserLongId: '@ownerUserLongId'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        var triageRouteCustomersResource = $resource(amlConfig.baseUrl + '/customers/triageRequests/route', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler } }
        });
        var triageCheckinCustomersResource = $resource(amlConfig.baseUrl + '/customers/triageRequests/checkin', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var triageCheckoutCustomersResource = $resource(amlConfig.baseUrl + '/customers/triageRequests/checkout', {}, { create: {
                method: 'POST', interceptor: { responseError: exceptionResourceHandler.resourceErrorLogOnlyHandler } }
        });
        var service = {
            getCustomers: getCustomers,
            getCustomer: getCustomer,
            getAlerts: getAlerts,
            getAssociatedDetails: getAssociatedDetails,
            getAssociatedCustomerAttributes: getAssociatedCustomerAttributes,
            getCustomersPage: getCustomersPage,
            getCustomerInArrayByNumber: getCustomerInArrayByNumber,
            routeCustomers: routeCustomers,
            checkinCustomers: checkinCustomers,
            checkoutCustomers: checkoutCustomers
        };
        return service;
        /**
         * Get list of customers
         * @param start
         * @param pageSize - the page size for each page of results
         * @param sortBys array of SortBy objects indicating the column and sort direction
         * @param filterStr the filter string to filter the query by
         * @param currentUserIdOwner - the current user to filter the results by; if not specified, then
         *  all customers matching the filter are returned
         * @param previousCount if the count is known and does not need to be recalculated on
         *  again by the service endpoint, it can be supplied (this can aid in performance if
         *  the initial count is generally sufficient for further pages)
         * @returns {$promise|*}
         */
        function getCustomers(start, pageSize, sortBys, filterStr, currentUserIdOwner, previousCount) {
            var sortByList = null;
            if (sortBys) {
                sortByList = '';
                for (var i = 0; i < sortBys.length; i++) {
                    if (i > 0) {
                        sortByList = sortByList + ',';
                    }
                    sortByList = sortByList + sortBys[i].name + ':' + sortBys[i].direction;
                }
            }
            if (!pageSize) {
                pageSize = amlConstants.defaultPageSize;
            }
            var filter = null;
            if (filterStr && filterStr.length >= 0) {
                filter = filterStr;
            }
            return alertedCustomersResource.get({
                start: start,
                limit: pageSize,
                previousCount: previousCount,
                sortBy: sortByList,
                filter: filter,
                ownerUserLongId: currentUserIdOwner
            }).$promise;
        }
        /**
         * Get the next page of list results
         * @param uri the uri to the next page of the results (returned as 'next' link href in the initial result
         *     request)
         * @returns {$promise|*}
         */
        function getCustomersPage(uri) {
            var resource = $resource(uri, {}, { get: { method: 'GET', params: {}, isArray: false } });
            return resource.get().$promise;
        }
        /**
         * Get a customer by customer number
         * @param customerid
         * @returns {$promise|*}
         */
        function getCustomer(customerid) {
            return customersResource.get({ id: customerid }).$promise;
        }
        function getCustomerInArrayByNumber(customerNumber, array) {
            var customer = _.find(array, function (item) {
                return item && item.customerNumber && item.customerNumber === customerNumber;
            });
            return customer;
        }
        /**
         * route an array of customers
         * @param customerNumbers
         * @param routeToUser
         * @returns {$promise|*}
         */
        function routeCustomers(customerNumbers, routeToUser) {
            var customerTriageParams = {
                customerNumbers: customerNumbers,
                ownerUserLongId: routeToUser
            };
            return triageRouteCustomersResource.create({}, customerTriageParams).$promise;
        }
        /**
         * checkin an array of customers
         * @param customerNumbers
         * @returns {$promise|*}
         */
        function checkinCustomers(customerNumbers) {
            var customerTriageParams = {
                customerNumbers: customerNumbers
            };
            return triageCheckinCustomersResource.create({}, customerTriageParams).$promise;
        }
        /**
         * checkout an array of customers
         * @param customerNumbers
         * @returns {$promise|*}
         */
        function checkoutCustomers(customerNumbers) {
            var customerTriageParams = {
                customerNumbers: customerNumbers
            };
            return triageCheckoutCustomersResource.create({}, customerTriageParams).$promise;
        }
        /**
         * Get all alerts associated with a given customer
         * @param customerid
         * @returns {$promise|*}
         */
        function getAlerts(customerid) {
            return alertsResource.get({ id: customerid }).$promise;
        }
        /**
         * Get associated details for a given customer
         *
         * @param customerid
         * @returns {$promise|*}
         */
        function getAssociatedDetails(customerid) {
            return associatedDetailsResource.get({ id: customerid }).$promise;
        }
        function getAssociatedCustomerAttributes(customerid, relatedPartyNumber, relationshipCode) {
            return associatedCustomerAttributesResource.get({ id: customerid, relatedPartyNumber: relatedPartyNumber, relationshipCode: relationshipCode }).$promise;
        }
    }
})();


(function () {
    'use strict';
    EntityListDirectiveController.$inject = ["logger", "kendoGridRendererService", "entityService", "$state", "resources", "amlConstants", "usersService", "$scope", "dataMessagingServiceFactory", "entityListDataMessagingService", "segmentNameFilter", "scenarioService"];
    angular
        .module('aml.customer')
        .controller('EntityListDirectiveController', EntityListDirectiveController);
    /* jshint maxparams: 18*/
    function EntityListDirectiveController(logger, kendoGridRendererService, entityService, $state, resources, amlConstants, usersService, $scope, dataMessagingServiceFactory, entityListDataMessagingService, segmentNameFilter, scenarioService) {
        var vm = this;
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.resources = resources;
        vm.currentEntity = {};
        vm.showSummary = false;
        vm.entitiesCount = null;
        vm.selectedEntitiesCount = null;
        // grid options
        vm.grid = {};
        vm.defaultPageSize = Math.max(50, vm.pageSize, amlConstants.config.triageListPageSize);
        var resetToFirstPage = (amlConstants.config && amlConstants.config.triageList && angular.isDefined(amlConstants.config.triageList.resetToFirstPage) ?
            amlConstants.config.triageList.resetToFirstPage : false);
        vm.handleDoubleClick = handleDoubleClick;
        vm.getEntities = getEntities;
        vm.displayMLS = true;
        //call activate before creating grid column to see if MLS has to be hidden
        activate();
        vm.gridColumns = [
            { field: 'priority', title: resources.aml.customer.priority,
                width: '4%',
                filterable: kendoGridRendererService.getPriorityCheckboxFilter('entityPriority'),
                template: kendoGridRendererService.entityPriorityRenderer('priority'),
                type: 'number',
                attributes: {} // don't add number class styling
            },
            { field: 'alertCount', title: resources.aml.customer.alerts,
                type: 'number',
                width: '4%'
            },
            {
                field: 'entityName', title: resources.aml.customer.name,
                width: '18%',
                template: kendoGridRendererService.titleCase('entityName')
            },
            {//resources.aml.common.employeeIndicatorHeaderTitleExt
                field: 'employeeIndicator', title: resources.aml.common.employeeIndicatorHeaderTitleExt,
                width: '8%',
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'queueCode', title: resources.aml.entity.queueExt,
                width: '22%',
                filterable: kendoGridRendererService.getCheckboxFilter('queueName'),
                template: '{{dataItem.queueCode | queueName:true}}'
            },
            {
                field: 'entitySegmentId', title: resources.aml.segment.segmentLabel,
                width: '8%',
                template: segmentNameFilter,
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(segmentNameFilter) },
                filterable: kendoGridRendererService.getCheckboxFilterForValues(scenarioService.getSegments('nondeleted'), true, 'segmentName', 'entitySegmentId', 'localizedSegmentName')
            },
            { field: 'entityKey', type: 'number', hidden: true },
            { field: 'entityNumber', hidden: true },
            {
                field: 'entityLevelCode', title: resources.aml.entity.type,
                width: '8%',
                filterable: kendoGridRendererService.getCheckboxFilter('entityLevel'),
                template: kendoGridRendererService.enum('entityLevelCode', 'entityLevel')
            },
            {
                field: 'riskScore', title: resources.aml.customer.risk,
                filterable: kendoGridRendererService.getCheckboxFilter('riskClassification'),
                template: kendoGridRendererService.enum('riskScore', 'riskClassification'),
                width: '5%'
            },
            {
                field: 'aggregateAmount', title: resources.aml.customer.aggregatedTransactionsAmount,
                type: 'number',
                template: kendoGridRendererService.currency('aggregateAmount'),
                width: '8%'
            },
/*
            {
                field: 'moneyLaunderingScore', title: resources.aml.entity.MLS,
                hidden: !vm.displayMLS,
                width: '8%',
                type: 'number'
            },
*/
            {
                field: 'currentAgeOfOldestAlert',
                type: 'number',
                width: '6%',
                title: resources.aml.entity.alertAge
            },
            {
                field: 'ownerUserId',
                title: resources.aml.customer.owner,
                width: '8%',
                template: '{{dataItem.ownerUserId | userName:true}}'
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            height: Math.max(400, amlConstants.config.triageListTableHeight),
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            remotePaging: true,
            selectFirstRowOnLoad: true
        });
        function getFilterWithQueueDisplayType(filter) {
            var combinedFilter;
            var displayQueueType = getDisplayCustomerType();
            if (displayQueueType === amlConstants.entityListQueueDisplayType.MY) {
                var currentUserName = getMyCustomerOnlyUser();
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'eq( ownerUserId, \'' + currentUserName + '\')');
            }
            else if (displayQueueType === amlConstants.entityListQueueDisplayType.AVAILABLE) {
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'blank( ownerUserId )');
            }
            else {
                combinedFilter = filter;
            }
            return combinedFilter;
        }
        vm.handleRowSelect = function (entityRows) {
            if (entityRows && entityRows.length > 0) {
                // update entity summary when a entity is selected;
                // if multiple rows selected, don't updated the entity summary
                vm.selectedEntitiesCount = entityRows.length;
                if (entityRows.length === 1) {
                    selectEntity(entityRows[0]);
                }
            }
            else {
                // if no entity selected, clear the summary
                clearEntity();
                vm.selectedEntitiesCount = 0;
            }
        };
        ////////////////
        function activate() {
            if (amlConstants.config.aml && amlConstants.config.aml.MLS && angular.isDefined(amlConstants.config.aml.MLS.display)) {
                vm.displayMLS = amlConstants.config.aml.MLS.display;
            }
            // set function on the dataMessagingService to get selected entities based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            entityListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedEntitiesFromSelectedRows);
            $scope.$watch(function () {
                return entityListDataMessagingService.getDisplayOwnersType();
            }, function (displayEntitiesWithOwnersType, oldValue) {
                if (displayEntitiesWithOwnersType === oldValue) {
                    return;
                }
                myEntitiesFilterChanged(displayEntitiesWithOwnersType);
            });
            $scope.$on('entitiesOwnerChanged', function (event, changedData) {
                updateEntitiesOwner(changedData.entityIds, changedData.owner, changedData.queue, changedData.replaceCurrentQueue, changedData.replaceCurrentOwner);
            });
            $scope.$on('reloadEntitiesGridPage', function () {
                kendoGridRendererService.refreshGrid(vm.grid, resetToFirstPage);
            });
            $scope.$on('entitiesAlertCountChanged', function (event, changedData) {
                updateEntitiesAlertCount(changedData.entityIds, changedData.alertCount);
            });
        }
        // function reloadGrid() {
        //     vm.grid.dataSource.read();
        // }
        // on double-click, go to entity detail page
        function handleDoubleClick(selectedEntity) {
            if (selectedEntity && selectedEntity.entityNumber && selectedEntity.entityLevelCode) {
                var entityState = entityService.getStateForEntity(selectedEntity);
                updateSelectedCount();
                $state.go(entityState.stateName, entityState.stateParams);
            }
        }
        function getUpdateFields(entityIds) {
            //S1387974 - we do not want to use keys anymore, all entity types have unique entityNumber values
            //S1404179 - fsk_alerted_entity does not have a key anymore
            var fields;
            fields = ['entityNumber', 'entityLevelCode'];
            return fields;
        }
        function getRouteUpdateFields(entityIds) {
            var fields;
            fields = ['entityNumber', 'entityLevelCode', 'queueCode'];
            return fields;
        }
        function updateEntitiesOwner(entityIds, owner, queue, replaceCurrentQueue, replaceCurrentOwner) {
            // if we have the key set for any entityId, then we'll update by key/type instead of number/type
            entityIds = entityService.ensureAppropriateEntityIds(entityIds);
            var fields = getRouteUpdateFields(entityIds);
            kendoGridRendererService.updateDataItemsWithCompositeKey(entityIds, fields, function (entityToBeUpdated) {
                if (replaceCurrentQueue) {
                    entityToBeUpdated.queueCode = queue;
                }
                if (replaceCurrentOwner) {
                    entityToBeUpdated.ownerUserId = owner;
                }
            }, vm.grid);
        }
        function updateEntitiesAlertCount(entityIds, count) {
            // if we have the key set for any entityId, then we'll update by key/type instead of number/type
            entityIds = entityService.ensureAppropriateEntityIds(entityIds);
            var fields = getUpdateFields(entityIds);
            kendoGridRendererService.updateDataItemsWithCompositeKey(entityIds, fields, function (entityToBeUpdated) {
                if (!entityToBeUpdated.ownerUserId) {
                    // if owner is null/undefined, the kendo update re-renders as 'null'
                    entityToBeUpdated.ownerUserId = '';
                }
                entityToBeUpdated.alertCount = count;
            }, vm.grid);
            _.each(entityIds, function (entityId) {
                // TODO: here
                if (vm.currentEntity && vm.currentEntity.entityNumber === entityId.entityNumber) {
                    // tell alerts messaging service that the alerts have changed in order to update
                    // the alerts grid
                    dataMessagingService.alertsChanged();
                }
            });
        }
        /**
         * Get the selected entities based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEntitiesFromSelectedRows() {
            var entities = [];
            if (vm.grid && vm.grid.select) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var entity = vm.grid.dataItem(rowSelection);
                    if (entity) {
                        entities.push(entity);
                    }
                });
            }
            updateSelectedCount(entities);
            return entities;
        }
        function updateSelectedCount(entities) {
            vm.selectedEntitiesCount = 0;
            if (entities) {
                vm.selectedEntitiesCount = entities.length;
                return;
            }
            if (vm.grid) {
                var selectedEntities = vm.grid.select();
                if (selectedEntities) {
                    vm.selectedEntitiesCount = selectedEntities.length;
                }
            }
        }
        function getEntities(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.defaultPageSize);
            // add queue filtering (My Entities, etc) to the grid filter
            filterStr = getFilterWithQueueDisplayType(filterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.entitiesCount;
            }
            entityService.getEntities(pageInfo.start, pageInfo.limit, sortCols, filterStr, null, previousCount).then(function (data) {
                vm.entitiesCount = data.count;
                // if no entities returned, clear the customer summary
                if (vm.entitiesCount === 0) {
                    clearEntity();
                }
                e.success(data);
                updateSelectedCount();
            }, function (data, status, headers, config) {
                clearEntity();
                logger.error('Could not get entities');
                updateSelectedCount();
            });
        }
        function myEntitiesFilterChanged(displayEntitiesType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
            updateSelectedCount();
        }
        function getDisplayCustomerType() {
            return entityListDataMessagingService.getDisplayOwnersType();
        }
        function getMyCustomerOnlyUser() {
            return usersService.getCurrentUserId();
        }
        function selectEntity(entity) {
            vm.currentEntity = entity;
            vm.currentEntity.entityId = entityService.createEntityId(entity);
            var amount = kendoGridRendererService.formatCurrency(entity.aggregateAmount);
            // Reset selected alerts to none when loading customer details page.
            //dataMessagingService.setAlertIds('alertids', 'all');
            dataMessagingService.setTotalAmount(amount);
            vm.showSummary = true;
        }
        function clearEntity() {
            vm.currentEntity = null;
            vm.showSummary = false;
        }
    }
})();


/**
 * Created by tommut on 1/22/2015.
 */
(function () {
    'use strict';
    EntityCaseListController.$inject = ["resources", "customerService", "amlConstants", "linksProcessor", "kendoGridRendererService", "logger", "$scope", "amlLov", "$state", "casesService", "entityService"];
    angular.module('aml.entities').controller('EntityCaseListController', EntityCaseListController);
    /* jshint maxparams: 14*/
    function EntityCaseListController(resources, customerService, amlConstants, linksProcessor, kendoGridRendererService, logger, $scope, amlLov, $state, casesService, entityService) {
        var vm = this;
        vm.resources = resources;
        vm.casesCount = 0;
        vm.grid = {};
        // display case duration in months based on configurable lookback value
        var numOfDaysToLookBack = amlConstants.config.customers.caseActivityLookBackNumOfDays;
        vm.caseDuration = Math.round(numOfDaysToLookBack / 30);
        vm.entityId = entityService.normalizeEntityId(vm.entityId, vm.entityLevelCode, vm.entityNumber, vm.entityKey);
        //closeDate: {type: 'date'},
        var dataSourceOptions = {
            transport: {
                read: getCases
            },
            schema: {
                model: {
                    fields: {
                        timeRemaining: { type: 'number' },
                        caseId: { type: 'string' },
                        description: { type: 'string' },
                        casePriorityCode: { type: 'string' },
                        caseCategoryCode: { type: 'string' },
                        caseSubcategoryCode: { type: 'string' },
                        statusCode: { type: 'string' },
                        createDate: { type: 'date' },
                        closeDate: { type: 'date' },
                        lastUpdateDate: { type: 'date' },
                        employeeIndicator: { type: 'string' },
                        ownerUserLongId: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: vm.pageSize || 10,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            { field: 'timeRemaining', title: resources.aml.cases.timeRemaining,
                width: 100,
                template: kendoGridRendererService.countdownColumnRenderer('CAS'),
                filterable: false,
                sortable: false
            },
            { field: 'caseId', title: resources.aml.cases.id,
                width: 90,
                template: kendoGridRendererService.titleCase('caseId')
            },
            {
                field: 'description', title: resources.aml.cases.description,
                width: 130,
                template: kendoGridRendererService.titleCase('description')
            },
            {
                field: 'employeeIndicator', title: resources.aml.reviews.employeeIndicatorHeaderTitle,
                width: 90,
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'caseCategoryCode', title: resources.aml.cases.caseCategoryCode,
                template: kendoGridRendererService.enum('caseCategoryCode', 'caseCategory'),
                filterable: kendoGridRendererService.getCheckboxFilter('caseCategory'),
                width: 150
            },
            {
                field: 'caseSubcategoryCode', title: resources.aml.cases.caseSubcategoryCode,
                template: kendoGridRendererService.enum('caseSubcategoryCode', 'caseSubcategory'),
                filterable: kendoGridRendererService.getCheckboxFilter('caseSubcategory'),
                width: 150
            },
            {
                field: 'casePriorityCode', title: resources.aml.cases.casePriorityCode,
                width: 65,
                template: kendoGridRendererService.enum('casePriorityCode', 'priority'),
                filterable: kendoGridRendererService.getCheckboxFilter('priority')
            },
            { field: 'statusCode', title: resources.aml.cases.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'caseStatus'),
                filterable: kendoGridRendererService.getCheckboxFilter('caseStatus'),
                width: 145
            },
            {
                field: 'createDate',
                width: 180,
                title: resources.aml.cases.createDate,
                template: kendoGridRendererService.longDate('createDate')
            },
            {
                field: 'lastUpdateDate',
                width: 180,
                title: resources.aml.cases.updatedDate,
                template: kendoGridRendererService.longDate('lastUpdateDate')
            },
            {
                field: 'ownerUserLongId', title: resources.aml.cases.owner,
                width: 80,
                template: '{{dataItem.ownerUserLongId | userName:true}}'
            },
            {
                field: 'closeDate', title: resources.aml.case.closed,
                template: kendoGridRendererService.longDate('closeDate'),
                width: 110
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            scrollable: true
        });
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'customerCasesList');
            $scope.$watch(function () {
                return vm.entityId;
            }, function (newEntity, oldEntity) {
                if (newEntity && newEntity !== oldEntity) {
                    // refresh grid
                    kendoGridRendererService.refreshGrid(vm.grid);
                }
            }, true);
        }
        // on double-click, go to case detail page
        function handleDoubleClick(evt, data) {
            var selectedCase = vm.grid.dataItem(evt.currentTarget);
            if (selectedCase && selectedCase.caseId) {
                $state.go('caseDetails', { caseid: selectedCase.caseId });
            }
        }
        function getCases(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data);
            var lookbackFilter = casesService.getCasesForEntityLookbackFilter();
            var filterStr = kendoGridRendererService.getCustomFilterString(lookbackFilter, vm.gridOptions, e.data.filter);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.casesCount;
            }
            var ownerUserLongId = null;
            if (!vm.entityId || !vm.entityId.entityNumber) {
                ownerUserLongId = vm.ownerUserLongId;
            }
            //if grid is on the case details page then show related cases
            //otherwise it is either on the entity page or entity is selected on the case details page  - show cases for entity
            if (vm.caseId && (!vm.entityId || !vm.entityId.entityNumber)) {
                casesService.getCaseRelatedCases(pageInfo.start, pageInfo.limit, sortCols, filterStr, previousCount, ownerUserLongId, vm.caseId).then(function (data) {
                    vm.casesCount = data.count;
                    e.success(data);
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.cases.couldNotLoadCasesErrorText);
                });
            }
            else {
                casesService.getCasesForEntity(pageInfo.start, pageInfo.limit, sortCols, filterStr, ownerUserLongId, previousCount, vm.entityId).then(function (data) {
                    vm.casesCount = data.count;
                    e.success(data);
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.cases.couldNotLoadCasesErrorText);
                });
            }
        }
    }
})();


(function () {
    'use strict';
    EfilesListController.$inject = ["efilesService", "logger", "linksProcessor", "kendoGridRendererService", "$state", "$q", "$timeout", "$filter", "resources", "amlConstants", "amlLov", "usersService", "$scope", "efilesListDataMessagingService"];
    angular
        .module('aml.efiles')
        .controller('EfilesListDirectiveController', EfilesListController);
    /* jshint maxparams: 14*/ /* jshint maxstatements: 50 */
    function EfilesListController(efilesService, logger, linksProcessor, kendoGridRendererService, $state, $q, $timeout, $filter, resources, amlConstants, amlLov, usersService, $scope, efilesListDataMessagingService /*, $locale*/) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        var firstDataLoad = true;
        vm.efilesCount = null;
        var dataSourceOptions = {
            transport: {
                read: getEfiles
            },
            schema: {
                model: {
                    fields: {
                        formConfigKey: { type: 'string' },
                        efileId: { type: 'string' },
                        description: { type: 'string' },
                        statusCode: { type: 'string' },
                        outputReportCount: { type: 'number' },
                        outputCreateDate: { type: 'date' },
                        agencyRefId: { type: 'string' },
                        transmissionId: { type: 'string' },
                        transmissionDate: { type: 'date' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: 50,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            {
                field: 'formConfigKey', title: resources.aml.regulatoryReports.reportType,
                width: 125,
                template: function (dataItem) {
                    return $filter('reportType')(dataItem.formConfigKey);
                },
                filterable: kendoGridRendererService.getCheckboxFilter('reportType')
            },
            { field: 'efileId', title: resources.aml.efiles.header.id,
                width: '15%',
                template: kendoGridRendererService.titleCase('efileId')
            },
            {
                field: 'description', title: resources.aml.efiles.header.description
            },
            //{ field: 'agencyStatusCode', title: resources.aml.efiles.statusCode,
            //    template: kendoGridRendererService.enum('agencyStatusCode', 'efileStatus'),
            //    filterable: kendoGridRendererService.getCheckboxFilter('efileStatus'),
            //    width: '10%'
            //},
            { field: 'statusCode', title: resources.aml.efiles.header.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'efileStatus'),
                filterable: kendoGridRendererService.getCheckboxFilter('efileStatus'),
                width: '10%'
            },
            {
                field: 'outputReportCount', title: resources.aml.efiles.header.reportCount,
                width: '10%'
            },
            {
                field: 'outputCreateDate',
                width: '10%',
                title: resources.aml.efiles.header.outputCreateDate,
                template: kendoGridRendererService.longDate('outputCreateDate')
            },
            {
                field: 'agencyRefId', title: resources.aml.efiles.header.agencyRefId,
                width: '10%'
            },
            //{
            //    field: 'createDate',
            //    width: '10%',
            //    title: resources.aml.efiles.createDate,
            //    template: kendoGridRendererService.longDate( 'createDate' )
            //},
            {
                field: 'transmissionId', title: resources.aml.efiles.header.transmissionId,
                width: '10%'
            },
            {
                field: 'transmissionDate',
                width: '10%',
                title: resources.aml.efiles.header.transmissionDate,
                template: kendoGridRendererService.longDate('transmissionDate')
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: 600,
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            dataBound: function (val) {
                if (firstDataLoad) {
                    kendoGridRendererService.selectFirstRow(vm.grid);
                    firstDataLoad = false;
                }
            }
        });
        function getFilterWithQueueDisplayType(filter) {
            //Only All display type
            return filter;
        }
        vm.handleRowSelect = function (efilesRows) {
            if (efilesRows && efilesRows.length > 0) {
                // update efile overview when a efile is selected;
                // if multiple rows selected, don't updated the efile summary
                if (efilesRows.length === 1) {
                    selectEfiles(efilesRows[0]);
                }
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'efilesList');
            // set function on the dataMessagingService to get selected efiles based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            efilesListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedEfilesFromSelectedRows, getSelectedEfileNamesFromSelectedRows);
            $scope.$watch(function () {
                return efilesListDataMessagingService.getDisplayOwnersType();
            }, function (displayEfilesWithOwnersType, oldValue) {
                if (displayEfilesWithOwnersType === oldValue) {
                    return;
                }
                myEfilesFilterChanged(displayEfilesWithOwnersType);
            });
            $scope.$on('efilesOwnerChanged', function (event, changedData) {
                updateEfilesOwner(changedData.efileNumbers, changedData.owner);
            });
            $scope.$on('efileListRefresh', function (event) {
                kendoGridRendererService.refreshGrid(vm.grid);
            });
        }
        // on double-click, go to efile detail page
        function handleDoubleClick(evt, data) {
            var selectedEfile = vm.grid.dataItem(evt.currentTarget);
            if (selectedEfile && selectedEfile.efileKey) {
                $state.go('efileDetails', { efilekey: selectedEfile.efileKey });
            }
        }
        function updateEfilesOwner(efileNumbers, owner) {
            kendoGridRendererService.updateDataItems(efileNumbers, 'efileId', function (efileToBeUpdated) {
                efileToBeUpdated.ownerUserLongId = owner;
            }, vm.grid);
        }
        /**
         * Get the selected efile numbers based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEfilesFromSelectedRows() {
            var efileNumbers = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aEfile = vm.grid.dataItem(rowSelection);
                    if (aEfile && aEfile.efileId) {
                        efileNumbers.push(aEfile.efileId);
                    }
                });
            }
            return efileNumbers;
        }
        /**
         * Get the selected efile names based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedEfileNamesFromSelectedRows() {
            var efileNames = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aEfile = vm.grid.dataItem(rowSelection);
                    if (aEfile && aEfile.efileId) {
                        efileNames.push(aEfile.efileId);
                    }
                });
            }
            return efileNames;
        }
        function getEfiles(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            // add queue filtering (My Efiles, etc) to the grid filter
            filterStr = getFilterWithQueueDisplayType(filterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.efilesCount;
            }
            efilesService.getEfiles(pageInfo.start, pageInfo.limit, sortCols, filterStr, null, previousCount).then(function (data) {
                vm.efilesCount = data.count;
                // if no efiles returned, clear the efile summary
                if (vm.efilesCount === 0) {
                    clearEfiles();
                }
                e.success(data);
            }, function (data, status, headers, config) {
                clearEfiles();
                logger.error('Could not get efiles');
            });
        }
        function myEfilesFilterChanged(displayEfilesType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
        }
        function selectEfiles(aEfile) {
            vm.currentEfile = aEfile;
        }
        function clearEfiles() {
            vm.currentEfile = null;
        }
    }
})();


(function () {
    'use strict';
    ReportsListController.$inject = ["reportsService", "logger", "linksProcessor", "kendoGridRendererService", "$state", "$q", "$timeout", "$filter", "resources", "amlLov", "amlConstants", "usersService", "$scope", "reportsListDataMessagingService"];
    angular
        .module('aml.reports')
        .controller('ReportsListDirectiveController', ReportsListController);
    /* jshint maxparams: 14*/
    /* jshint maxstatements: 50 */
    function ReportsListController(reportsService, logger, linksProcessor, kendoGridRendererService, $state, $q, $timeout, $filter, resources, amlLov, amlConstants, usersService, $scope, reportsListDataMessagingService) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        var firstDataLoad = true;
        vm.reportsCount = null;
        var defaultPageSize = Math.max(50, amlConstants.config.reportListPageSize);
        vm.selectedItemsCount = 0;
        var resetToFirstPage = (amlConstants.config && amlConstants.config.reportList && angular.isDefined(amlConstants.config.reportList.resetToFirstPage) ?
            amlConstants.config.reportList.resetToFirstPage : true);
        var dataSourceOptions = {
            transport: {
                read: getReports
            },
            schema: {
                model: {
                    fields: {
                        timeRemaining: { type: 'number' },
                        reportFormTypeKey: { type: 'number' },
                        reportKey: { type: 'number' },
                        reportParentObjectKey: { type: 'number' },
                        description: { type: 'string' },
                        statusCode: { type: 'string' },
                        createDate: { type: 'date' },
                        queueCode: { type: 'string' },
                        employeeIndicator: { type: 'string' },
                        ownerUserLongId: { type: 'string' }
                    },
                    startDate: function (dataItem) {
                        if (dataItem) {
                            // If the report is not closed or terminated then use the createDate
                            if (dataItem.statusCode !== amlLov.reportStatus.C &&
                                dataItem.statusCode !== amlLov.reportStatus.T) {
                                return dataItem.createDate;
                            }
                            else {
                                return dataItem.lastUpdateDate;
                            }
                        }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: defaultPageSize,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            {
                field: 'timeRemaining', title: resources.aml.regulatoryReports.timeRemaining,
                width: 150,
                template: kendoGridRendererService.countdownColumnRenderer('RPT'),
                filterable: false,
                sortable: false
            },
            {
                field: 'reportFormTypeKey', title: resources.aml.regulatoryReports.reportType,
                width: 125,
                template: function (dataItem) {
                    return $filter('reportType')(dataItem.reportFormTypeKey);
                },
                filterable: kendoGridRendererService.getCheckboxFilter('reportType')
            },
            {
                field: 'reportKey', title: resources.aml.regulatoryReports.id,
                width: 130
            },
            {
                field: 'reportParentObjectKey', title: resources.aml.regulatoryReports.parentObjectKey,
                width: 130
            },
            {
                field: 'description', title: resources.aml.regulatoryReports.description,
                width: 300
            },
            {
                field: 'employeeIndicator', title: resources.aml.reviews.employeeIndicatorHeaderTitle,
                width: '5%',
                template: kendoGridRendererService.enum('employeeIndicator', 'yesOrNo', true),
                filterable: kendoGridRendererService.getCheckboxFilter('yesOrNo')
            },
            {
                field: 'statusCode', title: resources.aml.regulatoryReports.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'reportStatus'),
                filterable: kendoGridRendererService.getCheckboxFilter('reportStatus'),
                width: 145
            },
            {
                field: 'createDate',
                width: 180,
                title: resources.aml.regulatoryReports.createDate,
                template: kendoGridRendererService.longDate('createDate')
            },
            {
                field: 'queueCode', title: resources.aml.entity.queue,
                width: '10%',
                filterable: kendoGridRendererService.getCheckboxFilter('queueName'),
                template: '{{dataItem.queueCode | queueName:true}}'
            },
            {
                field: 'ownerUserLongId',
                title: resources.aml.regulatoryReports.owner,
                template: '{{dataItem.ownerUserLongId | userName:true}}'
            },
            { field: 'startDate', hidden: true }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: Math.max(600, amlConstants.config.reportListTableHeight),
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            dataBound: function (val) {
                if (firstDataLoad) {
                    kendoGridRendererService.selectFirstRow(vm.grid);
                    firstDataLoad = false;
                }
            }
        });
        function updateSelectedCount(items) {
            vm.selectedItemsCount = 0;
            if (items) {
                vm.selectedItemsCount = items.length;
                return;
            }
            if (vm.grid) {
                var selectedItems = vm.grid.select();
                if (selectedItems) {
                    vm.selectedItemsCount = selectedItems.length;
                }
            }
        }
        function getFilterWithQueueDisplayType(filter) {
            var combinedFilter;
            var displayQueueType = getDisplayReportsType();
            if (displayQueueType === amlConstants.reportsListQueueDisplayType.MY) {
                var currentUserName = getMyReportsOnlyUser();
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'eq( ownerUserLongId, \'' + currentUserName + '\')');
            }
            else if (displayQueueType === amlConstants.reportsListQueueDisplayType.AVAILABLE) {
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'blank( ownerUserLongId )');
            }
            else {
                combinedFilter = filter;
            }
            return combinedFilter;
        }
        vm.handleRowSelect = function (reportsRows) {
            if (reportsRows && reportsRows.length > 0) {
                if (reportsRows.length === 1) {
                    selectReports(reportsRows[0]);
                }
                vm.selectedItemsCount = reportsRows.length;
            }
            else {
                clearReports();
                vm.selectedItemsCount = 0;
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'reportTriageList');
            // set function on the dataMessagingService to get selected reports based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            reportsListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedReportsFromSelectedRows, refreshGrid);
            $scope.$watch(function () {
                return reportsListDataMessagingService.getDisplayOwnersType();
            }, function (displayReportsWithOwnersType, oldValue) {
                if (displayReportsWithOwnersType === oldValue) {
                    return;
                }
                myReportsFilterChanged(displayReportsWithOwnersType);
            });
            $scope.$on('reportsOwnerChanged', function (event, changedData) {
                updateReportsOwner(changedData.reportNumbers, changedData.owner, changedData.queue);
            });
            $scope.$on('reportListRefresh', function (event) {
                kendoGridRendererService.refreshGrid(vm.grid);
            });
        }
        function refreshGrid() {
            kendoGridRendererService.refreshGrid(vm.grid, resetToFirstPage);
        }
        // on double-click, go to report detail page
        function handleDoubleClick(evt, data) {
            var selectedReport = vm.grid.dataItem(evt.currentTarget);
            if (selectedReport && selectedReport.reportKey) {
                //TODO: If we are OK with custom reports flashing, even directly from the report list, then we
                //TODO: could take out this function call and the if-then.  Just run reportDetails and let it decide.
                updateSelectedCount();
                var implementationTypeCode = reportsService.getImplementationTypeCode(selectedReport);
                if (implementationTypeCode === 'CUSTOM') {
                    $state.go('customReportDetails', {
                        reportkey: selectedReport.reportKey,
                        reporttype: $filter('reportType')(selectedReport.reportFormTypeKey)
                    });
                }
                else {
                    $state.go('reportDetails', {
                        reportkey: selectedReport.reportKey,
                        reporttype: $filter('reportType')(selectedReport.reportFormTypeKey)
                    });
                }
            }
        }
        function updateReportsOwner(reportNumbers, owner, queue) {
            /*
             If queue = '', that means remove any currently-assigned queue.
             If queue is undefined, that means don't change the queue.
            */
            kendoGridRendererService.updateDataItems(reportNumbers, 'reportKey', function (reportToBeUpdated) {
                reportToBeUpdated.ownerUserLongId = owner;
                if (typeof queue !== 'undefined') {
                    // queue is undefined if the user is clicking "Claim" or "Return to Queue".
                    reportToBeUpdated.queueCode = queue;
                }
            }, vm.grid);
        }
        /**
         * Get the selected reports based on the currently selected grid rows
         * @returns {Array}
         */
        function getSelectedReportsFromSelectedRows() {
            var reports = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aReport = vm.grid.dataItem(rowSelection);
                    if (aReport) {
                        reports.push(aReport);
                    }
                });
            }
            updateSelectedCount(reports);
            return reports;
        }
        function getReports(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            // add queue filtering (My Reports, etc) to the grid filter
            filterStr = getFilterWithQueueDisplayType(filterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.reportsCount;
            }
            reportsService.getReports(pageInfo.start, pageInfo.limit, sortCols, filterStr, null, previousCount).then(function (data) {
                vm.reportsCount = data.count;
                // if no reports returned, clear the report summary
                if (vm.reportsCount === 0) {
                    clearReports();
                }
                e.success(data);
                updateSelectedCount();
            }, function (data, status, headers, config) {
                clearReports();
                logger.error('Could not get reports');
                updateSelectedCount();
            });
        }
        function myReportsFilterChanged(displayReportsType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
        }
        function getDisplayReportsType() {
            return reportsListDataMessagingService.getDisplayOwnersType();
        }
        function getMyReportsOnlyUser() {
            return usersService.getCurrentUserId();
        }
        function selectReports(aReport) {
            vm.currentReport = aReport;
            // Reset selected alerts to none when loading report details page.
            //        dataMessagingService.setAlertIds('alertids', 'all');
            //        reportsListDataMessagingService.setTotalAmount(amount);
        }
        function clearReports() {
            vm.currentReport = null;
        }
    }
})();


/**
 * created by tommut
 */
(function () {
    'use strict';
    RiskClassifiersController.$inject = ["riskAssessmentService", "resources", "amlLov", "$scope", "kendoGridRendererService", "logger"];
    angular.module('aml.riskAssessments').controller('RiskClassifiersController', RiskClassifiersController);
    function RiskClassifiersController(riskAssessmentService, resources, amlLov, $scope, kendoGridRendererService, logger) {
        var vm = this;
        vm.resources = resources;
        vm.grid = {};
        vm.filterString = null;
        vm.riskClassifierCount = 0;
        var dataSourceOptions = {
            transport: { read: getRiskClassifiers },
            schema: {
                model: {
                    fields: {
                        key: { type: 'number' },
                        classifierName: { type: 'string' },
                        classifierShortDesc: { type: 'string' },
                        classifierDesc: { type: 'string' },
                        type: { type: 'string' },
                        active: { type: 'string' },
                        weight: { type: 'number' },
                        threshold: { type: 'number' },
                        createDate: { type: 'date' }
                    }
                }
            },
            pageSize: vm.pageSize || 10
        };
        vm.gridColumns = [
            { field: 'classifierName', title: resources.aml.riskClassifiers.riskClassifiersName, width: 5 },
            { field: 'createDate', title: resources.aml.riskClassifiers.riskClassifiersCreateDate, width: 5,
                template: kendoGridRendererService.longDate('create_date')
            },
            { field: 'classifierShortDesc', title: resources.aml.riskClassifiers.riskClassifiersDescription, width: 5 },
            { field: 'threshold', title: resources.aml.riskClassifiers.riskClassifiersThreshold, width: 3 }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions
        });
        vm.handleRowSelect = function (data) {
            var selectedRiskClassifierFilter = null;
            if (data && data.classifierName) {
                selectedRiskClassifierFilter = 'in(classifierName,' + data.classifierName + ')';
            }
        };
        activate();
        /////
        function getRiskClassifiers(gridCallback) {
            riskAssessmentService.getRiskAssessmentRiskClassifiers(vm.assessmentId).then(function (data) {
                if (data.riskClassifiers) {
                    vm.riskClassifierCount = data.riskClassifiers.length;
                    // refresh the grid
                    gridCallback.success(data.riskClassifiers);
                }
                else {
                    vm.riskClassifierCount = 0;
                    gridCallback.success([]);
                }
            }, function (data, status) {
                logger.error('Could not load risk classifiers');
                gridCallback.error([]);
            });
        }
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'riskClassifiersList');
        }
    }
})();


(function () {
    'use strict';
    RiskAssessmentsListController.$inject = ["riskAssessmentService", "logger", "linksProcessor", "kendoGridRendererService", "$state", "$q", "$timeout", "resources", "amlConstants", "amlLov", "usersService", "$scope", "amlCoreUtils", "riskAssessmentsListDataMessagingService"];
    angular
        .module('aml.riskAssessments')
        .controller('RiskAssessmentsListController', RiskAssessmentsListController);
    /* jshint maxparams: 15*/ /* jshint maxstatements: 50 */
    function RiskAssessmentsListController(riskAssessmentService, logger, linksProcessor, kendoGridRendererService, $state, $q, $timeout, resources, amlConstants, amlLov, usersService, $scope, amlCoreUtils, riskAssessmentsListDataMessagingService /*, $locale*/) {
        var vm = this;
        vm.grid = {};
        vm.resources = resources;
        var firstDataLoad = true;
        vm.showOverview = false;
        vm.riskAssessmentsCount = null;
        var dataSourceOptions = {
            transport: {
                read: getRiskAssessments
            },
            schema: {
                model: {
                    fields: {
                        assessmentId: { type: 'string' },
                        customerNumber: { type: 'string' },
                        partyName: { type: 'string' },
                        currentRiskClassification: { type: 'string' },
                        proposedRiskClassification: { type: 'string' },
                        owner: { type: 'string' },
                        assessmentDate: { type: 'date' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: 50,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            { field: 'assessmentId', title: resources.aml.riskAssessmentsList.assessmentId,
                width: 50
            },
            {
                field: 'customerNumber', title: resources.aml.riskAssessmentsList.entityNumber,
                width: 50
            },
            {
                field: 'partyName', title: resources.aml.riskAssessmentsList.entityName,
                filterable: true,
                template: kendoGridRendererService.titleCase('partyName'),
                width: 100
            },
            {
                field: 'currentRiskClassification', title: resources.aml.riskAssessmentsList.currentRiskClassification,
                filterable: kendoGridRendererService.getCheckboxFilter('riskClassification'),
                width: 100,
                template: kendoGridRendererService.enum('currentRiskClassification', 'riskClassification')
            },
            {
                field: 'proposedRiskClassification', title: resources.aml.riskAssessmentsList.proposedRiskClassification,
                filterable: kendoGridRendererService.getCheckboxFilter('riskClassification'),
                width: 100,
                template: kendoGridRendererService.enum('proposedRiskClassification', 'riskClassification')
            },
            { field: 'owner', title: resources.aml.riskAssessmentsList.owner,
                width: 50,
                template: '{{dataItem.owner | userName:true}}'
            },
            {
                field: 'assessmentDate',
                width: 180,
                title: resources.aml.riskAssessmentsList.assessmentDate,
                template: kendoGridRendererService.longDate('assessmentDate')
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: 400,
            pageable: false,
            selectable: 'multiple',
            scrollable: {
                virtual: true
            },
            dataBound: function (val) {
                if (firstDataLoad) {
                    kendoGridRendererService.selectFirstRow(vm.grid);
                    firstDataLoad = false;
                }
            }
        });
        function getFilterWithQueueDisplayType(filter) {
            var combinedFilter;
            var displayQueueType = getDisplayRiskAssessmentsType();
            if (displayQueueType === amlConstants.riskAssessmentsListQueueDisplayType.MY) {
                var currentUserName = getMyRiskAssessmentsOnlyUser();
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'eq( owner, \'' + currentUserName + '\')');
            }
            else if (displayQueueType === amlConstants.riskAssessmentsListQueueDisplayType.AVAILABLE) {
                combinedFilter = kendoGridRendererService.constructSingleFilter(filter, 'blank( owner )');
            }
            else {
                combinedFilter = filter;
            }
            return combinedFilter;
        }
        vm.handleRowSelect = function (riskAssessmentsRows) {
            if (riskAssessmentsRows && riskAssessmentsRows.length > 0) {
                // update riskAssessment overview when a riskAssessment is selected;
                // if multiple rows selected, don't updated the riskAssessment summary
                if (riskAssessmentsRows.length === 1) {
                    selectRiskAssessments(riskAssessmentsRows[0]);
                }
            }
            else {
                // if no riskAssessment selected, clear the overview
                clearRiskAssessments();
            }
        };
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'riskAssessmentsList');
            // set function on the dataMessagingService to get selected riskAssessments based on selected rows;
            // this allows the service to get the selected rows when needed, so the controller does not have
            // to constantly maintain the state of row selection
            riskAssessmentsListDataMessagingService.initializeDataRetrievalCallbacks(getSelectedRiskAssessmentsFromSelectedRows);
            $scope.$watch(function () {
                return riskAssessmentsListDataMessagingService.getDisplayOwnersType();
            }, function (displayRiskAssessmentsWithOwnersType, oldValue) {
                if (displayRiskAssessmentsWithOwnersType === oldValue) {
                    return;
                }
                myRiskAssessmentsFilterChanged(displayRiskAssessmentsWithOwnersType);
            });
            $scope.$on('riskAssessmentsOwnerChanged', function (event, changedData) {
                updateRiskAssessmentsOwner(changedData.riskAssessmentNumbers, changedData.owner);
            });
            $scope.$on('riskAssessmentsListRefresh', function (event) {
                kendoGridRendererService.refreshGrid(vm.grid);
            });
        }
        // on double-click, go to riskAssessment detail page
        function handleDoubleClick(evt, data) {
            var selectedRiskAssessment = vm.grid.dataItem(evt.currentTarget);
            if (selectedRiskAssessment && selectedRiskAssessment.assessmentId) {
                $state.go('riskAssessmentDetails', {
                    assessmentId: selectedRiskAssessment.assessmentId,
                    name: amlCoreUtils.titleCase(selectedRiskAssessment.partyName) });
            }
        }
        function updateRiskAssessmentsOwner(riskAssessmentNumbers, owner) {
            kendoGridRendererService.updateDataItems(riskAssessmentNumbers, 'assessmentId', function (riskAssessmentToBeUpdated) {
                riskAssessmentToBeUpdated.owner = owner;
            }, vm.grid);
        }
        function getSelectedRiskAssessmentsFromSelectedRows() {
            var riskAssessmentsNumbers = [];
            if (vm.grid) {
                // get all selected rows
                _.each(vm.grid.select(), function (rowSelection) {
                    var aRiskAssessment = vm.grid.dataItem(rowSelection);
                    if (aRiskAssessment) {
                        riskAssessmentsNumbers.push(aRiskAssessment);
                    }
                });
            }
            return riskAssessmentsNumbers;
        }
        /**
         * Get the selected riskAssessment names based on the currently selected grid rows
         * @returns {Array}
         */
        function getRiskAssessments(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            // get the grid filters
            var gridFilterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            // add queue filtering (My riskAssessments, etc) to the grid filter
            var userFilterStr = getFilterWithQueueDisplayType(gridFilterStr);
            // include only the Active Risk Assessments
            var actFilter = {
                logic: 'and',
                filters: [
                    {
                        field: 'STATUS',
                        operator: 'eq',
                        value: 'ACT'
                    }
                ]
            };
            var actFilterStr = kendoGridRendererService.getCustomFilterString(actFilter, vm.gridOptions);
            // combine all filters together
            var combinedFilterStr = kendoGridRendererService.constructSingleFilter(actFilterStr, userFilterStr);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.riskAssessmentsCount;
            }
            riskAssessmentService.getRiskAssessments(pageInfo.start, pageInfo.limit, sortCols, combinedFilterStr, null, previousCount).then(function (data) {
                vm.riskAssessmentsCount = data.count;
                // if no riskAssessments returned, clear the riskAssessment summary
                if (vm.riskAssessmentsCount === 0) {
                    clearRiskAssessments();
                }
                e.success(data);
            }, function (data, status, headers, config) {
                clearRiskAssessments();
                logger.error('Could not get riskAssessments');
            });
        }
        function myRiskAssessmentsFilterChanged(displayRiskAssessmentsType) {
            kendoGridRendererService.refreshGridSelectFirstRow(vm.grid);
        }
        function getDisplayRiskAssessmentsType() {
            return riskAssessmentsListDataMessagingService.getDisplayOwnersType();
        }
        function getMyRiskAssessmentsOnlyUser() {
            return usersService.getCurrentUserId();
        }
        function selectRiskAssessments(aRiskAssessment) {
            vm.currentRiskAssessment = aRiskAssessment;
            // Reset selected alerts to none when loading risk assessemtns details page.
            vm.showOverview = true;
        }
        function clearRiskAssessments() {
            vm.currentRiskAssessment = null;
            vm.showOverview = false;
        }
    }
})();


/**
 * created by omkulk
 */
(function () {
    'use strict';
    FundsTrackerTransactionListController.$inject = ["$scope", "kendoGridRendererService", "logger", "fundsTrackerService", "resources", "amlConstants"];
    angular.module('aml').controller('fundsTrackerTransactionListController', FundsTrackerTransactionListController);
    function FundsTrackerTransactionListController($scope, kendoGridRendererService, logger, fundsTrackerService, resources, amlConstants) {
        var vm = this;
        vm.grid = {};
        vm.amlGridActions = [];
        vm.params.reload = reloadGrid;
        vm.resources = resources;
        var dataSourceOptions = {
            transport: { read: getTransactionDetails },
            schema: {
                model: {
                    fields: {
                        date: { type: 'date' },
                        fromCustomer: { type: 'string' },
                        fromNode: { type: 'string' },
                        toCustomer: { type: 'string' },
                        toNode: { type: 'string' },
                        currencyAmount: { type: 'number' },
                        edgeTypeCode: { type: 'string' }
                    }
                }
            },
            pageSize: vm.pageSize || 10
        };
        var transactionDateTemplate = kendoGridRendererService.longDateMediumTime('date');
        if (amlConstants.config.useDateOnlyForTransactions) {
            transactionDateTemplate = kendoGridRendererService.longDate('date');
        }
        vm.gridColumns = [
            {
                field: 'date', title: resources.aml.fundsTrackerGrid.DateAndTime,
                width: '15%',
                template: transactionDateTemplate
            },
            {
                field: 'fromCustomer', title: resources.aml.fundsTrackerGrid.remitterName,
                width: '20%',
                template: kendoGridRendererService.titleCase('fromCustomer')
            },
            {
                field: 'fromNode', title: resources.aml.fundsTrackerGrid.remitterAccountNumber,
                width: '9%',
                template: kendoGridRendererService.titleCase('fromNode')
            },
            {
                field: 'toCustomer', title: resources.aml.fundsTrackerGrid.beneficiaryName,
                width: '20%',
                template: kendoGridRendererService.titleCase('toCustomer')
            },
            {
                field: 'toNode', title: resources.aml.fundsTrackerGrid.beneficiaryAccountNumber,
                width: '9%'
            },
            {
                field: 'currencyAmount', title: resources.aml.fundsTrackerGrid.currencyAmount,
                width: '17%',
                template: kendoGridRendererService.currency('currencyAmount')
            },
            {
                field: 'edgeTypeCode', title: resources.aml.fundsTrackerGrid.edgeTypeCode,
                width: '10%',
                template: function (dataItem) {
                    if (dataItem.edgeTypeCode === 'R') {
                        return resources.aml.fundsTrackerGrid.related;
                    }
                    else if (dataItem.edgeTypeCode === 'U') {
                        return resources.aml.fundsTrackerGrid.unrelated;
                    }
                    else if (dataItem.edgeTypeCode === 'I') {
                        return resources.aml.fundsTrackerGrid.inbound;
                    }
                    else {
                        return resources.aml.fundsTrackerGrid.outbound;
                    }
                },
                filterable: kendoGridRendererService.getCheckboxFilterForValues([
                    { name: resources.aml.fundsTrackerGrid.related, value: 'R' },
                    { name: resources.aml.fundsTrackerGrid.unrelated, value: 'U' },
                    { name: resources.aml.fundsTrackerGrid.inbound, value: 'I' },
                    { name: resources.aml.fundsTrackerGrid.outbound, value: 'O' }
                ])
            }
        ];
        function reloadGrid() {
            vm.grid.dataSource.read();
            vm.grid.refresh();
        }
        function getTransactionDetails(gridCallback) {
            if (!vm.params.entityNumber) {
                return [];
            }
            fundsTrackerService.getTransactionsDetails(vm.params.entityNumber, vm.params.fromNode, vm.params.toNode).then(function (data) {
                var transactions = data.items;
                gridCallback.success(transactions);
            }, function (data, status) {
                logger.error('Could not load transactions');
            });
        }
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions
        });
        activate();
        function activate() {
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'amlFundsTrackerTransactionDetails');
        }
    }
})();


/**
 * handle the alert triaging actions
 */
(function () {
    'use strict';
    CreateManualAlertModalController.$inject = ["$uibModalInstance", "resources", "amlLov", "dataMessagingServiceFactory", "queueListService", "segmentListService", "$filter"];
    angular.module('aml.customer.details').controller('CreateManualAlertModalController', CreateManualAlertModalController);
    function CreateManualAlertModalController($uibModalInstance, resources, amlLov, dataMessagingServiceFactory, queueListService, segmentListService, $filter) {
        var vm = this;
        vm.manualAlertReasonList = amlLov.getAsArray(amlLov.manualAlertReason);
        var dataMessagingService = dataMessagingServiceFactory.getCurrentInstance();
        vm.runDate = new Date();
        vm.description = null;
        vm.resources = resources;
        vm.ok = ok;
        vm.cancel = cancel;
        var empInd = dataMessagingService.getEmployeeIndicator();
        vm.employeeInd = !(empInd === null || empInd === undefined || empInd === 'N');
        vm.routeToQueue = '';
        vm.segmentId = '';
        vm.queues = [{ queueCode: '', queueName: resources.aml.scenarioAdmin.noneSelectedOptionTxt }];
        vm.segments = [{ entitySegmentId: '', segmentDisplayName: resources.aml.scenarioAdmin.noneSelectedOptionTxt }];
        //we use the javascript service class to call for queues
        queueListService.getQueues().then(//use the queueService to gather list of queues and update vm.queues
        //function passes data, which is returned by promise, we concatenate the values to vm.queues
        function (data) {
            data.items.forEach(function (item) {
                item.queueName = $filter('queueName')(item.queueCode, true);
            });
            vm.queues = vm.queues.concat(data.items);
        });
        segmentListService.getSegments('NONDELETED').then(//parameter is not handled
        function (data) {
            data.items.forEach(function (item) {
                item.segmentDisplayName = $filter('localizedSegmentName')(item.segmentName);
            });
            vm.segments = vm.segments.concat(data.items);
        });
        /////////
        function ok() {
//console.log("8888888");
            var entityId = dataMessagingService.getEntityId();
            var employeeIndYesorNo = (vm.employeeInd === true) ? 'Y' : 'N';
            var alert = {
                alertThreshold: vm.reason,
                moneyLaunderingRisk: 0,
                runDate: vm.runDate,
                description: vm.description,
                primaryEntityKey: entityId.entityKey,
                primaryEntityNumber: entityId.entityNumber,
                alertLevel: entityId.entityLevelCode,
                // service will populate these
                alertedEntityLevelCode: null,
                alertedEntityNumber: null,
                alertedEntityKey: null,
                employeeIndicator: employeeIndYesorNo,
                queueCode: vm.routeToQueue,
                entitySegmentId: vm.segmentId
            };
            $uibModalInstance.close(alert);
        }
        function cancel() {
            $uibModalInstance.dismiss('cancel');
        }
        vm.switchEmployeeInd = function switchEmployeeInd() {
            vm.employeeInd = !vm.employeeInd;
        };
    }
})();


(function () {
    'use strict';
    CaseReportListController.$inject = ["resources", "reportsService", "kendoGridRendererService", "logger", "$scope", "$state", "$filter"];
    angular.module('aml.cases.details').controller('CaseReportListController', CaseReportListController);
    /* jshint maxparams: 14*/
    function CaseReportListController(resources, reportsService, kendoGridRendererService, logger, $scope, $state, $filter) {
        var vm = this;
        vm.resources = resources;
        vm.reportsCount = 0;
        vm.grid = {};
        var dataSourceOptions = {
            transport: {
                read: getReports
            },
            schema: {
                model: {
                    fields: {
                        reportType: { type: 'string' },
                        reportKey: { type: 'number' },
                        description: { type: 'string' },
                        statusCode: { type: 'string' },
                        createDate: { type: 'date' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: vm.pageSize || 10,
            serverPaging: true,
            serverSorting: true,
            serverFiltering: true
        };
        vm.gridColumns = [
            {
                field: 'reportFormTypeKey', title: resources.aml.regulatoryReports.reportType,
                width: 125,
                template: function (dataItem) {
                    return $filter('reportType')(dataItem.reportFormTypeKey);
                }
            },
            { field: 'reportKey', title: resources.aml.regulatoryReports.id,
                width: 130,
                template: kendoGridRendererService.titleCase('reportKey')
            },
            {
                field: 'description', title: resources.aml.regulatoryReports.description,
                width: 300
            },
            { field: 'statusCode', title: resources.aml.regulatoryReports.statusCode,
                template: kendoGridRendererService.enum('statusCode', 'reportStatus'),
                filterable: kendoGridRendererService.getCheckboxFilter('reportStatus'),
                width: 145
            },
            {
                field: 'createDate',
                width: 180,
                title: resources.aml.regulatoryReports.createDate,
                template: kendoGridRendererService.longDate('createDate')
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions
        });
        activate();
        ////////////////
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, 'caseReportsList');
        }
        // on double-click, go to report detail page
        function handleDoubleClick(evt) {
            var selectedReport = vm.grid.dataItem(evt.currentTarget);
            if (selectedReport && selectedReport.reportKey) {
                //TODO: If we are OK with custom reports flashing, even directly from the report list, then we
                //TODO: could take out this function call and the if-then.  Just run reportDetails and let it decide.
                var implementationTypeCode = reportsService.getImplementationTypeCode(selectedReport);
                if (implementationTypeCode === 'CUSTOM') {
                    $state.go('customReportDetails', {
                        reportkey: selectedReport.reportKey,
                        reporttype: $filter('reportType')(selectedReport.reportFormTypeKey)
                    });
                }
                else {
                    $state.go('reportDetails', {
                        reportkey: selectedReport.reportKey,
                        reporttype: $filter('reportType')(selectedReport.reportFormTypeKey)
                    });
                }
            }
        }
        function getReports(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.reportsCount;
            }
            reportsService.getReportsForCase(pageInfo.start, pageInfo.limit, sortCols, vm.caseid, previousCount).then(function (data) {
                vm.reportsCount = data.count;
                e.success(data);
            }, function (data, status, headers, config) {
                logger.error(resources.aml.cases.couldNotLoadReportsErrorText);
            });
        }
    }
})();


(function () {
    'use strict';
    EditCommentDirectiveController.$inject = ["resources", "_", "kendoGridRendererService", "commentService", "amlLov", "attachmentService", "dialogService", "usersService", "amlConstants", "messageService", "exceptionResourceHandler", "cddReviewDetailsService"];
    angular.module('aml.core').controller('EditCommentDirectiveController', EditCommentDirectiveController);
    /* jshint maxparams: 12*/
    function EditCommentDirectiveController(resources, _, kendoGridRendererService, commentService, amlLov, attachmentService, dialogService, usersService, amlConstants, messageService, exceptionResourceHandler, cddReviewDetailsService) {
        var vm = this;

//console.log("EditCommentDirectiveController $(location).attr('href') : " + $(location).attr('href'));

        var tmp_commentCategory = amlLov.commentCategory;
        var hrefStr = $(location).attr('href').toUpperCase();
        if(hrefStr.indexOf('CUSTOMERS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('EXTERNALPARTIES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('CASES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCases;
        }else if(hrefStr.indexOf('ENTITIES') != -1){
        	tmp_commentCategory = amlLov.commentCategoryTriage;
        }else if(hrefStr.indexOf('REGULATORYREPORTS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryReport;
        }else if(hrefStr.indexOf('CDDREVIEWS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCddreviews;
        }else if(hrefStr.indexOf('ALERTS') != -1){
        	tmp_commentCategory = amlLov.commentCategoryCasesDel;
        }

//console.log(tmp_commentCategory);
        
        vm.resources = resources;
        vm.commentCategories = amlLov.getAsArray(tmp_commentCategory);
        vm.commentCategoriesForFilter = amlLov.getAsArray(tmp_commentCategory);
        // add default All Categories as the first filter
        vm.commentCategoriesForFilter.unshift({ key: null, value: resources.aml.comments.categoriesFilterAllLabel });
        vm.completeNewComment = completeNewComment;
        vm.completeEditComment = completeEditComment;
        vm.cancelEditComment = cancelEditComment;
        vm.cancelAddComment = cancelAddComment;
        var editingComment = {};
        vm.editorTools = kendoGridRendererService.getDefaultEditorTools();
        vm.editorOptions = {
            paste: handleEditorPaste
        };
        // attachments
        vm.deleteAttachment = deleteAttachment;
        vm.userCanAddAttachments = usersService.currentUserHasCapability(amlConstants.capabilities.createAttachment);
        vm.userCanDeleteAttachments = usersService.currentUserHasCapability(amlConstants.capabilities.deleteAttachment);
        var selectedFiles = [];
        vm.uploadOptions = {
            multiple: true,
            select: attachmentService.handleOnFileSelect(selectedFiles),
            remove: attachmentService.handleOnFileSelectRemove(selectedFiles),
            // to allow drag-and-drop support, must set 'async' mode
            async: attachmentService.kendoUploadAsyncForDnD
        };
        activate();
        ///////////
        function activate() {
            if (vm.addMode) {
                startAddNewComment();
            }
            else {
                startEditComment();
            }
        }
        function uploadAttachments(comment) {
            if (selectedFiles && selectedFiles.length > 0) {
                if (!comment.attachments) {
                    comment.attachments = [];
                }
                _.each(selectedFiles, function (file) {
                    var fileName;
                    // the rawfile contains the actual filename; use it if available
                    if (file.rawFile) {
                        fileName = file.rawFile.name;
                    }
                    if (!fileName) {
                        // the file.name escapes certain characters like ' ==> &39;
                        file = file.name;
                    }
                    var attachment = { name: fileName, id: null };
                    attachmentService.createAttachment(file.rawFile, comment.id, vm.objectId, vm.objectTypeCode).then(function (data) {
                        // set id from the assigned id generated by the server
                        attachment.id = data.id;
                        // disable attachment loading flag so it shows as completed
                        attachment.loading = false;
                    }, function errorFn(error) {
                        var errorMsg = resources.aml.attachments.failedToUploadErrorTxt;
                        messageService.danger(errorMsg, null, -1, error);
                        // remove attachment from the list (since we failed to add it)
                        var index = _.indexOf(comment.attachments, attachment);
                        comment.attachments.splice(index, 1);
                    });
                    // immediately add attachment with status = loading so it shows greyed out
                    comment.attachments.push(attachment);
                    attachment.loading = true;
                });
                // clear existing selected files
                attachmentService.clearSelectedFiles(selectedFiles);
            }
        }
        function handleEditorPaste(ev) {
            // if we want to disable pasting of external HTML; may be too restrictive as you can't copy your own
            // comment text; better to just disable it server side.
            //ev.html = $(ev.html).text();
        }
        function startAddNewComment() {
            vm.comment = {};
            vm.comment.objectId = vm.objectId;
            vm.comment.objectTypeCode = vm.objectTypeCode;
            vm.comment.commentText = '<ol><li><b>Overview</b></li><p></p><li><b>Research & Inverstigation</b></li><p></p><li><b>Transaction Summary</b></li><p></p><li><b>Negative news & Watchlist Check</b></li><p></p><li><b>Conclusion</b></li><p></p>';
            // set an initial category to the first ordered item in the list
            var category = _.first(vm.commentCategories);
            if (category) {
                vm.comment.categoryCode = category.key;
            }
            vm.commentsOptions.addingNewComment = true;
        }
        function completeNewComment() {
            vm.commentsOptions.addingNewComment = false;
            var commentToBeAdded = vm.comment;
            // set userId on the new comment so we don't have to wait until comment request completes
            // before it's shown
            commentToBeAdded.lastUpdatedUserId = usersService.getCurrentUserId();
            commentToBeAdded.createdUserId = usersService.getCurrentUserId();
            var createCommentRequest = commentService.createComment(commentToBeAdded).
                then(function (addedComment) {
                // update user, date, and id from added comment
                commentToBeAdded.lastUpdatedDate = addedComment.lastUpdatedDate;
                commentToBeAdded.lastUpdatedUserId = addedComment.lastUpdatedUserId;
                commentToBeAdded.id = addedComment.id;
                uploadAttachments(commentToBeAdded);
                return commentToBeAdded;
            });
            // callback to the parent directive to add new comment to list and
            // update comment count when the request returns.
            // Weird syntax: we're calling the function reference to get the function
            // and then executing it with parameters
            vm.onCommentAdd()(commentToBeAdded, createCommentRequest);
            // cleanup
            vm.comment = {};
        }
        function cancelAddComment() {
            vm.comment = {};
            vm.commentsOptions.addingNewComment = false;
        }
        function startEditComment() {
            vm.comment.isEditing = true;
            // keep backup of editable content in event user cancels
            editingComment.commentText = vm.comment.commentText;
            editingComment.categoryCode = vm.comment.categoryCode;
        }
        function completeEditComment() {
            // remove the isEditing field as that's not an expected part of the API
            delete vm.comment.isEditing;
            commentService.editComment(vm.comment).then(function (data) {
                // update user and date from added comment
                vm.comment.lastUpdatedDate = data.lastUpdatedDate;
                vm.comment.lastUpdatedUserId = data.lastUpdatedUserId;
            });
            uploadAttachments(vm.comment);
            // clean up saved values
            editingComment.commentText = null;
            editingComment.categoryCode = null;
        }
        function cancelEditComment() {
            vm.comment.isEditing = false;
            // reset values to original
            vm.comment.commentText = editingComment.commentText;
            vm.comment.categoryCode = editingComment.categoryCode;
            // clean up saved values
            editingComment.commentText = null;
            editingComment.categoryCode = null;
            attachmentService.clearSelectedFiles(selectedFiles);
        }
        function deleteAttachment(attachment) {
            dialogService.openConfirmDialog(resources.aml.attachments.deleteConfirmationWindowTitle, resources.aml.getResource('attachments.deleteConfirmationText', { attachmentName: attachment.name }))
                .then(function okayPressed() {
                attachmentService.deleteAttachment(attachment);
                var index = _.indexOf(vm.comment.attachments, attachment);
                vm.comment.attachments.splice(index, 1);
            });
        }
    }
})();


(function () {
    'use strict';
    CommentsToggleButtonDirectiveController.$inject = ["resources", "_", "commentService", "usersService"];
    angular.module('aml.core').controller('CommentsToggleButtonDirectiveController', CommentsToggleButtonDirectiveController);
    function CommentsToggleButtonDirectiveController(resources, _, commentService, usersService) {
        var vm = this;
        usersService.setCommentsVm(vm);
        vm.resources = resources;
        activate();
        ///////////
        function activate() {
            if (vm.commentsOptions && _.isUndefined(vm.commentsOptions.displayComments)) {
                // if not already set by the property passed into the directive, get the default
                // comment sidebar state (from the local storage, via commentService)
                vm.commentsOptions.defaultOpen = commentService.getDefaultCommentsSidebarOpen();
                if (angular.isDefined(vm.commentsOptions.defaultOpen)) {
                    vm.commentsOptions.displayComments = vm.commentsOptions.defaultOpen;
                }
                else {
                    vm.commentsOptions.displayComments = false;
                }
            }
            // if the sidebar defaults to open, then we do not need to do the comments count here
            // in the toggle control. The count will be populated when the comments are retrieved
            // in the sidebar. (This is just a performance optimization to not do an unneccessary
            // query).
            if (vm.showCount !== 'false' && !vm.commentsOptions.displayComments) {
//console.log("CommentsToggleButtonDirectiveController !!!!");
                commentService.getCommentsCount(vm.objectTypeCode, vm.objectId).then(function (data) {
                    vm.commentsOptions.commentsCount = data.count;
                    
										var hrefStr = $(location).attr('href').toUpperCase();
        						if(hrefStr.indexOf('CDDREVIEWS') != -1){
	                    if(data.count > 0){
	                    	$("#tranStatusShow").show();
	                    }else{
	                    	$("#tranStatusShow").hide();
	                    }
	                  }
                });
                
            }
        }
    }
})();


/**
 * @ngdoc directive
 * @name    aml.core:commentsToggleButton
 * @param {integer} pageSize specify the page size of the list
 * @param {string} defaultSortColumn the column to sort by default
 * @param {string} defaultSortDirection either 'ascending' or 'descending'
 *
 * @restrict E
 *
 * @description
 * The 'customerList' directive is used to generate a list of customers
 *
 * @element ANY
 * @required on-click
 *
 */
(function () {
    'use strict';
    angular
        .module('aml.core')
        .directive('amlCommentsToggleButton', amlCommentsToggleButton);
    /* @ngInject */
    function amlCommentsToggleButton() {
        var directive = {
            restrict: 'E',
            templateUrl: 'core/comments/toggleControl/amlCommentsToggleButtonDirective.html',
            controller: 'CommentsToggleButtonDirectiveController',
            controllerAs: 'vm',
            scope: {
                //  the scope is isolated
                showCount: '@',
                commentsOptions: '=',
                objectId: '=',
                objectTypeCode: '='
            },
            bindToController: true
        };
        return directive;
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:dialogService
 *
 * @restrict E
 *
 * @description
 * The dialogService service is used to handle opening simple, common modal dialogs.
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    dialogService.$inject = ["$uibModal"];
    angular
        .module('aml.core')
        .factory('dialogService', dialogService);
    /* @ngInject */
    function dialogService($uibModal) {
        var service = {
            openConfirmDialog: openConfirmDialog,
            openInformationDialog: openInformationDialog,
            openDirtyFormDialog: openDirtyFormDialog,
            openErrorFormDialog: openErrorFormDialog
        };
        return service;
        /**
         * Open a simple confirmation dialog with a given title and text, and OK and Cancel buttons.
         * Returns a promise whose success function is called on Okay press, and failure called if Cancel is pressed.
         * @param title
         * @param text
         * @returns {*|SVGAnimatedString|(function(*, string): *)|(function(string): *)|(function(string): _Chain<T>)}
         */
        function openConfirmDialog(title, text) {
            var modalInstance = $uibModal.open({
                templateUrl: 'core/layout/dialog/confirmation/confirmationDialog.html',
                controller: 'ConfirmationDialogController as vm',
                backdrop: 'static',
                resolve: {
                    title: function () {
                        return title;
                    },
                    text: function () {
                        return text;
                    }
                }
            });
            return modalInstance.result;
        }
        /**
         * Open a simple informational dialog with a given title and text, and an OK button.
         * Returns a promise whose success function is called on Ok press.
         * @param title
         * @param text
         * @returns {*|SVGAnimatedString|(function(*, string): *)|(function(string): *)|(function(string): _Chain<T>)}
         */
        function openInformationDialog(title, text) {
            var modalInstance = $uibModal.open({
                templateUrl: 'core/layout/dialog/information/information.html',
                controller: 'InformationModalController as vm',
                backdrop: 'static',
                size: 'xlg',
                resolve: {
                    title: function () {
                        return title;
                    },
                    text: function () {
                        return text;
                    }
                }
            });
            
//console.log("CCCCCC : " + $("#btnEfile").length);
            return modalInstance.result;
        }
        
        /**
         * Open a simple dialog stating the form being exited is dirty and give Discard, Save, Cancel options.
         * Returns a promise whose success/error functions are handled by the caller
         * @returns {SVGAnimatedString|*|function(any, string): any|function(string): any|function(string): _Chain<T>}
         */
        function openDirtyFormDialog() {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'core/layout/dialog/dirtyForm/formIsDirty.html',
                controller: 'DirtyModalController as viewVm',
                size: 'm',
                backdrop: 'static'
            });
            return modalInstance.result;
        }
        /**
         * Opens a dimple dialog stating the form has errors (i.e. is invalid).  There is no real result to return.
         * @returns {SVGAnimatedString|*|function(any, string): any|function(string): any|function(string): _Chain<T>}
         */
        function openErrorFormDialog() {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'core/layout/dialog/errorForm/formHasErrors.html',
                controller: 'ErrorModalController as viewVm',
                size: 'm',
                backdrop: 'static'
            });
            return modalInstance.result;
        }
    }
})();


(function () {
    'use strict';
    angular
        .module('aml.core')
        .directive('amlCustomFormValidation', amlCustomFormValidation);
    /* @ngInject */
    function amlCustomFormValidation() {
        return {
            require: ['ngModel'],
            restrict: 'A',
            link: function (scope, element, attr, ngModel) {
                var validations = attr.amlCustomFormValidation.split(',');
                // Multiple validations could potentially be comma-separated and then
                // more of these if blocks could be added to handle more validations.
                if (validations.indexOf('birthdate') !== -1) {
                    ngModel[0].$parsers.unshift(function (value) { return isValidDateWithUnknowns(value) ? value : undefined; });
                }
            }
        };
    }
    function isValidDateWithUnknowns(input) {
        if (!/^\d{4}\-(0[0-9]|1[012])\-(0[0-9]|[12][0-9]|3[01])$/.test(input)) {
            // It's not YYYY-MM-DD
            return false;
        }
        else {
            var year = Number(input.substr(0, 4));
            var month = Number(input.substr(5, 2));
            var day = Number(input.substr(8, 2));
            if ([0, 1, 3, 5, 7, 8, 10, 12].indexOf(month) > -1 && day >= 0 && day <= 31) {
                return true;
            }
            else if ([4, 6, 9, 11].indexOf(month) > -1 && day >= 0 && day <= 30) {
                return true;
            }
            else if (month === 2) {
                if (year % 4 === 0) {
                    if (day >= 0 && day <= 29) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    if (day >= 0 && day <= 28) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            else {
                return false;
            }
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:tabsListService
 *
 * @restrict E
 *
 * @description
 * The tabsListService service is used to manage creating and selecting tabs
 *
 * @element ANY
 * @required on-click
 */
(function () {
    'use strict';
    tabsListService.$inject = ["$state", "areaNavigationService", "amlUIViewService", "resources", "$q", "amlCoreUtils", "$timeout"];
    angular
        .module('aml.core')
        .factory('tabsListService', tabsListService);
    /* @ngInject */
    function tabsListService($state, areaNavigationService, amlUIViewService, resources, $q, amlCoreUtils, $timeout) {
        var tabs = [];
        var closeCallbacks = {};
        var service = {
            navigate: navigate,
            closeTab: closeTab,
            closeAllTabs: closeAllTabs,
            closeAllOtherTabs: closeAllOtherTabs,
            addTab: addTab,
            getTabs: getTabs,
            getTabInfo: getTabInfo,
            registerCloseCallback: registerCloseCallback,
            updateTabInfo: updateTabInfo,
            updateTabInfoForState: updateTabInfoForState,
            getTabForCurrentState: getTabForCurrentState,
            isAnyTabDirty: isAnyTabDirty,
            tabs: tabs
        };
        var tabId = 0; // used as unique id for ng-repeat
        return service;
        /////////////////////
        /**
         * Check if any open tab is currently marked dirty (based on tabs' data.dirty flag)
         *
         * @returns {boolean} true, if any tab is dirty; false otherwise
         */
        function isAnyTabDirty() {
            var isTabDirty = false;
            _.each(tabs, function (tab) {
                if (tab.data && tab.data.dirty) {
                    isTabDirty = true;
                }
            });
            return isTabDirty;
        }
        function getTabs() {
            return tabs;
        }
        function isTabEquals(tab, name, params) {
            if (name === tab.name) {
                // if the tab name has a _ in it it means it's an object tab
                // like "customerDetails_1234" in which case we just check the name;
                // otherwise in some cases the params may differ (like if the customer list
                // passes along the 'name' state param, but a tab opened via direct URL may not include
                // that param)
                if (name.indexOf('_') === -1) {
                    return _.isEqual(tab.params, params);
                }
                else {
                    return true;
                }
            }
            return false;
        }
        /*        function isExistingTab(name, params) {
                    let tabExists = _.some(tabs, function (tab:AMLTab) {
                        return isTabEquals( tab,  name, params );
                    });
                    return tabExists;
                }*/
        function getTab(stateName, stateParams) {
            var foundTab = _.find(tabs, function (tab) {
                if (stateParams) {
                    return isTabEquals(tab, stateName, stateParams);
                }
                else {
                    return stateName === tab.name;
                }
            });
            return foundTab;
        }
        function getTabForCurrentState() {
            var state = $state.current;
            return getTab(state.name);
        }
        /**
         * Retrieve the tabinfo for a given state.  The tabinfo is just a copy of the tab object with a known
         * set of updateable properties.
         * @param stateName
         * @param stateParams
         * @returns {null}
         */
        function getTabInfo(stateName, stateParams) {
            var tabInfo = null;
            var foundTab = getTab(stateName, stateParams);
            if (foundTab) {
                // get a *copy* of the object with just a set of properties we want to expose
                tabInfo = _.pick(foundTab, 'name', 'params', 'title', 'tooltip');
            }
            return tabInfo;
        }
        function createTab(name, stateParams, state) {
            var title;
            // if tab title is an angular expression "{{...}}" then just interpolate it and use
            // that as the title
            if (state.data.tabInfo.label && state.data.tabInfo.label.indexOf('{{') === 0) {
                title = amlCoreUtils.interpolateValue(state.data.tabInfo.label, stateParams);
            }
            else {
                // otherwise get the resource string
                title = resources.aml.getResource(state.data.tabInfo.label, stateParams);
            }
            var tooltip = resources.aml.getResource(state.data.tabInfo.tooltip, stateParams);
            var tab = {
                name: name,
                title: title,
                tooltip: tooltip,
                params: stateParams,
                id: tabId,
                data: state.data,
                iconClass: state.data.tabInfo.iconClass
            };
            tabs.push(tab);
            tabId++;
            return tab;
        }
        /**
         * update an existing tab
         * @param tab
         * @param stateParams
         * @param state
         */
        function updateTab(tab, stateParams, state) {
            var title;
            // if tab title is an angular expression "{{...}}" then just interpolate it and use
            // that as the title
            if (state.data.tabInfo.label && state.data.tabInfo.label.indexOf('{{') === 0) {
                title = amlCoreUtils.interpolateValue(state.data.tabInfo.label, stateParams);
            }
            else {
                // otherwise get the resource string
                title = resources.aml.getResource(state.data.tabInfo.label, stateParams);
            }
            var tooltip = resources.aml.getResource(state.data.tabInfo.tooltip, stateParams);
            tab.title = title;
            tab.tooltip = tooltip;
            tab.params = stateParams;
            tab.data = state.data;
            tab.iconClass = state.data.tabInfo.iconClass;
        }
        function addTab(name, params, state) {
            // add tab if it isn't already opened
            var createdTab;
            var existingTab = getTab(name, params);
            if (!existingTab) {
                createdTab = createTab(name, params, state);
            }
            else {
                // update existing tab in case the params, or title have changed
                updateTab(existingTab, params, state);
            }
            // for focus (keyboard accessibility) support, when a new tab is opened we want to give it focus
            // on the screen.
            $timeout(function () {
                var objectTabElements = $('.aml-object-tab.active .aml-tab');
                if (objectTabElements.length > 0) {
                    objectTabElements[0].focus();
                }
            }, 1);
            return createdTab;
        }
        /**
         * Add a callback function that will be called whenever the associated tab is going to be closed;
         * the function must return a promise that returns a boolean when resolved; a value of e of false from the
         * close callback promise will stop the tab from closing.
         * Do not use anonymous functions as callbacks if you registering more than one callback for
         * the same state.
         *
         * To register:  tabsListService.registerCloseCallback( $state.$current, closeCallback );
         * Detailed example:
         *     var closeCallback  = function() {
         *        // a function that returns a promise; it might call a modal dialog & return its promise, for instance
         *        var defer = $q.defer();
         *        $timeout( function() {
         *           defer.resolve(true);
         *        }, 5000);
         *        return defer.promise;
         *   };
         *
         *    tabsListService.registerCloseCallback($state.$current, closeCallback );
         *
         * @param state
         * @param closeCallback
         */
        function registerCloseCallback(state, closeCallback) {
            var stateCloseCallbacks = closeCallbacks[state.name];
            if (!stateCloseCallbacks) {
                stateCloseCallbacks = [];
                closeCallbacks[state.name] = stateCloseCallbacks;
            }
            for (var i = 0; i < stateCloseCallbacks.length; i++) {
                if (stateCloseCallbacks[i].name === closeCallback.name) {
                    //only one callback with the same name is allowed,
                    //this prevents registering multiple callbacks for the same entity
                    //when browser refresh button is used.
                    return;
                }
            }
            stateCloseCallbacks.push(closeCallback);
        }
        function performClose(tab, redirectAfterClose) {
            if (redirectAfterClose === void 0) { redirectAfterClose = true; }
            var foundIndex = _.indexOf(tabs, tab);
            if (foundIndex > -1) {
                tabs.splice(foundIndex, 1);
            }
            // clear tab state
            if (tab.data.messaging) {
                delete tab.data.messaging;
            }
            // clear callbacks , expecting that tab name is always the same as state name
            var stateCloseCallbacks = closeCallbacks[tab.name];
            if (stateCloseCallbacks) {
                stateCloseCallbacks = [];
                closeCallbacks[tab.name] = stateCloseCallbacks;
            }
            // send notification that a tab state should be removed
            var removedStateName = tab.name;
            amlUIViewService.removeState(removedStateName);
            // when closing an object tab, redirect back to last selected area
            if (redirectAfterClose) {
                areaNavigationService.navigateToLastSelectedArea();
            }
        }
        function getCloseCallbacksResultsForTab(tab) {
            var closePromises = [];
            var stateCloseCallbacks = closeCallbacks[tab.name];
            if (stateCloseCallbacks) {
                stateCloseCallbacks.forEach(function (closeCallback) {
                    var closeResultPromise = closeCallback();
                    if (closeResultPromise) {
                        closePromises.push(closeResultPromise);
                    }
                });
            }
            return closePromises;
        }
        function closeAllTabs() {
            if (tabs && tabs.length > 0) {
                var len = tabs.length;
                // go through each tab (from the end of the list) and close it
                for (var i = len - 1; i >= 0; i--) {
                    closeTab(tabs[i], false);
                }
                // when closing an object tab, redirect back to last selected area
                areaNavigationService.navigateToLastSelectedArea();
            }
        }
        function closeAllOtherTabs() {
            if (tabs && tabs.length > 0) {
                var selectedTab = _.find(tabs, function (tab) {
                    return $state.is(tab.name, tab.params);
                });
                var len = tabs.length;
                // go through each tab (from the end of the list) and close it
                for (var i = len - 1; i >= 0; i--) {
                    var tab = tabs[i];
                    if (tab !== selectedTab) {
                        closeTab(tab, false);
                    }
                }
            }
        }
        /**
         * Update the tab info for a given state, by applying any properties specified over top of
         * any existing properties. Any properties not specified will not be modified in the existing tab.
         * Example usage:
         *   var tabInfo = { title: 'my new title', tooltip: 'blah blah blah'};
         *   tabsListService.updateTabInfo( tabInfo, $state.$current.name );
         * @param tabInfoToUpdate
         * @param stateName
         * @param stateParams
         * @returns {boolean}
         */
        function updateTabInfoForState(tabInfoToUpdate, stateName, stateParams) {
            var foundTab = getTab(stateName, stateParams);
            var updated = false;
            if (foundTab) {
                _.extend(foundTab, tabInfoToUpdate);
                updated = true;
            }
            return updated;
        }
        /**
         * Update a given tab info that was previously retrieved
         * Example usage:
         *     var tabInfo = tabsListService.getTabInfo(  $state.$current.name  );
         *     tabInfo.title = 'my new title';
         *     tabsListService.updateTabInfo( tabInfo );
         * @param tabInfoToUpdate
         * @param generateTooltip - if true then new tooltip will be generated using tooltip
         *        message template from tabArea and tooltip value from tabInfo will not be used
         * @returns {boolean}
         */
        function updateTabInfo(tabInfoToUpdate, generateTooltip) {
            var foundTab = getTab(tabInfoToUpdate.name, tabInfoToUpdate.params);
            var updated = false;
            if (foundTab) {
                angular.merge(foundTab, tabInfoToUpdate);
                if (generateTooltip) {
                    var tooltip = resources.aml.getResource(foundTab.data.tabInfo.tooltip, foundTab.params);
                    foundTab.tooltip = tooltip;
                }
                updated = true;
            }
            return updated;
        }
        function closeTab(tab, redirectAfterClose) {
            var deferred = $q.defer();
            if (tab) {
                // run any registered close callbacks for this tab; if callback returns false, it means the close
                // action should not proceed
                var closePromises = getCloseCallbacksResultsForTab(tab);
                if (closePromises.length > 0) {
                    // check all promises at once
                    $q.all(closePromises).then(function (results) {
                        var cancelCloseAction = false;
                        results.forEach(function (result) {
                            if (!result) {
                                cancelCloseAction = true;
                            }
                        });
                        if (!cancelCloseAction) {
                            performClose(tab, redirectAfterClose);
                            deferred.resolve('closed');
                        }
                        else {
                            deferred.reject('cancel');
                        }
                    });
                }
                else {
                    performClose(tab, redirectAfterClose);
                    deferred.resolve();
                }
            }
            else {
                deferred.resolve();
            }
            return deferred.promise;
        }
        function navigate(tab) {
            $state.go(tab.name, tab.params);
        }
    }
})();


/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    SARFormBranchesController.$inject = ["$scope", "$uibModal", "$filter", "amlLov", "resources", "reportsService", "kendoGridRendererService", "logger"];
    angular.module('aml.reports.details').controller('SARFormBranchesController', SARFormBranchesController);
    function SARFormBranchesController($scope, $uibModal, $filter, amlLov, resources, reportsService, kendoGridRendererService, logger) {
        var vm = this;
        vm.resources = resources;
        vm.grid = {};
        vm.readonly = reportsService.isReportReadonly(vm.report);
        var dataSourceOptions = {
            transport: {
                read: getReportBranches
            },
            schema: {
                model: {
                    fields: {
                        branchNumber: { type: 'string' },
                        entityName: { type: 'string' },
                        role: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: 10
        };
        vm.gridColumns = [
            {
                field: 'uiJSON.branchNumber', title: resources.aml.SARReportdetails.step2.header.branchId,
                width: '15%'
            },
            {
                field: 'entityName', title: resources.aml.SARReportdetails.step2.header.entityName,
                width: '50%'
            },
            {
                field: 'uiJSON.branchRoleCode', title: resources.aml.SARReportdetails.step2.header.branchRoleCode,
                template: function (dataItem) {
                    return $filter('branchRoleCode')(dataItem.uiJSON.branchRoleCode);
                },
                width: '15%'
            },
            {
                template: '<input name="branchDeleteButton" type="button" value="' + resources.aml.grid.deleteActionLabel +
                    '" ng-if="!vm.readonly" class="k-button" ng-click="removeBranch(#=entityKey#)"/>',
                title: '&nbsp;',
                width: '20%'
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            selectFirstRowOnLoad: true,
            toolbar: [
                {
                    // My own version of "Add new record" button, with name **popup**
                    name: 'popup',
                    template: '<input name="branchAddButton" type="button" value="' + resources.aml.grid.addActionLabel +
                        '" ng-if="!vm.readonly" class="k-button" ng-click="addBranch()"/>'
                }
            ]
        });
        activate();
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick);
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
            //reload branches when new institution is selected
            $scope.$on('institutionSelected', function (event, args) {
                if (args) {
                    // have to change value here, somehow angular digest cycle is not done yet,
                    // when event happens and the value is not the same as in the parent controller
                    vm.institution = args.val;
                }
                vm.grid.dataSource.read();
            });
            //put the toolbar on the bottom
            $scope.$on('kendoWidgetCreated', function (ev, widget) {
                // in widget you have a reference to the event
                if (widget === vm.grid) {
                    vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
                }
            });
        }
        function getReportBranches(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            //let filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.branchesCount;
            }
            if (vm.institution) {
                //SARX only
                reportsService.getReportBranchesByParent(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey, vm.institution.entityKey, 'INSTITUTION').then(function (data) {
                    vm.branchesCount = data.count;
                    //filtered by institution
                    vm.branchList = data.items;
                    e.success(data);
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reports.couldNotLoadBranchesErrorText);
                });
            }
            else {
                reportsService.getReportBranches(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey).then(function (data) {
                    vm.branchesCount = data.count;
                    vm.branchList = data.items;
                    e.success(data);
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reports.couldNotLoadBranchesErrorText);
                });
            }
        }
        // on double-click, go to branch detail page
        function handleDoubleClick(evt) {
            var selectedBranch = vm.grid.dataItem(evt.currentTarget);
            if (selectedBranch) {
                openBranchViewDialog(vm.grid, selectedBranch);
            }
        }
        $scope.addBranch = function (e) {
            $scope.$evalAsync(function (e) {
                openBranchViewDialog(vm.grid, e);
            });
        };
        $scope.removeBranch = function (entityKey) {
            $scope.$evalAsync(function (e) {
                // delete entity and relationships from ENTITY_BRIDGE
                reportsService.removeReportEntity(vm.report.reportKey, entityKey, 'BRANCH', true).then(function () {
                    vm.grid.dataSource.read();
                });
            });
        };
        function openBranchViewDialog(mainBranchGrid, data) {
            // jshint ignore:start
            var implementationTypeCode = reportsService.getImplementationTypeCode(vm.report);
            var templateCode = (implementationTypeCode === '') ? $scope.vm.formTypeKey : implementationTypeCode;
            var modalInstance = $uibModal.open({
                animation: true,
                windowClass: 'subjects-modal-window',
                openedClass: 'subjects-modal-body',
                //templateUrl: 'regulatoryReports/reportDetails/forms/SARFormBranchesView.html',
                templateUrl: 'regulatoryReports/reportDetails/forms/formBranchesView' + templateCode + '.html',
                /* @ngInject */
                controller: ["$uibModalInstance", "$scope", "$filter", "resources", "messageService", function ($uibModalInstance, $scope, $filter, resources, messageService) {
                    var vm = this;
                    vm.resources = resources;
                    vm.grid = {};
                    vm.dataItem = data;
                    vm.originalDataItem = data;
                    vm.branchRoleCode = typeof vm.dataItem.uiJSON !== 'undefined' ? vm.dataItem.uiJSON.branchRoleCode : '';
                    vm.cashInAmount = typeof vm.dataItem.uiJSON !== 'undefined' ? vm.dataItem.uiJSON.cashInAmount : '';
                    vm.cashOutAmount = typeof vm.dataItem.uiJSON !== 'undefined' ? vm.dataItem.uiJSON.cashOutAmount : '';
                    vm.newBranch = (typeof vm.dataItem.uiJSON === 'undefined' || vm.dataItem.uiJSON === '') ? true : false;
                    vm.report = $uibModalInstance.report;
                    vm.institution = $uibModalInstance.institution;
                    vm.branchList = $uibModalInstance.branchList;
                    vm.readonly = reportsService.isReportReadonly(vm.report);
                    vm.branchRoleCodeList = amlLov.getAsArray(amlLov.branchRoleCode);
                    vm.financialInstitutionTypeList = amlLov.getAsArray(amlLov.financialInstitutionType);
                    vm.gamingTypeList = amlLov.getAsArray(amlLov.branchGamingTypeCode);
                    vm.branchSelectionGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            transport: {
                                read: getAllBranches
                            }
                        },
                        height: 400,
                        pageable: false,
                        scrollable: {
                            virtual: true
                        }
                    });
                    vm.branchSelectionColumns = [
                        {
                            field: 'uiJSON.branchNumber',
                            title: resources.aml.SARReportdetails.step2.header.branchId,
                            width: '20%'
                        },
                        {
                            field: 'uiJSON.branchName',
                            title: resources.aml.SARReportdetails.step2.header.branchName
                        },
                        {
                            field: 'uiJSON.branchAddress',
                            title: resources.aml.SARReportdetails.step2.header.branchAddress,
                            width: '25%'
                        },
                        {
                            field: 'uiJSON.branchCityName',
                            title: resources.aml.SARReportdetails.step2.header.branchCityName,
                            width: '15%'
                        },
                        {
                            field: 'uiJSON.branchCountryName',
                            title: resources.aml.SARReportdetails.step2.header.branchCountryCode,
                            width: '15%'
                        },
                        {
                            field: 'uiJSON.branchStateName',
                            title: resources.aml.SARReportdetails.step2.header.branchStateCode,
                            width: '15%'
                        }
                    ];
                    if (typeof vm.dataItem.entityKey !== 'undefined') {
                        reportsService.getReportEntityInfo(vm.report.reportKey, vm.dataItem.entityKey, 'FINCEN_BRANCH').then(function (data) {
                            vm.dataItem = data.items[0];
                        }, function (data, status, headers, config) {
                            logger.error('Could not get branches');
                        });
                    }
                    function findReportBranch(entityKey) {
                        var branch = {};
                        branch = _.findWhere(vm.branchList, { 'entityKey': entityKey });
                        if (branch) {
                            return branch;
                        }
                        return null;
                    }
                    function getAllBranches(e) {
                        // filter branches by institution of 2B institution is provided
                        // This is only applicable to SAR. institutionKey is for SARX only
                        if (vm.report.uiJSON.institution2bKey || vm.institution) {
                            if (vm.institution) {
                                //SARX only
                                getInstitutionBranches(e, vm.institution.entityNumber);
                            }
                            else {
                                var institutionNumber;
                                reportsService.getReportEntityInfo(vm.report.reportKey, vm.report.uiJSON.institution2bKey, 'FINCEN_INSTITUTION_' + vm.report.reportFormTypeKey, null).then(function (institutionData) {
                                    institutionNumber = institutionData.items[0].entityNumber;
                                    getInstitutionBranches(e, institutionNumber);
                                });
                            }
                        }
                        else {
                            getInstitutionBranches(e, null);
                        }
                    }
                    // get branches by institution
                    // if institutionNumber is null, all branches will be returned
                    function getInstitutionBranches(e, institutionNumber) {
                        var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
                        var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.branchSelectionGridOptions.dataSource.pageSize);
                        reportsService.getBranches(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey, institutionNumber).then(function (data) {
                            data.items.forEach(function (element) {
                                element.uiJSON.branchStateName = $filter('allCountriesStates')(element.uiJSON.branchStateCode, element.uiJSON.branchCountryCode);
                                element.uiJSON.branchCountryName = $filter('countryCode')(element.uiJSON.branchCountryCode);
                            });
                            e.success(data.items);
                        }, function (data, status, headers, config) {
                            logger.error(resources.aml.reports.couldNotLoadBranchesErrorText);
                        });
                    }
                    // on single-click, populate the fields.
                    vm.handleRowSelect = function (evt) {
                        vm.dataItem = evt;
                    };
                    vm.cancel = function () {
                        if (vm.originalDataItem.entityKey) {
                            vm.dataItem = vm.originalDataItem;
                        }
                        modalInstance.dismiss('cancel');
                    };
                    vm.save = function () {
                        var branch;
                        var uiJSON = { branchRoleCode: vm.branchRoleCode, cashInAmount: vm.cashInAmount, cashOutAmount: vm.cashOutAmount };
                        if (vm.dataItem.entityNumber) {
                            vm.dataItem.uiJSON.branchRoleCode = vm.branchRoleCode;
                            vm.dataItem.uiJSON.cashInAmount = vm.cashInAmount;
                            vm.dataItem.uiJSON.cashOutAmount = vm.cashOutAmount;
                            branch = findReportBranch(vm.dataItem.entityKey);
                        }
                        //if branch exists just update it
                        if (vm.originalDataItem.entityKey || branch) {
                            //editing existing branch
                            if (vm.institution) {
                            }
                            reportsService.updateReportEntity(vm.report.reportKey, vm.dataItem).then(function () {
                                if (vm.institution) {
                                    var entityBridge = {
                                        reportKey: vm.report.reportKey,
                                        entityKey: vm.dataItem.entityKey,
                                        entityLevelCode: 'BRANCH',
                                        parentEntityKey: vm.institution.entityKey,
                                        parentEntityLevelCode: 'INSTITUTION',
                                        uiJSON: uiJSON
                                    };
                                    reportsService.updateReportEntityBridge(vm.report.reportKey, entityBridge).then(function () {
                                        messageService.info(vm.resources.aml.getResource('reports.updatedBranchSuccessMessage'), null, 2000);
                                        mainBranchGrid.dataSource.read();
                                    });
                                }
                            });
                        }
                        else {
                            //create ENTITY_BRIDGE record and relationship between institution and ranch
                            if (vm.dataItem.entityNumber) {
                                if (vm.institution) {
                                }
                                reportsService.createReportEntity(vm.report.reportKey, vm.dataItem).then(function () {
                                    if (vm.institution) {
                                        var entityBridge = {
                                            reportKey: vm.report.reportKey,
                                            entityKey: vm.dataItem.entityKey,
                                            entityLevelCode: 'BRANCH',
                                            parentEntityKey: vm.institution.entityKey,
                                            parentEntityLevelCode: 'INSTITUTION',
                                            uiJSON: uiJSON
                                        };
                                        reportsService.createReportEntityBridge(vm.report.reportKey, entityBridge).then(function () {
                                            messageService.info(vm.resources.aml.getResource('reports.addedBranchSuccessMessage'), null, 2000);
                                            mainBranchGrid.dataSource.read();
                                        });
                                    }
                                });
                            }
                        }
                        modalInstance.dismiss('save');
                    };
                }],
                controllerAs: 'vm',
                backdrop: 'static'
            });
            // pass data from controller to modal dialog
            modalInstance.report = vm.report;
            modalInstance.institution = vm.institution;
            modalInstance.branchList = vm.branchList;
            return modalInstance.result;
            // jshint ignore:end
        }
    }
})();


/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    SARFormDetailsController.$inject = ["$scope", "$resource", "$stateParams", "$element", "$filter", "amlConfig", "resources", "kendoGridRendererService", "amlLov", "reportsService", "exceptionResourceHandler", "attachmentService"];
    angular.module('aml.reports.details').controller('SARFormDetailsController', SARFormDetailsController);
    /* jshint maxparams: 16*/
    /*jshint maxcomplexity:19 */
    /* jshint maxstatements: 55*/
    function SARFormDetailsController($scope, $resource, $stateParams, $element, $filter, amlConfig, resources, kendoGridRendererService, amlLov, reportsService, exceptionResourceHandler, attachmentService) {
        var vm = this;
        vm.resources = resources;
        vm.efileAttachmentList = null;
        vm.amountInvolvedCodeList = amlLov.getAsArray(amlLov.amountInvolved);
        vm.report = $scope.viewVm.report; //get report from parent
        vm.readonly = reportsService.isReportReadonly(vm.report);
        vm.institutionRoleCodeList = amlLov.getAsArray(amlLov.branchRoleCode);
        vm.filingTypeList = amlLov.getAsArray(amlLov.filingType);
        vm.countryCodeList = amlLov.getAsArray(amlLov.countryCode);
        vm.stateUSCodeList = amlLov.getAsArray(amlLov.stateUSCode);
        //CTR
        vm.CTRFilingTypeList = amlLov.getAsArray(amlLov.CTRFilingType);
        //DOEP
        vm.exemptPersonCodeList = amlLov.getAsArray(amlLov.exemptPersonCode);
        vm.taxIDTypeCodeList = amlLov.getAsArray(amlLov.taxIDType);
        vm.DOEPTaxIDTypeCodeList = amlLov.getAsArray(amlLov.DOEPTaxIDType);
        vm.DOEPFilingTypeList = amlLov.getAsArray(amlLov.DOEPFilingTypeCode);
        vm.NAICSCodeList = amlLov.getAsArray(amlLov.NAICS);
        //Doris' code to copy these two dates provides a ' ' when there is not specified value.  The moment code turns
        //that into 'Invalid Date' and causes problems with the Bootstrap date field.  Setting it to undefined sets the
        //UI field to blank
        if (vm.report.uiJSON.SARBeginDate !== ' ' && vm.report.uiJSON.SARBeginDate) {
            vm.report.uiJSON.SARBeginDate = moment(vm.report.uiJSON.SARBeginDate).toDate();
        }
        else {
            vm.report.uiJSON.SARBeginDate = undefined;
        }
        if (vm.report.uiJSON.SAREndDate !== ' ' && vm.report.uiJSON.SAREndDate) {
            vm.report.uiJSON.SAREndDate = moment(vm.report.uiJSON.SAREndDate).toDate();
        }
        else {
            vm.report.uiJSON.SAREndDate = undefined;
        }
        if (vm.report.uiJSON.LEContactDate !== ' ' && vm.report.uiJSON.LEContactDate) {
            vm.report.uiJSON.LEContactDate = moment(vm.report.uiJSON.LEContactDate).toDate();
        }
        else {
            vm.report.uiJSON.LEContactDate = undefined;
        }
        //CTR field
        if (vm.report.uiJSON.transactionDate !== ' ' && vm.report.uiJSON.transactionDate) {
            vm.report.uiJSON.transactionDate = moment(vm.report.uiJSON.transactionDate).toDate();
        }
        else {
            vm.report.uiJSON.transactionDate = undefined;
        }
        //DOEP field
        if (vm.report.uiJSON.effectiveDate !== ' ' && vm.report.uiJSON.effectiveDate) {
            vm.report.uiJSON.effectiveDate = moment(vm.report.uiJSON.effectiveDate).toDate();
        }
        else {
            vm.report.uiJSON.effectiveDate = undefined;
        }
        var financialInstitutionResource = $resource(amlConfig.baseUrl + '/regulatoryReports/:id/reportEntityInfo', {
            id: '@id',
            entityTypeName: '@entityTypeName'
        }, {
            get: {
                method: 'GET',
                interceptor: { responseError: exceptionResourceHandler.resourceErrorHandler }
            }
        });
        //put the toolbar on the bottom
        $scope.$on('kendoWidgetCreated', function (ev, widget) {
            // in widget you have a reference to the event
            if (widget === vm.grid) {
                vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
            }
        });
        vm.commodityGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.commodity[vm.report.uiJSON.commodity.length - 1].id + 1;
                        vm.report.uiJSON.commodity.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.commodity);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.commodity.length; i++) {
                            if (vm.report.uiJSON.commodity[i].id === options.data.id) {
                                vm.report.uiJSON.commodity[i].commodity = options.data.commodity;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.commodity.length; i++) {
                            if (vm.report.uiJSON.commodity[i].id === options.data.id) {
                                vm.report.uiJSON.commodity.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.commodity);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            commodity: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            save: function (e) {
                if (!vm.readonly) {
                    $scope.createReportForm.$dirty = true;
                }
            },
            edit: function (e) {
                if (!vm.readonly) {
                    $scope.createReportForm.$dirty = true;
                }
            },
            remove: function (e) {
                if (!vm.readonly) {
                    $scope.createReportForm.$dirty = true;
                }
            }
        });
        vm.commodityColumns = [
            {
                field: 'commodity',
                title: resources.aml.SARReportdetails.step4.header.commodity,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        vm.productGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.product[vm.report.uiJSON.product.length - 1].id + 1;
                        vm.report.uiJSON.product.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.product);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.product.length; i++) {
                            if (vm.report.uiJSON.product[i].id === options.data.id) {
                                vm.report.uiJSON.product[i].product = options.data.product;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.product.length; i++) {
                            if (vm.report.uiJSON.product[i].id === options.data.id) {
                                vm.report.uiJSON.product.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.product);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            product: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            save: function (e) {
                if (!vm.readonly) {
                    $scope.createReportForm.$dirty = true;
                }
            },
            remove: function (e) {
                if (!vm.readonly) {
                    $scope.createReportForm.$dirty = true;
                }
            }
        });
        vm.productColumns = [
            {
                field: 'product',
                title: resources.aml.SARReportdetails.step4.header.product,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        vm.micGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.MIC[vm.report.uiJSON.MIC.length - 1].id + 1;
                        vm.report.uiJSON.MIC.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.MIC);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.MIC.length; i++) {
                            if (vm.report.uiJSON.MIC[i].id === options.data.id) {
                                vm.report.uiJSON.MIC[i].MIC = options.data.MIC;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.MIC.length; i++) {
                            if (vm.report.uiJSON.MIC[i].id === options.data.id) {
                                vm.report.uiJSON.MIC.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.MIC);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            MIC: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            edit: function (e) {
                $scope.createReportForm.$dirty = true;
            },
            remove: function (e) {
                $scope.createReportForm.$dirty = true;
            }
        });
        vm.micColumns = [
            {
                field: 'MIC',
                title: resources.aml.SARReportdetails.step4.header.MIC,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        vm.IPAddressGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.IPAddress[vm.report.uiJSON.IPAddress.length - 1].id + 1;
                        vm.report.uiJSON.IPAddress.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.IPAddress);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.IPAddress.length; i++) {
                            if (vm.report.uiJSON.IPAddress[i].id === options.data.id) {
                                vm.report.uiJSON.IPAddress[i].product = options.data.IPAddress;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.IPAddress.length; i++) {
                            if (vm.report.uiJSON.IPAddress[i].id === options.data.id) {
                                vm.report.uiJSON.IPAddress.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.IPAddress);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            IPAddress: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            edit: function (e) {
                $scope.createReportForm.$dirty = true;
            },
            remove: function (e) {
                $scope.createReportForm.$dirty = true;
            }
        });
        vm.IPAddressColumns = [
            {
                field: 'IPAddress',
                title: resources.aml.SARReportdetails.step4.header.IPAddress,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        vm.cusipGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.CUSIP[vm.report.uiJSON.CUSIP.length - 1].id + 1;
                        vm.report.uiJSON.CUSIP.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.CUSIP);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.CUSIP.length; i++) {
                            if (vm.report.uiJSON.CUSIP[i].id === options.data.id) {
                                vm.report.uiJSON.CUSIP[i].CUSIP = options.data.CUSIP;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.CUSIP.length; i++) {
                            if (vm.report.uiJSON.CUSIP[i].id === options.data.id) {
                                vm.report.uiJSON.CUSIP.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.CUSIP);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            CUSIP: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: true,
            edit: function (e) {
                $scope.createReportForm.$dirty = true;
            },
            remove: function (e) {
                $scope.createReportForm.$dirty = true;
            }
        });
        vm.cusipColumns = [
            {
                field: 'CUSIP',
                title: resources.aml.SARReportdetails.step4.header.CUSIP,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        //CTR Grids
        vm.foreignCashInGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.foreignCashIn[vm.report.uiJSON.foreignCashIn.length - 1].id + 1;
                        vm.report.uiJSON.foreignCashIn.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.foreignCashIn);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.foreignCashIn.length; i++) {
                            if (vm.report.uiJSON.foreignCashIn[i].id === options.data.id) {
                                vm.report.uiJSON.foreignCashIn[i].foreignCashIn = options.data.foreignCashIn;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.foreignCashIn.length; i++) {
                            if (vm.report.uiJSON.foreignCashIn[i].id === options.data.id) {
                                vm.report.uiJSON.foreignCashIn.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.foreignCashIn);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            foreignCashInAmount: { type: 'number', editable: true },
                            foreignCashInCountryCode: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            edit: function (e) {
                $scope.createReportForm.$dirty = true;
            },
            remove: function (e) {
                $scope.createReportForm.$dirty = true;
            }
        });
        vm.foreignCashOutGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                autoSync: true,
                transport: {
                    create: function (options) {
                        options.data.id = vm.report.uiJSON.foreignCashOut[vm.report.uiJSON.foreignCashOut.length - 1].id + 1;
                        vm.report.uiJSON.foreignCashOut.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.foreignCashOut);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.foreignCashOut.length; i++) {
                            if (vm.report.uiJSON.foreignCashOut[i].id === options.data.id) {
                                vm.report.uiJSON.foreignCashOut[i].foreignCashOut = options.data.foreignCashOut;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.foreignCashOut.length; i++) {
                            if (vm.report.uiJSON.foreignCashOut[i].id === options.data.id) {
                                vm.report.uiJSON.foreignCashOut.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.foreignCashOut);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            foreignCashOutAmount: { type: 'number', editable: true },
                            foreignCashOutCountryCode: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: !vm.readonly,
            edit: function (e) {
                $scope.createReportForm.$dirty = true;
            },
            remove: function (e) {
                $scope.createReportForm.$dirty = true;
            }
        });
        //These don't really need to be different, but the JSON fields were named differently
        vm.foreignCashInColumns = [
            {
                field: 'foreignCashInAmount',
                type: 'number',
                width: '30%',
                title: resources.aml.CTRReportdetails.part2.header.foreignCashAmount,
                filterable: false
            },
            {
                field: 'foreignCashInCountryCode',
                title: resources.aml.CTRReportdetails.part2.header.foreignCashCountry,
                width: '30%',
                template: function (dataItem) {
                    return $filter('countryCode')(dataItem.foreignCashInCountryCode);
                },
                editor: function (container, options) {
                    var input = $('<input id="countryCodeEdit" name="countryCodeEdit" data-bind="value: ' + options.field + '" />');
                    input.appendTo(container);
                    input.kendoDropDownList({
                        autoBind: true,
                        dataTextField: 'value',
                        dataValueField: 'key',
                        dataSource: vm.countryCodeList
                    });
                },
                filterable: false
            },
            { command: ['destroy'], title: '&nbsp;', width: '12%' }
        ];
        vm.foreignCashOutColumns = [
            {
                field: 'foreignCashOutAmount',
                type: 'number',
                width: '30%',
                title: resources.aml.CTRReportdetails.part2.header.foreignCashAmount,
                filterable: false
            },
            {
                field: 'foreignCashOutCountryCode',
                title: resources.aml.CTRReportdetails.part2.header.foreignCashCountry,
                width: '30%',
                template: function (dataItem) {
                    return $filter('countryCode')(dataItem.foreignCashOutCountryCode);
                },
                editor: function (container, options) {
                    var input = $('<input id="outCountryCodeEdit" name="outCountryCodeEdit" data-bind="value: ' + options.field + '" />');
                    input.appendTo(container);
                    input.kendoDropDownList({
                        autoBind: true,
                        dataTextField: 'value',
                        dataValueField: 'key',
                        dataSource: vm.countryCodeList
                    });
                },
                filterable: false
            },
            (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '17%' })
        ];
        /* tslint:disable */
        /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        attachmentService.onAttachmentAdded($scope, function reportDetailsAddAttachmentHandler(attachment) {
            if (attachment.objectTypeCode === 'RPT' &&
                attachment.size <= 1000000 &&
                attachment.objectId == vm.report.reportKey &&
                attachment.mimeType === 'application/vnd.ms-excel') {
                vm.efileAttachmentList.push(attachment);
                setTimeout(function () {
                    $($element[0].querySelector('efileAttachment')).change();
                });
            }
        });
        /* tslint:enable */
        /* jshint ignore:end */
        /* tslint:disable */
        /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        attachmentService.onAttachmentRemoved($scope, function reportDetailsRemoveAttachmentHandler(attachment) {
            var arrayLength = vm.efileAttachmentList.length;
            for (var i = 0; i < arrayLength; i++) {
                if (vm.efileAttachmentList[i].id == attachment.id) {
                    vm.efileAttachmentList.splice(i, 1);
                    break;
                }
            }
            setTimeout(function () {
                $($element[0].querySelector('efileAttachment')).change();
            });
        });
        /* tslint:enable */
        /* jshint ignore:end */
        activate();
        function activate() {
            reportsService.getSARAttachments($stateParams.reportkey).then(function (data) {
                vm.efileAttachmentList = data.items;
            });
            // get institution data
            getFinancialInstitutionData(vm.report).then(function (data) {
                // 2A institution is always the first item in the list
                vm.financialInstitution = data.items[0];
                // create a list of institutions for 2B selection
                var i, key, value, financialInstitutionList = [];
                for (i = 0; i < data.items.length; i++) {
                    key = data.items[i].entityKey.toString();
                    // get 2B institution detail if an existing institution2bKey is found
                    if (vm.report.uiJSON.institution2bKey === key) {
                        vm.financialInstitution2 = data.items[i];
                    }
                    value = data.items[i].entityName;
                    financialInstitutionList.push({ key: key, value: value, detail: data.items[i] });
                }
                vm.financialInstitutionList = financialInstitutionList;
            });
            $scope.reloadInstitution2 = function reloadInstitution2(newValue) {
                var institution = {};
                institution = _.findWhere(vm.financialInstitutionList, { 'key': newValue });
                vm.financialInstitution2 = institution.detail;
            };
            // This ended up causing a problem with Manual Parties (MPTY) types.  Had to go with non-generic solution
            // for now since we are the ones that are going to be creating any new report types.
            // Currently DOEP reports are 303 type config key.
            if (vm.report.reportFormTypeKey === 303) {
                getDOEPSubject().then(function (data) {
                    vm.DOEPSubject = data.items[0];
                });
            }
            //SAR Field
            if (vm.report.uiJSON.lossAmount === '') {
                vm.report.uiJSON.lossAmount = null;
            }
            //CTR Fields
            $scope.calculateCashInTotal = function () {
                vm.report.uiJSON.usCashInAmount = vm.report.uiJSON.usCashInAmountA + vm.report.uiJSON.usCashInAmountB +
                    vm.report.uiJSON.usCashInAmountC + vm.report.uiJSON.usCashInAmountD + vm.report.uiJSON.usCashInAmountE +
                    vm.report.uiJSON.usCashInAmountF + vm.report.uiJSON.usCashInAmountG + vm.report.uiJSON.usCashInAmountH +
                    vm.report.uiJSON.usCashInAmountI + vm.report.uiJSON.usCashInAmountOther;
            };
            $scope.calculateCashOutTotal = function () {
                vm.report.uiJSON.usCashOutAmount = vm.report.uiJSON.usCashOutAmountA + vm.report.uiJSON.usCashOutAmountB +
                    vm.report.uiJSON.usCashOutAmountC + vm.report.uiJSON.usCashOutAmountD + vm.report.uiJSON.usCashOutAmountE +
                    vm.report.uiJSON.usCashOutAmountF + vm.report.uiJSON.usCashOutAmountG + vm.report.uiJSON.usCashOutAmountH +
                    vm.report.uiJSON.usCashOutAmountI + vm.report.uiJSON.usCashOutAmountJ + vm.report.uiJSON.usCashOutAmountOther;
            };
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
            $scope.$on('reportSaveCallback', function (event, args) {
                if (vm.DOEPSubject) {
                    reportsService.updateReportEntity(vm.report.reportKey, vm.DOEPSubject);
                }
            });
        }
        /**
         * Get financial institution data for this report
         * @returns {$promise|*}
         */
        function getFinancialInstitutionData(report) {
            return financialInstitutionResource.get({
                id: report.reportKey,
                entityTypeName: 'FINCEN_INSTITUTION_' + report.reportFormTypeKey
            }).$promise;
        }
        /**
         * Get the DOEP subject
         */
        function getDOEPSubject() {
            return reportsService.getSubjects(1, 1, null, vm.report.reportKey);
        }
    }
})();


/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    SARFormSubjectsController.$inject = ["$scope", "$filter", "$uibModal", "resources", "reportsService", "kendoGridRendererService", "logger", "amlLov"];
    angular.module('aml.reports.details').controller('SARFormSubjectsController', SARFormSubjectsController);
    function SARFormSubjectsController($scope, $filter, $uibModal, resources, reportsService, kendoGridRendererService, logger, amlLov) {
        var vm = this;
        vm.resources = resources;
        vm.grid = {};
        vm.readonly = reportsService.isReportReadonly(vm.report);
        var dataSourceOptions = {
            transport: {
                read: getSubjects,
                update: updateSubject
            },
            schema: {
                model: {
                    fields: {
                        lastName: { type: 'string' },
                        firstName: { type: 'string' },
                        middleName: { type: 'string' },
                        TaxID: { type: 'string' },
                        TaxIDType: { type: 'string' },
                        subjectDetailsUnknownFlag: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: 50
        };
        vm.gridColumns = [
            {
                field: 'lastName', title: resources.aml.SARReportdetails.step3.header.lastName,
                width: '20%',
                template: function (dataItem) {
                    return dataItem.uiJSON.lastName;
                }
            },
            {
                field: 'firstName', title: resources.aml.SARReportdetails.step3.header.firstName,
                width: '15%',
                template: function (dataItem) {
                    return dataItem.uiJSON.firstName;
                }
            },
            {
                field: 'middleName', title: resources.aml.SARReportdetails.step3.header.middleName,
                width: '15%',
                template: function (dataItem) {
                    return '{{dataItem.uiJSON.middleName | nullNA }}';
                }
            },
            {
                field: 'TaxID', title: resources.aml.SARReportdetails.step3.header.TaxID,
                width: '10%',
                template: function (dataItem) {
                    return '{{dataItem.uiJSON.TaxID | nullNA }}';
                }
            },
            {
                field: 'TaxIDType', title: resources.aml.SARReportdetails.step3.header.TaxIDType,
                //filterable: kendoGridRendererService.getCheckboxFilter('reportStatus'),
                width: '10%',
                template: function (dataItem) {
                    if (typeof dataItem.uiJSON.TaxIDType !== 'undefined') {
                        return $filter('taxIDType')(dataItem.uiJSON.TaxIDType);
                    }
                    else {
                        return '{{ dataItem.uiJSON.TaxIDType | nullNA }}';
                    }
                }
            },
            {
                field: 'subjectDetailsUnknownFlag',
                title: resources.aml.SARReportdetails.step3.header.subjectDetailsUnknownFlag,
                width: '15%',
                template: function (dataItem) {
                    return '{{ dataItem.uiJSON.subjectDetailsUnknownFlag | nullNA }}';
                }
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: 400,
            toolbar: [
                {
                    // My own version of "Add new record" button, with name **popup**
                    name: 'popup',
                    template: '<input name="subjectAddButton" type="button" ng-if="!vm.readonly" value="' + resources.aml.grid.addActionLabel + '" class="k-button" ng-click="addSubject()"/>'
                }
            ]
        });
        activate();
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick);
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
        }
        function getSubjects(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            //let filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.subjectsCount;
            }
            reportsService.getSubjects(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey).then(function (data) {
                vm.subjectsCount = data.count;
                e.success(data);
            }, function (data, status, headers, config) {
                logger.error('Could not get subjects');
            });
        }
        function updateSubject(e) {
            return null;
        }
        $scope.addSubject = function (e) {
            $scope.$evalAsync(openSubjectViewDialog(vm.grid, e));
        };
        function openSubjectViewDialog(mainSubjectGrid, data) {
            // jshint ignore:start
            var implementationTypeCode = reportsService.getImplementationTypeCode(vm.report);
            var templateCode = (implementationTypeCode === '') ? $scope.vm.formTypeKey : implementationTypeCode;
            var modalInstance = $uibModal.open({
                animation: true,
                windowClass: 'subjects-modal-window',
                openedClass: 'subjects-modal-body',
                templateUrl: 'regulatoryReports/reportDetails/forms/formSubjectsView' + templateCode + '.html',
                /* @ngInject */
                controller: ["$scope", "resources", "$uibModalInstance", function ($scope, resources, $uibModalInstance) {
                    var vm = this;
                    vm.resources = resources;
                    vm.grid = {};
                    vm.subject = {};
                    // TODO: add comment to describe what's happening here. Was difficult to figure out the purpose.
                    angular.copy(data, vm.subject);
                    vm.originalSubject = data;
                    // create uiJSON property if it does not exist
                    if (!vm.subject.uiJSON) {
                        vm.subject.uiJSON = {};
                    }
                    //SAR
                    vm.report = $uibModalInstance.report;
                    vm.readonly = reportsService.isReportReadonly(vm.report);
                    vm.genderCodeList = amlLov.getAsArray(amlLov.gender);
                    vm.NAICSCodeList = amlLov.getAsArray(amlLov.NAICS);
                    vm.taxIDTypeCodeList = amlLov.getAsArray(amlLov.taxIDType);
                    vm.subjectRoleCodeList = amlLov.getAsArray(amlLov.subjectRoleCode);
                    vm.countryCodeList = amlLov.getAsArray(amlLov.countryCode);
                    vm.IDTypeCodeList = amlLov.getAsArray(amlLov.IDType);
                    vm.phoneTypeCodeList = amlLov.getAsArray(amlLov.phoneTypeCode);
                    vm.relationshipTypeStatusCodeList = amlLov.getAsArray(amlLov.relationshipTypeStatusCode);
                    vm.stateUSCodeList = amlLov.getAsArray(amlLov.stateUSCode);
                    vm.stateMXCodeList = amlLov.getAsArray(amlLov.stateMXCode);
                    vm.stateCACodeList = amlLov.getAsArray(amlLov.stateCACode);
                    //CTR
                    vm.personInvolvedCodeList = amlLov.getAsArray(amlLov.subjectTypeCode);
                    vm.subjectIDTypeCodeList = amlLov.getAsArray(amlLov.subjectIDTypeCode);
                    //CTRX
                    vm.CTRXpersonInvolvedCodeList = amlLov.getAsArray(amlLov.subjectTypeCodeX);
                    //CTRX and SARX - states in US territories
                    vm.stateASCodeList = amlLov.getAsArray(amlLov.stateASCode);
                    vm.stateGUCodeList = amlLov.getAsArray(amlLov.stateGUCode);
                    vm.stateMHCodeList = amlLov.getAsArray(amlLov.stateMHCode);
                    vm.stateFMCodeList = amlLov.getAsArray(amlLov.stateFMCode);
                    vm.stateMPCodeList = amlLov.getAsArray(amlLov.stateMPCode);
                    vm.statePWCodeList = amlLov.getAsArray(amlLov.statePWCode);
                    vm.statePRCodeList = amlLov.getAsArray(amlLov.statePRCode);
                    vm.stateVICodeList = amlLov.getAsArray(amlLov.stateVICode);
                    //put the toolbar on the bottom
                    $scope.$on('kendoWidgetCreated', function (ev, widget) {
                        // in widget you have a reference to the event
                        if (widget === vm.grid) {
                            vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
                        }
                    });
                    if (!vm.subject.uiJSON.subjectAlternateName) {
                        // new subject list values need to be wrapped in an observableArray, or else
                        // the object will only be updated in the grid dataItem and not reflected back to the original
                        // array object.
                        vm.subject.uiJSON.subjectAlternateName = new kendo.data.ObservableArray([]);
                    }
                    //SAR Grids
                    vm.alternateNameGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectAlternateName
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.alternateNameColumns = [
                        {
                            field: 'alternateName',
                            title: resources.aml.SARReportdetails.step3.header.alternateName,
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '12%' })
                    ];
                    if (!vm.subject.uiJSON.subjectPhone) {
                        vm.subject.uiJSON.subjectPhone = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectPhoneGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectPhone,
                            schema: {
                                model: {
                                    fields: {
                                        phoneTypeCode: { type: 'string' },
                                        phoneNumber: { type: 'string' },
                                        phoneExtension: { type: 'string' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectPhoneColumns = [
                        {
                            field: 'phoneTypeCode',
                            title: resources.aml.SARReportdetails.step3.header.phoneTypeCode,
                            template: function (dataItem) {
                                return $filter('phoneTypeCode')(dataItem.phoneTypeCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="phoneTypeCodeEdit" name="phoneTypeCodeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.phoneTypeCodeList
                                });
                            },
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'phoneNumber',
                            template: kendoGridRendererService.enum('phoneNumber', 'phoneNumber'),
                            title: resources.aml.SARReportdetails.step3.header.phoneNumber,
                            filterable: false
                        },
                        {
                            field: 'phoneExtension',
                            title: resources.aml.SARReportdetails.step3.header.phoneExtension,
                            width: '15%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '12%' })
                    ];
                    if (!vm.subject.uiJSON.subjectEmail) {
                        vm.subject.uiJSON.subjectEmail = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectEmailGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectEmail
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectEmailColumns = [
                        {
                            field: 'emailAddress',
                            title: resources.aml.SARReportdetails.step3.header.subjectEmail,
                            width: '75%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;' })
                    ];
                    if (!vm.subject.uiJSON.subjectUrl) {
                        vm.subject.uiJSON.subjectUrl = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectURLGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectUrl
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectURLColumns = [
                        {
                            field: 'URLAddress',
                            title: resources.aml.SARReportdetails.step3.header.subjectURL,
                            width: '75%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;' })
                    ];
                    if (!vm.subject.uiJSON.subjectAddress) {
                        vm.subject.uiJSON.subjectAddress = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectAddressGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectAddress,
                            schema: {
                                model: {
                                    fields: {
                                        address: { type: 'string' },
                                        city: { type: 'string' },
                                        stateCode: { type: 'string' },
                                        postalCode: { type: 'string' },
                                        countryCode: { type: 'string' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectAddressColumns = [
                        {
                            field: 'address',
                            title: resources.aml.SARReportdetails.step3.header.address,
                            width: '20%',
                            filterable: false
                        },
                        {
                            field: 'city',
                            title: resources.aml.SARReportdetails.step3.header.city,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'stateCode',
                            title: resources.aml.SARReportdetails.step3.header.stateCode,
                            width: '15%',
                            template: function (dataItem) {
                                return determineStateFilter(dataItem.stateCode, dataItem.countryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="stateCodeEdit" name="stateCodeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.determineStateList(options.field, options.model.countryCode)
                                });
                            },
                            filterable: false
                        },
                        {
                            field: 'postalCode',
                            title: resources.aml.SARReportdetails.step3.header.postalCode,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'countryCode',
                            title: resources.aml.SARReportdetails.step3.header.countryCode,
                            width: '15%',
                            template: function (dataItem) {
                                return $filter('countryCode')(dataItem.countryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="countryCodeEdit" name="countryCodeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.countryCodeList
                                });
                            },
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '12%' })
                    ];
                    if (!vm.subject.uiJSON.subjectID) {
                        vm.subject.uiJSON.subjectID = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectIDGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectID,
                            schema: {
                                model: {
                                    fields: {
                                        IDType: { type: 'string' },
                                        IDTypeOther: { type: 'string' },
                                        IDNumber: { type: 'string' },
                                        IDAuthorityStateCode: { type: 'string' },
                                        IDAuthorityCountryCode: { type: 'string' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectIDColumns = [
                        {
                            field: 'IDType',
                            title: resources.aml.SARReportdetails.step3.header.IDType,
                            template: function (dataItem) {
                                return $filter('IDType')(dataItem.IDType);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDTypeEdit" name="IDTypeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.IDTypeCodeList
                                });
                            },
                            filterable: false
                        },
                        {
                            field: 'IDTypeOther',
                            title: resources.aml.SARReportdetails.step3.header.IDTypeOther,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'IDNumber',
                            title: resources.aml.SARReportdetails.step3.header.IDNumber,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'IDAuthorityStateCode',
                            title: resources.aml.SARReportdetails.step3.header.IDAuthorityStateCode,
                            width: '15%',
                            template: function (dataItem) {
                                return determineStateFilter(dataItem.IDAuthorityStateCode, dataItem.IDAuthorityCountryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDAuthorityStateEdit" name="IDAuthorityStateEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.determineStateList(options.field, options.model.IDAuthorityCountryCode)
                                });
                            },
                            filterable: false
                        },
                        {
                            field: 'IDAuthorityCountryCode',
                            title: resources.aml.SARReportdetails.step3.header.IDAuthorityCountryCode,
                            width: '15%',
                            template: function (dataItem) {
                                return $filter('countryCode')(dataItem.IDAuthorityCountryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDAuthorityCountryCodeEdit" name="IDAuthorityCountryCodeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.countryCodeList
                                });
                            },
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '12%' })
                    ];
                    if (!vm.subject.uiJSON.subjectAccount) {
                        vm.subject.uiJSON.subjectAccount = new kendo.data.ObservableArray([]);
                    }
                    vm.subjectAccountGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            data: vm.subject.uiJSON.subjectAccount,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: { editable: false, visible: false, type: 'number' },
                                        accountInstitutionTaxID: { type: 'string' },
                                        accountInstitutionNonUSFlag: { type: 'boolean' },
                                        accountID: { type: 'string' },
                                        accountClosedFlag: { type: 'boolean' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.subjectAccountColumns = [
                        {
                            field: 'accountInstitutionTaxID',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionTaxID,
                            width: '20%',
                            filterable: false
                        },
                        {
                            field: 'accountInstitutionNonUSFlag',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionUSFlag,
                            width: '15%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= accountInstitutionNonUSFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false
                        },
                        {
                            field: 'accountID',
                            title: resources.aml.SARReportdetails.step3.header.accountID,
                            filterable: false
                        },
                        {
                            field: 'accountClosedFlag',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionClosedFlag,
                            width: '15%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= accountClosedFlag ? \'checked="checked"\' : "" # class="chkbx" />',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '12%' })
                    ];
                    //CTR Grids
                    vm.cashInAccountGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subject.uiJSON.accountNumberCashIn[vm.subject.uiJSON.accountNumberCashIn.length - 1].id + 1;
                                    vm.subject.uiJSON.accountNumberCashIn.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.accountNumberCashIn);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.accountNumberCashIn.length; i++) {
                                        if (vm.subject.uiJSON.accountNumberCashIn[i].id === options.data.id) {
                                            vm.subject.uiJSON.accountNumberCashIn[i].accountNumberCashIn = options.data.accountNumberCashIn;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.accountNumberCashIn.length; i++) {
                                        if (vm.subject.uiJSON.accountNumberCashIn[i].id === options.data.id) {
                                            vm.subject.uiJSON.accountNumberCashIn.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.accountNumberCashIn);
                                }
                            },
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        cashInAcctID: { editable: true }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    vm.cashOutAccountGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subject.uiJSON.accountNumberCashOut[vm.subject.uiJSON.accountNumberCashOut.length - 1].id + 1;
                                    vm.subject.uiJSON.accountNumberCashOut.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.accountNumberCashOut);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.accountNumberCashOut.length; i++) {
                                        if (vm.subject.uiJSON.accountNumberCashOut[i].id === options.data.id) {
                                            vm.subject.uiJSON.accountNumberCashOut[i].accountNumberCashOut = options.data.accountNumberCashOut;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.accountNumberCashOut.length; i++) {
                                        if (vm.subject.uiJSON.accountNumberCashOut[i].id === options.data.id) {
                                            vm.subject.uiJSON.accountNumberCashOut.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.report.uiJSON.accountNumberCashOut);
                                }
                            },
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        cashOutAcctID: { editable: true }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: !vm.readonly
                    });
                    //These don't really need to be different, but the JSON fields were named differently
                    if (!vm.subject.uiJSON.accountNumberCashIn) {
                        vm.subject.uiJSON.accountNumberCashIn = new kendo.data.ObservableArray([]);
                    }
                    vm.cashInAccountColumns = [
                        {
                            field: 'cashInAcctID',
                            type: 'string',
                            title: resources.aml.SARReportdetails.step3.header.accountID,
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '30%' })
                    ];
                    if (!vm.subject.uiJSON.accountNumberCashOut) {
                        vm.subject.uiJSON.accountNumberCashOut = new kendo.data.ObservableArray([]);
                    }
                    vm.cashOutAccountColumns = [
                        {
                            field: 'cashOutAcctID',
                            type: 'string',
                            title: resources.aml.SARReportdetails.step3.header.accountID,
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['destroy'], title: '&nbsp;', width: '30%' })
                    ];
                    vm.cancel = function () {
                        vm.subject = vm.originalSubject;
                        modalInstance.dismiss('cancel');
                    };
                    vm.save = function () {
                        // Add these to keep MPTY types from causing a problem when updating them
                        if (typeof vm.subject.entityName === 'undefined') {
                            vm.subject.entityNumber = null;
                            vm.subject.entityName = '';
                        }
                        //We are updating an existing entity
                        if (typeof vm.originalSubject !== 'undefined') {
                            reportsService.updateReportEntity(vm.report.reportKey, vm.subject).then(function () {
                                mainSubjectGrid.dataSource.read();
                            });
                        }
                        else {
                            //Add entity level code
                            vm.subject.entityLevelCode = 'MPTY';
                            reportsService.createReportEntity(vm.report.reportKey, vm.subject).then(function () {
                                mainSubjectGrid.dataSource.read();
                            });
                        }
                        modalInstance.dismiss('save');
                    };
                    vm.determineStateList = function (stateCode, countryCode) {
                        if (countryCode === 'US') {
                            return vm.stateUSCodeList;
                        }
                        if (countryCode === 'MX') {
                            return vm.stateMXCodeList;
                        }
                        if (countryCode === 'CA') {
                            return vm.stateCACodeList;
                        }
                        if (vm.report.reportFormTypeKey === 311 || vm.report.reportFormTypeKey === 312) {
                            if (countryCode === 'AS') {
                                return vm.stateASCodeList;
                            }
                            if (countryCode === 'GU') {
                                return vm.stateGUCodeList;
                            }
                            if (countryCode === 'MH') {
                                return vm.stateMHCodeList;
                            }
                            if (countryCode === 'FM') {
                                return vm.stateFMCodeList;
                            }
                            if (countryCode === 'MP') {
                                return vm.stateMPCodeList;
                            }
                            if (countryCode === 'PW') {
                                return vm.statePWCodeList;
                            }
                            if (countryCode === 'PR') {
                                return vm.statePRCodeList;
                            }
                            if (countryCode === 'VI') {
                                return vm.stateVICodeList;
                            }
                        }
                    };
                }],
                controllerAs: 'vm',
                backdrop: 'static'
            });
            // pass data from controller to modal dialog
            modalInstance.report = vm.report;
            return modalInstance.result;
            // jshint ignore:end
        }
        // on double-click, go to subject detail page
        function handleDoubleClick(evt) {
            var selectedSubject = vm.grid.dataItem(evt.currentTarget);
            if (selectedSubject) {
                openSubjectViewDialog(vm.grid, selectedSubject);
            }
        }
        // jshint ignore:start
        function determineStateFilter(stateCode, countryCode) {
            return $filter('allCountriesStates')(stateCode, countryCode);
        }
        // jshint ignore:end
    }
})();


/**
 * Created by Sergey Galkin on 8/31/2018.
 */
(function () {
    'use strict';
    SARXFormDetailsController.$inject = ["$scope", "$resource", "$stateParams", "$element", "$filter", "amlConfig", "resources", "kendoGridRendererService", "amlLov", "reportsService", "exceptionResourceHandler", "attachmentService", "logger"];
    angular.module('aml.reports.details').controller('SARXFormDetailsController', SARXFormDetailsController);
    /* jshint maxparams: 16*/
    /*jshint maxcomplexity:35 */
    /* jshint maxstatements: 70*/
    function SARXFormDetailsController($scope, $resource, $stateParams, $element, $filter, amlConfig, resources, kendoGridRendererService, amlLov, reportsService, exceptionResourceHandler, attachmentService, logger) {
        var vm = this;
        vm.resources = resources;
        vm.efileAttachmentList = null;
        vm.reportInstitutions = [];
        vm.amountInvolvedCodeList = amlLov.getAsArray(amlLov.amountInvolved);
        vm.report = $scope.viewVm.report; //get report from parent
        vm.readonly = reportsService.isReportReadonly(vm.report);
        vm.filingTypeList = amlLov.getAsArray(amlLov.filingType);
        // vm.countryCodeList = amlLov.getAsArray(amlLov.countryCode);
        // vm.stateUSCodeList = amlLov.getAsArray(amlLov.stateUSCode);
        $scope.reportGridsDirtyFlag = false;
        //Doris' code to copy these two dates provides a ' ' when there is not specified value.  The moment code turns
        //that into 'Invalid Date' and causes problems with the Bootstrap date field.  Setting it to undefined sets the
        //UI field to blank
        if (vm.report.uiJSON.SARBeginDate !== ' ' && vm.report.uiJSON.SARBeginDate) {
            vm.report.uiJSON.SARBeginDate = moment(vm.report.uiJSON.SARBeginDate).toDate();
        }
        else {
            vm.report.uiJSON.SARBeginDate = undefined;
        }
        if (vm.report.uiJSON.SAREndDate !== ' ' && vm.report.uiJSON.SAREndDate) {
            vm.report.uiJSON.SAREndDate = moment(vm.report.uiJSON.SAREndDate).toDate();
        }
        else {
            vm.report.uiJSON.SAREndDate = undefined;
        }
        if (vm.report.uiJSON.LEContactDate !== ' ' && vm.report.uiJSON.LEContactDate) {
            vm.report.uiJSON.LEContactDate = moment(vm.report.uiJSON.LEContactDate).toDate();
        }
        else {
            vm.report.uiJSON.LEContactDate = undefined;
        }
        //put the toolbar on the bottom
        $scope.$on('kendoWidgetCreated', function (ev, widget) {
            // in widget you have a reference to the event
            if (widget === vm.grid) {
                vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
            }
        });
        function markGridsDirty() {
            $scope.$evalAsync(function (e) {
                $scope.createReportForm.reportGridsDirtyFlag = true;
                $scope.createReportForm.$dirty = true;
            });
        }
        if (!vm.report.uiJSON.commodity) {
            vm.report.uiJSON.commodity = [];
        }
        vm.commodityMaxId = (vm.report.uiJSON.commodity && vm.report.uiJSON.commodity.length > 0 ?
            vm.report.uiJSON.commodity[vm.report.uiJSON.commodity.length - 1].id + 1 : 1);
        vm.commodityGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.commodityMaxId++;
                        vm.report.uiJSON.commodity.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.commodity);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.commodity.length; i++) {
                            if (vm.report.uiJSON.commodity[i].id === options.data.id) {
                                vm.report.uiJSON.commodity[i].commodity = options.data.commodity;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.commodity.length; i++) {
                            if (vm.report.uiJSON.commodity[i].id === options.data.id) {
                                vm.report.uiJSON.commodity.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.commodity);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            commodity: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            },
            edit: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            },
            remove: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            }
        });
        vm.commodityColumns = [
            {
                field: 'commodity',
                title: resources.aml.SARReportdetails.step4.header.commodity,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '30%' })
        ];
        if (!vm.report.uiJSON.product) {
            vm.report.uiJSON.product = [];
        }
        vm.productMaxId = (vm.report.uiJSON.product && vm.report.uiJSON.product.length > 0 ?
            vm.report.uiJSON.product[vm.report.uiJSON.product.length - 1].id + 1 : 1);
        vm.productGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.productMaxId++;
                        vm.report.uiJSON.product.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.product);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.product.length; i++) {
                            if (vm.report.uiJSON.product[i].id === options.data.id) {
                                vm.report.uiJSON.product[i].product = options.data.product;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.product.length; i++) {
                            if (vm.report.uiJSON.product[i].id === options.data.id) {
                                vm.report.uiJSON.product.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.product);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            product: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            },
            edit: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            },
            remove: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            }
        });
        vm.productColumns = [
            {
                field: 'product',
                title: resources.aml.SARReportdetails.step4.header.product,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '30%' })
        ];
        if (!vm.report.uiJSON.MIC) {
            vm.report.uiJSON.MIC = [];
        }
        vm.MICMaxId = (vm.report.uiJSON.MIC && vm.report.uiJSON.MIC.length > 0 ?
            vm.report.uiJSON.MIC[vm.report.uiJSON.MIC.length - 1].id + 1 : 1);
        vm.micGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.MICMaxId++;
                        vm.report.uiJSON.MIC.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.MIC);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.MIC.length; i++) {
                            if (vm.report.uiJSON.MIC[i].id === options.data.id) {
                                vm.report.uiJSON.MIC[i].MIC = options.data.MIC;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.MIC.length; i++) {
                            if (vm.report.uiJSON.MIC[i].id === options.data.id) {
                                vm.report.uiJSON.MIC.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.MIC);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            MIC: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            },
            edit: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
                var micField = e.container.find('input[name="MIC"]');
                micField.attr('pattern', '.{3,5}');
                micField.prop('required', true);
                micField.attr('title', vm.resources.aml.SARXReportdetails.step4.validation.invalidMIC);
            },
            remove: function (e) {
                if (!vm.readonly) {
                    markGridsDirty();
                }
            }
        });
        vm.micColumns = [
            {
                field: 'MIC',
                title: resources.aml.SARReportdetails.step4.header.MIC,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '30%' })
        ];
        function isIPAddress(element) {
            if (element.is('[name="IPAddress"]')) {
                if (vm.isIPv4Address(element.val()) || vm.isIPv6Address(element.val())) {
                    return true;
                }
                else {
                    element.attr('data-ipAddressValidation-msg', vm.resources.aml.component.errorInvalidIPAddress);
                    return false;
                }
            }
            else {
                return true;
            }
        }
        vm.isIPv4Address = function (string) {
            return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(string);
        };
        vm.isIPv6Address = function (string) {
            return /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i.test(string);
        };
        vm.isHHMMSS = function (element, identifier) {
            if (/^((?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$)?$/.test(element.val())) {
                return true;
            }
            else {
                element.attr("data-" + identifier + "-msg", vm.resources.aml.component.errorInvalidIPAddressTimestamp);
                return false;
            }
        };
        function isIPAddressHHMMSS(element) {
            if (element.is('[name="IPAddressUTCTime"]')) {
                return vm.isHHMMSS(element, 'ipAddressTimestampValidation');
            }
            else {
                return true;
            }
        }
        function isCyberHHMMSS(element) {
            if (element.is('[name="cyberEventUTCTimeEdit"]')) {
                return vm.isHHMMSS(element, 'cyberEventTimestampValidation');
            }
            else {
                return true;
            }
        }
        if (!vm.report.uiJSON.IPAddress) {
            vm.report.uiJSON.IPAddress = [];
        }
        vm.IPAddressMaxId = (vm.report.uiJSON.IPAddress && vm.report.uiJSON.IPAddress.length > 0 ?
            vm.report.uiJSON.IPAddress[vm.report.uiJSON.IPAddress.length - 1].id + 1 : 1);
        vm.IPAddressGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.IPAddressMaxId++;
                        vm.report.uiJSON.IPAddress.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.IPAddress);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.IPAddress.length; i++) {
                            if (vm.report.uiJSON.IPAddress[i].id === options.data.id) {
                                vm.report.uiJSON.IPAddress[i].IPAddress = options.data.IPAddress;
                                vm.report.uiJSON.IPAddress[i].IPAddressUTCDate = options.data.IPAddressUTCDate;
                                vm.report.uiJSON.IPAddress[i].IPAddressUTCTime = options.data.IPAddressUTCTime;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.IPAddress.length; i++) {
                            if (vm.report.uiJSON.IPAddress[i].id === options.data.id) {
                                vm.report.uiJSON.IPAddress.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.IPAddress);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            IPAddress: {
                                editable: true,
                                validation: {
                                    required: true,
                                    ipAddressValidation: isIPAddress
                                }
                            },
                            IPAddressUTCDate: {
                                editable: true,
                                required: false
                            },
                            IPAddressUTCTime: {
                                editable: true,
                                validation: {
                                    required: false,
                                    ipAddressTimestampValidation: isIPAddressHHMMSS
                                }
                            }
                        }
                    }
                }
            },
            toolbar: [{ name: 'create', text: resources.aml.grid.addActionLabel }],
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                markGridsDirty();
            },
            edit: function (e) {
                markGridsDirty();
            },
            remove: function (e) {
                markGridsDirty();
            }
        });
        vm.IPAddressColumns = [
            {
                field: 'IPAddress',
                title: resources.aml.SARXReportdetails.step4.header.IPAddress,
                filterable: false
            },
            {
                field: 'IPAddressUTCDate',
                title: resources.aml.SARXReportdetails.step4.header.IPAddressUTCDate,
                filterable: false,
                editor: dateInput,
                template: function (item) {
                    if (!item.IPAddressUTCDate) {
                        return '';
                    }
                    var itemDate = new Date(item.IPAddressUTCDate);
                    return itemDate.toDateString();
                }
            },
            {
                field: 'IPAddressUTCTime',
                title: resources.aml.SARXReportdetails.step4.header.IPAddressUTCTime,
                filterable: false
            },
            { command: ['edit', 'destroy'], title: '&nbsp;', width: '17%' }
        ];
        if (!vm.report.uiJSON.cyberEvent) {
            vm.report.uiJSON.cyberEvent = [];
        }
        vm.cyberEventMaxId = (vm.report.uiJSON.cyberEvent && vm.report.uiJSON.cyberEvent.length > 0 ?
            vm.report.uiJSON.cyberEvent[vm.report.uiJSON.cyberEvent.length - 1].id + 1 : 1);
        vm.cyberGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.cyberEventMaxId++;
                        vm.report.uiJSON.cyberEvent.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.cyberEvent);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.cyberEvent.length; i++) {
                            if (vm.report.uiJSON.cyberEvent[i].id === options.data.id) {
                                vm.report.uiJSON.cyberEvent[i].cyberEventTypeCode = options.data.cyberEventTypeCode;
                                vm.report.uiJSON.cyberEvent[i].cyberEventTypeOther = options.data.cyberEventTypeOther;
                                vm.report.uiJSON.cyberEvent[i].cyberEventValue = options.data.cyberEventValue;
                                vm.report.uiJSON.cyberEvent[i].cyberEventUTCDate = options.data.cyberEventUTCDate;
                                vm.report.uiJSON.cyberEvent[i].cyberEventUTCTime = options.data.cyberEventUTCTime;
                            }
                        }
// console.log(vm.report.uiJSON.cyberEvent);
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.cyberEvent.length; i++) {
                            if (vm.report.uiJSON.cyberEvent[i].id === options.data.id) {
                                vm.report.uiJSON.cyberEvent.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.cyberEvent);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            cyberEventTypeCode: { editable: true,
                                validation: {
                                    required: true
                                }
                            },
                            cyberEventTypeOther: { editable: true },
                            cyberEventValue: { editable: true,
                                validation: {
                                    required: true
                                }
                            },
                            cyberEventUTCDate: { editable: true },
                            cyberEventUTCTime: {
                                editable: true,
                                validation: {
                                    required: false,
                                    cyberEventTimestampValidation: isCyberHHMMSS
                                }
                            }
                        }
                    }
                }
            },
            toolbar: [{ name: 'create', text: resources.aml.grid.addActionLabel }],
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                markGridsDirty();
            },
            edit: function (e) {
                markGridsDirty();
            },
            remove: function (e) {
                markGridsDirty();
            }
        });
        // this function creates the cyber category dropdown
        function cyberCategoryDropDown(container, options) {
            $('<input name="' + options.field + '"/>')
                .appendTo(container)
                .kendoDropDownList({
                autoBind: false,
                dataTextField: 'value',
                dataValueField: 'key',
                dataSource: amlLov.getAsArray(amlLov.cyberEventTypeCode)
            });
        }
        // this function creates a date picker in a kendo grid
        function dateInput(container, options) {
            $('<input name="' + options.field + '"/>')
                .appendTo(container)
                .kendoDatePicker({
                start: 'month'
            });
        }
        vm.cyberColumns = [
            {
                field: 'cyberEventTypeCode',
                title: resources.aml.SARXReportdetails.step4.header.cyberEventType,
                editor: cyberCategoryDropDown,
                template: function (item) { return $filter('cyberEventTypeCode')(item.cyberEventTypeCode); },
                width: '33%',
                filterable: false
            },
            {
                field: 'cyberEventTypeOther',
                title: resources.aml.SARXReportdetails.step4.header.cyberEventTypeOther,
                filterable: false
            },
            {
                field: 'cyberEventValue',
                title: resources.aml.SARXReportdetails.step4.header.cyberEvent,
                filterable: false
            },
            {
                field: 'cyberEventUTCDate',
                editor: function (container, options) {
                    $('<input name="' + options.field + '"/>')
                        .appendTo(container)
                        .kendoDatePicker({
                        start: 'month'
                    });
                },
                template: function (item) {
                    if (!item.cyberEventUTCDate) {
                        return '';
                    }
                    var itemDate = new Date(item.cyberEventUTCDate);
                    return itemDate.toDateString();
                },
                title: resources.aml.SARXReportdetails.step4.header.cyberEventUTCDate,
                filterable: false
            },
            {
                field: 'cyberEventUTCTime',
                title: resources.aml.SARXReportdetails.step4.header.cyberEventUTCTime,
                // this field is only enabled for events of type 1 and 8
                editor: function (container, options) {
                    var input = $('<input id="cyberEventUTCTimeEdit" name="cyberEventUTCTimeEdit"' +
                        '" type="text" data-bind="value:cyberEventUTCTime" class="k-input k-textbox">');
                    input.appendTo(container);
                },
                filterable: false
            },
            { command: ['edit', 'destroy'], title: '&nbsp;', width: '17%' }
        ];
        if (!vm.report.uiJSON.CUSIP) {
            vm.report.uiJSON.CUSIP = [];
        }
        vm.CUSIPMaxId = (vm.report.uiJSON.CUSIP && vm.report.uiJSON.CUSIP.length > 0 ?
            vm.report.uiJSON.CUSIP[vm.report.uiJSON.CUSIP.length - 1].id + 1 : 1);
        vm.cusipGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: {
                pageSize: 5,
                transport: {
                    create: function (options) {
                        options.data.id = vm.CUSIPMaxId++;
                        vm.report.uiJSON.CUSIP.push(options.data);
                        options.success(options.data);
                    },
                    read: function (options) {
                        options.success(vm.report.uiJSON.CUSIP);
                    },
                    update: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.CUSIP.length; i++) {
                            if (vm.report.uiJSON.CUSIP[i].id === options.data.id) {
                                vm.report.uiJSON.CUSIP[i].CUSIP = options.data.CUSIP;
                            }
                        }
                        options.success(options.data);
                    },
                    destroy: function (options) {
                        for (var i = 0; i < vm.report.uiJSON.CUSIP.length; i++) {
                            if (vm.report.uiJSON.CUSIP[i].id === options.data.id) {
                                vm.report.uiJSON.CUSIP.splice(i, 1);
                                break;
                            }
                        }
                        options.success(vm.report.uiJSON.CUSIP);
                    }
                },
                schema: {
                    model: {
                        id: 'id',
                        fields: {
                            id: {
                                editable: false,
                                visible: false,
                                type: 'number'
                            },
                            CUSIP: { editable: true }
                        }
                    }
                }
            },
            toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
            editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
            selectable: 'multiple',
            save: function (e) {
                markGridsDirty();
            },
            edit: function (e) {
                markGridsDirty();
                e.container.find('input[name="CUSIP"]').attr('maxLength', '12');
            },
            remove: function (e) {
                markGridsDirty();
            }
        });
        vm.cusipColumns = [
            {
                field: 'CUSIP',
                title: resources.aml.SARReportdetails.step4.header.CUSIP,
                filterable: false
            },
            (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '30%' })
        ];
        /* tslint:disable */
        /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        attachmentService.onAttachmentAdded($scope, function reportDetailsAddAttachmentHandler(attachment) {
            if (attachment.objectTypeCode === 'RPT' &&
                attachment.size <= 1000000 &&
                attachment.objectId == vm.report.reportKey &&
                attachment.mimeType === 'application/vnd.ms-excel') {
                vm.efileAttachmentList.push(attachment);
                setTimeout(function () {
                    $($element[0].querySelector('efileAttachment')).change();
                });
            }
        });
        /* tslint:enable */
        /* jshint ignore:end */
        /* tslint:disable */
        /* jshint ignore:start */ // doing an implicit comparison between string/int for objectId and attachment id
        attachmentService.onAttachmentRemoved($scope, function reportDetailsRemoveAttachmentHandler(attachment) {
            var arrayLength = vm.efileAttachmentList.length;
            for (var i = 0; i < arrayLength; i++) {
                if (vm.efileAttachmentList[i].id == attachment.id) {
                    vm.efileAttachmentList.splice(i, 1);
                    break;
                }
            }
            setTimeout(function () {
                $($element[0].querySelector('efileAttachment')).change();
            });
        });
        /* tslint:enable */
        /* jshint ignore:end */
        activate();
        function activate() {
            reportsService.getSARAttachments($stateParams.reportkey).then(function (data) {
                vm.efileAttachmentList = data.items;
            });
            // get institution data
            getFinancialInstitutionData(vm.report).then(function (data) {
                // 2A institution is always the first item in the list
                vm.financialInstitution = data.items[0];
                // create a list of institutions for 2B selection
                var i, key, value, financialInstitutionList = [];
                for (i = 0; i < data.items.length; i++) {
                    key = data.items[i].entityKey.toString();
                    value = data.items[i].entityName;
                    financialInstitutionList.push({ key: key, value: value, detail: data.items[i] });
                }
                vm.financialInstitutionList = financialInstitutionList;
            });
            //get list of institutions, needed for subjects section
            reportsService.getReportInstitutions(0, 9999, null, vm.report.reportKey).then(function (data) {
                vm.reportInstitutions = data.items;
                $scope.$broadcast('SARXInstitutionsChanged', vm.reportInstitutions);
            }, function (data, status, headers, config) {
                logger.error(resources.aml.reports.couldNotLoadInstitutionsErrorText);
            });
            //SAR Field
            if (vm.report.uiJSON.lossAmount === '') {
                vm.report.uiJSON.lossAmount = null;
            }
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
            $scope.$on('reportSaveCallback', function (event, args) {
                if (vm.DOEPSubject) {
                    reportsService.updateReportEntity(vm.report.reportKey, vm.DOEPSubject);
                }
            });
        }
        /**
         * Get financial institution data for this report
         * @returns {$promise|*}
         */
        function getFinancialInstitutionData(report) {
            return reportsService.getFinancialInstitutionData(report);
        }
        vm.removeSpace = function (string) {
            if (string === ' ') {
                return '';
            }
            else {
                return string;
            }
        };
        vm.resetInvolvedAmount = function () {
            vm.report.uiJSON.involvedAmount = '';
        };
    }
})();


/**
 * Created by Sergey Galkin on 8/31/2018.
 */
(function () {
    'use strict';
    SARXFormInstitutionsController.$inject = ["$rootScope", "$scope", "$uibModal", "$filter", "amlLov", "resources", "reportsService", "kendoGridRendererService", "logger", "messageService"];
    angular.module('aml.reports.details').controller('SARXFormInstitutionsController', SARXFormInstitutionsController);
    angular.module('aml.reports.details').directive('noDirtyCheck', function () {
        // Interacting with input elements having this directive won't cause the form to be marked dirty.
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, elm, attrs, ctrl) {
                ctrl.$pristine = false;
                elm.focus(function () {
                    ctrl.$pristine = false;
                });
            }
        };
    });
    function SARXFormInstitutionsController($rootScope, $scope, $uibModal, $filter, amlLov, resources, reportsService, kendoGridRendererService, logger, messageService) {
        var vm = this;
        vm.resources = resources;
        vm.grid = {};
        vm.financialInstitution3 = null;
        vm.financialInstitution2 = null;
        // vm.financialInstitution3.uiJSONrel = {};
        vm.readonly = reportsService.isReportReadonly(vm.report);
        vm.institutionRoleCodeList = amlLov.getAsArray(amlLov.branchRoleCode);
//console.log(amlLov.branchRoleCode);
        vm.branchList = [];
        vm.selectedInstitutionKey = '';
        vm.defaultOptionText = vm.resources.aml.component.selectOptionDefault;
        var dataSourceOptions = {
            transport: {
                read: getReportInstitutions
            },
            schema: {
                model: {
                    fields: {
                        entityNumber: { type: 'string' },
                        entityName: { type: 'string' }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            pageSize: 10
        };
        vm.gridColumns = [
            {
                field: 'entityNumber', title: resources.aml.SARReportdetails.step2.header.institutionNumber,
                width: '30%'
            },
            {
                field: 'entityName', title: resources.aml.SARReportdetails.step2.header.institutionName,
                width: '50%'
            },
            {
                template: '<input name="institutionDeleteButton" type="button" value="' + resources.aml.grid.deleteActionLabel +
                    '" ng-if="!vm.readonly" class="k-button" ng-click="removeInstitution2(#=entityKey#)"/>',
                title: '&nbsp;',
                width: '20%'
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            selectFirstRowOnLoad: true
        });
        activate();
        function findInstitutionDetails(entityKey) {
            var institution = {};
            institution = _.findWhere(vm.financialInstitutionList, { 'key': entityKey.toString() });
            if (institution && institution.detail) {
                return institution.detail;
            }
            return {};
        }
        function findInstitutionReportDetails(entityKey) {
            var institution = {};
            institution = _.findWhere(vm.reportInstitutions, { 'entityKey': entityKey });
            if (institution) {
                return institution;
            }
            return {};
        }
        function findInstitutionRelationshipDetails(entityKey) {
            var institution = {};
            institution = _.findWhere(vm.reportInstitutions, { 'entityKey': entityKey });
            if (institution && institution.uiJSON) {
                return institution.uiJSON;
            }
            return {};
        }
        //this saves institution selected in the drop down
        vm.saveInstitution2 = function saveInstitution2(newValue) {
            var institution = {};
            institution = _.findWhere(vm.financialInstitutionList, { 'key': newValue });
            if (institution && institution.detail) {
                vm.financialInstitution2 = institution.detail;
            }
            else {
                vm.financialInstitution2 = null;
            }
        };
        vm.addSelectedInstitution2 = function addSelectedInstitution2() {
            //create  'INSTITUTION'
            if (vm.financialInstitution2) {
                reportsService.createReportEntity(vm.report.reportKey, vm.financialInstitution2).then(function () {
                    reloadGrid();
                });
            }
        };
        vm.saveSelectedInstitutionsDetail = function saveInstitutionsDetail() {
            if (vm.financialInstitution3) {
                var entity = findInstitutionReportDetails(vm.financialInstitution3.entityKey);
                reportsService.updateReportEntity(vm.report.reportKey, entity).then(function success() {
                    messageService.info(vm.resources.aml.getResource('reports.saveInstitutionsDetailSuccessMessage'), null, 2000);
                }, function error() {
                    messageService.danger(vm.resources.aml.getResource('reports.saveInstitutionsDetailErrorMessage'), null, 4000);
                });
            }
        };
        function institutionSelected(institution) {
            $scope.$evalAsync(function (e) {
                $scope.$broadcast('institutionSelected', { val: institution });
            });
        }
        function clearInstitutionSelection() {
            //do not clear if nothing is selected
            if (vm.financialInstitution3) {
                vm.selectedEntityKey = null;
                vm.financialInstitution3 = null;
                institutionSelected(vm.financialInstitution3);
            }
        }
        vm.handleRowSelect = function (data) {
            $scope.$evalAsync(function (e) {
                if (data && data.entityKey) {
                    vm.selectedEntityKey = data.entityKey;
                    vm.financialInstitution3 = findInstitutionDetails(data.entityKey);
                    vm.financialInstitution3.uiJSONrel = findInstitutionRelationshipDetails(data.entityKey);
                    institutionSelected(vm.financialInstitution3);
                }
                else {
                    clearInstitutionSelection();
                }
            });
        };
        function reloadGrid() {
            $scope.$evalAsync(function (e) {
                vm.selectedEntityKey = null;
                vm.financialInstitution3 = null;
                institutionSelected(vm.financialInstitution3);
                vm.grid.dataSource.read();
                clearInstitutionSelection();
            });
        }
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, null, 'sarxInstList');
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
            //put the toolbar on the bottom
            $scope.$on('kendoWidgetCreated', function (ev, widget) {
                // in widget you have a reference to the event
                if (widget === vm.grid) {
                    vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
                }
            });
        }
        function getReportInstitutions(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            //let filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.institutionsCount;
            }
            clearInstitutionSelection();
            reportsService.getReportInstitutions(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey).then(function (data) {
                $scope.$evalAsync(function (e1) {
                    vm.institutionsCount = data.count;
                    vm.reportInstitutions = data.items;
/*
                    console.log("# kortsc data ");
                    console.log(data);
                    console.log("# kortsc data.count ");
                    console.log(data.count);
                    console.log("# kortsc data.items ");
                    console.log(data.items);
*/
                    
                    $rootScope.$broadcast('SARXInstitutionsChanged', vm.reportInstitutions);
                });
                e.success(data);
            }, function (data, status, headers, config) {
                logger.error(resources.aml.reports.couldNotLoadInstitutionsErrorText);
            });
        }
        $scope.removeInstitution2 = function (entityKey) {
            $scope.$evalAsync(function (e) {
                //remove related branches first, otherwise they cannot be found, because bridges will be deleted
                reportsService.getReportBranchesByParent(0, 9999, null, vm.report.reportKey, entityKey, 'INSTITUTION').then(function (data) {
                    var branchList = data.items;
                    if (branchList.length > 0) {
                        for (var i = 0; i < branchList.length; i++) {
                            reportsService.removeReportEntity(vm.report.reportKey, branchList[i].entityKey, 'BRANCH', true);
                        }
                    }
                    // save to submit removeReportEntity for institution because delete branches requests have
                    // been submitted. removeReportEntity will remove institution and all bridges
                    reportsService.removeReportEntity(vm.report.reportKey, entityKey, 'INSTITUTION', true).then(function () {
                        reloadGrid();
                        //remove all branches for the institution
                    });
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reports.couldNotLoadBranchesErrorText);
                });
            });
        };
    }
})();


/**
 * Created by sasrns on 9/2/2015.
 */
(function () {
    'use strict';
    angular
        .module('aml.reports.details')
        .directive('amlSarxFormInstitutions', amlSARXFormInstitutions);
    /* @ngInject */
    function amlSARXFormInstitutions() {
        var directive = {
            restrict: 'E',
            scope: {
                report: '=',
                financialInstitutionList: '=',
                reportInstitutions: '='
            },
            templateUrl: 'regulatoryReports/reportDetails/forms/SARXFormInstitutionsDirective.html',
            controller: 'SARXFormInstitutionsController',
            controllerAs: 'vm',
            bindToController: true // because the scope is isolated
        };
        return directive;
    }
})();


/**
 * Created by sasrns on 8/19/2015.
 */
(function () {
    'use strict';
    SARXFormSubjectsController.$inject = ["$scope", "$filter", "$uibModal", "resources", "reportsService", "kendoGridRendererService", "logger", "messageService", "amlLov"];
    angular.module('aml.reports.details').controller('SARXFormSubjectsController', SARXFormSubjectsController);
    function SARXFormSubjectsController($scope, $filter, $uibModal, resources, reportsService, kendoGridRendererService, logger, messageService, amlLov) {
        var vm = this;
        vm.resources = resources;
        //subjects grid
        vm.grid = {};
        vm.amlGridActions = [];
        vm.filterString = '';
        vm.gridId = 'sarxSubjList';
        vm.readonly = reportsService.isReportReadonly(vm.report);
        vm.relationshipTypeStatusCodeList = amlLov.getAsArray(amlLov.relationshipTypeStatusCode);
        vm.selectedSubject = null;
        vm.subjectInstitutionRels = null;
        vm.subjects = {};
        var dataSourceOptions = {
            transport: {
                destroy: function (e) {
                    reportsService.removeReportEntity(vm.report.reportKey, e.data.entityKey, e.data.entityLevelCode, true).then(function success() {
                        e.success();
                    }, function error() {
                        e.error();
                    });
                },
                read: getSubjects
            },
            schema: {
                model: {
                    id: 'entityKey',
                    fields: {
                        entityKey: { type: 'number', editable: false },
                        lastName: { type: 'string', editable: false },
                        firstName: { type: 'string', editable: false },
                        middleName: { type: 'string', editable: false },
                        TaxID: { type: 'string', editable: false },
                        TaxIDType: { type: 'string', editable: false },
                        subjectDetailsUnknownFlag: { type: 'string', editable: false }
                    }
                },
                data: 'items',
                total: 'count' // total number of results
            },
            change: function (e) {
                if (e.action === 'remove') {
                    this.sync();
                }
            },
            batch: false,
            pageSize: 50,
            serverPaging: false,
            serverSorting: false,
            serverFiltering: false
        };
        var taxIDTypeRenderingFilter = kendoGridRendererService.enum('uiJSON.TaxIDType', 'taxIDType', true);
        vm.gridColumns = [
            {
                field: 'uiJSON.lastName', title: resources.aml.SARReportdetails.step3.header.lastName,
                width: '20%',
                sortable: true
            },
            {
                field: 'uiJSON.firstName', title: resources.aml.SARReportdetails.step3.header.firstName,
                width: '15%'
            },
            {
                field: 'uiJSON.middleName', title: resources.aml.SARReportdetails.step3.header.middleName,
                width: '15%'
            },
            {
                field: 'uiJSON.TaxID', title: resources.aml.SARReportdetails.step3.header.TaxID,
                width: '15%'
            },
            {
                field: 'uiJSON.TaxIDType', title: resources.aml.SARReportdetails.step3.header.TaxIDType,
                width: '10%',
                sortable: { compare: kendoGridRendererService.getFilterSortFunction(taxIDTypeRenderingFilter) },
                filterable: kendoGridRendererService.getCheckboxFilter('taxIDType'),
                template: taxIDTypeRenderingFilter
            },
            {
                field: 'uiJSON.subjectDetailsUnknownFlag',
                title: resources.aml.SARReportdetails.step3.header.subjectDetailsUnknownFlag,
                width: '10%'
            },
            {
                command: ['destroy'],
                width: '15%'
            }
        ];
        vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
            dataSource: dataSourceOptions,
            height: 400,
            sortable: {
                mode: 'multiple',
                allowUnsort: true
            },
            editable: 'inline',
            toolbar: [
                {
                    // My own version of "Add new record" button, with name **popup**
                    name: 'popup',
                    template: '<input name="subjectAddButton" type="button" ng-if="!vm.readonly" value="' +
                        resources.aml.grid.addActionLabel +
                        '" class="k-button btn btn-primary btn-sm" ng-click="addSubject()"/>'
                }
            ]
        });
        vm.handleRowSelect = function (data) {
            $scope.$evalAsync(function (e) {
                if (data) {
                    vm.selectedSubject = data;
                    loadRelationships(data);
                }
                else {
                    vm.selectedSubject = null;
                    vm.subjectInstitutionRels = null;
                }
            });
        };
        // convert uiJSON fields to Date object for uib-datepicker
        function convertUiJSONDateStringsToDate(items, fieldName) {
            if (items && items.length && fieldName) {
                for (var i = 0; i < items.length; i++) {
                    var df = items[i].uiJSON[fieldName];
                    if (df !== '' && df) {
                        items[i].uiJSON[fieldName] = moment(df).toDate();
                    }
                    else {
                        items[i].uiJSON[fieldName] = undefined;
                    }
                }
            }
        }
        function loadRelationships(subject) {
            if (subject && subject.entityKey) {
                vm.subjectInstitutionRels = null;
                reportsService.getReportBridges(0, 9999, null, vm.report.reportKey, subject.entityKey, subject.entityLevelCode, 'INSTITUTION').then(function (data) {
                    vm.subjectInstitutionRels = data.items;
                    convertUiJSONDateStringsToDate(vm.subjectInstitutionRels, 'statusDate');
                }, function (data, status, headers, config) {
                    logger.error(resources.aml.reports.couldNotLoadSubjectRelationshipsErrorText);
                });
            }
        }
        function findSubject(subjectKey) {
            var rel = {};
            rel = _.findWhere(vm.subjects, { 'entityKey': subjectKey });
            if (rel && rel.uiJSON) {
                return rel;
            }
            return null;
        }
        function findSubjectInstitutionRel(subjectKey, institutionKey) {
            var rel = {};
            rel = _.findWhere(vm.subjectInstitutionRels, { 'entityKey': institutionKey, 'parentEntityKey': subjectKey });
            if (rel && rel.uiJSON) {
                return rel;
            }
            return null;
        }
        activate();
        function activate() {
            // initialize the grid with default clearFilters/resetGrid functions
            kendoGridRendererService.initialize(vm, vm.grid, vm.gridOptions, $scope, handleDoubleClick, vm.gridId);
            $scope.$on('readonlyChange', function (event, args) {
                vm.readonly = args.val;
            });
            $scope.$on('SARXInstitutionsChanged', function (event, args) {
                // have to change value here, somehow angular digest cycle is not done yet,
                // when event happens and the value is not the same as in the parent controller
                vm.reportInstitutions = args;
            });
        }
        function getSubjects(e) {
            var sortCols = kendoGridRendererService.getSortColumns(e.data, vm.defaultSortColumn, vm.defaultSortDirection);
            //let filterStr = kendoGridRendererService.getFilterString(e.data, vm.gridOptions);
            var pageInfo = kendoGridRendererService.getPageInfo(e.data, vm.gridOptions.dataSource.pageSize);
            var previousCount = null;
            if (pageInfo.start > 0) {
                previousCount = vm.subjectsCount;
            }
            vm.selectedSubject = null;
            reportsService.getSubjects(pageInfo.start, pageInfo.limit, sortCols, vm.report.reportKey).then(function (data) {
                vm.subjectsCount = data.count;
                vm.subjects = data.items;
                e.success(data);
            }, function (data, status, headers, config) {
                logger.error('Could not get subjects');
            });
        }
        $scope.addSubject = function (e) {
            $scope.$evalAsync(openSubjectViewDialog(vm.grid, e));
        };
        // on double-click, go to subject detail page
        function handleDoubleClick(evt) {
            var selectedSubject = vm.grid.dataItem(evt.currentTarget);
            //do not use dataItem, it is already data source of the grid and may be wrapped into observable
            //and grids for all arrays in uiJSON will not work correctly. Use original subject instead.
            var subject = findSubject(selectedSubject.entityKey);
            if (subject) {
                openSubjectViewDialog(vm.grid, subject);
            }
        }
        // jshint ignore:start
        function determineStateFilter(stateCode, countryCode) {
            return $filter('allCountriesStates')(stateCode, countryCode);
        }
        // jshint ignore:end
        vm.saveSubjectRelationship = function (selectedSubjectInstitutionRel) {
            if (selectedSubjectInstitutionRel && selectedSubjectInstitutionRel.entityKey &&
                selectedSubjectInstitutionRel.entityKey !== '' && vm.selectedSubject) {
                var entityBridge = selectedSubjectInstitutionRel;
                //     {
                //     reportKey: vm.report.reportKey,
                //     entityKey: selectedSubjectInstitutionRel.entityKey,
                //     entityLevelCode: 'INSTITUTION',
                //     parentEntityKey: vm.selectedSubject.entityKey,
                //     parentEntityLevelCode: vm.selectedSubject.entityLevelCode,
                //     uiJSON: selectedSubjectInstitutionRel.uiJSON
                // };
                if (selectedSubjectInstitutionRel.parentEntityKey) {
                    reportsService.updateReportEntityBridge(vm.report.reportKey, entityBridge).then(function () {
                        messageService.info(vm.resources.aml.getResource('reports.updatedSubjInstRelSuccessMessage'), null, 2000);
                        loadRelationships(vm.selectedSubject);
                    });
                }
                else {
                    var rel = findSubjectInstitutionRel(vm.selectedSubject.entityKey, selectedSubjectInstitutionRel.entityKey);
                    if (rel) {
                        messageService.danger(vm.resources.aml.getResource('reports.duplicateRelationshipErrorMessage'), null, -1);
                        return;
                    }
                    selectedSubjectInstitutionRel.parentEntityKey = vm.selectedSubject.entityKey;
                    reportsService.createReportEntityBridge(vm.report.reportKey, entityBridge).then(function () {
                        messageService.info(vm.resources.aml.getResource('reports.createdSubjInstRelSuccessMessage'), null, 2000);
                        loadRelationships(vm.selectedSubject);
                    });
                }
            }
        };
        vm.deleteSubjectRelationship = function (selectedSubjectInstitutionRel) {
            if (selectedSubjectInstitutionRel && selectedSubjectInstitutionRel.entityKey &&
                selectedSubjectInstitutionRel.entityKey !== '' && vm.selectedSubject &&
                selectedSubjectInstitutionRel.parentEntityKey) {
                if (selectedSubjectInstitutionRel.parentEntityKey) {
                    reportsService.deleteReportBridge(vm.report.reportKey, vm.selectedSubject.entityKey, vm.selectedSubject.entityLevelCode, selectedSubjectInstitutionRel.entityKey, 'INSTITUTION').then(function () {
                        vm.selectedSubjectInstitutionRel = {};
                        messageService.info(vm.resources.aml.getResource('reports.deletedSubjInstRelSuccessMessage'), null, 2000);
                        loadRelationships(vm.selectedSubject);
                    });
                }
            }
        };
        vm.addSubjectRelationship = function () {
            if (vm.subjectInstitutionRels && vm.selectedSubject) {
                var entityBridge = {
                    reportKey: vm.report.reportKey,
                    entityKey: null,
                    entityLevelCode: 'INSTITUTION',
                    parentEntityKey: null,
                    parentEntityLevelCode: vm.selectedSubject.entityLevelCode,
                    uiJSON: {}
                };
                vm.subjectInstitutionRels.unshift(entityBridge);
            }
        };
        vm.relationshipTypeStatusSelected = function (subjInstRel) {
            if (!subjInstRel.uiJSON.statusCode || subjInstRel.uiJSON.statusCode === '') {
                //clear the date if status is (none selected) - SARX validation does not allow date value without status code
                subjInstRel.uiJSON.statusDate = null;
            }
        };
        vm.isEmailAddress = function (string) {
            return /^[a-zA-Z0-9.!#$%&*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(string);
        };
        // Doing it this way for purposes of unit testing
        // jshint ignore:start
        function isEmailAddress(string) {
            return vm.isEmailAddress(string);
        }
        // jshint ignore:end
        function openSubjectViewDialog(mainSubjectGrid, data) {
            // jshint ignore:start
            var implementationTypeCode = reportsService.getImplementationTypeCode(vm.report);
            var templateCode = (implementationTypeCode === '') ? $scope.vm.formTypeKey : implementationTypeCode;
            var modalInstance = $uibModal.open({
                animation: true,
                windowClass: 'subjects-modal-window',
                openedClass: 'subjects-modal-body',
                size: 'lg',
                templateUrl: 'regulatoryReports/reportDetails/forms/formSubjectsView' + templateCode + '.html',
                /* @ngInject */
                controller: ["$scope", "resources", "$uibModalInstance", function ($scope, resources, $uibModalInstance) {
                    var vm = this;
                    vm.resources = resources;
                    vm.defaultOptionText = vm.resources.aml.component.selectOptionDefault;
                    vm.grid = {};
                    vm.subject = {};
                    // clone the original value so we can use it for editing, original value is used later to cancel changes
                    angular.copy(data, vm.subject);
                    vm.originalSubject = data;
                    // create uiJSON property if it does not exist
                    if (!vm.subject.uiJSON) {
                        vm.subject.uiJSON = {};
                    }
                    //SAR
                    vm.report = $uibModalInstance.report;
                    vm.readonly = reportsService.isReportReadonly(vm.report);
                    vm.genderCodeList = amlLov.getAsArray(amlLov.gender);
                    vm.NAICSCodeList = amlLov.getAsArray(amlLov.NAICS);
                    vm.taxIDTypeCodeList = amlLov.getAsArray(amlLov.taxIDType);
                    vm.subjectRoleCodeList = amlLov.getAsArray(amlLov.subjectRoleCode);
                    vm.countryCodeList = amlLov.getAsArray(amlLov.countryCode);
                    vm.IDTypeCodeList = amlLov.getAsArray(amlLov.IDType);
                    vm.phoneTypeCodeList = amlLov.getAsArray(amlLov.phoneTypeCode);
                    vm.stateUSCodeList = amlLov.getAsArray(amlLov.stateUSCode);
                    vm.stateMXCodeList = amlLov.getAsArray(amlLov.stateMXCode);
                    vm.stateCACodeList = amlLov.getAsArray(amlLov.stateCACode);
                    //SARX - states in US territories
                    vm.stateASCodeList = amlLov.getAsArray(amlLov.stateASCode);
                    vm.stateGUCodeList = amlLov.getAsArray(amlLov.stateGUCode);
                    vm.stateMHCodeList = amlLov.getAsArray(amlLov.stateMHCode);
                    vm.stateFMCodeList = amlLov.getAsArray(amlLov.stateFMCode);
                    vm.stateMPCodeList = amlLov.getAsArray(amlLov.stateMPCode);
                    vm.statePWCodeList = amlLov.getAsArray(amlLov.statePWCode);
                    vm.statePRCodeList = amlLov.getAsArray(amlLov.statePRCode);
                    vm.stateVICodeList = amlLov.getAsArray(amlLov.stateVICode);
                    vm.allStates = [];
                    // create list of all states to contain countryCode field and fix country list alos have countryCode
                    // this is needed for cascading dropdown boxes
                    function addCountryCode(allStates, states, countryCode) {
                        var noneSelected = { key: '', value: vm.defaultOptionText, stateCode: '', countryCode: countryCode };
                        allStates.push(noneSelected);
                        for (var i = 0; i < states.length; i++) {
                            states[i].countryCode = countryCode;
                            states[i].stateCode = states[i].key;
                            allStates.push(states[i]);
                        }
                    }
                    // create state list for cascading drop down boxes
                    function createStateList(allStates) {
                        addCountryCode(allStates, vm.stateUSCodeList, 'US');
                        addCountryCode(allStates, vm.stateCACodeList, 'CA');
                        addCountryCode(allStates, vm.stateASCodeList, 'AS');
                        addCountryCode(allStates, vm.stateMXCodeList, 'MX');
                        addCountryCode(allStates, vm.stateGUCodeList, 'GU');
                        addCountryCode(allStates, vm.stateMHCodeList, 'MH');
                        addCountryCode(allStates, vm.stateFMCodeList, 'FM');
                        addCountryCode(allStates, vm.stateMPCodeList, 'MP');
                        addCountryCode(allStates, vm.statePWCodeList, 'PW');
                        addCountryCode(allStates, vm.statePRCodeList, 'PR');
                        addCountryCode(allStates, vm.stateVICodeList, 'VI');
                    }
                    createStateList(vm.allStates);
                    function findStateAndCountry(stateCode, countryCode) {
                        var rel = {};
                        rel = _.findWhere(vm.allStates, { 'stateCode': stateCode, countryCode: countryCode });
                        return rel;
                    }
                    function validateStateCode(item, countryFieldName, stateFieldName) {
                        if (!countryFieldName) {
                            countryFieldName = 'countryCode';
                        }
                        if (!stateFieldName) {
                            stateFieldName = 'stateCode';
                        }
                        if (item[stateFieldName] && item[stateFieldName] !== '') {
                            var state = findStateAndCountry(item[stateFieldName], item[countryFieldName]);
                            if (!state || state === null) {
                                //reset state if invalid
                                item[stateFieldName] = '';
                            }
                        }
                    }
                    /**
                     * for each entry create countryCode fields with the same value as key - this is used in
                     * cascading dropdows
                     * for each country that does not have state list add '(none selected)' option for states
                     */
                    function processCountryCodes() {
                        for (var i = 0; i < vm.countryCodeList.length; i++) {
                            var key = vm.countryCodeList[i].key;
                            vm.countryCodeList[i].countryCode = key;
                            if (key && key !== 'US' && key !== 'CA' && key !== 'AS' && key !== 'MX' && key !== 'GU' &&
                                key !== 'MH' && key !== 'FM' && key !== 'MP' && key !== 'PW' && key !== 'PR' && key !== 'VI') {
                                vm.allStates.push({ key: '', value: vm.defaultOptionText, stateCode: '', countryCode: key });
                            }
                        }
                    }
                    processCountryCodes();
                    var noneSelected = { key: '', value: vm.defaultOptionText, countryCode: '' };
                    vm.countryCodeList.unshift(noneSelected);
                    //put the toolbar on the bottom
                    $scope.$on('kendoWidgetCreated', function (ev, widget) {
                        // in widget you have a reference to the event
                        if (widget === vm.grid) {
                            vm.grid.element.find('.k-grid-toolbar').insertAfter(vm.grid.element.find('.k-grid-content'));
                        }
                    });
                    // use this fucntion to ensure that all loaded items have ids
                    function generateIds(list) {
                        for (var i = 0; i < list.length; i++) {
                            list[i].id = i + 1;
                        }
                    }
                    //SARX Grids
                    if (!vm.subject.uiJSON.subjectAlternateName) {
                        vm.subject.uiJSON.subjectAlternateName = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectAlternateName);
                    vm.subjectAlternateNameMaxId = (vm.subject.uiJSON.subjectAlternateName && vm.subject.uiJSON.subjectAlternateName.length > 0 ?
                        vm.subject.uiJSON.subjectAlternateName[vm.subject.uiJSON.subjectAlternateName.length - 1].id + 1 : 1);
                    vm.alternateNameGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectAlternateNameMaxId++;
                                    vm.subject.uiJSON.subjectAlternateName.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectAlternateName);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAlternateName.length; i++) {
                                        if (vm.subject.uiJSON.subjectAlternateName[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAlternateName[i].alternateName = options.data.alternateName;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAlternateName.length; i++) {
                                        if (vm.subject.uiJSON.subjectAlternateName[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAlternateName.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success();
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        alternateName: { type: 'string' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        selectable: 'multiple'
                    });
                    vm.alternateNameColumns = [
                        {
                            field: 'alternateName',
                            title: resources.aml.SARReportdetails.step3.header.alternateName,
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '30%' })
                    ];
                    vm.getTaxIdPattern = function () {
                        if (vm.subject && ['A', 'B'].indexOf(vm.subject.uiJSON.TaxIDType) > -1) {
                            return '^\\d{9}$';
                        }
                    };
                    if (!vm.subject.uiJSON.subjectPhone) {
                        vm.subject.uiJSON.subjectPhone = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectPhone);
                    vm.subjectPhoneMaxId = (vm.subject.uiJSON.subjectPhone && vm.subject.uiJSON.subjectPhone.length > 0 ?
                        vm.subject.uiJSON.subjectPhone[vm.subject.uiJSON.subjectPhone.length - 1].id + 1 : 1);
                    vm.subjectPhoneGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectPhoneMaxId++;
                                    options.success(options.data);
                                    vm.subject.uiJSON.subjectPhone.push(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectPhone);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectPhone.length; i++) {
                                        if (vm.subject.uiJSON.subjectPhone[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectPhone[i].phoneTypeCode = options.data.phoneTypeCode;
                                            vm.subject.uiJSON.subjectPhone[i].phoneNumber = options.data.phoneNumber;
                                            vm.subject.uiJSON.subjectPhone[i].phoneExtension = options.data.phoneExtension;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectPhone.length; i++) {
                                        if (vm.subject.uiJSON.subjectPhone[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectPhone.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectPhone);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        phoneTypeCode: { type: 'string' },
                                        phoneNumber: {
                                            type: 'string',
                                            validation: {
                                                phoneNumberValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'phoneNumber', function (string) {
                                                        return /^\d*$/.test(string);
                                                    }, vm.resources.aml.component.errorNonNumericPhoneNumber);
                                                }
                                            }
                                        },
                                        phoneExtension: {
                                            type: 'string',
                                            validation: {
                                                phoneExtensionValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'phoneExtension', function (string) {
                                                        return /^\d*$/.test(string);
                                                    }, vm.resources.aml.component.errorNonNumericPhoneNumber);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        selectable: 'multiple'
                    });
                    vm.subjectPhoneColumns = [
                        {
                            field: 'phoneTypeCode',
                            title: resources.aml.SARXReportdetails.step3.header.phoneTypeCode,
                            template: function (dataItem) {
                                return $filter('phoneTypeCode')(dataItem.phoneTypeCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="phoneTypeCodeEdit" name="phoneTypeCodeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.phoneTypeCodeList
                                });
                            },
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'phoneNumber',
                            title: resources.aml.SARXReportdetails.step3.header.phoneNumber,
                            width: '40%',
                            filterable: false
                        },
                        {
                            field: 'phoneExtension',
                            title: resources.aml.SARXReportdetails.step3.header.phoneExtension,
                            width: '15%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '25%' })
                    ];
                    if (!vm.subject.uiJSON.subjectEmail) {
                        vm.subject.uiJSON.subjectEmail = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectEmail);
                    vm.subjectEmailMaxId = (vm.subject.uiJSON.subjectEmail && vm.subject.uiJSON.subjectEmail.length > 0 ?
                        vm.subject.uiJSON.subjectEmail[vm.subject.uiJSON.subjectEmail.length - 1].id + 1 : 1);
                    vm.subjectEmailGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectEmailMaxId++;
                                    vm.subject.uiJSON.subjectEmail.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectEmail);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectEmail.length; i++) {
                                        if (vm.subject.uiJSON.subjectEmail[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectEmail[i].emailAddress = options.data.emailAddress;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectEmail.length; i++) {
                                        if (vm.subject.uiJSON.subjectEmail[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectEmail.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectEmail);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        emailAddress: {
                                            type: 'string',
                                            validation: {
                                                emailAddressValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'emailAddress', isEmailAddress, vm.resources.aml.component.errorInvalidEmailAddress);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        edit: function (e) {
                            e.container.find('input[name="emailAddress"]').attr('maxLength', 50);
                        },
                        selectable: 'multiple'
                    });
                    vm.subjectEmailColumns = [
                        {
                            field: 'emailAddress',
                            title: resources.aml.SARReportdetails.step3.header.subjectEmail,
                            width: '60%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '40%' })
                    ];
                    if (!vm.subject.uiJSON.subjectUrl) {
                        vm.subject.uiJSON.subjectUrl = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectUrl);
                    vm.subjectUrlMaxId = (vm.subject.uiJSON.subjectUrl && vm.subject.uiJSON.subjectUrl.length > 0 ?
                        vm.subject.uiJSON.subjectUrl[vm.subject.uiJSON.subjectUrl.length - 1].id + 1 : 1);
                    vm.subjectURLGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectUrlMaxId++;
                                    vm.subject.uiJSON.subjectUrl.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectUrl);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectUrl.length; i++) {
                                        if (vm.subject.uiJSON.subjectUrl[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectUrl[i].URLAddress = options.data.URLAddress;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectUrl.length; i++) {
                                        if (vm.subject.uiJSON.subjectUrl[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectUrl.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectUrl);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        URLAddress: {
                                            type: 'string',
                                            validation: {
                                                URLAddressValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'URLAddress', function (string) {
                                                        return element.val().indexOf('.') > -1 && element.val().length <= 517;
                                                    }, vm.resources.aml.component.errorInvalidURL);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        selectable: 'multiple'
                    });
                    vm.subjectURLColumns = [
                        {
                            field: 'URLAddress',
                            title: resources.aml.SARReportdetails.step3.header.subjectURL,
                            width: '60%',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '40%' })
                    ];
                    if (!vm.subject.uiJSON.subjectAddress) {
                        vm.subject.uiJSON.subjectAddress = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectAddress);
                    vm.subjectAddressMaxId = (vm.subject.uiJSON.subjectAddress && vm.subject.uiJSON.subjectAddress.length > 0 ?
                        vm.subject.uiJSON.subjectAddress[vm.subject.uiJSON.subjectAddress.length - 1].id + 1 : 1);
                    vm.subjectAddressGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectAddressMaxId++;
                                    validateStateCode(options.data);
                                    vm.subject.uiJSON.subjectAddress.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectAddress);
                                },
                                update: function (options) {
                                    validateStateCode(options.data);
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAddress.length; i++) {
                                        if (vm.subject.uiJSON.subjectAddress[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAddress[i].address = options.data.address;
                                            vm.subject.uiJSON.subjectAddress[i].addressUnknownFlag = options.data.addressUnknownFlag;
                                            vm.subject.uiJSON.subjectAddress[i].city = options.data.city;
                                            vm.subject.uiJSON.subjectAddress[i].cityUnknownFlag = options.data.cityUnknownFlag;
                                            vm.subject.uiJSON.subjectAddress[i].stateCode = options.data.stateCode;
                                            vm.subject.uiJSON.subjectAddress[i].stateUnknownFlag = options.data.stateUnknownFlag;
                                            vm.subject.uiJSON.subjectAddress[i].postalCode = options.data.postalCode;
                                            vm.subject.uiJSON.subjectAddress[i].postalCodeUnknownFlag = options.data.postalCodeUnknownFlag;
                                            vm.subject.uiJSON.subjectAddress[i].countryCode = options.data.countryCode;
                                            vm.subject.uiJSON.subjectAddress[i].countryUnknownFlag = options.data.countryUnknownFlag;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAddress.length; i++) {
                                        if (vm.subject.uiJSON.subjectAddress[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAddress.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectAddress);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        address: { type: 'string' },
                                        addressUnknownFlag: { type: 'boolean' },
                                        city: { type: 'string' },
                                        cityUnknownFlag: { type: 'boolean' },
                                        stateCode: { type: 'string' },
                                        stateUnknownFlag: { type: 'boolean' },
                                        postalCode: { type: 'string' },
                                        postalCodeUnknownFlag: { type: 'boolean' },
                                        countryCode: { type: 'string',
                                            defaultValue: 'US'
                                        },
                                        countryUnknownFlag: { type: 'boolean' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        navigatable: false,
                        selectable: 'multiple'
                    });
                    vm.subjectAddressColumns = [
                        {
                            field: 'address',
                            title: resources.aml.SARXReportdetails.step3.header.address,
                            width: '20%',
                            filterable: false
                        },
                        {
                            field: 'addressUnknownFlag',
                            title: '&nbsp;',
                            width: '3%',
                            template: '<input type="checkbox" disabled=\'enabled\' #= addressUnknownFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false,
                            sortable: false
                        },
                        {
                            field: 'city',
                            title: resources.aml.SARXReportdetails.step3.header.city,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'cityUnknownFlag',
                            title: '&nbsp;',
                            width: '3%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= cityUnknownFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false,
                            sortable: false
                        },
                        {
                            field: 'countryCode',
                            title: resources.aml.SARXReportdetails.step3.header.countryCode,
                            width: '15%',
                            template: function (dataItem) {
                                return $filter('countryCode')(dataItem.countryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="countryCode" name="countryCode" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    dataTextField: 'value',
                                    dataValueField: 'countryCode',
                                    dataSource: vm.countryCodeList
                                }).appendTo(container);
                            },
                            filterable: false
                        },
                        {
                            field: 'countryUnknownFlag',
                            title: '&nbsp;',
                            width: '3%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= countryUnknownFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false,
                            sortable: false
                        },
                        {
                            field: 'stateCode',
                            title: resources.aml.SARXReportdetails.step3.header.stateCode,
                            width: '10%',
                            template: function (dataItem) {
                                return determineStateFilter(dataItem.stateCode, dataItem.countryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="stateCode" name="stateCode" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    dataTextField: 'value',
                                    dataValueField: 'stateCode',
                                    cascadeFrom: 'countryCode',
                                    dataSource: vm.allStates
                                }).appendTo(container);
                            },
                            filterable: false
                        },
                        {
                            field: 'stateUnknownFlag',
                            title: '&nbsp;',
                            width: '3%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= stateUnknownFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false,
                            sortable: false
                        },
                        {
                            field: 'postalCode',
                            title: resources.aml.SARXReportdetails.step3.header.postalCode,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'postalCodeUnknownFlag',
                            title: '&nbsp;',
                            width: '3%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= postalCodeUnknownFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false,
                            sortable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '25%' })
                    ];
                    function isAlphaNumeric(string) {
                        return /^[a-zA-Z0-9]*$/.test(string);
                    }
                    if (!vm.subject.uiJSON.subjectID) {
                        vm.subject.uiJSON.subjectID = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectID);
                    vm.subjectIDMaxId = (vm.subject.uiJSON.subjectID && vm.subject.uiJSON.subjectID.length > 0 ?
                        vm.subject.uiJSON.subjectID[vm.subject.uiJSON.subjectID.length - 1].id + 1 : 1);
                    vm.subjectIDGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectIDMaxId++;
                                    validateStateCode(options.data, 'IDAuthorityCountryCode', 'IDAuthorityStateCode');
                                    vm.subject.uiJSON.subjectID.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectID);
                                },
                                update: function (options) {
                                    validateStateCode(options.data, 'IDAuthorityCountryCode', 'IDAuthorityStateCode');
                                    for (var i = 0; i < vm.subject.uiJSON.subjectID.length; i++) {
                                        if (vm.subject.uiJSON.subjectID[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectID[i].IDType = options.data.IDType;
                                            vm.subject.uiJSON.subjectID[i].IDTypeOther = options.data.IDTypeOther;
                                            vm.subject.uiJSON.subjectID[i].IDNumber = options.data.IDNumber;
                                            vm.subject.uiJSON.subjectID[i].IDAuthorityStateCode = options.data.IDAuthorityStateCode;
                                            vm.subject.uiJSON.subjectID[i].IDAuthorityCountryCode = options.data.IDAuthorityCountryCode;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectID.length; i++) {
                                        if (vm.subject.uiJSON.subjectID[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectID.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectID);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        IDType: { type: 'string' },
                                        IDTypeOther: { type: 'string' },
                                        IDNumber: {
                                            type: 'string',
                                            validation: {
                                                IDNumberValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'IDNumber', isAlphaNumeric, vm.resources.aml.component.errorInvalidAlphaNumeric);
                                                }
                                            }
                                        },
                                        IDAuthorityStateCode: { type: 'string' },
                                        IDAuthorityCountryCode: { type: 'string' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        selectable: 'multiple'
                    });
                    vm.subjectIDColumns = [
                        {
                            field: 'IDType',
                            title: resources.aml.SARReportdetails.step3.header.IDType,
                            template: function (dataItem) {
                                return $filter('IDType')(dataItem.IDType);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDTypeEdit" name="IDTypeEdit" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    autoBind: true,
                                    dataTextField: 'value',
                                    dataValueField: 'key',
                                    dataSource: vm.IDTypeCodeList
                                });
                            },
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'IDTypeOther',
                            title: resources.aml.SARReportdetails.step3.header.IDTypeOther,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'IDNumber',
                            title: resources.aml.SARReportdetails.step3.header.IDNumber,
                            width: '15%',
                            filterable: false
                        },
                        {
                            field: 'IDAuthorityCountryCode',
                            title: resources.aml.SARReportdetails.step3.header.IDAuthorityCountryCode,
                            width: '15%',
                            template: function (dataItem) {
                                return $filter('countryCode')(dataItem.IDAuthorityCountryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDAuthorityCountryCode" name="IDAuthorityCountryCode" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    dataTextField: 'value',
                                    dataValueField: 'countryCode',
                                    dataSource: vm.countryCodeList
                                }).appendTo(container);
                            },
                            filterable: false
                        },
                        {
                            field: 'IDAuthorityStateCode',
                            title: resources.aml.SARReportdetails.step3.header.IDAuthorityStateCode,
                            width: '15%',
                            template: function (dataItem) {
                                return determineStateFilter(dataItem.IDAuthorityStateCode, dataItem.IDAuthorityCountryCode);
                            },
                            editor: function (container, options) {
                                var input = $('<input id="IDAuthorityStateCode" name="IDAuthorityStateCode" data-bind="value: ' + options.field + '" />');
                                input.appendTo(container);
                                input.kendoDropDownList({
                                    dataTextField: 'value',
                                    dataValueField: 'stateCode',
                                    cascadeFrom: 'IDAuthorityCountryCode',
                                    dataSource: vm.allStates
                                }).appendTo(container);
                            },
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '25%' })
                    ];
                    if (!vm.subject.uiJSON.subjectAccount) {
                        vm.subject.uiJSON.subjectAccount = [];
                    }
                    generateIds(vm.subject.uiJSON.subjectAccount);
                    vm.subjectAccountMaxId = (vm.subject.uiJSON.subjectAccount && vm.subject.uiJSON.subjectAccount.length > 0 ?
                        vm.subject.uiJSON.subjectAccount[vm.subject.uiJSON.subjectAccount.length - 1].id + 1 : 1);
                    vm.subjectAccountGridOptions = kendoGridRendererService.initGridOptionsWithDefaults({
                        dataSource: {
                            pageSize: 5,
                            transport: {
                                create: function (options) {
                                    options.data.id = vm.subjectAccountMaxId++;
                                    vm.subject.uiJSON.subjectAccount.push(options.data);
                                    options.success(options.data);
                                },
                                read: function (options) {
                                    options.success(vm.subject.uiJSON.subjectAccount);
                                },
                                update: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAccount.length; i++) {
                                        if (vm.subject.uiJSON.subjectAccount[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAccount[i].accountInstitutionTaxID = options.data.accountInstitutionTaxID;
                                            vm.subject.uiJSON.subjectAccount[i].accountInstitutionNonUSFlag = options.data.accountInstitutionNonUSFlag;
                                            vm.subject.uiJSON.subjectAccount[i].accountID = options.data.accountID;
                                            vm.subject.uiJSON.subjectAccount[i].accountClosedFlag = options.data.accountClosedFlag;
                                        }
                                    }
                                    options.success(options.data);
                                },
                                destroy: function (options) {
                                    for (var i = 0; i < vm.subject.uiJSON.subjectAccount.length; i++) {
                                        if (vm.subject.uiJSON.subjectAccount[i].id === options.data.id) {
                                            vm.subject.uiJSON.subjectAccount.splice(i, 1);
                                            break;
                                        }
                                    }
                                    options.success(vm.subject.uiJSON.subjectAccount);
                                }
                            },
                            batch: false,
                            schema: {
                                model: {
                                    id: 'id',
                                    fields: {
                                        id: {
                                            editable: false,
                                            visible: false,
                                            type: 'number'
                                        },
                                        accountInstitutionTaxID: {
                                            type: 'string',
                                            validation: {
                                                accountInstitutionTaxIDValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'accountInstitutionTaxID', isAlphaNumeric, vm.resources.aml.component.errorInvalidAlphaNumeric);
                                                }
                                            }
                                        },
                                        accountInstitutionNonUSFlag: { type: 'boolean' },
                                        accountID: {
                                            type: 'string',
                                            validation: {
                                                accountIDValidation: function (element) {
                                                    return kendoGridRendererService.validateField(element, 'accountID', isAlphaNumeric, vm.resources.aml.component.errorInvalidAlphaNumeric);
                                                }
                                            }
                                        },
                                        accountClosedFlag: { type: 'boolean' }
                                    }
                                }
                            }
                        },
                        toolbar: (vm.readonly ? [] : [{ name: 'create', text: resources.aml.grid.addActionLabel }]),
                        editable: (vm.readonly ? false : { mode: 'inline', confirmation: true }),
                        selectable: 'multiple'
                    });
                    vm.subjectAccountColumns = [
                        {
                            field: 'accountInstitutionTaxID',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionTaxID,
                            width: '20%',
                            filterable: false
                        },
                        {
                            field: 'accountInstitutionNonUSFlag',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionUSFlag,
                            width: '15%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= accountInstitutionNonUSFlag ? \'checked="checked"\' : "" # class="chkbx"/>',
                            filterable: false
                        },
                        {
                            field: 'accountID',
                            title: resources.aml.SARReportdetails.step3.header.accountID,
                            width: '25%',
                            filterable: false
                        },
                        {
                            field: 'accountClosedFlag',
                            title: resources.aml.SARReportdetails.step3.header.accountInstitutionClosedFlag,
                            width: '15%',
                            template: '<input type="checkbox" disabled=\'disabled\' #= accountClosedFlag ? \'checked="checked"\' : "" # class="chkbx" />',
                            filterable: false
                        },
                        (vm.readonly ? {} : { command: ['edit', 'destroy'], title: '&nbsp;', width: '25%' })
                    ];
                    vm.cancel = function () {
                        vm.subject = vm.originalSubject;
                        modalInstance.dismiss('cancel');
                    };
                    function createFullName(first, middle, last) {
                        return resources.aml.getResource('SARXReportdetails.fullNameTemplate', {
                            first: first,
                            middle: middle,
                            last: last
                        });
                    }
                    vm.save = function () {
                        // Add these to keep MPTY types from causing a problem when updating them
                        if (typeof vm.subject.entityName === 'undefined' || vm.subject.entityName === null) {
                            //new MPTY
                            vm.subject.entityNumber = null;
                            vm.subject.entityName = createFullName(vm.subject.uiJSON.firstName, vm.subject.uiJSON.middleName, vm.subject.uiJSON.lastName);
                        }
                        //We are updating an existing entity
                        if (typeof vm.originalSubject !== 'undefined') {
                            if (vm.subject.entityLevelCode === 'MPTY') {
                                //existing MPTY
                                vm.subject.entityNumber = null;
                                vm.subject.entityName = createFullName(vm.subject.uiJSON.firstName, vm.subject.uiJSON.middleName, vm.subject.uiJSON.lastName);
                            }
                            reportsService.updateReportEntity(vm.report.reportKey, vm.subject).then(function () {
                                mainSubjectGrid.dataSource.read();
                            });
                        }
                        else {
                            vm.subject.entityLevelCode = 'MPTY'; // new MPTY - add entity level code
                            reportsService.createReportEntity(vm.report.reportKey, vm.subject).then(function () {
                                mainSubjectGrid.dataSource.read();
                            });
                        }
                        modalInstance.dismiss('save');
                    };
                }],
                controllerAs: 'vm',
                backdrop: 'static'
            });
            // pass data from controller to modal dialog
            modalInstance.report = vm.report;
            return modalInstance.result;
            // jshint ignore:end
        }
    }
})();


(function () {
    'use strict';
    angular.module('aml.core').directive('amlRoutingModal', amlRoutingModal);
    /* @ngInject */
    function amlRoutingModal() {
        return {
            restrict: 'E',
            scope: {
                uibModalInstance: '=',
                title: '@',
                formName: '@',
                users: '=',
                routeToUser: '=',
                hideRouteToQueue: '=',
                routeToMultipleQueues: '=',
                routeToQueue: '=',
                buttonLabel: '@'
            },
            templateUrl: 'core/layout/forms/routing/routingModalDirective.html',
            /* @ngInject */
            controller: ["resources", "queueListService", "amlConstants", "usersService", "$filter", function (resources, queueListService, amlConstants, usersService, $filter) {
                var vm = this;
                vm.resources = resources;
                vm.queues = [{ queueCode: '', queueName: vm.resources.aml.component.selectOptionDefault }];
                vm.replaceCurrentQueue = true;
                queueListService.getQueues().then(function (data) {
                    data.items.forEach(function (item) {
                        item.queueName = $filter('queueName')(item.queueCode, true);
                    });
                    if (amlConstants.config.routeToAllQueues) {
                        vm.queues = vm.queues.concat(data.items);
                    }
                    else {
                        var currentUserQueues_1 = usersService.getCurrentUserQueues();
                        vm.queues = vm.queues.concat(data.items.filter(function (queue) {
                            return currentUserQueues_1.indexOf(queue.queueCode) > -1;
                        }));
                    }
                });
                vm.typeaheadOnSelect = function (item, model, label, event) {
                    vm.userChanged();
                };
                vm.userChanged = function () {
console.log("vm.userChanged #01");
                    vm.invalidName = {};
                    if (vm.routeToUnassigned) {
                        vm.routeToUser = null;
                    }
                    else if (vm.routeToUser && vm.routeToUser.userId) {
                        //userid was bound by typeahed - use it
                        vm.invalidName = {};
                    }
                    else if (vm.routeToUser && !vm.routeToUser.userId) {
                        //user has typed the name but did not select from dropdown. search in the list.
                        var user = _.findWhere(vm.users, { userId: vm.routeToUser });
                        if (user && user.userId) {
                            vm.routeToUser = user;
                        }
                        else {
                            // if did not find in the list throw an error
                            vm.invalidName = { invalid: true };
                        }
                    }
                    else {
                        // if did not bind to a model,  throw an error
                        vm.invalidName = { invalid: true };
                    }
                };
                vm.ok = function () {
                    var userId = null;
                    vm.userChanged();
                    if (vm.routeToUnassigned) {
                        userId = '';
                    }
                    else if (vm.routeToUser && vm.routeToUser.userId) {
                        userId = vm.routeToUser.userId;
                    }
                    else {
                        // if did not bind to a model, throw an error
                        userId = null;
                    }
console.log("----------------------001");
console.log(userId);
console.log(vm.routeToQueue);
console.log(vm.replaceCurrentQueue);
                    var result = {
                        routeToUser: userId,
                        routeToQueue: null,
                        replaceCurrentQueue: null
                    };
                    if (userId !== null) {
                        vm.uibModalInstance.close(result);
                    }
                };
                vm.cancel = function () {
                    vm.uibModalInstance.dismiss('cancel');
                };
                vm.getUsers = function () {
console.log("vm.getUsers #01");
                    return vm.users.filter(function (user) {
console.log("vm.users.filter #01");
console.log(vm);
console.log(user);

											return true;

/*
                        if (vm.routeToQueue === null || vm.routeToQueue === '') {
                            // A queue is not selected. All users should be included.
                            return true;
                        }
                        else {
                            // Include only the users who have access to the queue.
console.log("vm.users.filter #01 ELSE");
console.log(user.queues);
console.log(vm.routeToQueue);
                            return user.queues && user.queues.includes(vm.routeToQueue);
                        }
*/
                    });
                };
            }],
            controllerAs: 'vm',
            bindToController: true
        };
    }
})();


/**
 * created by tommut
 *
 */
(function () {
    'use strict';
    AmlGridController.$inject = ["$scope", "kendoGridRendererService", "amlCoreUtils", "amlGridService"];
    angular.module('aml.core').controller('AmlGridController', AmlGridController);
    function AmlGridController($scope, kendoGridRendererService, amlCoreUtils, amlGridService) {
        var vm = this;
        if (!vm.grid) {
            vm.grid = {};
        }
        vm.filterString = null;
        var gridId = vm.id;
        activate();
        /////////////////
        function activate() {
            if (!vm.options) {
                vm.options = {};
            }
            // if local data was specified instead, just construct a simple onDataLoad to return that
            if (vm.data && !vm.onDataLoad) {
                vm.onDataLoad = function (gridCallback) {
                    gridCallback.success(vm.data);
                };
            }
            vm.options.dataSource = amlGridService.constructDataSource(vm.columns, vm.options, vm.defaultPageSize, vm.onDataLoad);
            // build vm.options
            vm.gridOptions = kendoGridRendererService.initGridOptionsWithDefaults(vm.options);
            // build gridColumns
            vm.gridColumns = amlGridService.buildGridColumns(vm.columns);
            // handle events
            addEventHandlers();
            handleGridInitialization();
        }
        function addEventHandlers() {
            /*jshint camelcase: false */ // typescript generates several vars in this fn as firstDataLoad_1 for some reason
            // handle selectFirstRowOnLoad
            if (vm.options.selectFirstRowOnLoad) {
                var firstDataLoad_1 = true;
                vm.gridOptions.dataBound = function (val) {
                    if (firstDataLoad_1) {
                        kendoGridRendererService.selectFirstRow(vm.grid);
                        firstDataLoad_1 = false;
                    }
                };
            }
            if (vm.onGridChange) {
                vm.gridOptions.dataSource.change = amlCoreUtils.wrap(vm.gridOptions.dataSource.change, null, vm.onGridChange);
            }
            // register doubleClickFn
            if (vm.onDoubleClick) {
                var initialized_1 = false;
                // wrap dooubleClick to capture the dom event and then send the actual item from the grid
                var handleDoubleClick_1 = function (evt, data) {
                    var selectedEntity = vm.grid.dataItem(evt.currentTarget);
                    vm.onDoubleClick(selectedEntity);
                };
                if (vm.grid && vm.grid.element) {
                    //if grid is already bound then do not wait for bound event, it may have been fired already
                    kendoGridRendererService.registerDoubleClickHandler(vm.grid, handleDoubleClick_1, null);
                }
                else {
                    var dataBound = function (val) {
                        if (!initialized_1) {
                            initialized_1 = true;
                            // add this handler
                            kendoGridRendererService.registerDoubleClickHandler(vm.grid, handleDoubleClick_1, this);
                        }
                    };
                    vm.gridOptions.dataBound = amlCoreUtils.wrap(vm.gridOptions.dataBound, dataBound);
                }
            }
            if (vm.onDataSourceChange) {
                vm.gridOptions.dataSource.change = amlCoreUtils.wrap(vm.gridOptions.dataSource.change, null, vm.onDataSourceChange);
            }
        }
        function handleGridInitialization() {
            var dataSourceFn = function (e) {
                var filterString = kendoGridRendererService.getTextForFilter(vm.grid, vm.gridOptions);
                vm.filterString = filterString;
                // need to run angular eval since if using local filtering, it happens outside of angular lifecycle.
                // Use evalAsync vs $digest because on initial load it does run in digest cycle and will get
                // angular cylcical digest cycle warning
                $scope.$evalAsync();
            };
            vm.gridOptions.dataSource.change = amlCoreUtils.wrap(vm.gridOptions.dataSource.change, dataSourceFn);
            var originalColumns = vm.gridColumns; // keep a copy via extend
            kendoGridRendererService.loadGridState(gridId, vm, originalColumns, vm.gridOptions);
            kendoGridRendererService.addDefaultGridActions(vm, originalColumns, gridId);
            // now that grid is initialize (and saved state is loaded, if needed) call any
            // onGridInitialized callbacks
            if (vm.onGridInitialized) {
                // pass in kendo gridOptions
                vm.onGridInitialized(vm.gridOptions);
            }
        }
    }
})();


/**
 * @ngdoc service
 * @name     aml.core:amlGridService
 *
 * @restrict E
 *
 * @description
 * The amlGridService service is used to handle logic needed by the aml-grid directive
 *
 * @element ANY
 * @required on-click
 *
 * @example
 */
(function () {
    'use strict';
    amlGridService.$inject = ["$resource", "amlConfig", "_", "exceptionResourceHandler", "$state", "kendoGridRendererService"];
    angular
        .module('aml.core')
        .factory('amlGridService', amlGridService);
    /* @ngInject */
    function amlGridService($resource, amlConfig, _, exceptionResourceHandler, $state, kendoGridRendererService) {
        var service = {
            constructDataSource: constructDataSource,
            buildGridColumns: buildGridColumns,
            setTemplateOnColumn: setTemplateOnColumn
        };
        return service;
        //////////////////////////
        /**
         * Constructs kendo datasource based off of options set on the aml-grid instance
         * @param columns
         * @param options
         * @param defaultPageSize
         * @param onDataLoad
         * @returns {kendo.data.DataSourceOptions}
         */
        function constructDataSource(columns, options, defaultPageSize, onDataLoad) {
            var fields = {};
            _.each(columns, function (col) {
                var colType = col.type;
                if (!colType) {
                    colType = 'string'; // default to string type if none specified
                }
                fields[col.field] = { type: colType };
            });
            var dataSourceOptions = {
                transport: { read: onDataLoad },
                schema: {
                    model: {
                        fields: fields
                    }
                },
                pageSize: defaultPageSize ? parseInt(defaultPageSize, 10) : 10
            };
            if (options && options.remotePaging) {
                dataSourceOptions.schema.data = 'items'; // records are returned in the 'items' field of the response
                dataSourceOptions.schema.total = 'count';
                dataSourceOptions.serverPaging = true;
                dataSourceOptions.serverSorting = true;
                dataSourceOptions.serverFiltering = true;
            }
            return dataSourceOptions;
        }
        /**
         * Sets template on a kendo gridColumn based off of the template type on the generic AML Column definition
         * @param col
         * @param gridCol
         */
        function setTemplateOnColumn(col, gridCol) {
            if (col.templateType === 'titleCase') {
                gridCol.template = kendoGridRendererService.titleCase(col.field);
            }
            else if (col.templateType === 'longDate') {
                gridCol.template = kendoGridRendererService.longDate(col.field);
            }
            else if (col.templateType === 'longDateMediumTime') {
                gridCol.template = kendoGridRendererService.longDateMediumTime(col.field);
            }
            else if (col.templateType === 'currency') {
                gridCol.template = kendoGridRendererService.currency(col.field);
            }
        }
        /**
         * Constructs kendo grid columns from generic AML Grid Column definitions
         * @param columns
         * @returns {Array}
         */
        function buildGridColumns(columns) {
            var gridCols = [];
            _.each(columns, function (col) {
                if (!col.hidden) {
                    var gridCol = {
                        field: col.field,
                        title: col.title,
                        width: col.width,
                        template: col.template,
                        filterable: col.filterable,
                        sortable: col.sortable,
                        attributes: col.attributes
                    };
                    if (col.lovTable) {
                        var enumMapName = null;
                        if (col.lovTable === true) {
                            enumMapName = col.field;
                        }
                        else if (col.lovTable !== false) {
                            enumMapName = col.lovTable;
                        }
                        gridCol.template = kendoGridRendererService.enum(col.field, enumMapName);
                        gridCol.filterable = kendoGridRendererService.getCheckboxFilter(enumMapName);
                    }
                    if (col.templateType) {
                        setTemplateOnColumn(col, gridCol);
                    }
                    // add number-display class for number columns (add css to right-justify number columns, which
                    // is a SAS standard
                    if (col.type === 'number' && !gridCol.attributes) {
                        gridCol.attributes = { class: 'number-display' };
                    }
                    gridCols.push(gridCol);
                }
            });
            return gridCols;
        }
    }
})();



				function createEFile(){
					var key = $("#reqKeyValue").val();
//console.log("key : " + key);
				
					var sp_URI = "SBIP://METASERVER/KFI_NY/AML Compliance/00.Environments/StoredProcess/report_Create_EFile(StoredProcess)";
					var param={
							_program     : sp_URI,
							_result     : "STREAMFRAGMENT",
							_action     : "background",
							form_config_key	: key
						}
						$.ajax({
							url: "/SASStoredProcess/do?",
							data: param,
							cache:false,
							dataType: 'html',
							async: true,
							beforeSend: function() {
								//$("#progressIndicatorWIP").show();
							},
							success : function(data){           
								console.log("STP Success.....");
								console.log("JSON.stringify(data) : " + JSON.stringify(data));
								alert("Create E-File Success!");
								location.reload();
							},
							error : function(request,status, e){
								console.log("code : " + request.status);
								console.log("message : " + request.responseText);
								console.log("Error : " + e);
								alert("Create E-File Fail!");
								location.reload();
							}
						});
				
				}